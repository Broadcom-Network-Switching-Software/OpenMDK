#ifndef __BCM53262_A0_DEFS_H__
#define __BCM53262_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * This software is governed by the Broadcom Switch APIs license.
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenMDK/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * Definition file for the BCM53262_A0.
 * This file provides all basic definitions required to program the BCM53262_A0.
 */

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/robo_reg.h>
#include <cdk/arch/robo_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/* CPIC/IMP port */
#define BCM53262_A0_CPIC_PORT           24

/* Additional block types */
#define BCM53262_A0_BLKTYPE_CPIC        0
#define BCM53262_A0_BLKTYPE_EPIC        1
#define BCM53262_A0_BLKTYPE_EXP         2
#define BCM53262_A0_BLKTYPE_GPIC        3
#define BCM53262_A0_BLKTYPE_SPI         4
#define BCM53262_A0_BLKTYPE_SYS         5


#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPIC_PORT                       BCM53262_A0_CPIC_PORT

#define BLKTYPE_CPIC                    BCM53262_A0_BLKTYPE_CPIC
#define BLKTYPE_EPIC                    BCM53262_A0_BLKTYPE_EPIC
#define BLKTYPE_EXP                     BCM53262_A0_BLKTYPE_EXP
#define BLKTYPE_GPIC                    BCM53262_A0_BLKTYPE_GPIC
#define BLKTYPE_SPI                     BCM53262_A0_BLKTYPE_SPI
#define BLKTYPE_SYS                     BCM53262_A0_BLKTYPE_SYS


#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ACTLSTS
 * BLOCKS:   EPIC0
 * DESC:     Auxiliary Control/Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_ACTLSTSr 0x0000a030

#define BCM53262_A0_ACTLSTSr_SIZE 2

/*
 * This structure should be used to declare and program ACTLSTS.
 */
typedef union BCM53262_A0_ACTLSTSr_s {
	uint32_t v[1];
	uint32_t actlsts[1];
	uint32_t _actlsts;
} BCM53262_A0_ACTLSTSr_t;

#define BCM53262_A0_ACTLSTSr_CLR(r) (r).actlsts[0] = 0
#define BCM53262_A0_ACTLSTSr_SET(r,d) (r).actlsts[0] = d
#define BCM53262_A0_ACTLSTSr_GET(r) (r).actlsts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ACTLSTSr_RESERVED_Rf_GET(r) (((r).actlsts[0]) & 0xffff)
#define BCM53262_A0_ACTLSTSr_RESERVED_Rf_SET(r,f) (r).actlsts[0]=(((r).actlsts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ACTLSTS.
 */
#define BCM53262_A0_READ_ACTLSTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_ACTLSTSr,(r._actlsts),2)
#define BCM53262_A0_WRITE_ACTLSTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_ACTLSTSr,&(r._actlsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ACTLSTSr BCM53262_A0_ACTLSTSr
#define ACTLSTSr_SIZE BCM53262_A0_ACTLSTSr_SIZE
typedef BCM53262_A0_ACTLSTSr_t ACTLSTSr_t;
#define ACTLSTSr_CLR BCM53262_A0_ACTLSTSr_CLR
#define ACTLSTSr_SET BCM53262_A0_ACTLSTSr_SET
#define ACTLSTSr_GET BCM53262_A0_ACTLSTSr_GET
#define ACTLSTSr_RESERVED_Rf_GET BCM53262_A0_ACTLSTSr_RESERVED_Rf_GET
#define ACTLSTSr_RESERVED_Rf_SET BCM53262_A0_ACTLSTSr_RESERVED_Rf_SET
#define READ_ACTLSTSr BCM53262_A0_READ_ACTLSTSr
#define WRITE_ACTLSTSr BCM53262_A0_WRITE_ACTLSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ACTLSTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ACT_POL_DATA
 * BLOCKS:   SYS
 * DESC:     CFP Action/Policy Data Registers
 * SIZE:     48
 * FIELDS:
 *     NEW_FWD_IB       New Destination Port Number for In -Band6b'00_0000 means port 0.6'b00_0001 means port 1.¡K6'b11_1110 means flood to all link-up ports6'b11_1111 means drop frame
 *     CHANGE_FWD_IB    Change forwarding for In-Band 2'b11 will add NEW_FWD_IB into final port map.2'b10 will change the final port map to NEW_FWD_IB.2'b0x means do not care NEW_FWD_OB.
 *     NEW_COS_IMP      Priority Map for In/Out-Band (IMP port only)The priority to be changed to if CHANGE_COS is asserted
 *     CHANGE_COS_IMP   Change COS for In/Out-Band (IMP port only, Do not modify packet)1'b1 will change the priority of the corresponding frame 1'b0 means do not care PRI_MAP content for this policy
 *     NEW_COS          Priority Map for In/Out-Band (Ethernet port only)The priority to be changed to if CHANGE_COS is asserted
 *     CHANGE_COS       Change COS for In/Out-Band (Ethernet port only, Do not modify packet)1'b1 will change the priority of the corresponding frame 1'b0 means do not care PRI_MAP content for this policy
 *     NEW_PCP          New 802.1p header for In/Out-Band.The value will replace the original 802.1p tag if CHANGE_1P is asserted.
 *     CHANGE_PCP       Change 1P header for In/Out-Band. (Modify packet)1'b1 will change the 802.1p of the corresponding frame 1'b0 means do not care NEW_1P_IB content for this policy
 *     NEW_DSCP_IB      New DSCP value for In-Band.The value will replace the original DSCP value if CHANGE_DSCP is asserted.
 *     CHANGE_DSCP_IB   Change DSCP for In-Band (Modify packet).1'b1 will change the DSCP field of the corresponding frame.1'b0 means do not care NEW_DSCP_OB content for this policy.
 *     NEW_FLOW_INDEX   New FLOW (VID) index for In/Out-BandThe value will used as an index on egress find the VID value.
 *     CHANGE_FLOW      Change FLOW (VID) for In-Band/out (Modify packet)2'b11 means do use NEW_FLOW_INDEX to get VID value on egress side to swap CVID/SPVID at UNI/NNI port.2'b10 means do use NEW_FLOW_INDEX to get VID value on egress side to swap SPVID at NNI port.2'b01 means do use NEW_FLOW_INDEX to get VID value on egress side to swap CVID at UNI port.2'b00 means do not care NEW_FLOW_INDEX content for this policy.
 *     NEW_FWD_OB       New Destination Port Number for Out -Band6b'00_0000 means port 0.6'b00_0001 means port 1.¡K6'b11_1110 means flood to all link-up ports6'b11_1111 means drop frame
 *     CHANGE_FWD_OB    Change forwarding for Out-Band 2'b11 will add NEW_FWD_OB into final port map.2'b10 will change the final port map to NEW_FWD_OB.2'b0x means do not care NEW_FWD_OB.
 *     NEW_DSCP_OB      New DSCP value for Out-Band.The value will replace the original DSCP value if CHANGE_DSCP is asserted.
 *     CHANGE_DSCP_OB   Change DSCP for Out-Band (Modify packet).1'b1 will change the DSCP field of the corresponding frame.1'b0 means do not care NEW_DSCP_OB content for this policy.
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_ACT_POL_DATAr 0x00002070

#define BCM53262_A0_ACT_POL_DATAr_SIZE 6

/*
 * This structure should be used to declare and program ACT_POL_DATA.
 */
typedef union BCM53262_A0_ACT_POL_DATAr_s {
	uint32_t v[2];
	uint32_t act_pol_data[2];
	uint32_t _act_pol_data;
} BCM53262_A0_ACT_POL_DATAr_t;

#define BCM53262_A0_ACT_POL_DATAr_CLR(r) CDK_MEMSET(&((r)._act_pol_data), 0, sizeof(BCM53262_A0_ACT_POL_DATAr_t))
#define BCM53262_A0_ACT_POL_DATAr_SET(r,i,d) (r).act_pol_data[i] = d
#define BCM53262_A0_ACT_POL_DATAr_GET(r,i) (r).act_pol_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ACT_POL_DATAr_NEW_FWD_IBf_GET(r) (((r).act_pol_data[0]) & 0x3f)
#define BCM53262_A0_ACT_POL_DATAr_NEW_FWD_IBf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_IBf_GET(r) ((((r).act_pol_data[0]) >> 6) & 0x3)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_IBf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_ACT_POL_DATAr_NEW_COS_IMPf_GET(r) ((((r).act_pol_data[0]) >> 8) & 0x3)
#define BCM53262_A0_ACT_POL_DATAr_NEW_COS_IMPf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_COS_IMPf_GET(r) ((((r).act_pol_data[0]) >> 10) & 0x1)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_COS_IMPf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_ACT_POL_DATAr_NEW_COSf_GET(r) ((((r).act_pol_data[0]) >> 11) & 0x3)
#define BCM53262_A0_ACT_POL_DATAr_NEW_COSf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_COSf_GET(r) ((((r).act_pol_data[0]) >> 13) & 0x1)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_COSf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_ACT_POL_DATAr_NEW_PCPf_GET(r) ((((r).act_pol_data[0]) >> 14) & 0x7)
#define BCM53262_A0_ACT_POL_DATAr_NEW_PCPf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x7 << 14)) | ((((uint32_t)f) & 0x7) << 14))
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_PCPf_GET(r) ((((r).act_pol_data[0]) >> 17) & 0x1)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_PCPf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_IBf_GET(r) ((((r).act_pol_data[0]) >> 18) & 0x3f)
#define BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_IBf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_IBf_GET(r) ((((r).act_pol_data[0]) >> 24) & 0x1)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_IBf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53262_A0_ACT_POL_DATAr_NEW_FLOW_INDEXf_GET(r) ((((r).act_pol_data[0]) >> 25) & 0xf)
#define BCM53262_A0_ACT_POL_DATAr_NEW_FLOW_INDEXf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_FLOWf_GET(r) ((((r).act_pol_data[0]) >> 29) & 0x3)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_FLOWf_SET(r,f) (r).act_pol_data[0]=(((r).act_pol_data[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53262_A0_ACT_POL_DATAr_NEW_FWD_OBf_GET(r) cdk_field32_get((r).act_pol_data,31,36)
#define BCM53262_A0_ACT_POL_DATAr_NEW_FWD_OBf_SET(r,f) cdk_field32_set((r).act_pol_data,31,36,f)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_OBf_GET(r) ((((r).act_pol_data[1]) >> 5) & 0x3)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_OBf_SET(r,f) (r).act_pol_data[1]=(((r).act_pol_data[1] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_OBf_GET(r) ((((r).act_pol_data[1]) >> 7) & 0x3f)
#define BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_OBf_SET(r,f) (r).act_pol_data[1]=(((r).act_pol_data[1] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_OBf_GET(r) ((((r).act_pol_data[1]) >> 13) & 0x1)
#define BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_OBf_SET(r,f) (r).act_pol_data[1]=(((r).act_pol_data[1] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_ACT_POL_DATAr_RESERVED_Rf_GET(r) ((((r).act_pol_data[1]) >> 14) & 0x3)
#define BCM53262_A0_ACT_POL_DATAr_RESERVED_Rf_SET(r,f) (r).act_pol_data[1]=(((r).act_pol_data[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access ACT_POL_DATA.
 */
#define BCM53262_A0_READ_ACT_POL_DATAr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ACT_POL_DATAr,(r._act_pol_data),6)
#define BCM53262_A0_WRITE_ACT_POL_DATAr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ACT_POL_DATAr,&(r._act_pol_data),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ACT_POL_DATAr BCM53262_A0_ACT_POL_DATAr
#define ACT_POL_DATAr_SIZE BCM53262_A0_ACT_POL_DATAr_SIZE
typedef BCM53262_A0_ACT_POL_DATAr_t ACT_POL_DATAr_t;
#define ACT_POL_DATAr_CLR BCM53262_A0_ACT_POL_DATAr_CLR
#define ACT_POL_DATAr_SET BCM53262_A0_ACT_POL_DATAr_SET
#define ACT_POL_DATAr_GET BCM53262_A0_ACT_POL_DATAr_GET
#define ACT_POL_DATAr_NEW_FWD_IBf_GET BCM53262_A0_ACT_POL_DATAr_NEW_FWD_IBf_GET
#define ACT_POL_DATAr_NEW_FWD_IBf_SET BCM53262_A0_ACT_POL_DATAr_NEW_FWD_IBf_SET
#define ACT_POL_DATAr_CHANGE_FWD_IBf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_IBf_GET
#define ACT_POL_DATAr_CHANGE_FWD_IBf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_IBf_SET
#define ACT_POL_DATAr_NEW_COS_IMPf_GET BCM53262_A0_ACT_POL_DATAr_NEW_COS_IMPf_GET
#define ACT_POL_DATAr_NEW_COS_IMPf_SET BCM53262_A0_ACT_POL_DATAr_NEW_COS_IMPf_SET
#define ACT_POL_DATAr_CHANGE_COS_IMPf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_COS_IMPf_GET
#define ACT_POL_DATAr_CHANGE_COS_IMPf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_COS_IMPf_SET
#define ACT_POL_DATAr_NEW_COSf_GET BCM53262_A0_ACT_POL_DATAr_NEW_COSf_GET
#define ACT_POL_DATAr_NEW_COSf_SET BCM53262_A0_ACT_POL_DATAr_NEW_COSf_SET
#define ACT_POL_DATAr_CHANGE_COSf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_COSf_GET
#define ACT_POL_DATAr_CHANGE_COSf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_COSf_SET
#define ACT_POL_DATAr_NEW_PCPf_GET BCM53262_A0_ACT_POL_DATAr_NEW_PCPf_GET
#define ACT_POL_DATAr_NEW_PCPf_SET BCM53262_A0_ACT_POL_DATAr_NEW_PCPf_SET
#define ACT_POL_DATAr_CHANGE_PCPf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_PCPf_GET
#define ACT_POL_DATAr_CHANGE_PCPf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_PCPf_SET
#define ACT_POL_DATAr_NEW_DSCP_IBf_GET BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_IBf_GET
#define ACT_POL_DATAr_NEW_DSCP_IBf_SET BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_IBf_SET
#define ACT_POL_DATAr_CHANGE_DSCP_IBf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_IBf_GET
#define ACT_POL_DATAr_CHANGE_DSCP_IBf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_IBf_SET
#define ACT_POL_DATAr_NEW_FLOW_INDEXf_GET BCM53262_A0_ACT_POL_DATAr_NEW_FLOW_INDEXf_GET
#define ACT_POL_DATAr_NEW_FLOW_INDEXf_SET BCM53262_A0_ACT_POL_DATAr_NEW_FLOW_INDEXf_SET
#define ACT_POL_DATAr_CHANGE_FLOWf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_FLOWf_GET
#define ACT_POL_DATAr_CHANGE_FLOWf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_FLOWf_SET
#define ACT_POL_DATAr_NEW_FWD_OBf_GET BCM53262_A0_ACT_POL_DATAr_NEW_FWD_OBf_GET
#define ACT_POL_DATAr_NEW_FWD_OBf_SET BCM53262_A0_ACT_POL_DATAr_NEW_FWD_OBf_SET
#define ACT_POL_DATAr_CHANGE_FWD_OBf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_OBf_GET
#define ACT_POL_DATAr_CHANGE_FWD_OBf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_FWD_OBf_SET
#define ACT_POL_DATAr_NEW_DSCP_OBf_GET BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_OBf_GET
#define ACT_POL_DATAr_NEW_DSCP_OBf_SET BCM53262_A0_ACT_POL_DATAr_NEW_DSCP_OBf_SET
#define ACT_POL_DATAr_CHANGE_DSCP_OBf_GET BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_OBf_GET
#define ACT_POL_DATAr_CHANGE_DSCP_OBf_SET BCM53262_A0_ACT_POL_DATAr_CHANGE_DSCP_OBf_SET
#define ACT_POL_DATAr_RESERVED_Rf_GET BCM53262_A0_ACT_POL_DATAr_RESERVED_Rf_GET
#define ACT_POL_DATAr_RESERVED_Rf_SET BCM53262_A0_ACT_POL_DATAr_RESERVED_Rf_SET
#define READ_ACT_POL_DATAr BCM53262_A0_READ_ACT_POL_DATAr
#define WRITE_ACT_POL_DATAr BCM53262_A0_WRITE_ACT_POL_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ACT_POL_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  AEGSTS
 * BLOCKS:   EPIC0
 * DESC:     10BASE-T Auxiliary Error And General Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_AEGSTSr 0x0000a038

#define BCM53262_A0_AEGSTSr_SIZE 2

/*
 * This structure should be used to declare and program AEGSTS.
 */
typedef union BCM53262_A0_AEGSTSr_s {
	uint32_t v[1];
	uint32_t aegsts[1];
	uint32_t _aegsts;
} BCM53262_A0_AEGSTSr_t;

#define BCM53262_A0_AEGSTSr_CLR(r) (r).aegsts[0] = 0
#define BCM53262_A0_AEGSTSr_SET(r,d) (r).aegsts[0] = d
#define BCM53262_A0_AEGSTSr_GET(r) (r).aegsts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_AEGSTSr_RESERVED_Rf_GET(r) (((r).aegsts[0]) & 0xffff)
#define BCM53262_A0_AEGSTSr_RESERVED_Rf_SET(r,f) (r).aegsts[0]=(((r).aegsts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AEGSTS.
 */
#define BCM53262_A0_READ_AEGSTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_AEGSTSr,(r._aegsts),2)
#define BCM53262_A0_WRITE_AEGSTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_AEGSTSr,&(r._aegsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AEGSTSr BCM53262_A0_AEGSTSr
#define AEGSTSr_SIZE BCM53262_A0_AEGSTSr_SIZE
typedef BCM53262_A0_AEGSTSr_t AEGSTSr_t;
#define AEGSTSr_CLR BCM53262_A0_AEGSTSr_CLR
#define AEGSTSr_SET BCM53262_A0_AEGSTSr_SET
#define AEGSTSr_GET BCM53262_A0_AEGSTSr_GET
#define AEGSTSr_RESERVED_Rf_GET BCM53262_A0_AEGSTSr_RESERVED_Rf_GET
#define AEGSTSr_RESERVED_Rf_SET BCM53262_A0_AEGSTSr_RESERVED_Rf_SET
#define READ_AEGSTSr BCM53262_A0_READ_AEGSTSr
#define WRITE_AEGSTSr BCM53262_A0_WRITE_AEGSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_AEGSTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  AGEOUT_CTL
 * BLOCKS:   SYS
 * DESC:     Ageout Control Registers
 * SIZE:     32
 * FIELDS:
 *     AGE_EN_PORT      Use to select the VLAN ID we want aged out.
 *     AGE_EN_VID       Use to select the VLAN ID we want aged out.
 *     SPT_AGE_EN       Use to select the SPT ID we want aged out.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_AGEOUT_CTLr 0x00004504

#define BCM53262_A0_AGEOUT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AGEOUT_CTL.
 */
typedef union BCM53262_A0_AGEOUT_CTLr_s {
	uint32_t v[1];
	uint32_t ageout_ctl[1];
	uint32_t _ageout_ctl;
} BCM53262_A0_AGEOUT_CTLr_t;

#define BCM53262_A0_AGEOUT_CTLr_CLR(r) (r).ageout_ctl[0] = 0
#define BCM53262_A0_AGEOUT_CTLr_SET(r,d) (r).ageout_ctl[0] = d
#define BCM53262_A0_AGEOUT_CTLr_GET(r) (r).ageout_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_AGEOUT_CTLr_AGE_EN_PORTf_GET(r) (((r).ageout_ctl[0]) & 0x3f)
#define BCM53262_A0_AGEOUT_CTLr_AGE_EN_PORTf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_AGEOUT_CTLr_AGE_EN_VIDf_GET(r) ((((r).ageout_ctl[0]) >> 6) & 0xfff)
#define BCM53262_A0_AGEOUT_CTLr_AGE_EN_VIDf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM53262_A0_AGEOUT_CTLr_SPT_AGE_ENf_GET(r) ((((r).ageout_ctl[0]) >> 18) & 0xff)
#define BCM53262_A0_AGEOUT_CTLr_SPT_AGE_ENf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0xff << 18)) | ((((uint32_t)f) & 0xff) << 18))
#define BCM53262_A0_AGEOUT_CTLr_RESERVED_Rf_GET(r) ((((r).ageout_ctl[0]) >> 26) & 0x3f)
#define BCM53262_A0_AGEOUT_CTLr_RESERVED_Rf_SET(r,f) (r).ageout_ctl[0]=(((r).ageout_ctl[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access AGEOUT_CTL.
 */
#define BCM53262_A0_READ_AGEOUT_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_AGEOUT_CTLr,(r._ageout_ctl),4)
#define BCM53262_A0_WRITE_AGEOUT_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_AGEOUT_CTLr,&(r._ageout_ctl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AGEOUT_CTLr BCM53262_A0_AGEOUT_CTLr
#define AGEOUT_CTLr_SIZE BCM53262_A0_AGEOUT_CTLr_SIZE
typedef BCM53262_A0_AGEOUT_CTLr_t AGEOUT_CTLr_t;
#define AGEOUT_CTLr_CLR BCM53262_A0_AGEOUT_CTLr_CLR
#define AGEOUT_CTLr_SET BCM53262_A0_AGEOUT_CTLr_SET
#define AGEOUT_CTLr_GET BCM53262_A0_AGEOUT_CTLr_GET
#define AGEOUT_CTLr_AGE_EN_PORTf_GET BCM53262_A0_AGEOUT_CTLr_AGE_EN_PORTf_GET
#define AGEOUT_CTLr_AGE_EN_PORTf_SET BCM53262_A0_AGEOUT_CTLr_AGE_EN_PORTf_SET
#define AGEOUT_CTLr_AGE_EN_VIDf_GET BCM53262_A0_AGEOUT_CTLr_AGE_EN_VIDf_GET
#define AGEOUT_CTLr_AGE_EN_VIDf_SET BCM53262_A0_AGEOUT_CTLr_AGE_EN_VIDf_SET
#define AGEOUT_CTLr_SPT_AGE_ENf_GET BCM53262_A0_AGEOUT_CTLr_SPT_AGE_ENf_GET
#define AGEOUT_CTLr_SPT_AGE_ENf_SET BCM53262_A0_AGEOUT_CTLr_SPT_AGE_ENf_SET
#define AGEOUT_CTLr_RESERVED_Rf_GET BCM53262_A0_AGEOUT_CTLr_RESERVED_Rf_GET
#define AGEOUT_CTLr_RESERVED_Rf_SET BCM53262_A0_AGEOUT_CTLr_RESERVED_Rf_SET
#define READ_AGEOUT_CTLr BCM53262_A0_READ_AGEOUT_CTLr
#define WRITE_AGEOUT_CTLr BCM53262_A0_WRITE_AGEOUT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_AGEOUT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  AMODE2
 * BLOCKS:   EPIC0
 * DESC:     Auxiliary Mode 2 Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_AMODE2r 0x0000a036

#define BCM53262_A0_AMODE2r_SIZE 2

/*
 * This structure should be used to declare and program AMODE2.
 */
typedef union BCM53262_A0_AMODE2r_s {
	uint32_t v[1];
	uint32_t amode2[1];
	uint32_t _amode2;
} BCM53262_A0_AMODE2r_t;

#define BCM53262_A0_AMODE2r_CLR(r) (r).amode2[0] = 0
#define BCM53262_A0_AMODE2r_SET(r,d) (r).amode2[0] = d
#define BCM53262_A0_AMODE2r_GET(r) (r).amode2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_AMODE2r_RESERVED_Rf_GET(r) (((r).amode2[0]) & 0xffff)
#define BCM53262_A0_AMODE2r_RESERVED_Rf_SET(r,f) (r).amode2[0]=(((r).amode2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AMODE2.
 */
#define BCM53262_A0_READ_AMODE2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_AMODE2r,(r._amode2),2)
#define BCM53262_A0_WRITE_AMODE2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_AMODE2r,&(r._amode2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AMODE2r BCM53262_A0_AMODE2r
#define AMODE2r_SIZE BCM53262_A0_AMODE2r_SIZE
typedef BCM53262_A0_AMODE2r_t AMODE2r_t;
#define AMODE2r_CLR BCM53262_A0_AMODE2r_CLR
#define AMODE2r_SET BCM53262_A0_AMODE2r_SET
#define AMODE2r_GET BCM53262_A0_AMODE2r_GET
#define AMODE2r_RESERVED_Rf_GET BCM53262_A0_AMODE2r_RESERVED_Rf_GET
#define AMODE2r_RESERVED_Rf_SET BCM53262_A0_AMODE2r_RESERVED_Rf_SET
#define READ_AMODE2r BCM53262_A0_READ_AMODE2r
#define WRITE_AMODE2r BCM53262_A0_WRITE_AMODE2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_AMODE2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  AMPHY
 * BLOCKS:   EPIC0
 * DESC:     Auxiliary Multiple PHY Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_AMPHYr 0x0000a03c

#define BCM53262_A0_AMPHYr_SIZE 2

/*
 * This structure should be used to declare and program AMPHY.
 */
typedef union BCM53262_A0_AMPHYr_s {
	uint32_t v[1];
	uint32_t amphy[1];
	uint32_t _amphy;
} BCM53262_A0_AMPHYr_t;

#define BCM53262_A0_AMPHYr_CLR(r) (r).amphy[0] = 0
#define BCM53262_A0_AMPHYr_SET(r,d) (r).amphy[0] = d
#define BCM53262_A0_AMPHYr_GET(r) (r).amphy[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_AMPHYr_RESERVED_Rf_GET(r) (((r).amphy[0]) & 0xffff)
#define BCM53262_A0_AMPHYr_RESERVED_Rf_SET(r,f) (r).amphy[0]=(((r).amphy[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AMPHY.
 */
#define BCM53262_A0_READ_AMPHYr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_AMPHYr,(r._amphy),2)
#define BCM53262_A0_WRITE_AMPHYr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_AMPHYr,&(r._amphy),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AMPHYr BCM53262_A0_AMPHYr
#define AMPHYr_SIZE BCM53262_A0_AMPHYr_SIZE
typedef BCM53262_A0_AMPHYr_t AMPHYr_t;
#define AMPHYr_CLR BCM53262_A0_AMPHYr_CLR
#define AMPHYr_SET BCM53262_A0_AMPHYr_SET
#define AMPHYr_GET BCM53262_A0_AMPHYr_GET
#define AMPHYr_RESERVED_Rf_GET BCM53262_A0_AMPHYr_RESERVED_Rf_GET
#define AMPHYr_RESERVED_Rf_SET BCM53262_A0_AMPHYr_RESERVED_Rf_SET
#define READ_AMPHYr BCM53262_A0_READ_AMPHYr
#define WRITE_AMPHYr BCM53262_A0_WRITE_AMPHYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_AMPHYr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ANADV
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     ADV_SEL_FIELD    
 *     ADV_B10T         
 *     ADV_B10T_FDX     
 *     ADV_B100X        
 *     ADV_B100X_FDX    
 *     ADV_B100T4       
 *     ADV_PAUSE_CAP    
 *     RESV_TECH        
 *     REMOTE_FAULT_R   
 *     RESERVED_R       Reserved
 *     NEXT_PAGE        
 */
#define BCM53262_A0_ANADVr 0x0000a008

#define BCM53262_A0_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program ANADV.
 */
typedef union BCM53262_A0_ANADVr_s {
	uint32_t v[1];
	uint32_t anadv[1];
	uint32_t _anadv;
} BCM53262_A0_ANADVr_t;

#define BCM53262_A0_ANADVr_CLR(r) (r).anadv[0] = 0
#define BCM53262_A0_ANADVr_SET(r,d) (r).anadv[0] = d
#define BCM53262_A0_ANADVr_GET(r) (r).anadv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ANADVr_ADV_SEL_FIELDf_GET(r) (((r).anadv[0]) & 0x1f)
#define BCM53262_A0_ANADVr_ADV_SEL_FIELDf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_ANADVr_ADV_B10Tf_GET(r) ((((r).anadv[0]) >> 5) & 0x1)
#define BCM53262_A0_ANADVr_ADV_B10Tf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).anadv[0]) >> 6) & 0x1)
#define BCM53262_A0_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_ANADVr_ADV_B100Xf_GET(r) ((((r).anadv[0]) >> 7) & 0x1)
#define BCM53262_A0_ANADVr_ADV_B100Xf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_ANADVr_ADV_B100X_FDXf_GET(r) ((((r).anadv[0]) >> 8) & 0x1)
#define BCM53262_A0_ANADVr_ADV_B100X_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_ANADVr_ADV_B100T4f_GET(r) ((((r).anadv[0]) >> 9) & 0x1)
#define BCM53262_A0_ANADVr_ADV_B100T4f_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).anadv[0]) >> 10) & 0x1)
#define BCM53262_A0_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_ANADVr_RESV_TECHf_GET(r) ((((r).anadv[0]) >> 11) & 0x3)
#define BCM53262_A0_ANADVr_RESV_TECHf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53262_A0_ANADVr_REMOTE_FAULT_Rf_GET(r) ((((r).anadv[0]) >> 13) & 0x1)
#define BCM53262_A0_ANADVr_REMOTE_FAULT_Rf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_ANADVr_RESERVED_Rf_GET(r) ((((r).anadv[0]) >> 14) & 0x1)
#define BCM53262_A0_ANADVr_RESERVED_Rf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_ANADVr_NEXT_PAGEf_GET(r) ((((r).anadv[0]) >> 15) & 0x1)
#define BCM53262_A0_ANADVr_NEXT_PAGEf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANADV.
 */
#define BCM53262_A0_READ_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_ANADVr,(r._anadv),2)
#define BCM53262_A0_WRITE_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_ANADVr,&(r._anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANADVr BCM53262_A0_ANADVr
#define ANADVr_SIZE BCM53262_A0_ANADVr_SIZE
typedef BCM53262_A0_ANADVr_t ANADVr_t;
#define ANADVr_CLR BCM53262_A0_ANADVr_CLR
#define ANADVr_SET BCM53262_A0_ANADVr_SET
#define ANADVr_GET BCM53262_A0_ANADVr_GET
#define ANADVr_ADV_SEL_FIELDf_GET BCM53262_A0_ANADVr_ADV_SEL_FIELDf_GET
#define ANADVr_ADV_SEL_FIELDf_SET BCM53262_A0_ANADVr_ADV_SEL_FIELDf_SET
#define ANADVr_ADV_B10Tf_GET BCM53262_A0_ANADVr_ADV_B10Tf_GET
#define ANADVr_ADV_B10Tf_SET BCM53262_A0_ANADVr_ADV_B10Tf_SET
#define ANADVr_ADV_B10T_FDXf_GET BCM53262_A0_ANADVr_ADV_B10T_FDXf_GET
#define ANADVr_ADV_B10T_FDXf_SET BCM53262_A0_ANADVr_ADV_B10T_FDXf_SET
#define ANADVr_ADV_B100Xf_GET BCM53262_A0_ANADVr_ADV_B100Xf_GET
#define ANADVr_ADV_B100Xf_SET BCM53262_A0_ANADVr_ADV_B100Xf_SET
#define ANADVr_ADV_B100X_FDXf_GET BCM53262_A0_ANADVr_ADV_B100X_FDXf_GET
#define ANADVr_ADV_B100X_FDXf_SET BCM53262_A0_ANADVr_ADV_B100X_FDXf_SET
#define ANADVr_ADV_B100T4f_GET BCM53262_A0_ANADVr_ADV_B100T4f_GET
#define ANADVr_ADV_B100T4f_SET BCM53262_A0_ANADVr_ADV_B100T4f_SET
#define ANADVr_ADV_PAUSE_CAPf_GET BCM53262_A0_ANADVr_ADV_PAUSE_CAPf_GET
#define ANADVr_ADV_PAUSE_CAPf_SET BCM53262_A0_ANADVr_ADV_PAUSE_CAPf_SET
#define ANADVr_RESV_TECHf_GET BCM53262_A0_ANADVr_RESV_TECHf_GET
#define ANADVr_RESV_TECHf_SET BCM53262_A0_ANADVr_RESV_TECHf_SET
#define ANADVr_REMOTE_FAULT_Rf_GET BCM53262_A0_ANADVr_REMOTE_FAULT_Rf_GET
#define ANADVr_REMOTE_FAULT_Rf_SET BCM53262_A0_ANADVr_REMOTE_FAULT_Rf_SET
#define ANADVr_RESERVED_Rf_GET BCM53262_A0_ANADVr_RESERVED_Rf_GET
#define ANADVr_RESERVED_Rf_SET BCM53262_A0_ANADVr_RESERVED_Rf_SET
#define ANADVr_NEXT_PAGEf_GET BCM53262_A0_ANADVr_NEXT_PAGEf_GET
#define ANADVr_NEXT_PAGEf_SET BCM53262_A0_ANADVr_NEXT_PAGEf_SET
#define READ_ANADVr BCM53262_A0_READ_ANADVr
#define WRITE_ANADVr BCM53262_A0_WRITE_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ANADVr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ANEXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_ANEXPr 0x0000a00c

#define BCM53262_A0_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program ANEXP.
 */
typedef union BCM53262_A0_ANEXPr_s {
	uint32_t v[1];
	uint32_t anexp[1];
	uint32_t _anexp;
} BCM53262_A0_ANEXPr_t;

#define BCM53262_A0_ANEXPr_CLR(r) (r).anexp[0] = 0
#define BCM53262_A0_ANEXPr_SET(r,d) (r).anexp[0] = d
#define BCM53262_A0_ANEXPr_GET(r) (r).anexp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ANEXPr_RESERVED_Rf_GET(r) (((r).anexp[0]) & 0xffff)
#define BCM53262_A0_ANEXPr_RESERVED_Rf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ANEXP.
 */
#define BCM53262_A0_READ_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_ANEXPr,(r._anexp),2)
#define BCM53262_A0_WRITE_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_ANEXPr,&(r._anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANEXPr BCM53262_A0_ANEXPr
#define ANEXPr_SIZE BCM53262_A0_ANEXPr_SIZE
typedef BCM53262_A0_ANEXPr_t ANEXPr_t;
#define ANEXPr_CLR BCM53262_A0_ANEXPr_CLR
#define ANEXPr_SET BCM53262_A0_ANEXPr_SET
#define ANEXPr_GET BCM53262_A0_ANEXPr_GET
#define ANEXPr_RESERVED_Rf_GET BCM53262_A0_ANEXPr_RESERVED_Rf_GET
#define ANEXPr_RESERVED_Rf_SET BCM53262_A0_ANEXPr_RESERVED_Rf_SET
#define READ_ANEXPr BCM53262_A0_READ_ANEXPr
#define WRITE_ANEXPr BCM53262_A0_WRITE_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ANEXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ANLPAR
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_ANLPARr 0x0000a00a

#define BCM53262_A0_ANLPARr_SIZE 2

/*
 * This structure should be used to declare and program ANLPAR.
 */
typedef union BCM53262_A0_ANLPARr_s {
	uint32_t v[1];
	uint32_t anlpar[1];
	uint32_t _anlpar;
} BCM53262_A0_ANLPARr_t;

#define BCM53262_A0_ANLPARr_CLR(r) (r).anlpar[0] = 0
#define BCM53262_A0_ANLPARr_SET(r,d) (r).anlpar[0] = d
#define BCM53262_A0_ANLPARr_GET(r) (r).anlpar[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ANLPARr_RESERVED_Rf_GET(r) (((r).anlpar[0]) & 0xffff)
#define BCM53262_A0_ANLPARr_RESERVED_Rf_SET(r,f) (r).anlpar[0]=(((r).anlpar[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ANLPAR.
 */
#define BCM53262_A0_READ_ANLPARr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_ANLPARr,(r._anlpar),2)
#define BCM53262_A0_WRITE_ANLPARr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_ANLPARr,&(r._anlpar),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANLPARr BCM53262_A0_ANLPARr
#define ANLPARr_SIZE BCM53262_A0_ANLPARr_SIZE
typedef BCM53262_A0_ANLPARr_t ANLPARr_t;
#define ANLPARr_CLR BCM53262_A0_ANLPARr_CLR
#define ANLPARr_SET BCM53262_A0_ANLPARr_SET
#define ANLPARr_GET BCM53262_A0_ANLPARr_GET
#define ANLPARr_RESERVED_Rf_GET BCM53262_A0_ANLPARr_RESERVED_Rf_GET
#define ANLPARr_RESERVED_Rf_SET BCM53262_A0_ANLPARr_RESERVED_Rf_SET
#define READ_ANLPARr BCM53262_A0_READ_ANLPARr
#define WRITE_ANLPARr BCM53262_A0_WRITE_ANLPARr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ANLPARr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ANNXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Next Page Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_ANNXPr 0x0000a00e

#define BCM53262_A0_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program ANNXP.
 */
typedef union BCM53262_A0_ANNXPr_s {
	uint32_t v[1];
	uint32_t annxp[1];
	uint32_t _annxp;
} BCM53262_A0_ANNXPr_t;

#define BCM53262_A0_ANNXPr_CLR(r) (r).annxp[0] = 0
#define BCM53262_A0_ANNXPr_SET(r,d) (r).annxp[0] = d
#define BCM53262_A0_ANNXPr_GET(r) (r).annxp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ANNXPr_RESERVED_Rf_GET(r) (((r).annxp[0]) & 0xffff)
#define BCM53262_A0_ANNXPr_RESERVED_Rf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ANNXP.
 */
#define BCM53262_A0_READ_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_ANNXPr,(r._annxp),2)
#define BCM53262_A0_WRITE_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_ANNXPr,&(r._annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANNXPr BCM53262_A0_ANNXPr
#define ANNXPr_SIZE BCM53262_A0_ANNXPr_SIZE
typedef BCM53262_A0_ANNXPr_t ANNXPr_t;
#define ANNXPr_CLR BCM53262_A0_ANNXPr_CLR
#define ANNXPr_SET BCM53262_A0_ANNXPr_SET
#define ANNXPr_GET BCM53262_A0_ANNXPr_GET
#define ANNXPr_RESERVED_Rf_GET BCM53262_A0_ANNXPr_RESERVED_Rf_GET
#define ANNXPr_RESERVED_Rf_SET BCM53262_A0_ANNXPr_RESERVED_Rf_SET
#define READ_ANNXPr BCM53262_A0_READ_ANNXPr
#define WRITE_ANNXPr BCM53262_A0_WRITE_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ANNXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_ENTRY_0
 * BLOCKS:   SYS
 * DESC:     ARL Entry0 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address.
 *     ARL_PID          Port Identification (for Unicast Address)The port number which identifies where the station with unique MACADDR is connected.Multicast Index (for Multicast Address)multicast_index[5:0]
 *     ARL_ENTRY_RSRV0  Reserved (for Unicast Address)Multicast Index (for Multicast Address)multicast_index[10:6]
 *     ARL_AGE          Age (for Unicast Address)Set to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast Index (for Multicast Address)multicast_index[11]
 *     ARL_CON          ARL mode control00: Normal ARL function. Forward to destination port specified by ARL.01: Drop if MAC_DA match. (Please also set bit 62)10: Drop if MAC_SA match. (Please also set bit 62)11: Forward to destination port specified by ARL.  And also send to IMP. (Please aslo set bit 62)
 *     ARL_STATIC       StaticSet to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        ValidSet to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 */
#define BCM53262_A0_ARLA_ENTRY_0r 0x00000510

#define BCM53262_A0_ARLA_ENTRY_0r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_ENTRY_0.
 */
typedef union BCM53262_A0_ARLA_ENTRY_0r_s {
	uint32_t v[2];
	uint32_t arla_entry_0[2];
	uint32_t _arla_entry_0;
} BCM53262_A0_ARLA_ENTRY_0r_t;

#define BCM53262_A0_ARLA_ENTRY_0r_CLR(r) CDK_MEMSET(&((r)._arla_entry_0), 0, sizeof(BCM53262_A0_ARLA_ENTRY_0r_t))
#define BCM53262_A0_ARLA_ENTRY_0r_SET(r,i,d) (r).arla_entry_0[i] = d
#define BCM53262_A0_ARLA_ENTRY_0r_GET(r,i) (r).arla_entry_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_entry_0,0,47,a)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_entry_0,0,47,a)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_PIDf_GET(r) ((((r).arla_entry_0[1]) >> 16) & 0x3f)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_PIDf_SET(r,f) (r).arla_entry_0[1]=(((r).arla_entry_0[1] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_ENTRY_RSRV0f_GET(r) ((((r).arla_entry_0[1]) >> 22) & 0x1f)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_ENTRY_RSRV0f_SET(r,f) (r).arla_entry_0[1]=(((r).arla_entry_0[1] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_AGEf_GET(r) ((((r).arla_entry_0[1]) >> 27) & 0x1)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_AGEf_SET(r,f) (r).arla_entry_0[1]=(((r).arla_entry_0[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_CONf_GET(r) ((((r).arla_entry_0[1]) >> 28) & 0x3)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_CONf_SET(r,f) (r).arla_entry_0[1]=(((r).arla_entry_0[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_STATICf_GET(r) ((((r).arla_entry_0[1]) >> 30) & 0x1)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_STATICf_SET(r,f) (r).arla_entry_0[1]=(((r).arla_entry_0[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_VALIDf_GET(r) ((((r).arla_entry_0[1]) >> 31) & 0x1)
#define BCM53262_A0_ARLA_ENTRY_0r_ARL_VALIDf_SET(r,f) (r).arla_entry_0[1]=(((r).arla_entry_0[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ARLA_ENTRY_0.
 */
#define BCM53262_A0_READ_ARLA_ENTRY_0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_ENTRY_0r,(r._arla_entry_0),8)
#define BCM53262_A0_WRITE_ARLA_ENTRY_0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_ENTRY_0r,&(r._arla_entry_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_ENTRY_0r BCM53262_A0_ARLA_ENTRY_0r
#define ARLA_ENTRY_0r_SIZE BCM53262_A0_ARLA_ENTRY_0r_SIZE
typedef BCM53262_A0_ARLA_ENTRY_0r_t ARLA_ENTRY_0r_t;
#define ARLA_ENTRY_0r_CLR BCM53262_A0_ARLA_ENTRY_0r_CLR
#define ARLA_ENTRY_0r_SET BCM53262_A0_ARLA_ENTRY_0r_SET
#define ARLA_ENTRY_0r_GET BCM53262_A0_ARLA_ENTRY_0r_GET
#define ARLA_ENTRY_0r_ARL_MACADDRf_GET BCM53262_A0_ARLA_ENTRY_0r_ARL_MACADDRf_GET
#define ARLA_ENTRY_0r_ARL_MACADDRf_SET BCM53262_A0_ARLA_ENTRY_0r_ARL_MACADDRf_SET
#define ARLA_ENTRY_0r_ARL_PIDf_GET BCM53262_A0_ARLA_ENTRY_0r_ARL_PIDf_GET
#define ARLA_ENTRY_0r_ARL_PIDf_SET BCM53262_A0_ARLA_ENTRY_0r_ARL_PIDf_SET
#define ARLA_ENTRY_0r_ARL_ENTRY_RSRV0f_GET BCM53262_A0_ARLA_ENTRY_0r_ARL_ENTRY_RSRV0f_GET
#define ARLA_ENTRY_0r_ARL_ENTRY_RSRV0f_SET BCM53262_A0_ARLA_ENTRY_0r_ARL_ENTRY_RSRV0f_SET
#define ARLA_ENTRY_0r_ARL_AGEf_GET BCM53262_A0_ARLA_ENTRY_0r_ARL_AGEf_GET
#define ARLA_ENTRY_0r_ARL_AGEf_SET BCM53262_A0_ARLA_ENTRY_0r_ARL_AGEf_SET
#define ARLA_ENTRY_0r_ARL_CONf_GET BCM53262_A0_ARLA_ENTRY_0r_ARL_CONf_GET
#define ARLA_ENTRY_0r_ARL_CONf_SET BCM53262_A0_ARLA_ENTRY_0r_ARL_CONf_SET
#define ARLA_ENTRY_0r_ARL_STATICf_GET BCM53262_A0_ARLA_ENTRY_0r_ARL_STATICf_GET
#define ARLA_ENTRY_0r_ARL_STATICf_SET BCM53262_A0_ARLA_ENTRY_0r_ARL_STATICf_SET
#define ARLA_ENTRY_0r_ARL_VALIDf_GET BCM53262_A0_ARLA_ENTRY_0r_ARL_VALIDf_GET
#define ARLA_ENTRY_0r_ARL_VALIDf_SET BCM53262_A0_ARLA_ENTRY_0r_ARL_VALIDf_SET
#define READ_ARLA_ENTRY_0r BCM53262_A0_READ_ARLA_ENTRY_0r
#define WRITE_ARLA_ENTRY_0r BCM53262_A0_WRITE_ARLA_ENTRY_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_ENTRY_0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_ENTRY_1
 * BLOCKS:   SYS
 * DESC:     ARL Entry1 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address.
 *     ARL_PID          Port Identification (for Unicast Address)The port number which identifies where the station with unique MACADDR is connected.Multicast Index (for Multicast Address)multicast_index[5:0]
 *     ARL_ENTRY_RSRV0  Reserved (for Unicast Address)Multicast Index (for Multicast Address)multicast_index[10:6]
 *     ARL_AGE          Age (for Unicast Address)Set to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast Index (for Multicast Address)multicast_index[11]
 *     ARL_CON          ARL mode control00: Normal ARL function. Forward to destination port specified by ARL.01: Drop if MAC_DA match. (Please also set bit 62)10: Drop if MAC_SA match. (Please also set bit 62)11: Forward to destination port specified by ARL.  And also send to IMP. (Please aslo set bit 62)
 *     ARL_STATIC       StaticSet to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        ValidSet to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 */
#define BCM53262_A0_ARLA_ENTRY_1r 0x00000518

#define BCM53262_A0_ARLA_ENTRY_1r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_ENTRY_1.
 */
typedef union BCM53262_A0_ARLA_ENTRY_1r_s {
	uint32_t v[2];
	uint32_t arla_entry_1[2];
	uint32_t _arla_entry_1;
} BCM53262_A0_ARLA_ENTRY_1r_t;

#define BCM53262_A0_ARLA_ENTRY_1r_CLR(r) CDK_MEMSET(&((r)._arla_entry_1), 0, sizeof(BCM53262_A0_ARLA_ENTRY_1r_t))
#define BCM53262_A0_ARLA_ENTRY_1r_SET(r,i,d) (r).arla_entry_1[i] = d
#define BCM53262_A0_ARLA_ENTRY_1r_GET(r,i) (r).arla_entry_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_entry_1,0,47,a)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_entry_1,0,47,a)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_PIDf_GET(r) ((((r).arla_entry_1[1]) >> 16) & 0x3f)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_PIDf_SET(r,f) (r).arla_entry_1[1]=(((r).arla_entry_1[1] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_ENTRY_RSRV0f_GET(r) ((((r).arla_entry_1[1]) >> 22) & 0x1f)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_ENTRY_RSRV0f_SET(r,f) (r).arla_entry_1[1]=(((r).arla_entry_1[1] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_AGEf_GET(r) ((((r).arla_entry_1[1]) >> 27) & 0x1)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_AGEf_SET(r,f) (r).arla_entry_1[1]=(((r).arla_entry_1[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_CONf_GET(r) ((((r).arla_entry_1[1]) >> 28) & 0x3)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_CONf_SET(r,f) (r).arla_entry_1[1]=(((r).arla_entry_1[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_STATICf_GET(r) ((((r).arla_entry_1[1]) >> 30) & 0x1)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_STATICf_SET(r,f) (r).arla_entry_1[1]=(((r).arla_entry_1[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_VALIDf_GET(r) ((((r).arla_entry_1[1]) >> 31) & 0x1)
#define BCM53262_A0_ARLA_ENTRY_1r_ARL_VALIDf_SET(r,f) (r).arla_entry_1[1]=(((r).arla_entry_1[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ARLA_ENTRY_1.
 */
#define BCM53262_A0_READ_ARLA_ENTRY_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_ENTRY_1r,(r._arla_entry_1),8)
#define BCM53262_A0_WRITE_ARLA_ENTRY_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_ENTRY_1r,&(r._arla_entry_1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_ENTRY_1r BCM53262_A0_ARLA_ENTRY_1r
#define ARLA_ENTRY_1r_SIZE BCM53262_A0_ARLA_ENTRY_1r_SIZE
typedef BCM53262_A0_ARLA_ENTRY_1r_t ARLA_ENTRY_1r_t;
#define ARLA_ENTRY_1r_CLR BCM53262_A0_ARLA_ENTRY_1r_CLR
#define ARLA_ENTRY_1r_SET BCM53262_A0_ARLA_ENTRY_1r_SET
#define ARLA_ENTRY_1r_GET BCM53262_A0_ARLA_ENTRY_1r_GET
#define ARLA_ENTRY_1r_ARL_MACADDRf_GET BCM53262_A0_ARLA_ENTRY_1r_ARL_MACADDRf_GET
#define ARLA_ENTRY_1r_ARL_MACADDRf_SET BCM53262_A0_ARLA_ENTRY_1r_ARL_MACADDRf_SET
#define ARLA_ENTRY_1r_ARL_PIDf_GET BCM53262_A0_ARLA_ENTRY_1r_ARL_PIDf_GET
#define ARLA_ENTRY_1r_ARL_PIDf_SET BCM53262_A0_ARLA_ENTRY_1r_ARL_PIDf_SET
#define ARLA_ENTRY_1r_ARL_ENTRY_RSRV0f_GET BCM53262_A0_ARLA_ENTRY_1r_ARL_ENTRY_RSRV0f_GET
#define ARLA_ENTRY_1r_ARL_ENTRY_RSRV0f_SET BCM53262_A0_ARLA_ENTRY_1r_ARL_ENTRY_RSRV0f_SET
#define ARLA_ENTRY_1r_ARL_AGEf_GET BCM53262_A0_ARLA_ENTRY_1r_ARL_AGEf_GET
#define ARLA_ENTRY_1r_ARL_AGEf_SET BCM53262_A0_ARLA_ENTRY_1r_ARL_AGEf_SET
#define ARLA_ENTRY_1r_ARL_CONf_GET BCM53262_A0_ARLA_ENTRY_1r_ARL_CONf_GET
#define ARLA_ENTRY_1r_ARL_CONf_SET BCM53262_A0_ARLA_ENTRY_1r_ARL_CONf_SET
#define ARLA_ENTRY_1r_ARL_STATICf_GET BCM53262_A0_ARLA_ENTRY_1r_ARL_STATICf_GET
#define ARLA_ENTRY_1r_ARL_STATICf_SET BCM53262_A0_ARLA_ENTRY_1r_ARL_STATICf_SET
#define ARLA_ENTRY_1r_ARL_VALIDf_GET BCM53262_A0_ARLA_ENTRY_1r_ARL_VALIDf_GET
#define ARLA_ENTRY_1r_ARL_VALIDf_SET BCM53262_A0_ARLA_ENTRY_1r_ARL_VALIDf_SET
#define READ_ARLA_ENTRY_1r BCM53262_A0_READ_ARLA_ENTRY_1r
#define WRITE_ARLA_ENTRY_1r BCM53262_A0_WRITE_ARLA_ENTRY_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_ENTRY_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_MAC
 * BLOCKS:   SYS
 * DESC:     MAC Address Index Register
 * SIZE:     48
 * FIELDS:
 *     MAC_ADDR_INDX    MAC Address IndexThe MAC address for which status is to be read or written. By writing the 48 bit SA or DA address, and initiating a read command, the complete ARL bin location (2 entries deep) is returned in the ARL Entry 0/1 locations. Both entries are 64 bits wide. Initiating a write command will write the contents of ARL Entry 0/1 to the specified bin location (2 entries deep) and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.Note : This register is also used to access MAC2VLAN table.
 */
#define BCM53262_A0_ARLA_MACr 0x00000502

#define BCM53262_A0_ARLA_MACr_SIZE 6

/*
 * This structure should be used to declare and program ARLA_MAC.
 */
typedef union BCM53262_A0_ARLA_MACr_s {
	uint32_t v[2];
	uint32_t arla_mac[2];
	uint32_t _arla_mac;
} BCM53262_A0_ARLA_MACr_t;

#define BCM53262_A0_ARLA_MACr_CLR(r) CDK_MEMSET(&((r)._arla_mac), 0, sizeof(BCM53262_A0_ARLA_MACr_t))
#define BCM53262_A0_ARLA_MACr_SET(r,i,d) (r).arla_mac[i] = d
#define BCM53262_A0_ARLA_MACr_GET(r,i) (r).arla_mac[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_MACr_MAC_ADDR_INDXf_GET(r,a) cdk_field_get((r).arla_mac,0,47,a)
#define BCM53262_A0_ARLA_MACr_MAC_ADDR_INDXf_SET(r,a) cdk_field_set((r).arla_mac,0,47,a)

/*
 * These macros can be used to access ARLA_MAC.
 */
#define BCM53262_A0_READ_ARLA_MACr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_MACr,(r._arla_mac),6)
#define BCM53262_A0_WRITE_ARLA_MACr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_MACr,&(r._arla_mac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACr BCM53262_A0_ARLA_MACr
#define ARLA_MACr_SIZE BCM53262_A0_ARLA_MACr_SIZE
typedef BCM53262_A0_ARLA_MACr_t ARLA_MACr_t;
#define ARLA_MACr_CLR BCM53262_A0_ARLA_MACr_CLR
#define ARLA_MACr_SET BCM53262_A0_ARLA_MACr_SET
#define ARLA_MACr_GET BCM53262_A0_ARLA_MACr_GET
#define ARLA_MACr_MAC_ADDR_INDXf_GET BCM53262_A0_ARLA_MACr_MAC_ADDR_INDXf_GET
#define ARLA_MACr_MAC_ADDR_INDXf_SET BCM53262_A0_ARLA_MACr_MAC_ADDR_INDXf_SET
#define READ_ARLA_MACr BCM53262_A0_READ_ARLA_MACr
#define WRITE_ARLA_MACr BCM53262_A0_WRITE_ARLA_MACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_MACr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_RWCTL
 * BLOCKS:   SYS
 * DESC:     ARL Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     TAB_RW           Read/Write1 = Read.0 = write.
 *     TAB_INDEX        000 = ARL table access.001 = VLAN table access.010 = Multicast table access.011 = Multiple spanning tree table.100 = VLAN2VLAN table access.101 = MAC2VLAN table access.110 = PROTOCOL2VLAN table access.111 = FLOW2VLAN table access.
 *     ARLA_RWCTL_RSRV0 Reserved
 *     ARL_STRTDN       Start/Done Command.Write as 1 to initiate a read or write command for a table access (ARL table, VLAN table , Multicast table or Multiple spanning tree).It will be reset to indicate a write operation completed, or a read operation has completed.
 */
#define BCM53262_A0_ARLA_RWCTLr 0x00000500

#define BCM53262_A0_ARLA_RWCTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_RWCTL.
 */
typedef union BCM53262_A0_ARLA_RWCTLr_s {
	uint32_t v[1];
	uint32_t arla_rwctl[1];
	uint32_t _arla_rwctl;
} BCM53262_A0_ARLA_RWCTLr_t;

#define BCM53262_A0_ARLA_RWCTLr_CLR(r) (r).arla_rwctl[0] = 0
#define BCM53262_A0_ARLA_RWCTLr_SET(r,d) (r).arla_rwctl[0] = d
#define BCM53262_A0_ARLA_RWCTLr_GET(r) (r).arla_rwctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_RWCTLr_TAB_RWf_GET(r) (((r).arla_rwctl[0]) & 0x1)
#define BCM53262_A0_ARLA_RWCTLr_TAB_RWf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_ARLA_RWCTLr_TAB_INDEXf_GET(r) ((((r).arla_rwctl[0]) >> 1) & 0x7)
#define BCM53262_A0_ARLA_RWCTLr_TAB_INDEXf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53262_A0_ARLA_RWCTLr_ARLA_RWCTL_RSRV0f_GET(r) ((((r).arla_rwctl[0]) >> 4) & 0x7)
#define BCM53262_A0_ARLA_RWCTLr_ARLA_RWCTL_RSRV0f_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53262_A0_ARLA_RWCTLr_ARL_STRTDNf_GET(r) ((((r).arla_rwctl[0]) >> 7) & 0x1)
#define BCM53262_A0_ARLA_RWCTLr_ARL_STRTDNf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_RWCTL.
 */
#define BCM53262_A0_READ_ARLA_RWCTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_RWCTLr,(r._arla_rwctl),1)
#define BCM53262_A0_WRITE_ARLA_RWCTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_RWCTLr,&(r._arla_rwctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_RWCTLr BCM53262_A0_ARLA_RWCTLr
#define ARLA_RWCTLr_SIZE BCM53262_A0_ARLA_RWCTLr_SIZE
typedef BCM53262_A0_ARLA_RWCTLr_t ARLA_RWCTLr_t;
#define ARLA_RWCTLr_CLR BCM53262_A0_ARLA_RWCTLr_CLR
#define ARLA_RWCTLr_SET BCM53262_A0_ARLA_RWCTLr_SET
#define ARLA_RWCTLr_GET BCM53262_A0_ARLA_RWCTLr_GET
#define ARLA_RWCTLr_TAB_RWf_GET BCM53262_A0_ARLA_RWCTLr_TAB_RWf_GET
#define ARLA_RWCTLr_TAB_RWf_SET BCM53262_A0_ARLA_RWCTLr_TAB_RWf_SET
#define ARLA_RWCTLr_TAB_INDEXf_GET BCM53262_A0_ARLA_RWCTLr_TAB_INDEXf_GET
#define ARLA_RWCTLr_TAB_INDEXf_SET BCM53262_A0_ARLA_RWCTLr_TAB_INDEXf_SET
#define ARLA_RWCTLr_ARLA_RWCTL_RSRV0f_GET BCM53262_A0_ARLA_RWCTLr_ARLA_RWCTL_RSRV0f_GET
#define ARLA_RWCTLr_ARLA_RWCTL_RSRV0f_SET BCM53262_A0_ARLA_RWCTLr_ARLA_RWCTL_RSRV0f_SET
#define ARLA_RWCTLr_ARL_STRTDNf_GET BCM53262_A0_ARLA_RWCTLr_ARL_STRTDNf_GET
#define ARLA_RWCTLr_ARL_STRTDNf_SET BCM53262_A0_ARLA_RWCTLr_ARL_STRTDNf_SET
#define READ_ARLA_RWCTLr BCM53262_A0_READ_ARLA_RWCTLr
#define WRITE_ARLA_RWCTLr BCM53262_A0_WRITE_ARLA_RWCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_RWCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_SRCH_ADR
 * BLOCKS:   SYS
 * DESC:     ARL Search Address Register
 * SIZE:     16
 * FIELDS:
 *     SRCH_ADR         ARL Address13 bit internal representation of the address of the ARL entry currently being accessed by the ARL search routine. This is not a direct address of the ARL location, and is intended for factory test/ diagnostic use only.
 *     RESERVED_R       Reserved.
 *     ARLA_SRCH_ADR_EN ARL Address ValidIndicates the lower 15 bits of this register contain a valid internal representation of the ARL entry currently being accessed. Intended for factory test/ diagnostic use only.
 */
#define BCM53262_A0_ARLA_SRCH_ADRr 0x00000552

#define BCM53262_A0_ARLA_SRCH_ADRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_ADR.
 */
typedef union BCM53262_A0_ARLA_SRCH_ADRr_s {
	uint32_t v[1];
	uint32_t arla_srch_adr[1];
	uint32_t _arla_srch_adr;
} BCM53262_A0_ARLA_SRCH_ADRr_t;

#define BCM53262_A0_ARLA_SRCH_ADRr_CLR(r) (r).arla_srch_adr[0] = 0
#define BCM53262_A0_ARLA_SRCH_ADRr_SET(r,d) (r).arla_srch_adr[0] = d
#define BCM53262_A0_ARLA_SRCH_ADRr_GET(r) (r).arla_srch_adr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_SRCH_ADRr_SRCH_ADRf_GET(r) (((r).arla_srch_adr[0]) & 0x1fff)
#define BCM53262_A0_ARLA_SRCH_ADRr_SRCH_ADRf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53262_A0_ARLA_SRCH_ADRr_RESERVED_Rf_GET(r) ((((r).arla_srch_adr[0]) >> 13) & 0x3)
#define BCM53262_A0_ARLA_SRCH_ADRr_RESERVED_Rf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53262_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_GET(r) ((((r).arla_srch_adr[0]) >> 15) & 0x1)
#define BCM53262_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_ADR.
 */
#define BCM53262_A0_READ_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_SRCH_ADRr,(r._arla_srch_adr),2)
#define BCM53262_A0_WRITE_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_SRCH_ADRr,&(r._arla_srch_adr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_ADRr BCM53262_A0_ARLA_SRCH_ADRr
#define ARLA_SRCH_ADRr_SIZE BCM53262_A0_ARLA_SRCH_ADRr_SIZE
typedef BCM53262_A0_ARLA_SRCH_ADRr_t ARLA_SRCH_ADRr_t;
#define ARLA_SRCH_ADRr_CLR BCM53262_A0_ARLA_SRCH_ADRr_CLR
#define ARLA_SRCH_ADRr_SET BCM53262_A0_ARLA_SRCH_ADRr_SET
#define ARLA_SRCH_ADRr_GET BCM53262_A0_ARLA_SRCH_ADRr_GET
#define ARLA_SRCH_ADRr_SRCH_ADRf_GET BCM53262_A0_ARLA_SRCH_ADRr_SRCH_ADRf_GET
#define ARLA_SRCH_ADRr_SRCH_ADRf_SET BCM53262_A0_ARLA_SRCH_ADRr_SRCH_ADRf_SET
#define ARLA_SRCH_ADRr_RESERVED_Rf_GET BCM53262_A0_ARLA_SRCH_ADRr_RESERVED_Rf_GET
#define ARLA_SRCH_ADRr_RESERVED_Rf_SET BCM53262_A0_ARLA_SRCH_ADRr_RESERVED_Rf_SET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_GET BCM53262_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_SET BCM53262_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_SET
#define READ_ARLA_SRCH_ADRr BCM53262_A0_READ_ARLA_SRCH_ADRr
#define WRITE_ARLA_SRCH_ADRr BCM53262_A0_WRITE_ARLA_SRCH_ADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_SRCH_ADRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_SRCH_CTL
 * BLOCKS:   SYS
 * DESC:     ARL Search Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_SRCH_VLID   ARL Search Result ValidSet by the chip to indicate that an ARL entry is available in the ARL Search Result register.Reset by a host read to the ARL Search Result register, which will cause the ARL search process to continue through the ARL entries until the next entry is found with a Valid bit is set.
 *     ARLA_SRCH_RSRV0  Reserved
 *     ARLA_SRCH_STDN   Start/DoneWrite as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result MAC Register causes the ARL search to continue.The BCM53242 will clear this bit to indicate the entire ARL entry database has been searched.
 */
#define BCM53262_A0_ARLA_SRCH_CTLr 0x00000550

#define BCM53262_A0_ARLA_SRCH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_SRCH_CTL.
 */
typedef union BCM53262_A0_ARLA_SRCH_CTLr_s {
	uint32_t v[1];
	uint32_t arla_srch_ctl[1];
	uint32_t _arla_srch_ctl;
} BCM53262_A0_ARLA_SRCH_CTLr_t;

#define BCM53262_A0_ARLA_SRCH_CTLr_CLR(r) (r).arla_srch_ctl[0] = 0
#define BCM53262_A0_ARLA_SRCH_CTLr_SET(r,d) (r).arla_srch_ctl[0] = d
#define BCM53262_A0_ARLA_SRCH_CTLr_GET(r) (r).arla_srch_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET(r) (((r).arla_srch_ctl[0]) & 0x1)
#define BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_RSRV0f_GET(r) ((((r).arla_srch_ctl[0]) >> 1) & 0x3f)
#define BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_RSRV0f_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET(r) ((((r).arla_srch_ctl[0]) >> 7) & 0x1)
#define BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_SRCH_CTL.
 */
#define BCM53262_A0_READ_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_SRCH_CTLr,(r._arla_srch_ctl),1)
#define BCM53262_A0_WRITE_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_SRCH_CTLr,&(r._arla_srch_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_CTLr BCM53262_A0_ARLA_SRCH_CTLr
#define ARLA_SRCH_CTLr_SIZE BCM53262_A0_ARLA_SRCH_CTLr_SIZE
typedef BCM53262_A0_ARLA_SRCH_CTLr_t ARLA_SRCH_CTLr_t;
#define ARLA_SRCH_CTLr_CLR BCM53262_A0_ARLA_SRCH_CTLr_CLR
#define ARLA_SRCH_CTLr_SET BCM53262_A0_ARLA_SRCH_CTLr_SET
#define ARLA_SRCH_CTLr_GET BCM53262_A0_ARLA_SRCH_CTLr_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET
#define ARLA_SRCH_CTLr_ARLA_SRCH_RSRV0f_GET BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_RSRV0f_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_RSRV0f_SET BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_RSRV0f_SET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET BCM53262_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET
#define READ_ARLA_SRCH_CTLr BCM53262_A0_READ_ARLA_SRCH_CTLr
#define WRITE_ARLA_SRCH_CTLr BCM53262_A0_WRITE_ARLA_SRCH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_SRCH_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_SRCH_RSLT
 * BLOCKS:   SYS
 * DESC:     ARL Search Result MAC Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_RSLT_ADDR MAC AddressThe unique MAC address of the station occupying this ARL entry.
 *     ARLA_SRCH_RSLT_PRID Port IdentificationThe port number which identifies where the station with unique MACADDR is connected.
 *     ENTRY_RSRV0      Unused bit.
 *     ARLA_SRCH_RSLT_AGE AgeSet to indicate that this address entry has been learned or accessed. Reset by the internal aging algorithm.The ARL search process will return an entry if it is Valid and/or Static, the AGE bit is irrelevant.
 *     ARL_SRCH_RSLT_CON ARL mode control00: Normal ARL function. Forward to destination port specified by ARL.01: Drop if MAC_DA match. (Please also set bit 62)10: Drop if MAC_SA match. (Please also set bit 62)11: Forward to destination port specified by ARL.  And also send to IMP. (Please aslo set bit 62)
 *     ARLA_SRCH_RSLT_STATIC StaticSet to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.All entries with the STATIC bit set will be returned by the ARL search process.When cleared, the internal learning and aging process will control the validity of this entry.
 *     ARLA_SRCH_RSLT_VLID ValidIndicates a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.All entries returned by the ARL search process will have the VALID bit set.
 */
#define BCM53262_A0_ARLA_SRCH_RSLTr 0x00000554

#define BCM53262_A0_ARLA_SRCH_RSLTr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT.
 */
typedef union BCM53262_A0_ARLA_SRCH_RSLTr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt[2];
	uint32_t _arla_srch_rslt;
} BCM53262_A0_ARLA_SRCH_RSLTr_t;

#define BCM53262_A0_ARLA_SRCH_RSLTr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt), 0, sizeof(BCM53262_A0_ARLA_SRCH_RSLTr_t))
#define BCM53262_A0_ARLA_SRCH_RSLTr_SET(r,i,d) (r).arla_srch_rslt[i] = d
#define BCM53262_A0_ARLA_SRCH_RSLTr_GET(r,i) (r).arla_srch_rslt[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_ADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt,0,47,a)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_ADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt,0,47,a)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIDf_GET(r) ((((r).arla_srch_rslt[1]) >> 16) & 0x3f)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIDf_SET(r,f) (r).arla_srch_rslt[1]=(((r).arla_srch_rslt[1] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53262_A0_ARLA_SRCH_RSLTr_ENTRY_RSRV0f_GET(r) ((((r).arla_srch_rslt[1]) >> 22) & 0x1f)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ENTRY_RSRV0f_SET(r,f) (r).arla_srch_rslt[1]=(((r).arla_srch_rslt[1] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt[1]) >> 27) & 0x1)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt[1]=(((r).arla_srch_rslt[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARL_SRCH_RSLT_CONf_GET(r) ((((r).arla_srch_rslt[1]) >> 28) & 0x3)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARL_SRCH_RSLT_CONf_SET(r,f) (r).arla_srch_rslt[1]=(((r).arla_srch_rslt[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt[1]) >> 30) & 0x1)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt[1]=(((r).arla_srch_rslt[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt[1]) >> 31) & 0x1)
#define BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt[1]=(((r).arla_srch_rslt[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ARLA_SRCH_RSLT.
 */
#define BCM53262_A0_READ_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_SRCH_RSLTr,(r._arla_srch_rslt),8)
#define BCM53262_A0_WRITE_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_SRCH_RSLTr,&(r._arla_srch_rslt),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLTr BCM53262_A0_ARLA_SRCH_RSLTr
#define ARLA_SRCH_RSLTr_SIZE BCM53262_A0_ARLA_SRCH_RSLTr_SIZE
typedef BCM53262_A0_ARLA_SRCH_RSLTr_t ARLA_SRCH_RSLTr_t;
#define ARLA_SRCH_RSLTr_CLR BCM53262_A0_ARLA_SRCH_RSLTr_CLR
#define ARLA_SRCH_RSLTr_SET BCM53262_A0_ARLA_SRCH_RSLTr_SET
#define ARLA_SRCH_RSLTr_GET BCM53262_A0_ARLA_SRCH_RSLTr_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_ADDRf_GET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_ADDRf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_ADDRf_SET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_ADDRf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIDf_GET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIDf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIDf_SET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIDf_SET
#define ARLA_SRCH_RSLTr_ENTRY_RSRV0f_GET BCM53262_A0_ARLA_SRCH_RSLTr_ENTRY_RSRV0f_GET
#define ARLA_SRCH_RSLTr_ENTRY_RSRV0f_SET BCM53262_A0_ARLA_SRCH_RSLTr_ENTRY_RSRV0f_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLTr_ARL_SRCH_RSLT_CONf_GET BCM53262_A0_ARLA_SRCH_RSLTr_ARL_SRCH_RSLT_CONf_GET
#define ARLA_SRCH_RSLTr_ARL_SRCH_RSLT_CONf_SET BCM53262_A0_ARLA_SRCH_RSLTr_ARL_SRCH_RSLT_CONf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET BCM53262_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET
#define READ_ARLA_SRCH_RSLTr BCM53262_A0_READ_ARLA_SRCH_RSLTr
#define WRITE_ARLA_SRCH_RSLTr BCM53262_A0_WRITE_ARLA_SRCH_RSLTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_SRCH_RSLTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_SRCH_RSLT_VID
 * BLOCKS:   SYS
 * DESC:     ARL Search Result VID Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_SRCH_RSLT_VID VID area for search result.Note : If 1Q enable, it is recommended to read VID register first, then read MAC register later.
 *     ARL_SRCH_RSLT_CUSTOMER Reserced for customer use
 *     ARLA_SRCH_RSLT_VID_RSRV0 Reserved.
 */
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr 0x0000055c

#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_VID.
 */
typedef union BCM53262_A0_ARLA_SRCH_RSLT_VIDr_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt_vid[1];
	uint32_t _arla_srch_rslt_vid;
} BCM53262_A0_ARLA_SRCH_RSLT_VIDr_t;

#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_CLR(r) (r).arla_srch_rslt_vid[0] = 0
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_SET(r,d) (r).arla_srch_rslt_vid[0] = d
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_GET(r) (r).arla_srch_rslt_vid[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VIDf_GET(r) (((r).arla_srch_rslt_vid[0]) & 0xfff)
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_vid[0]=(((r).arla_srch_rslt_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARL_SRCH_RSLT_CUSTOMERf_GET(r) ((((r).arla_srch_rslt_vid[0]) >> 12) & 0x7)
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARL_SRCH_RSLT_CUSTOMERf_SET(r,f) (r).arla_srch_rslt_vid[0]=(((r).arla_srch_rslt_vid[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VID_RSRV0f_GET(r) ((((r).arla_srch_rslt_vid[0]) >> 15) & 0x1)
#define BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VID_RSRV0f_SET(r,f) (r).arla_srch_rslt_vid[0]=(((r).arla_srch_rslt_vid[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_VID.
 */
#define BCM53262_A0_READ_ARLA_SRCH_RSLT_VIDr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_SRCH_RSLT_VIDr,(r._arla_srch_rslt_vid),2)
#define BCM53262_A0_WRITE_ARLA_SRCH_RSLT_VIDr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_SRCH_RSLT_VIDr,&(r._arla_srch_rslt_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_VIDr BCM53262_A0_ARLA_SRCH_RSLT_VIDr
#define ARLA_SRCH_RSLT_VIDr_SIZE BCM53262_A0_ARLA_SRCH_RSLT_VIDr_SIZE
typedef BCM53262_A0_ARLA_SRCH_RSLT_VIDr_t ARLA_SRCH_RSLT_VIDr_t;
#define ARLA_SRCH_RSLT_VIDr_CLR BCM53262_A0_ARLA_SRCH_RSLT_VIDr_CLR
#define ARLA_SRCH_RSLT_VIDr_SET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_SET
#define ARLA_SRCH_RSLT_VIDr_GET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_GET
#define ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VIDf_GET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VIDf_SET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_VIDr_ARL_SRCH_RSLT_CUSTOMERf_GET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARL_SRCH_RSLT_CUSTOMERf_GET
#define ARLA_SRCH_RSLT_VIDr_ARL_SRCH_RSLT_CUSTOMERf_SET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARL_SRCH_RSLT_CUSTOMERf_SET
#define ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VID_RSRV0f_GET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VID_RSRV0f_GET
#define ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VID_RSRV0f_SET BCM53262_A0_ARLA_SRCH_RSLT_VIDr_ARLA_SRCH_RSLT_VID_RSRV0f_SET
#define READ_ARLA_SRCH_RSLT_VIDr BCM53262_A0_READ_ARLA_SRCH_RSLT_VIDr
#define WRITE_ARLA_SRCH_RSLT_VIDr BCM53262_A0_WRITE_ARLA_SRCH_RSLT_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_SRCH_RSLT_VIDr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_VID
 * BLOCKS:   SYS
 * DESC:     VID Table Index Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VIDTAB_INDX VID Table IndexWhen VID_MAC Hash Enable asserted (Page 34h, Addr 00h), ARLA_VIDTAB_INDX and MAC_ADDR_INDX will be used for hashing ARL table entry when CPU use ARL Read/Write Control (Page 05h, Addr 0h). to access ARL tableNote : When access MAC2VLAN table, this register is ingored.
 *     ARLA_VIDTAB_RSRV0 Reserved
 */
#define BCM53262_A0_ARLA_VIDr 0x00000508

#define BCM53262_A0_ARLA_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID.
 */
typedef union BCM53262_A0_ARLA_VIDr_s {
	uint32_t v[1];
	uint32_t arla_vid[1];
	uint32_t _arla_vid;
} BCM53262_A0_ARLA_VIDr_t;

#define BCM53262_A0_ARLA_VIDr_CLR(r) (r).arla_vid[0] = 0
#define BCM53262_A0_ARLA_VIDr_SET(r,d) (r).arla_vid[0] = d
#define BCM53262_A0_ARLA_VIDr_GET(r) (r).arla_vid[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET(r) (((r).arla_vid[0]) & 0xfff)
#define BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET(r) ((((r).arla_vid[0]) >> 12) & 0xf)
#define BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VID.
 */
#define BCM53262_A0_READ_ARLA_VIDr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_VIDr,(r._arla_vid),2)
#define BCM53262_A0_WRITE_ARLA_VIDr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_VIDr,&(r._arla_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VIDr BCM53262_A0_ARLA_VIDr
#define ARLA_VIDr_SIZE BCM53262_A0_ARLA_VIDr_SIZE
typedef BCM53262_A0_ARLA_VIDr_t ARLA_VIDr_t;
#define ARLA_VIDr_CLR BCM53262_A0_ARLA_VIDr_CLR
#define ARLA_VIDr_SET BCM53262_A0_ARLA_VIDr_SET
#define ARLA_VIDr_GET BCM53262_A0_ARLA_VIDr_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_GET BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_SET BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET BCM53262_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET
#define READ_ARLA_VIDr BCM53262_A0_READ_ARLA_VIDr
#define WRITE_ARLA_VIDr BCM53262_A0_WRITE_ARLA_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_VIDr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_VID_ENTRY_0
 * BLOCKS:   SYS
 * DESC:     VID Entry0 Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VID         When VID_MAC Hash Enable asserted (Page 34h, Addr 00h) and CPU use ARL Read/Write Control (Page 05h, Addr 0h) to access ARL table, ARL_VID_Entry_ will be written ARL table entry.
 *     RESERVED_1R      Reserved for customers use.Note : This filed will be written into ARL table entry.
 *     RESERVED_2R      Reserved only.Note : This filed will not be written into ARL table entry.
 */
#define BCM53262_A0_ARLA_VID_ENTRY_0r 0x00000520

#define BCM53262_A0_ARLA_VID_ENTRY_0r_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID_ENTRY_0.
 */
typedef union BCM53262_A0_ARLA_VID_ENTRY_0r_s {
	uint32_t v[1];
	uint32_t arla_vid_entry_0[1];
	uint32_t _arla_vid_entry_0;
} BCM53262_A0_ARLA_VID_ENTRY_0r_t;

#define BCM53262_A0_ARLA_VID_ENTRY_0r_CLR(r) (r).arla_vid_entry_0[0] = 0
#define BCM53262_A0_ARLA_VID_ENTRY_0r_SET(r,d) (r).arla_vid_entry_0[0] = d
#define BCM53262_A0_ARLA_VID_ENTRY_0r_GET(r) (r).arla_vid_entry_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_VID_ENTRY_0r_ARLA_VIDf_GET(r) (((r).arla_vid_entry_0[0]) & 0xfff)
#define BCM53262_A0_ARLA_VID_ENTRY_0r_ARLA_VIDf_SET(r,f) (r).arla_vid_entry_0[0]=(((r).arla_vid_entry_0[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_1Rf_GET(r) ((((r).arla_vid_entry_0[0]) >> 12) & 0x7)
#define BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_1Rf_SET(r,f) (r).arla_vid_entry_0[0]=(((r).arla_vid_entry_0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_2Rf_GET(r) ((((r).arla_vid_entry_0[0]) >> 15) & 0x1)
#define BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_2Rf_SET(r,f) (r).arla_vid_entry_0[0]=(((r).arla_vid_entry_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_VID_ENTRY_0.
 */
#define BCM53262_A0_READ_ARLA_VID_ENTRY_0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_VID_ENTRY_0r,(r._arla_vid_entry_0),2)
#define BCM53262_A0_WRITE_ARLA_VID_ENTRY_0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_VID_ENTRY_0r,&(r._arla_vid_entry_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VID_ENTRY_0r BCM53262_A0_ARLA_VID_ENTRY_0r
#define ARLA_VID_ENTRY_0r_SIZE BCM53262_A0_ARLA_VID_ENTRY_0r_SIZE
typedef BCM53262_A0_ARLA_VID_ENTRY_0r_t ARLA_VID_ENTRY_0r_t;
#define ARLA_VID_ENTRY_0r_CLR BCM53262_A0_ARLA_VID_ENTRY_0r_CLR
#define ARLA_VID_ENTRY_0r_SET BCM53262_A0_ARLA_VID_ENTRY_0r_SET
#define ARLA_VID_ENTRY_0r_GET BCM53262_A0_ARLA_VID_ENTRY_0r_GET
#define ARLA_VID_ENTRY_0r_ARLA_VIDf_GET BCM53262_A0_ARLA_VID_ENTRY_0r_ARLA_VIDf_GET
#define ARLA_VID_ENTRY_0r_ARLA_VIDf_SET BCM53262_A0_ARLA_VID_ENTRY_0r_ARLA_VIDf_SET
#define ARLA_VID_ENTRY_0r_RESERVED_1Rf_GET BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_1Rf_GET
#define ARLA_VID_ENTRY_0r_RESERVED_1Rf_SET BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_1Rf_SET
#define ARLA_VID_ENTRY_0r_RESERVED_2Rf_GET BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_2Rf_GET
#define ARLA_VID_ENTRY_0r_RESERVED_2Rf_SET BCM53262_A0_ARLA_VID_ENTRY_0r_RESERVED_2Rf_SET
#define READ_ARLA_VID_ENTRY_0r BCM53262_A0_READ_ARLA_VID_ENTRY_0r
#define WRITE_ARLA_VID_ENTRY_0r BCM53262_A0_WRITE_ARLA_VID_ENTRY_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_VID_ENTRY_0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ARLA_VID_ENTRY_1
 * BLOCKS:   SYS
 * DESC:     VID Entry Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VID         When VID_MAC Hash Enable asserted (Page 34h, Addr 00h) and CPU use ARL Read/Write Control (Page 05h, Addr 0h) to access ARL table, ARL_VID_Entry_ will be written ARL table entry.
 *     RESERVED_1R      Reserved for customers use.Note : This filed will be written into ARL table entry.
 *     RESERVED_2R      Reserved only.Note : This filed will not be written into ARL table entry.
 */
#define BCM53262_A0_ARLA_VID_ENTRY_1r 0x00000528

#define BCM53262_A0_ARLA_VID_ENTRY_1r_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID_ENTRY_1.
 */
typedef union BCM53262_A0_ARLA_VID_ENTRY_1r_s {
	uint32_t v[1];
	uint32_t arla_vid_entry_1[1];
	uint32_t _arla_vid_entry_1;
} BCM53262_A0_ARLA_VID_ENTRY_1r_t;

#define BCM53262_A0_ARLA_VID_ENTRY_1r_CLR(r) (r).arla_vid_entry_1[0] = 0
#define BCM53262_A0_ARLA_VID_ENTRY_1r_SET(r,d) (r).arla_vid_entry_1[0] = d
#define BCM53262_A0_ARLA_VID_ENTRY_1r_GET(r) (r).arla_vid_entry_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ARLA_VID_ENTRY_1r_ARLA_VIDf_GET(r) (((r).arla_vid_entry_1[0]) & 0xfff)
#define BCM53262_A0_ARLA_VID_ENTRY_1r_ARLA_VIDf_SET(r,f) (r).arla_vid_entry_1[0]=(((r).arla_vid_entry_1[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_1Rf_GET(r) ((((r).arla_vid_entry_1[0]) >> 12) & 0x7)
#define BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_1Rf_SET(r,f) (r).arla_vid_entry_1[0]=(((r).arla_vid_entry_1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_2Rf_GET(r) ((((r).arla_vid_entry_1[0]) >> 15) & 0x1)
#define BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_2Rf_SET(r,f) (r).arla_vid_entry_1[0]=(((r).arla_vid_entry_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_VID_ENTRY_1.
 */
#define BCM53262_A0_READ_ARLA_VID_ENTRY_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_ARLA_VID_ENTRY_1r,(r._arla_vid_entry_1),2)
#define BCM53262_A0_WRITE_ARLA_VID_ENTRY_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_ARLA_VID_ENTRY_1r,&(r._arla_vid_entry_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VID_ENTRY_1r BCM53262_A0_ARLA_VID_ENTRY_1r
#define ARLA_VID_ENTRY_1r_SIZE BCM53262_A0_ARLA_VID_ENTRY_1r_SIZE
typedef BCM53262_A0_ARLA_VID_ENTRY_1r_t ARLA_VID_ENTRY_1r_t;
#define ARLA_VID_ENTRY_1r_CLR BCM53262_A0_ARLA_VID_ENTRY_1r_CLR
#define ARLA_VID_ENTRY_1r_SET BCM53262_A0_ARLA_VID_ENTRY_1r_SET
#define ARLA_VID_ENTRY_1r_GET BCM53262_A0_ARLA_VID_ENTRY_1r_GET
#define ARLA_VID_ENTRY_1r_ARLA_VIDf_GET BCM53262_A0_ARLA_VID_ENTRY_1r_ARLA_VIDf_GET
#define ARLA_VID_ENTRY_1r_ARLA_VIDf_SET BCM53262_A0_ARLA_VID_ENTRY_1r_ARLA_VIDf_SET
#define ARLA_VID_ENTRY_1r_RESERVED_1Rf_GET BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_1Rf_GET
#define ARLA_VID_ENTRY_1r_RESERVED_1Rf_SET BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_1Rf_SET
#define ARLA_VID_ENTRY_1r_RESERVED_2Rf_GET BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_2Rf_GET
#define ARLA_VID_ENTRY_1r_RESERVED_2Rf_SET BCM53262_A0_ARLA_VID_ENTRY_1r_RESERVED_2Rf_SET
#define READ_ARLA_VID_ENTRY_1r BCM53262_A0_READ_ARLA_VID_ENTRY_1r
#define WRITE_ARLA_VID_ENTRY_1r BCM53262_A0_WRITE_ARLA_VID_ENTRY_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ARLA_VID_ENTRY_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ASTSSUM
 * BLOCKS:   EPIC0
 * DESC:     Auxiliary Status Summary Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_ASTSSUMr 0x0000a032

#define BCM53262_A0_ASTSSUMr_SIZE 2

/*
 * This structure should be used to declare and program ASTSSUM.
 */
typedef union BCM53262_A0_ASTSSUMr_s {
	uint32_t v[1];
	uint32_t astssum[1];
	uint32_t _astssum;
} BCM53262_A0_ASTSSUMr_t;

#define BCM53262_A0_ASTSSUMr_CLR(r) (r).astssum[0] = 0
#define BCM53262_A0_ASTSSUMr_SET(r,d) (r).astssum[0] = d
#define BCM53262_A0_ASTSSUMr_GET(r) (r).astssum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ASTSSUMr_RESERVED_Rf_GET(r) (((r).astssum[0]) & 0xffff)
#define BCM53262_A0_ASTSSUMr_RESERVED_Rf_SET(r,f) (r).astssum[0]=(((r).astssum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ASTSSUM.
 */
#define BCM53262_A0_READ_ASTSSUMr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_ASTSSUMr,(r._astssum),2)
#define BCM53262_A0_WRITE_ASTSSUMr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_ASTSSUMr,&(r._astssum),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ASTSSUMr BCM53262_A0_ASTSSUMr
#define ASTSSUMr_SIZE BCM53262_A0_ASTSSUMr_SIZE
typedef BCM53262_A0_ASTSSUMr_t ASTSSUMr_t;
#define ASTSSUMr_CLR BCM53262_A0_ASTSSUMr_CLR
#define ASTSSUMr_SET BCM53262_A0_ASTSSUMr_SET
#define ASTSSUMr_GET BCM53262_A0_ASTSSUMr_GET
#define ASTSSUMr_RESERVED_Rf_GET BCM53262_A0_ASTSSUMr_RESERVED_Rf_GET
#define ASTSSUMr_RESERVED_Rf_SET BCM53262_A0_ASTSSUMr_RESERVED_Rf_SET
#define READ_ASTSSUMr BCM53262_A0_READ_ASTSSUMr
#define WRITE_ASTSSUMr BCM53262_A0_WRITE_ASTSSUMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ASTSSUMr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BCAST_FWD_MAP
 * BLOCKS:   SYS
 * DESC:     Broadcast Packet Forwarding Map Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     BCAST_FWD_MAP    Broadcast Packet Forwarding Map RegisterWhen BCAST_FWD_MAP_EN enable, Broadcast packet will only be forwarded to this port map.Bit 47~24 : for port 47~ port 24,Bit 48   : for IMP port,Bit 52~49: for goga3 ~ giga0
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_BCAST_FWD_MAPr 0x00000020

#define BCM53262_A0_BCAST_FWD_MAPr_SIZE 8

/*
 * This structure should be used to declare and program BCAST_FWD_MAP.
 */
typedef union BCM53262_A0_BCAST_FWD_MAPr_s {
	uint32_t v[2];
	uint32_t bcast_fwd_map[2];
	uint32_t _bcast_fwd_map;
} BCM53262_A0_BCAST_FWD_MAPr_t;

#define BCM53262_A0_BCAST_FWD_MAPr_CLR(r) CDK_MEMSET(&((r)._bcast_fwd_map), 0, sizeof(BCM53262_A0_BCAST_FWD_MAPr_t))
#define BCM53262_A0_BCAST_FWD_MAPr_SET(r,i,d) (r).bcast_fwd_map[i] = d
#define BCM53262_A0_BCAST_FWD_MAPr_GET(r,i) (r).bcast_fwd_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BCAST_FWD_MAPr_RESERVED_0Rf_GET(r) (((r).bcast_fwd_map[0]) & 0xffffff)
#define BCM53262_A0_BCAST_FWD_MAPr_RESERVED_0Rf_SET(r,f) (r).bcast_fwd_map[0]=(((r).bcast_fwd_map[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_BCAST_FWD_MAPr_BCAST_FWD_MAPf_GET(r) cdk_field32_get((r).bcast_fwd_map,24,52)
#define BCM53262_A0_BCAST_FWD_MAPr_BCAST_FWD_MAPf_SET(r,f) cdk_field32_set((r).bcast_fwd_map,24,52,f)
#define BCM53262_A0_BCAST_FWD_MAPr_RESERVED_1Rf_GET(r) ((((r).bcast_fwd_map[1]) >> 21) & 0x7ff)
#define BCM53262_A0_BCAST_FWD_MAPr_RESERVED_1Rf_SET(r,f) (r).bcast_fwd_map[1]=(((r).bcast_fwd_map[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access BCAST_FWD_MAP.
 */
#define BCM53262_A0_READ_BCAST_FWD_MAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_BCAST_FWD_MAPr,(r._bcast_fwd_map),8)
#define BCM53262_A0_WRITE_BCAST_FWD_MAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_BCAST_FWD_MAPr,&(r._bcast_fwd_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_FWD_MAPr BCM53262_A0_BCAST_FWD_MAPr
#define BCAST_FWD_MAPr_SIZE BCM53262_A0_BCAST_FWD_MAPr_SIZE
typedef BCM53262_A0_BCAST_FWD_MAPr_t BCAST_FWD_MAPr_t;
#define BCAST_FWD_MAPr_CLR BCM53262_A0_BCAST_FWD_MAPr_CLR
#define BCAST_FWD_MAPr_SET BCM53262_A0_BCAST_FWD_MAPr_SET
#define BCAST_FWD_MAPr_GET BCM53262_A0_BCAST_FWD_MAPr_GET
#define BCAST_FWD_MAPr_RESERVED_0Rf_GET BCM53262_A0_BCAST_FWD_MAPr_RESERVED_0Rf_GET
#define BCAST_FWD_MAPr_RESERVED_0Rf_SET BCM53262_A0_BCAST_FWD_MAPr_RESERVED_0Rf_SET
#define BCAST_FWD_MAPr_BCAST_FWD_MAPf_GET BCM53262_A0_BCAST_FWD_MAPr_BCAST_FWD_MAPf_GET
#define BCAST_FWD_MAPr_BCAST_FWD_MAPf_SET BCM53262_A0_BCAST_FWD_MAPr_BCAST_FWD_MAPf_SET
#define BCAST_FWD_MAPr_RESERVED_1Rf_GET BCM53262_A0_BCAST_FWD_MAPr_RESERVED_1Rf_GET
#define BCAST_FWD_MAPr_RESERVED_1Rf_SET BCM53262_A0_BCAST_FWD_MAPr_RESERVED_1Rf_SET
#define READ_BCAST_FWD_MAPr BCM53262_A0_READ_BCAST_FWD_MAPr
#define WRITE_BCAST_FWD_MAPr BCM53262_A0_WRITE_BCAST_FWD_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BCAST_FWD_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BG_SEL
 * BLOCKS:   SYS
 * DESC:     Regulator Output Voltage Trim Control Register
 * SIZE:     8
 * FIELDS:
 *     BG_SEL           Regulator output voltage trim controlis used to adjust the output voltage by +14% to -16% by 2% stepsBit 7:4 : for regulator 1,Bit 3:0 : for regulator 0.
 */
#define BCM53262_A0_BG_SELr 0x00000010

#define BCM53262_A0_BG_SELr_SIZE 1

/*
 * This structure should be used to declare and program BG_SEL.
 */
typedef union BCM53262_A0_BG_SELr_s {
	uint32_t v[1];
	uint32_t bg_sel[1];
	uint32_t _bg_sel;
} BCM53262_A0_BG_SELr_t;

#define BCM53262_A0_BG_SELr_CLR(r) (r).bg_sel[0] = 0
#define BCM53262_A0_BG_SELr_SET(r,d) (r).bg_sel[0] = d
#define BCM53262_A0_BG_SELr_GET(r) (r).bg_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BG_SELr_BG_SELf_GET(r) (((r).bg_sel[0]) & 0xff)
#define BCM53262_A0_BG_SELr_BG_SELf_SET(r,f) (r).bg_sel[0]=(((r).bg_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access BG_SEL.
 */
#define BCM53262_A0_READ_BG_SELr(u,r) cdk_robo_reg_read(u,BCM53262_A0_BG_SELr,(r._bg_sel),1)
#define BCM53262_A0_WRITE_BG_SELr(u,r) cdk_robo_reg_write(u,BCM53262_A0_BG_SELr,&(r._bg_sel),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BG_SELr BCM53262_A0_BG_SELr
#define BG_SELr_SIZE BCM53262_A0_BG_SELr_SIZE
typedef BCM53262_A0_BG_SELr_t BG_SELr_t;
#define BG_SELr_CLR BCM53262_A0_BG_SELr_CLR
#define BG_SELr_SET BCM53262_A0_BG_SELr_SET
#define BG_SELr_GET BCM53262_A0_BG_SELr_GET
#define BG_SELr_BG_SELf_GET BCM53262_A0_BG_SELr_BG_SELf_GET
#define BG_SELr_BG_SELf_SET BCM53262_A0_BG_SELr_BG_SELf_SET
#define READ_BG_SELr BCM53262_A0_READ_BG_SELr
#define WRITE_BG_SELr BCM53262_A0_WRITE_BG_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BG_SELr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BIST_STS0
 * BLOCKS:   SYS
 * DESC:     BIST Status 0 Register
 * SIZE:     64
 * FIELDS:
 *     TXQ_MBIST_ERR    
 *     GTXQ_MBIST_ERR   
 *     MIB_MBIST_ERR    
 *     CFP_TCAM_MBIST_ERR 
 *     CFP_RM_MBIST_ERR 
 *     CFP_ACT_MBIST_ERR 
 *     CFP_CNT_MBIST_ERR 
 *     CFP_TCAM_LOGIC_ERR 
 *     MSPT_MBIST_ERR   
 *     IPMC_MBIST_ERR   
 *     FLOW2VLAN_MBIST_ERR 
 *     PROTOCOL2VLAN_MBIST_ERR 
 *     MAC2VLAN_MBIST_ERR 
 */
#define BCM53262_A0_BIST_STS0r 0x00000200

#define BCM53262_A0_BIST_STS0r_SIZE 8

/*
 * This structure should be used to declare and program BIST_STS0.
 */
typedef union BCM53262_A0_BIST_STS0r_s {
	uint32_t v[2];
	uint32_t bist_sts0[2];
	uint32_t _bist_sts0;
} BCM53262_A0_BIST_STS0r_t;

#define BCM53262_A0_BIST_STS0r_CLR(r) CDK_MEMSET(&((r)._bist_sts0), 0, sizeof(BCM53262_A0_BIST_STS0r_t))
#define BCM53262_A0_BIST_STS0r_SET(r,i,d) (r).bist_sts0[i] = d
#define BCM53262_A0_BIST_STS0r_GET(r,i) (r).bist_sts0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BIST_STS0r_TXQ_MBIST_ERRf_GET(r) (((r).bist_sts0[0]) & 0x1fffffff)
#define BCM53262_A0_BIST_STS0r_TXQ_MBIST_ERRf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53262_A0_BIST_STS0r_GTXQ_MBIST_ERRf_GET(r) ((((r).bist_sts0[0]) >> 29) & 0x1)
#define BCM53262_A0_BIST_STS0r_GTXQ_MBIST_ERRf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53262_A0_BIST_STS0r_MIB_MBIST_ERRf_GET(r) cdk_field32_get((r).bist_sts0,30,38)
#define BCM53262_A0_BIST_STS0r_MIB_MBIST_ERRf_SET(r,f) cdk_field32_set((r).bist_sts0,30,38,f)
#define BCM53262_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 7) & 0xffff)
#define BCM53262_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0xffff << 7)) | ((((uint32_t)f) & 0xffff) << 7))
#define BCM53262_A0_BIST_STS0r_CFP_RM_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 23) & 0x1)
#define BCM53262_A0_BIST_STS0r_CFP_RM_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53262_A0_BIST_STS0r_CFP_ACT_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 24) & 0x1)
#define BCM53262_A0_BIST_STS0r_CFP_ACT_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53262_A0_BIST_STS0r_CFP_CNT_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 25) & 0x1)
#define BCM53262_A0_BIST_STS0r_CFP_CNT_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53262_A0_BIST_STS0r_CFP_TCAM_LOGIC_ERRf_GET(r) ((((r).bist_sts0[1]) >> 26) & 0x1)
#define BCM53262_A0_BIST_STS0r_CFP_TCAM_LOGIC_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53262_A0_BIST_STS0r_MSPT_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 27) & 0x1)
#define BCM53262_A0_BIST_STS0r_MSPT_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_BIST_STS0r_IPMC_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 28) & 0x1)
#define BCM53262_A0_BIST_STS0r_IPMC_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53262_A0_BIST_STS0r_FLOW2VLAN_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 29) & 0x1)
#define BCM53262_A0_BIST_STS0r_FLOW2VLAN_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53262_A0_BIST_STS0r_PROTOCOL2VLAN_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 30) & 0x1)
#define BCM53262_A0_BIST_STS0r_PROTOCOL2VLAN_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_BIST_STS0r_MAC2VLAN_MBIST_ERRf_GET(r) ((((r).bist_sts0[1]) >> 31) & 0x1)
#define BCM53262_A0_BIST_STS0r_MAC2VLAN_MBIST_ERRf_SET(r,f) (r).bist_sts0[1]=(((r).bist_sts0[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access BIST_STS0.
 */
#define BCM53262_A0_READ_BIST_STS0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_BIST_STS0r,(r._bist_sts0),8)
#define BCM53262_A0_WRITE_BIST_STS0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_BIST_STS0r,&(r._bist_sts0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STS0r BCM53262_A0_BIST_STS0r
#define BIST_STS0r_SIZE BCM53262_A0_BIST_STS0r_SIZE
typedef BCM53262_A0_BIST_STS0r_t BIST_STS0r_t;
#define BIST_STS0r_CLR BCM53262_A0_BIST_STS0r_CLR
#define BIST_STS0r_SET BCM53262_A0_BIST_STS0r_SET
#define BIST_STS0r_GET BCM53262_A0_BIST_STS0r_GET
#define BIST_STS0r_TXQ_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_TXQ_MBIST_ERRf_GET
#define BIST_STS0r_TXQ_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_TXQ_MBIST_ERRf_SET
#define BIST_STS0r_GTXQ_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_GTXQ_MBIST_ERRf_GET
#define BIST_STS0r_GTXQ_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_GTXQ_MBIST_ERRf_SET
#define BIST_STS0r_MIB_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_MIB_MBIST_ERRf_GET
#define BIST_STS0r_MIB_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_MIB_MBIST_ERRf_SET
#define BIST_STS0r_CFP_TCAM_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_GET
#define BIST_STS0r_CFP_TCAM_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_CFP_TCAM_MBIST_ERRf_SET
#define BIST_STS0r_CFP_RM_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_CFP_RM_MBIST_ERRf_GET
#define BIST_STS0r_CFP_RM_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_CFP_RM_MBIST_ERRf_SET
#define BIST_STS0r_CFP_ACT_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_CFP_ACT_MBIST_ERRf_GET
#define BIST_STS0r_CFP_ACT_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_CFP_ACT_MBIST_ERRf_SET
#define BIST_STS0r_CFP_CNT_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_CFP_CNT_MBIST_ERRf_GET
#define BIST_STS0r_CFP_CNT_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_CFP_CNT_MBIST_ERRf_SET
#define BIST_STS0r_CFP_TCAM_LOGIC_ERRf_GET BCM53262_A0_BIST_STS0r_CFP_TCAM_LOGIC_ERRf_GET
#define BIST_STS0r_CFP_TCAM_LOGIC_ERRf_SET BCM53262_A0_BIST_STS0r_CFP_TCAM_LOGIC_ERRf_SET
#define BIST_STS0r_MSPT_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_MSPT_MBIST_ERRf_GET
#define BIST_STS0r_MSPT_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_MSPT_MBIST_ERRf_SET
#define BIST_STS0r_IPMC_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_IPMC_MBIST_ERRf_GET
#define BIST_STS0r_IPMC_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_IPMC_MBIST_ERRf_SET
#define BIST_STS0r_FLOW2VLAN_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_FLOW2VLAN_MBIST_ERRf_GET
#define BIST_STS0r_FLOW2VLAN_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_FLOW2VLAN_MBIST_ERRf_SET
#define BIST_STS0r_PROTOCOL2VLAN_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_PROTOCOL2VLAN_MBIST_ERRf_GET
#define BIST_STS0r_PROTOCOL2VLAN_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_PROTOCOL2VLAN_MBIST_ERRf_SET
#define BIST_STS0r_MAC2VLAN_MBIST_ERRf_GET BCM53262_A0_BIST_STS0r_MAC2VLAN_MBIST_ERRf_GET
#define BIST_STS0r_MAC2VLAN_MBIST_ERRf_SET BCM53262_A0_BIST_STS0r_MAC2VLAN_MBIST_ERRf_SET
#define READ_BIST_STS0r BCM53262_A0_READ_BIST_STS0r
#define WRITE_BIST_STS0r BCM53262_A0_WRITE_BIST_STS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BIST_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BIST_STS1
 * BLOCKS:   SYS
 * DESC:     BIST Status 1 Register
 * SIZE:     64
 * FIELDS:
 *     VLAN2VLAN_MBIST_ERR 
 *     ERC_MBIST_ERR    
 *     IRC_MBIST_ERR    
 *     BFC_MBIST_ERR    
 *     FM_ECC_MBIST_ERR 
 *     VT_MCOL_DEFECT2  
 *     AT_MCOL_DEFECT2  
 *     FM_MCOL_DEFECT2  
 *     VT_MCOL_DEFECT1  
 *     AT_MCOL_DEFECT1  
 *     FM_MCOL_DEFECT1  
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_BIST_STS1r 0x00000208

#define BCM53262_A0_BIST_STS1r_SIZE 8

/*
 * This structure should be used to declare and program BIST_STS1.
 */
typedef union BCM53262_A0_BIST_STS1r_s {
	uint32_t v[2];
	uint32_t bist_sts1[2];
	uint32_t _bist_sts1;
} BCM53262_A0_BIST_STS1r_t;

#define BCM53262_A0_BIST_STS1r_CLR(r) CDK_MEMSET(&((r)._bist_sts1), 0, sizeof(BCM53262_A0_BIST_STS1r_t))
#define BCM53262_A0_BIST_STS1r_SET(r,i,d) (r).bist_sts1[i] = d
#define BCM53262_A0_BIST_STS1r_GET(r,i) (r).bist_sts1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BIST_STS1r_VLAN2VLAN_MBIST_ERRf_GET(r) (((r).bist_sts1[0]) & 0x1)
#define BCM53262_A0_BIST_STS1r_VLAN2VLAN_MBIST_ERRf_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_BIST_STS1r_ERC_MBIST_ERRf_GET(r) ((((r).bist_sts1[0]) >> 1) & 0x1)
#define BCM53262_A0_BIST_STS1r_ERC_MBIST_ERRf_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_BIST_STS1r_IRC_MBIST_ERRf_GET(r) ((((r).bist_sts1[0]) >> 2) & 0x1)
#define BCM53262_A0_BIST_STS1r_IRC_MBIST_ERRf_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_BIST_STS1r_BFC_MBIST_ERRf_GET(r) ((((r).bist_sts1[0]) >> 3) & 0x1)
#define BCM53262_A0_BIST_STS1r_BFC_MBIST_ERRf_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_BIST_STS1r_FM_ECC_MBIST_ERRf_GET(r) ((((r).bist_sts1[0]) >> 4) & 0x1)
#define BCM53262_A0_BIST_STS1r_FM_ECC_MBIST_ERRf_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT2f_GET(r) ((((r).bist_sts1[0]) >> 5) & 0x1)
#define BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT2f_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT2f_GET(r) ((((r).bist_sts1[0]) >> 6) & 0x1)
#define BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT2f_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT2f_GET(r) ((((r).bist_sts1[0]) >> 7) & 0x1)
#define BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT2f_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT1f_GET(r) ((((r).bist_sts1[0]) >> 8) & 0x1)
#define BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT1f_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT1f_GET(r) ((((r).bist_sts1[0]) >> 9) & 0x1)
#define BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT1f_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT1f_GET(r) ((((r).bist_sts1[0]) >> 10) & 0x1)
#define BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT1f_SET(r,f) (r).bist_sts1[0]=(((r).bist_sts1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_BIST_STS1r_RESERVED_Rf_GET(r,a) cdk_field_get((r).bist_sts1,11,63,a)
#define BCM53262_A0_BIST_STS1r_RESERVED_Rf_SET(r,a) cdk_field_set((r).bist_sts1,11,63,a)

/*
 * These macros can be used to access BIST_STS1.
 */
#define BCM53262_A0_READ_BIST_STS1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_BIST_STS1r,(r._bist_sts1),8)
#define BCM53262_A0_WRITE_BIST_STS1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_BIST_STS1r,&(r._bist_sts1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STS1r BCM53262_A0_BIST_STS1r
#define BIST_STS1r_SIZE BCM53262_A0_BIST_STS1r_SIZE
typedef BCM53262_A0_BIST_STS1r_t BIST_STS1r_t;
#define BIST_STS1r_CLR BCM53262_A0_BIST_STS1r_CLR
#define BIST_STS1r_SET BCM53262_A0_BIST_STS1r_SET
#define BIST_STS1r_GET BCM53262_A0_BIST_STS1r_GET
#define BIST_STS1r_VLAN2VLAN_MBIST_ERRf_GET BCM53262_A0_BIST_STS1r_VLAN2VLAN_MBIST_ERRf_GET
#define BIST_STS1r_VLAN2VLAN_MBIST_ERRf_SET BCM53262_A0_BIST_STS1r_VLAN2VLAN_MBIST_ERRf_SET
#define BIST_STS1r_ERC_MBIST_ERRf_GET BCM53262_A0_BIST_STS1r_ERC_MBIST_ERRf_GET
#define BIST_STS1r_ERC_MBIST_ERRf_SET BCM53262_A0_BIST_STS1r_ERC_MBIST_ERRf_SET
#define BIST_STS1r_IRC_MBIST_ERRf_GET BCM53262_A0_BIST_STS1r_IRC_MBIST_ERRf_GET
#define BIST_STS1r_IRC_MBIST_ERRf_SET BCM53262_A0_BIST_STS1r_IRC_MBIST_ERRf_SET
#define BIST_STS1r_BFC_MBIST_ERRf_GET BCM53262_A0_BIST_STS1r_BFC_MBIST_ERRf_GET
#define BIST_STS1r_BFC_MBIST_ERRf_SET BCM53262_A0_BIST_STS1r_BFC_MBIST_ERRf_SET
#define BIST_STS1r_FM_ECC_MBIST_ERRf_GET BCM53262_A0_BIST_STS1r_FM_ECC_MBIST_ERRf_GET
#define BIST_STS1r_FM_ECC_MBIST_ERRf_SET BCM53262_A0_BIST_STS1r_FM_ECC_MBIST_ERRf_SET
#define BIST_STS1r_VT_MCOL_DEFECT2f_GET BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT2f_GET
#define BIST_STS1r_VT_MCOL_DEFECT2f_SET BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT2f_SET
#define BIST_STS1r_AT_MCOL_DEFECT2f_GET BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT2f_GET
#define BIST_STS1r_AT_MCOL_DEFECT2f_SET BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT2f_SET
#define BIST_STS1r_FM_MCOL_DEFECT2f_GET BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT2f_GET
#define BIST_STS1r_FM_MCOL_DEFECT2f_SET BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT2f_SET
#define BIST_STS1r_VT_MCOL_DEFECT1f_GET BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT1f_GET
#define BIST_STS1r_VT_MCOL_DEFECT1f_SET BCM53262_A0_BIST_STS1r_VT_MCOL_DEFECT1f_SET
#define BIST_STS1r_AT_MCOL_DEFECT1f_GET BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT1f_GET
#define BIST_STS1r_AT_MCOL_DEFECT1f_SET BCM53262_A0_BIST_STS1r_AT_MCOL_DEFECT1f_SET
#define BIST_STS1r_FM_MCOL_DEFECT1f_GET BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT1f_GET
#define BIST_STS1r_FM_MCOL_DEFECT1f_SET BCM53262_A0_BIST_STS1r_FM_MCOL_DEFECT1f_SET
#define BIST_STS1r_RESERVED_Rf_GET BCM53262_A0_BIST_STS1r_RESERVED_Rf_GET
#define BIST_STS1r_RESERVED_Rf_SET BCM53262_A0_BIST_STS1r_RESERVED_Rf_SET
#define READ_BIST_STS1r BCM53262_A0_READ_BIST_STS1r
#define WRITE_BIST_STS1r BCM53262_A0_WRITE_BIST_STS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BIST_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BONDING_PAD
 * BLOCKS:   SYS
 * DESC:     Bonding_Pad Register, used as CHIP ID
 * SIZE:     16
 * FIELDS:
 *     BONDING_PAD      Bit 4   : MII2ENBit 3-2 : PORT_CNT_OPTBit 1-0 : CFP_OPTBCM53242M: 5'b0_1111, 24F+2GBCM53242S:  5'b0_1110, 24F+2GBCM53212M: 5'b0_1011, 16F+2GBCM53212S:  5'b0_1010, 16F+2GBCM53202M: 5'b0_0111, 8F+2GBCM53202S:  5'b0_0110, 8F+2GBCM53222M: 5'b1_1111, 26FBCM53222S:  5'b1_1110, 26FBCM53262M: 5'b0_0011, 24F+4GBCM53262S:  5'b0_0010, 24F+4G
 *     RESERVED_R       Reserved.
 *     FPGA_REVID       FPGA Revision ID.
 */
#define BCM53262_A0_BONDING_PADr 0x000000ee

#define BCM53262_A0_BONDING_PADr_SIZE 2

/*
 * This structure should be used to declare and program BONDING_PAD.
 */
typedef union BCM53262_A0_BONDING_PADr_s {
	uint32_t v[1];
	uint32_t bonding_pad[1];
	uint32_t _bonding_pad;
} BCM53262_A0_BONDING_PADr_t;

#define BCM53262_A0_BONDING_PADr_CLR(r) (r).bonding_pad[0] = 0
#define BCM53262_A0_BONDING_PADr_SET(r,d) (r).bonding_pad[0] = d
#define BCM53262_A0_BONDING_PADr_GET(r) (r).bonding_pad[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BONDING_PADr_BONDING_PADf_GET(r) (((r).bonding_pad[0]) & 0x1f)
#define BCM53262_A0_BONDING_PADr_BONDING_PADf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_BONDING_PADr_RESERVED_Rf_GET(r) ((((r).bonding_pad[0]) >> 5) & 0x7)
#define BCM53262_A0_BONDING_PADr_RESERVED_Rf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53262_A0_BONDING_PADr_FPGA_REVIDf_GET(r) ((((r).bonding_pad[0]) >> 8) & 0xff)
#define BCM53262_A0_BONDING_PADr_FPGA_REVIDf_SET(r,f) (r).bonding_pad[0]=(((r).bonding_pad[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access BONDING_PAD.
 */
#define BCM53262_A0_READ_BONDING_PADr(u,r) cdk_robo_reg_read(u,BCM53262_A0_BONDING_PADr,(r._bonding_pad),2)
#define BCM53262_A0_WRITE_BONDING_PADr(u,r) cdk_robo_reg_write(u,BCM53262_A0_BONDING_PADr,&(r._bonding_pad),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BONDING_PADr BCM53262_A0_BONDING_PADr
#define BONDING_PADr_SIZE BCM53262_A0_BONDING_PADr_SIZE
typedef BCM53262_A0_BONDING_PADr_t BONDING_PADr_t;
#define BONDING_PADr_CLR BCM53262_A0_BONDING_PADr_CLR
#define BONDING_PADr_SET BCM53262_A0_BONDING_PADr_SET
#define BONDING_PADr_GET BCM53262_A0_BONDING_PADr_GET
#define BONDING_PADr_BONDING_PADf_GET BCM53262_A0_BONDING_PADr_BONDING_PADf_GET
#define BONDING_PADr_BONDING_PADf_SET BCM53262_A0_BONDING_PADr_BONDING_PADf_SET
#define BONDING_PADr_RESERVED_Rf_GET BCM53262_A0_BONDING_PADr_RESERVED_Rf_GET
#define BONDING_PADr_RESERVED_Rf_SET BCM53262_A0_BONDING_PADr_RESERVED_Rf_SET
#define BONDING_PADr_FPGA_REVIDf_GET BCM53262_A0_BONDING_PADr_FPGA_REVIDf_GET
#define BONDING_PADr_FPGA_REVIDf_SET BCM53262_A0_BONDING_PADr_FPGA_REVIDf_SET
#define READ_BONDING_PADr BCM53262_A0_READ_BONDING_PADr
#define WRITE_BONDING_PADr BCM53262_A0_WRITE_BONDING_PADr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BONDING_PADr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BPDU_MCADDR
 * BLOCKS:   SYS
 * DESC:     BPDU Multicast Address Register
 * SIZE:     48
 * FIELDS:
 *     BPDU_MC_ADDR     (not release to customer)BPDU Multicast AddressDefaults to the 802.1 defined reserved multicast address for the Bridge Group Address. Programming to an alternate value allows support of proprietary protocols in place of the normal Spanning Tree Protocol. Frames with a matching DA to this address will be forwarded only to the designated management port (IMP).
 */
#define BCM53262_A0_BPDU_MCADDRr 0x00000404

#define BCM53262_A0_BPDU_MCADDRr_SIZE 6

/*
 * This structure should be used to declare and program BPDU_MCADDR.
 */
typedef union BCM53262_A0_BPDU_MCADDRr_s {
	uint32_t v[2];
	uint32_t bpdu_mcaddr[2];
	uint32_t _bpdu_mcaddr;
} BCM53262_A0_BPDU_MCADDRr_t;

#define BCM53262_A0_BPDU_MCADDRr_CLR(r) CDK_MEMSET(&((r)._bpdu_mcaddr), 0, sizeof(BCM53262_A0_BPDU_MCADDRr_t))
#define BCM53262_A0_BPDU_MCADDRr_SET(r,i,d) (r).bpdu_mcaddr[i] = d
#define BCM53262_A0_BPDU_MCADDRr_GET(r,i) (r).bpdu_mcaddr[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET(r,a) cdk_field_get((r).bpdu_mcaddr,0,47,a)
#define BCM53262_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET(r,a) cdk_field_set((r).bpdu_mcaddr,0,47,a)

/*
 * These macros can be used to access BPDU_MCADDR.
 */
#define BCM53262_A0_READ_BPDU_MCADDRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_BPDU_MCADDRr,(r._bpdu_mcaddr),6)
#define BCM53262_A0_WRITE_BPDU_MCADDRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_BPDU_MCADDRr,&(r._bpdu_mcaddr),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BPDU_MCADDRr BCM53262_A0_BPDU_MCADDRr
#define BPDU_MCADDRr_SIZE BCM53262_A0_BPDU_MCADDRr_SIZE
typedef BCM53262_A0_BPDU_MCADDRr_t BPDU_MCADDRr_t;
#define BPDU_MCADDRr_CLR BCM53262_A0_BPDU_MCADDRr_CLR
#define BPDU_MCADDRr_SET BCM53262_A0_BPDU_MCADDRr_SET
#define BPDU_MCADDRr_GET BCM53262_A0_BPDU_MCADDRr_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_GET BCM53262_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_SET BCM53262_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET
#define READ_BPDU_MCADDRr BCM53262_A0_READ_BPDU_MCADDRr
#define WRITE_BPDU_MCADDRr BCM53262_A0_WRITE_BPDU_MCADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BPDU_MCADDRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BRCMTST
 * BLOCKS:   EPIC0
 * DESC:     Broadcom Test Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_BRCMTSTr 0x0000a03e

#define BCM53262_A0_BRCMTSTr_SIZE 2

/*
 * This structure should be used to declare and program BRCMTST.
 */
typedef union BCM53262_A0_BRCMTSTr_s {
	uint32_t v[1];
	uint32_t brcmtst[1];
	uint32_t _brcmtst;
} BCM53262_A0_BRCMTSTr_t;

#define BCM53262_A0_BRCMTSTr_CLR(r) (r).brcmtst[0] = 0
#define BCM53262_A0_BRCMTSTr_SET(r,d) (r).brcmtst[0] = d
#define BCM53262_A0_BRCMTSTr_GET(r) (r).brcmtst[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BRCMTSTr_RESERVED_Rf_GET(r) (((r).brcmtst[0]) & 0xffff)
#define BCM53262_A0_BRCMTSTr_RESERVED_Rf_SET(r,f) (r).brcmtst[0]=(((r).brcmtst[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BRCMTST.
 */
#define BCM53262_A0_READ_BRCMTSTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_BRCMTSTr,(r._brcmtst),2)
#define BCM53262_A0_WRITE_BRCMTSTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_BRCMTSTr,&(r._brcmtst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BRCMTSTr BCM53262_A0_BRCMTSTr
#define BRCMTSTr_SIZE BCM53262_A0_BRCMTSTr_SIZE
typedef BCM53262_A0_BRCMTSTr_t BRCMTSTr_t;
#define BRCMTSTr_CLR BCM53262_A0_BRCMTSTr_CLR
#define BRCMTSTr_SET BCM53262_A0_BRCMTSTr_SET
#define BRCMTSTr_GET BCM53262_A0_BRCMTSTr_GET
#define BRCMTSTr_RESERVED_Rf_GET BCM53262_A0_BRCMTSTr_RESERVED_Rf_GET
#define BRCMTSTr_RESERVED_Rf_SET BCM53262_A0_BRCMTSTr_RESERVED_Rf_SET
#define READ_BRCMTSTr BCM53262_A0_READ_BRCMTSTr
#define WRITE_BRCMTSTr BCM53262_A0_WRITE_BRCMTSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BRCMTSTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BUFCON_MEMADR
 * BLOCKS:   SYS
 * DESC:     BUFCON Memory Read Control Register
 * SIZE:     32
 * FIELDS:
 *     MEM_ADR          The 7 bit memory address that points to a unique 96-bit memory entry in the internal RAM. The address location will have its contents read into the Memory Entry register, or that the contents of the Memory Entry register will be written to the internal RAM location specified. Note that the addressing format is incremented by one for every 96-bit entry.
 *     MEMADR_RSRV0     Reserved
 *     MEM_STDN         Start/Done CommandWrite as 1 to initiate a read  memory location after first loading the MEM_ADDR with the address which is to be read n. The BCM5348M will reset the bit to indicate a read operation has completed and data from the memory location is available in Memory Entry register. Note that the entire 96-bit memory entry is always read by the BCM5348 when accessing the RAM.
 *     MEMADR_RSRV1     Reserved
 */
#define BCM53262_A0_BUFCON_MEMADRr 0x00000700

#define BCM53262_A0_BUFCON_MEMADRr_SIZE 4

/*
 * This structure should be used to declare and program BUFCON_MEMADR.
 */
typedef union BCM53262_A0_BUFCON_MEMADRr_s {
	uint32_t v[1];
	uint32_t bufcon_memadr[1];
	uint32_t _bufcon_memadr;
} BCM53262_A0_BUFCON_MEMADRr_t;

#define BCM53262_A0_BUFCON_MEMADRr_CLR(r) (r).bufcon_memadr[0] = 0
#define BCM53262_A0_BUFCON_MEMADRr_SET(r,d) (r).bufcon_memadr[0] = d
#define BCM53262_A0_BUFCON_MEMADRr_GET(r) (r).bufcon_memadr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BUFCON_MEMADRr_MEM_ADRf_GET(r) (((r).bufcon_memadr[0]) & 0x7f)
#define BCM53262_A0_BUFCON_MEMADRr_MEM_ADRf_SET(r,f) (r).bufcon_memadr[0]=(((r).bufcon_memadr[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV0f_GET(r) ((((r).bufcon_memadr[0]) >> 7) & 0xfff)
#define BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV0f_SET(r,f) (r).bufcon_memadr[0]=(((r).bufcon_memadr[0] & ~((uint32_t)0xfff << 7)) | ((((uint32_t)f) & 0xfff) << 7))
#define BCM53262_A0_BUFCON_MEMADRr_MEM_STDNf_GET(r) ((((r).bufcon_memadr[0]) >> 19) & 0x1)
#define BCM53262_A0_BUFCON_MEMADRr_MEM_STDNf_SET(r,f) (r).bufcon_memadr[0]=(((r).bufcon_memadr[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV1f_GET(r) ((((r).bufcon_memadr[0]) >> 20) & 0xfff)
#define BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV1f_SET(r,f) (r).bufcon_memadr[0]=(((r).bufcon_memadr[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access BUFCON_MEMADR.
 */
#define BCM53262_A0_READ_BUFCON_MEMADRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_BUFCON_MEMADRr,(r._bufcon_memadr),4)
#define BCM53262_A0_WRITE_BUFCON_MEMADRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_BUFCON_MEMADRr,&(r._bufcon_memadr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BUFCON_MEMADRr BCM53262_A0_BUFCON_MEMADRr
#define BUFCON_MEMADRr_SIZE BCM53262_A0_BUFCON_MEMADRr_SIZE
typedef BCM53262_A0_BUFCON_MEMADRr_t BUFCON_MEMADRr_t;
#define BUFCON_MEMADRr_CLR BCM53262_A0_BUFCON_MEMADRr_CLR
#define BUFCON_MEMADRr_SET BCM53262_A0_BUFCON_MEMADRr_SET
#define BUFCON_MEMADRr_GET BCM53262_A0_BUFCON_MEMADRr_GET
#define BUFCON_MEMADRr_MEM_ADRf_GET BCM53262_A0_BUFCON_MEMADRr_MEM_ADRf_GET
#define BUFCON_MEMADRr_MEM_ADRf_SET BCM53262_A0_BUFCON_MEMADRr_MEM_ADRf_SET
#define BUFCON_MEMADRr_MEMADR_RSRV0f_GET BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV0f_GET
#define BUFCON_MEMADRr_MEMADR_RSRV0f_SET BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV0f_SET
#define BUFCON_MEMADRr_MEM_STDNf_GET BCM53262_A0_BUFCON_MEMADRr_MEM_STDNf_GET
#define BUFCON_MEMADRr_MEM_STDNf_SET BCM53262_A0_BUFCON_MEMADRr_MEM_STDNf_SET
#define BUFCON_MEMADRr_MEMADR_RSRV1f_GET BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV1f_GET
#define BUFCON_MEMADRr_MEMADR_RSRV1f_SET BCM53262_A0_BUFCON_MEMADRr_MEMADR_RSRV1f_SET
#define READ_BUFCON_MEMADRr BCM53262_A0_READ_BUFCON_MEMADRr
#define WRITE_BUFCON_MEMADRr BCM53262_A0_WRITE_BUFCON_MEMADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BUFCON_MEMADRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BUFCON_MEMDAT0
 * BLOCKS:   SYS
 * DESC:     BUFCON Memory Read Data 0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          63~0bits of data read from memory, prior to setting the Start bit.
 */
#define BCM53262_A0_BUFCON_MEMDAT0r 0x00000710

#define BCM53262_A0_BUFCON_MEMDAT0r_SIZE 8

/*
 * This structure should be used to declare and program BUFCON_MEMDAT0.
 */
typedef union BCM53262_A0_BUFCON_MEMDAT0r_s {
	uint32_t v[2];
	uint32_t bufcon_memdat0[2];
	uint32_t _bufcon_memdat0;
} BCM53262_A0_BUFCON_MEMDAT0r_t;

#define BCM53262_A0_BUFCON_MEMDAT0r_CLR(r) CDK_MEMSET(&((r)._bufcon_memdat0), 0, sizeof(BCM53262_A0_BUFCON_MEMDAT0r_t))
#define BCM53262_A0_BUFCON_MEMDAT0r_SET(r,i,d) (r).bufcon_memdat0[i] = d
#define BCM53262_A0_BUFCON_MEMDAT0r_GET(r,i) (r).bufcon_memdat0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BUFCON_MEMDAT0r_MEM_DATf_GET(r,a) cdk_field_get((r).bufcon_memdat0,0,63,a)
#define BCM53262_A0_BUFCON_MEMDAT0r_MEM_DATf_SET(r,a) cdk_field_set((r).bufcon_memdat0,0,63,a)

/*
 * These macros can be used to access BUFCON_MEMDAT0.
 */
#define BCM53262_A0_READ_BUFCON_MEMDAT0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_BUFCON_MEMDAT0r,(r._bufcon_memdat0),8)
#define BCM53262_A0_WRITE_BUFCON_MEMDAT0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_BUFCON_MEMDAT0r,&(r._bufcon_memdat0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BUFCON_MEMDAT0r BCM53262_A0_BUFCON_MEMDAT0r
#define BUFCON_MEMDAT0r_SIZE BCM53262_A0_BUFCON_MEMDAT0r_SIZE
typedef BCM53262_A0_BUFCON_MEMDAT0r_t BUFCON_MEMDAT0r_t;
#define BUFCON_MEMDAT0r_CLR BCM53262_A0_BUFCON_MEMDAT0r_CLR
#define BUFCON_MEMDAT0r_SET BCM53262_A0_BUFCON_MEMDAT0r_SET
#define BUFCON_MEMDAT0r_GET BCM53262_A0_BUFCON_MEMDAT0r_GET
#define BUFCON_MEMDAT0r_MEM_DATf_GET BCM53262_A0_BUFCON_MEMDAT0r_MEM_DATf_GET
#define BUFCON_MEMDAT0r_MEM_DATf_SET BCM53262_A0_BUFCON_MEMDAT0r_MEM_DATf_SET
#define READ_BUFCON_MEMDAT0r BCM53262_A0_READ_BUFCON_MEMDAT0r
#define WRITE_BUFCON_MEMDAT0r BCM53262_A0_WRITE_BUFCON_MEMDAT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BUFCON_MEMDAT0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  BUFCON_MEMDAT1
 * BLOCKS:   SYS
 * DESC:     BUFCON Memory Read Data 1 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          79~64bits of data read from memory, prior to setting the Start bit.
 *     MEMADR_RSRV0     Reserved
 */
#define BCM53262_A0_BUFCON_MEMDAT1r 0x00000718

#define BCM53262_A0_BUFCON_MEMDAT1r_SIZE 8

/*
 * This structure should be used to declare and program BUFCON_MEMDAT1.
 */
typedef union BCM53262_A0_BUFCON_MEMDAT1r_s {
	uint32_t v[2];
	uint32_t bufcon_memdat1[2];
	uint32_t _bufcon_memdat1;
} BCM53262_A0_BUFCON_MEMDAT1r_t;

#define BCM53262_A0_BUFCON_MEMDAT1r_CLR(r) CDK_MEMSET(&((r)._bufcon_memdat1), 0, sizeof(BCM53262_A0_BUFCON_MEMDAT1r_t))
#define BCM53262_A0_BUFCON_MEMDAT1r_SET(r,i,d) (r).bufcon_memdat1[i] = d
#define BCM53262_A0_BUFCON_MEMDAT1r_GET(r,i) (r).bufcon_memdat1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_BUFCON_MEMDAT1r_MEM_DATf_GET(r) (((r).bufcon_memdat1[0]) & 0xffff)
#define BCM53262_A0_BUFCON_MEMDAT1r_MEM_DATf_SET(r,f) (r).bufcon_memdat1[0]=(((r).bufcon_memdat1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53262_A0_BUFCON_MEMDAT1r_MEMADR_RSRV0f_GET(r,a) cdk_field_get((r).bufcon_memdat1,16,63,a)
#define BCM53262_A0_BUFCON_MEMDAT1r_MEMADR_RSRV0f_SET(r,a) cdk_field_set((r).bufcon_memdat1,16,63,a)

/*
 * These macros can be used to access BUFCON_MEMDAT1.
 */
#define BCM53262_A0_READ_BUFCON_MEMDAT1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_BUFCON_MEMDAT1r,(r._bufcon_memdat1),8)
#define BCM53262_A0_WRITE_BUFCON_MEMDAT1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_BUFCON_MEMDAT1r,&(r._bufcon_memdat1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BUFCON_MEMDAT1r BCM53262_A0_BUFCON_MEMDAT1r
#define BUFCON_MEMDAT1r_SIZE BCM53262_A0_BUFCON_MEMDAT1r_SIZE
typedef BCM53262_A0_BUFCON_MEMDAT1r_t BUFCON_MEMDAT1r_t;
#define BUFCON_MEMDAT1r_CLR BCM53262_A0_BUFCON_MEMDAT1r_CLR
#define BUFCON_MEMDAT1r_SET BCM53262_A0_BUFCON_MEMDAT1r_SET
#define BUFCON_MEMDAT1r_GET BCM53262_A0_BUFCON_MEMDAT1r_GET
#define BUFCON_MEMDAT1r_MEM_DATf_GET BCM53262_A0_BUFCON_MEMDAT1r_MEM_DATf_GET
#define BUFCON_MEMDAT1r_MEM_DATf_SET BCM53262_A0_BUFCON_MEMDAT1r_MEM_DATf_SET
#define BUFCON_MEMDAT1r_MEMADR_RSRV0f_GET BCM53262_A0_BUFCON_MEMDAT1r_MEMADR_RSRV0f_GET
#define BUFCON_MEMDAT1r_MEMADR_RSRV0f_SET BCM53262_A0_BUFCON_MEMDAT1r_MEMADR_RSRV0f_SET
#define READ_BUFCON_MEMDAT1r BCM53262_A0_READ_BUFCON_MEMDAT1r
#define WRITE_BUFCON_MEMDAT1r BCM53262_A0_WRITE_BUFCON_MEMDAT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_BUFCON_MEMDAT1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_ACC
 * BLOCKS:   SYS
 * DESC:     CFP Access Registers
 * SIZE:     32
 * FIELDS:
 *     OPCODE_R         Operation CodeSoftware set the code the start the operation after having configured all necessary registers.Hardware clears the code automatically when operation is done.4'b0000 NOP4'b0001 Memory read operation. Read the memories assigned by mem_sel.4'b0010 Memory write operation. Write the memories assigned by mem_sel.4'b0011 Memory fill operation. Software runs the operation to fill data to the memory assigned by mem_sel. The pattern to fill are TCAM_DATA0-5, ¡K4'b0100 TCAM valid entry map lookup Hardware will search 512 entries and group the valid status as a map. {xcess_addr[9],9¡¦b0} is the start address. Result will be put at TCAM_DATA0-5, TCAM_MASK0-1. mem_sel[0] should be 1.others  reserved
 *     MEMSEL           Memory SelectionThis field selects the target of the memory operation.Multiple selections are allowed.5'b1xxxx out-band statistic memory5'bx1xxx in-band statistic memory5'bxx1xx rate meter memory5'bxxx1x action/policy memory5'bxxxx1 TCAM
 *     XCESS_ADDR       Access AddressThis field indicates the address offset of the RAM blocks for the operation.For read and write operation, this is the target address for the TCAM and RAM blocks.
 *     RESERVED_R       Reserved.
 *     RATE_METER_EN    Rate Meter EnableThis field enables hardware for rate meter function. Software should set this bit after the rate meter RAM has been initialized, and software would like to start rate meter function.If the bit is not enabled, all rules will be in-band.
 */
#define BCM53262_A0_CFP_ACCr 0x00002000

#define BCM53262_A0_CFP_ACCr_SIZE 4

/*
 * This structure should be used to declare and program CFP_ACC.
 */
typedef union BCM53262_A0_CFP_ACCr_s {
	uint32_t v[1];
	uint32_t cfp_acc[1];
	uint32_t _cfp_acc;
} BCM53262_A0_CFP_ACCr_t;

#define BCM53262_A0_CFP_ACCr_CLR(r) (r).cfp_acc[0] = 0
#define BCM53262_A0_CFP_ACCr_SET(r,d) (r).cfp_acc[0] = d
#define BCM53262_A0_CFP_ACCr_GET(r) (r).cfp_acc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_ACCr_OPCODE_Rf_GET(r) (((r).cfp_acc[0]) & 0xf)
#define BCM53262_A0_CFP_ACCr_OPCODE_Rf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53262_A0_CFP_ACCr_MEMSELf_GET(r) ((((r).cfp_acc[0]) >> 4) & 0x1f)
#define BCM53262_A0_CFP_ACCr_MEMSELf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM53262_A0_CFP_ACCr_XCESS_ADDRf_GET(r) ((((r).cfp_acc[0]) >> 9) & 0x3ff)
#define BCM53262_A0_CFP_ACCr_XCESS_ADDRf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x3ff << 9)) | ((((uint32_t)f) & 0x3ff) << 9))
#define BCM53262_A0_CFP_ACCr_RESERVED_Rf_GET(r) ((((r).cfp_acc[0]) >> 19) & 0xfff)
#define BCM53262_A0_CFP_ACCr_RESERVED_Rf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0xfff << 19)) | ((((uint32_t)f) & 0xfff) << 19))
#define BCM53262_A0_CFP_ACCr_RATE_METER_ENf_GET(r) ((((r).cfp_acc[0]) >> 31) & 0x1)
#define BCM53262_A0_CFP_ACCr_RATE_METER_ENf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CFP_ACC.
 */
#define BCM53262_A0_READ_CFP_ACCr(u,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_ACCr,(r._cfp_acc),4)
#define BCM53262_A0_WRITE_CFP_ACCr(u,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_ACCr,&(r._cfp_acc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_ACCr BCM53262_A0_CFP_ACCr
#define CFP_ACCr_SIZE BCM53262_A0_CFP_ACCr_SIZE
typedef BCM53262_A0_CFP_ACCr_t CFP_ACCr_t;
#define CFP_ACCr_CLR BCM53262_A0_CFP_ACCr_CLR
#define CFP_ACCr_SET BCM53262_A0_CFP_ACCr_SET
#define CFP_ACCr_GET BCM53262_A0_CFP_ACCr_GET
#define CFP_ACCr_OPCODE_Rf_GET BCM53262_A0_CFP_ACCr_OPCODE_Rf_GET
#define CFP_ACCr_OPCODE_Rf_SET BCM53262_A0_CFP_ACCr_OPCODE_Rf_SET
#define CFP_ACCr_MEMSELf_GET BCM53262_A0_CFP_ACCr_MEMSELf_GET
#define CFP_ACCr_MEMSELf_SET BCM53262_A0_CFP_ACCr_MEMSELf_SET
#define CFP_ACCr_XCESS_ADDRf_GET BCM53262_A0_CFP_ACCr_XCESS_ADDRf_GET
#define CFP_ACCr_XCESS_ADDRf_SET BCM53262_A0_CFP_ACCr_XCESS_ADDRf_SET
#define CFP_ACCr_RESERVED_Rf_GET BCM53262_A0_CFP_ACCr_RESERVED_Rf_GET
#define CFP_ACCr_RESERVED_Rf_SET BCM53262_A0_CFP_ACCr_RESERVED_Rf_SET
#define CFP_ACCr_RATE_METER_ENf_GET BCM53262_A0_CFP_ACCr_RATE_METER_ENf_GET
#define CFP_ACCr_RATE_METER_ENf_SET BCM53262_A0_CFP_ACCr_RATE_METER_ENf_SET
#define READ_CFP_ACCr BCM53262_A0_READ_CFP_ACCr
#define WRITE_CFP_ACCr BCM53262_A0_WRITE_CFP_ACCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_ACCr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_ACT_POL
 * BLOCKS:   SYS
 * DESC:     Action/police RAM
 * SIZE:     48
 * FIELDS:
 *     NEW_FWD_IB       New destination port number for in-band
 *     CHANGE_FWD_IB    Change forwarding for in-band
 *     NEW_COS_IMP      Priority map for In/Out-band(IMP port only)
 *     CHANGE_COS_IMP   Change COS for In/Out-band(IMP port only)
 *     NEW_COS          Priority map for In/Out-band(Ether port only)
 *     CHANGE_COS       Change COS for In/Out-band(Ether port only)
 *     NEW_PCP          New 802.1p header for In/Out-band
 *     CHANGE_PCP       Change 1P header for In/Out-band
 *     NEW_DSCP_IB      New DSCP value for in-band
 *     CHANGE_DSCP_IB   Change DSCP for in-band
 *     NEW_FLOW_INDEX   New FLOW(VID) index for In/Out-band
 *     CHANGE_FLOW      Change FLOW(VID) for In/Out-band
 *     NEW_FWD_OB       New destination port number for out-band
 *     CHANGE_FWD_OB    Change forwarding for out-band
 *     NEW_DSCP_OB      New DSCP value for out-band
 *     CHANGE_DSCP_OB   Change DSCP for out-band
 *     RESVD            Reserved
 */
#define BCM53262_A0_CFP_ACT_POLm 0x00004e00

#define BCM53262_A0_CFP_ACT_POLm_MIN 0
#define BCM53262_A0_CFP_ACT_POLm_MAX 1023
#define BCM53262_A0_CFP_ACT_POLm_CMAX(u) 1023
#define BCM53262_A0_CFP_ACT_POLm_SIZE 6

/*
 * This structure should be used to declare and program CFP_ACT_POL.
 */
typedef union BCM53262_A0_CFP_ACT_POLm_s {
	uint32_t v[2];
	uint32_t cfp_act_pol[2];
	uint32_t _cfp_act_pol;
} BCM53262_A0_CFP_ACT_POLm_t;

#define BCM53262_A0_CFP_ACT_POLm_CLR(r) CDK_MEMSET(&((r)._cfp_act_pol), 0, sizeof(BCM53262_A0_CFP_ACT_POLm_t))
#define BCM53262_A0_CFP_ACT_POLm_SET(r,i,d) (r).cfp_act_pol[i] = d
#define BCM53262_A0_CFP_ACT_POLm_GET(r,i) (r).cfp_act_pol[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_ACT_POLm_NEW_FWD_IBf_GET(r) (((r).cfp_act_pol[0]) & 0x3f)
#define BCM53262_A0_CFP_ACT_POLm_NEW_FWD_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 6) & 0x3)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_CFP_ACT_POLm_NEW_COS_IMPf_GET(r) ((((r).cfp_act_pol[0]) >> 8) & 0x3)
#define BCM53262_A0_CFP_ACT_POLm_NEW_COS_IMPf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_COS_IMPf_GET(r) ((((r).cfp_act_pol[0]) >> 10) & 0x1)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_COS_IMPf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_CFP_ACT_POLm_NEW_COSf_GET(r) ((((r).cfp_act_pol[0]) >> 11) & 0x3)
#define BCM53262_A0_CFP_ACT_POLm_NEW_COSf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_COSf_GET(r) ((((r).cfp_act_pol[0]) >> 13) & 0x1)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_COSf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_CFP_ACT_POLm_NEW_PCPf_GET(r) ((((r).cfp_act_pol[0]) >> 14) & 0x7)
#define BCM53262_A0_CFP_ACT_POLm_NEW_PCPf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x7 << 14)) | ((((uint32_t)f) & 0x7) << 14))
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_PCPf_GET(r) ((((r).cfp_act_pol[0]) >> 17) & 0x1)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_PCPf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 18) & 0x3f)
#define BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 24) & 0x1)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53262_A0_CFP_ACT_POLm_NEW_FLOW_INDEXf_GET(r) ((((r).cfp_act_pol[0]) >> 25) & 0xf)
#define BCM53262_A0_CFP_ACT_POLm_NEW_FLOW_INDEXf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_FLOWf_GET(r) ((((r).cfp_act_pol[0]) >> 29) & 0x3)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_FLOWf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53262_A0_CFP_ACT_POLm_NEW_FWD_OBf_GET(r) cdk_field32_get((r).cfp_act_pol,31,36)
#define BCM53262_A0_CFP_ACT_POLm_NEW_FWD_OBf_SET(r,f) cdk_field32_set((r).cfp_act_pol,31,36,f)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_OBf_GET(r) ((((r).cfp_act_pol[1]) >> 5) & 0x3)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_OBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_OBf_GET(r) ((((r).cfp_act_pol[1]) >> 7) & 0x3f)
#define BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_OBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7))
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_GET(r) ((((r).cfp_act_pol[1]) >> 13) & 0x1)
#define BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_CFP_ACT_POLm_RESVDf_GET(r) ((((r).cfp_act_pol[1]) >> 14) & 0x3)
#define BCM53262_A0_CFP_ACT_POLm_RESVDf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access CFP_ACT_POL.
 */
#define BCM53262_A0_READ_CFP_ACT_POLm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_ACT_POLm,i,(m),6)
#define BCM53262_A0_WRITE_CFP_ACT_POLm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_ACT_POLm,i,&(m),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_ACT_POLm BCM53262_A0_CFP_ACT_POLm
#define CFP_ACT_POLm_MIN BCM53262_A0_CFP_ACT_POLm_MIN
#define CFP_ACT_POLm_MAX BCM53262_A0_CFP_ACT_POLm_MAX
#define CFP_ACT_POLm_CMAX(u) BCM53262_A0_CFP_ACT_POLm_CMAX(u)
#define CFP_ACT_POLm_SIZE BCM53262_A0_CFP_ACT_POLm_SIZE
typedef BCM53262_A0_CFP_ACT_POLm_t CFP_ACT_POLm_t;
#define CFP_ACT_POLm_CLR BCM53262_A0_CFP_ACT_POLm_CLR
#define CFP_ACT_POLm_SET BCM53262_A0_CFP_ACT_POLm_SET
#define CFP_ACT_POLm_GET BCM53262_A0_CFP_ACT_POLm_GET
#define CFP_ACT_POLm_NEW_FWD_IBf_GET BCM53262_A0_CFP_ACT_POLm_NEW_FWD_IBf_GET
#define CFP_ACT_POLm_NEW_FWD_IBf_SET BCM53262_A0_CFP_ACT_POLm_NEW_FWD_IBf_SET
#define CFP_ACT_POLm_CHANGE_FWD_IBf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_IBf_GET
#define CFP_ACT_POLm_CHANGE_FWD_IBf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_IBf_SET
#define CFP_ACT_POLm_NEW_COS_IMPf_GET BCM53262_A0_CFP_ACT_POLm_NEW_COS_IMPf_GET
#define CFP_ACT_POLm_NEW_COS_IMPf_SET BCM53262_A0_CFP_ACT_POLm_NEW_COS_IMPf_SET
#define CFP_ACT_POLm_CHANGE_COS_IMPf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_COS_IMPf_GET
#define CFP_ACT_POLm_CHANGE_COS_IMPf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_COS_IMPf_SET
#define CFP_ACT_POLm_NEW_COSf_GET BCM53262_A0_CFP_ACT_POLm_NEW_COSf_GET
#define CFP_ACT_POLm_NEW_COSf_SET BCM53262_A0_CFP_ACT_POLm_NEW_COSf_SET
#define CFP_ACT_POLm_CHANGE_COSf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_COSf_GET
#define CFP_ACT_POLm_CHANGE_COSf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_COSf_SET
#define CFP_ACT_POLm_NEW_PCPf_GET BCM53262_A0_CFP_ACT_POLm_NEW_PCPf_GET
#define CFP_ACT_POLm_NEW_PCPf_SET BCM53262_A0_CFP_ACT_POLm_NEW_PCPf_SET
#define CFP_ACT_POLm_CHANGE_PCPf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_PCPf_GET
#define CFP_ACT_POLm_CHANGE_PCPf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_PCPf_SET
#define CFP_ACT_POLm_NEW_DSCP_IBf_GET BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_IBf_GET
#define CFP_ACT_POLm_NEW_DSCP_IBf_SET BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_IBf_SET
#define CFP_ACT_POLm_CHANGE_DSCP_IBf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_GET
#define CFP_ACT_POLm_CHANGE_DSCP_IBf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_SET
#define CFP_ACT_POLm_NEW_FLOW_INDEXf_GET BCM53262_A0_CFP_ACT_POLm_NEW_FLOW_INDEXf_GET
#define CFP_ACT_POLm_NEW_FLOW_INDEXf_SET BCM53262_A0_CFP_ACT_POLm_NEW_FLOW_INDEXf_SET
#define CFP_ACT_POLm_CHANGE_FLOWf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_FLOWf_GET
#define CFP_ACT_POLm_CHANGE_FLOWf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_FLOWf_SET
#define CFP_ACT_POLm_NEW_FWD_OBf_GET BCM53262_A0_CFP_ACT_POLm_NEW_FWD_OBf_GET
#define CFP_ACT_POLm_NEW_FWD_OBf_SET BCM53262_A0_CFP_ACT_POLm_NEW_FWD_OBf_SET
#define CFP_ACT_POLm_CHANGE_FWD_OBf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_OBf_GET
#define CFP_ACT_POLm_CHANGE_FWD_OBf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_FWD_OBf_SET
#define CFP_ACT_POLm_NEW_DSCP_OBf_GET BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_OBf_GET
#define CFP_ACT_POLm_NEW_DSCP_OBf_SET BCM53262_A0_CFP_ACT_POLm_NEW_DSCP_OBf_SET
#define CFP_ACT_POLm_CHANGE_DSCP_OBf_GET BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_GET
#define CFP_ACT_POLm_CHANGE_DSCP_OBf_SET BCM53262_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_SET
#define CFP_ACT_POLm_RESVDf_GET BCM53262_A0_CFP_ACT_POLm_RESVDf_GET
#define CFP_ACT_POLm_RESVDf_SET BCM53262_A0_CFP_ACT_POLm_RESVDf_SET
#define READ_CFP_ACT_POLm BCM53262_A0_READ_CFP_ACT_POLm
#define WRITE_CFP_ACT_POLm BCM53262_A0_WRITE_CFP_ACT_POLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_ACT_POLm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_DATA
 * BLOCKS:   SYS
 * DESC:     CFP TCAM Data X Registers
 * SIZE:     64
 * FIELDS:
 *     TCAM_DATA        TCAM Data Register for Different Opcode .TCAM data field is located at {TCAM_DATA5[47:0],TCAM_DATA4-0}TCAM valid field is located at TCAM_DATA5[63:60].opcode = 4'b001TCAM_DATA0[63:0]  the output of TCAM data [63:0]TCAM_DATA1[63:0]  the output of TCAM data[127:64]TCAM_DATA2[63:0]  the output of TCAM data[191:128]TCAM_DATA3[63:0]  the output of TCAM data[255:192]TCAM_DATA4[63:0]  the output of TCAM data[319:256]TCAM_DATA5[63:0]  the output of TCAM data[371:320]opcode = 4'b0010TCAM_DATA0[63:0]  the input of TCAM data [63:0]TCAM_DATA1[63:0]  the input of TCAM data[127:64]TCAM_DATA2[63:0]  the input of TCAM data[191:128]TCAM_DATA3[63:0]  the input of TCAM data[255:192]TCAM_DATA4[63:0]  the input of TCAM data[319:256]TCAM_DATA5[63:0]  the input of TCAM data[371:320]opcode = 4'b0100TCAM_DATA0[63:0]  the input of TCAM valid map [63:0]TCAM_DATA1[63:0]  the input of TCAM valid map[127:64]TCAM_DATA2[63:0]  the input of TCAM valid map[191:128]TCAM_DATA3[63:0]  the input of TCAM valid map[255:192]TCAM_DATA4[63:0]  the input of TCAM valid map[319:256]TCAM_DATA5[63:0]  the input of TCAM valid map[383:320]
 */
#define BCM53262_A0_CFP_DATAr 0x00002010

#define BCM53262_A0_CFP_DATAr_SIZE 8

/*
 * This structure should be used to declare and program CFP_DATA.
 */
typedef union BCM53262_A0_CFP_DATAr_s {
	uint32_t v[2];
	uint32_t cfp_data[2];
	uint32_t _cfp_data;
} BCM53262_A0_CFP_DATAr_t;

#define BCM53262_A0_CFP_DATAr_CLR(r) CDK_MEMSET(&((r)._cfp_data), 0, sizeof(BCM53262_A0_CFP_DATAr_t))
#define BCM53262_A0_CFP_DATAr_SET(r,i,d) (r).cfp_data[i] = d
#define BCM53262_A0_CFP_DATAr_GET(r,i) (r).cfp_data[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_DATAr_TCAM_DATAf_GET(r,a) cdk_field_get((r).cfp_data,0,63,a)
#define BCM53262_A0_CFP_DATAr_TCAM_DATAf_SET(r,a) cdk_field_set((r).cfp_data,0,63,a)

/*
 * These macros can be used to access CFP_DATA.
 */
#define BCM53262_A0_READ_CFP_DATAr(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_DATAr+(8*(i)),(r._cfp_data),8)
#define BCM53262_A0_WRITE_CFP_DATAr(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_DATAr+(8*(i)),&(r._cfp_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_DATAr BCM53262_A0_CFP_DATAr
#define CFP_DATAr_SIZE BCM53262_A0_CFP_DATAr_SIZE
typedef BCM53262_A0_CFP_DATAr_t CFP_DATAr_t;
#define CFP_DATAr_CLR BCM53262_A0_CFP_DATAr_CLR
#define CFP_DATAr_SET BCM53262_A0_CFP_DATAr_SET
#define CFP_DATAr_GET BCM53262_A0_CFP_DATAr_GET
#define CFP_DATAr_TCAM_DATAf_GET BCM53262_A0_CFP_DATAr_TCAM_DATAf_GET
#define CFP_DATAr_TCAM_DATAf_SET BCM53262_A0_CFP_DATAr_TCAM_DATAf_SET
#define READ_CFP_DATAr BCM53262_A0_READ_CFP_DATAr
#define WRITE_CFP_DATAr BCM53262_A0_WRITE_CFP_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     CFP Enable Control Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     EN_CFP_MAP       CFP Enable Control Register.When set to one, the corresponding port CFP feature is enabled.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_CFP_EN_CTRLr 0x00002120

#define BCM53262_A0_CFP_EN_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program CFP_EN_CTRL.
 */
typedef union BCM53262_A0_CFP_EN_CTRLr_s {
	uint32_t v[2];
	uint32_t cfp_en_ctrl[2];
	uint32_t _cfp_en_ctrl;
} BCM53262_A0_CFP_EN_CTRLr_t;

#define BCM53262_A0_CFP_EN_CTRLr_CLR(r) CDK_MEMSET(&((r)._cfp_en_ctrl), 0, sizeof(BCM53262_A0_CFP_EN_CTRLr_t))
#define BCM53262_A0_CFP_EN_CTRLr_SET(r,i,d) (r).cfp_en_ctrl[i] = d
#define BCM53262_A0_CFP_EN_CTRLr_GET(r,i) (r).cfp_en_ctrl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_EN_CTRLr_RESERVED_0Rf_GET(r) (((r).cfp_en_ctrl[0]) & 0xffffff)
#define BCM53262_A0_CFP_EN_CTRLr_RESERVED_0Rf_SET(r,f) (r).cfp_en_ctrl[0]=(((r).cfp_en_ctrl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_CFP_EN_CTRLr_EN_CFP_MAPf_GET(r) cdk_field32_get((r).cfp_en_ctrl,24,52)
#define BCM53262_A0_CFP_EN_CTRLr_EN_CFP_MAPf_SET(r,f) cdk_field32_set((r).cfp_en_ctrl,24,52,f)
#define BCM53262_A0_CFP_EN_CTRLr_RESERVED_1Rf_GET(r) ((((r).cfp_en_ctrl[1]) >> 21) & 0x1ff)
#define BCM53262_A0_CFP_EN_CTRLr_RESERVED_1Rf_SET(r,f) (r).cfp_en_ctrl[1]=(((r).cfp_en_ctrl[1] & ~((uint32_t)0x1ff << 21)) | ((((uint32_t)f) & 0x1ff) << 21))

/*
 * These macros can be used to access CFP_EN_CTRL.
 */
#define BCM53262_A0_READ_CFP_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_EN_CTRLr,(r._cfp_en_ctrl),8)
#define BCM53262_A0_WRITE_CFP_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_EN_CTRLr,&(r._cfp_en_ctrl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_EN_CTRLr BCM53262_A0_CFP_EN_CTRLr
#define CFP_EN_CTRLr_SIZE BCM53262_A0_CFP_EN_CTRLr_SIZE
typedef BCM53262_A0_CFP_EN_CTRLr_t CFP_EN_CTRLr_t;
#define CFP_EN_CTRLr_CLR BCM53262_A0_CFP_EN_CTRLr_CLR
#define CFP_EN_CTRLr_SET BCM53262_A0_CFP_EN_CTRLr_SET
#define CFP_EN_CTRLr_GET BCM53262_A0_CFP_EN_CTRLr_GET
#define CFP_EN_CTRLr_RESERVED_0Rf_GET BCM53262_A0_CFP_EN_CTRLr_RESERVED_0Rf_GET
#define CFP_EN_CTRLr_RESERVED_0Rf_SET BCM53262_A0_CFP_EN_CTRLr_RESERVED_0Rf_SET
#define CFP_EN_CTRLr_EN_CFP_MAPf_GET BCM53262_A0_CFP_EN_CTRLr_EN_CFP_MAPf_GET
#define CFP_EN_CTRLr_EN_CFP_MAPf_SET BCM53262_A0_CFP_EN_CTRLr_EN_CFP_MAPf_SET
#define CFP_EN_CTRLr_RESERVED_1Rf_GET BCM53262_A0_CFP_EN_CTRLr_RESERVED_1Rf_GET
#define CFP_EN_CTRLr_RESERVED_1Rf_SET BCM53262_A0_CFP_EN_CTRLr_RESERVED_1Rf_SET
#define READ_CFP_EN_CTRLr BCM53262_A0_READ_CFP_EN_CTRLr
#define WRITE_CFP_EN_CTRLr BCM53262_A0_WRITE_CFP_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_EN_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     Global CFP Control Registers
 * SIZE:     8
 * FIELDS:
 *     VLAN_HANDLE      1'b1: if the action is flood , we will flood to all the ports. So, we didn't care VLAN security.1'b0: if the action is flood, we will only forward packet to member set which the packet belong to.
 *     TRUNK_HANDLE     CFP Trunk Handle.1'b1: if the action is flood , we will flood to all the ports. So, trunk ports will have multiple copies.1'b0: if the action is flood, we will only forward one copy in each trunk group. We will not do load balance in this condition. It is up to the designer which port to send the frame.
 *     SLICE0_PRI       Slice 0 Priority.
 *     SLICE1_PRI       Slice 1 Priority.
 *     SLICE2_PRI       Slice 2 Priority.
 */
#define BCM53262_A0_CFP_GLOBAL_CTLr 0x00002100

#define BCM53262_A0_CFP_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program CFP_GLOBAL_CTL.
 */
typedef union BCM53262_A0_CFP_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t cfp_global_ctl[1];
	uint32_t _cfp_global_ctl;
} BCM53262_A0_CFP_GLOBAL_CTLr_t;

#define BCM53262_A0_CFP_GLOBAL_CTLr_CLR(r) (r).cfp_global_ctl[0] = 0
#define BCM53262_A0_CFP_GLOBAL_CTLr_SET(r,d) (r).cfp_global_ctl[0] = d
#define BCM53262_A0_CFP_GLOBAL_CTLr_GET(r) (r).cfp_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_GLOBAL_CTLr_VLAN_HANDLEf_GET(r) (((r).cfp_global_ctl[0]) & 0x1)
#define BCM53262_A0_CFP_GLOBAL_CTLr_VLAN_HANDLEf_SET(r,f) (r).cfp_global_ctl[0]=(((r).cfp_global_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_CFP_GLOBAL_CTLr_TRUNK_HANDLEf_GET(r) ((((r).cfp_global_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_CFP_GLOBAL_CTLr_TRUNK_HANDLEf_SET(r,f) (r).cfp_global_ctl[0]=(((r).cfp_global_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_CFP_GLOBAL_CTLr_SLICE0_PRIf_GET(r) ((((r).cfp_global_ctl[0]) >> 2) & 0x3)
#define BCM53262_A0_CFP_GLOBAL_CTLr_SLICE0_PRIf_SET(r,f) (r).cfp_global_ctl[0]=(((r).cfp_global_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_CFP_GLOBAL_CTLr_SLICE1_PRIf_GET(r) ((((r).cfp_global_ctl[0]) >> 4) & 0x3)
#define BCM53262_A0_CFP_GLOBAL_CTLr_SLICE1_PRIf_SET(r,f) (r).cfp_global_ctl[0]=(((r).cfp_global_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_CFP_GLOBAL_CTLr_SLICE2_PRIf_GET(r) ((((r).cfp_global_ctl[0]) >> 6) & 0x3)
#define BCM53262_A0_CFP_GLOBAL_CTLr_SLICE2_PRIf_SET(r,f) (r).cfp_global_ctl[0]=(((r).cfp_global_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access CFP_GLOBAL_CTL.
 */
#define BCM53262_A0_READ_CFP_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_GLOBAL_CTLr,(r._cfp_global_ctl),1)
#define BCM53262_A0_WRITE_CFP_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_GLOBAL_CTLr,&(r._cfp_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_GLOBAL_CTLr BCM53262_A0_CFP_GLOBAL_CTLr
#define CFP_GLOBAL_CTLr_SIZE BCM53262_A0_CFP_GLOBAL_CTLr_SIZE
typedef BCM53262_A0_CFP_GLOBAL_CTLr_t CFP_GLOBAL_CTLr_t;
#define CFP_GLOBAL_CTLr_CLR BCM53262_A0_CFP_GLOBAL_CTLr_CLR
#define CFP_GLOBAL_CTLr_SET BCM53262_A0_CFP_GLOBAL_CTLr_SET
#define CFP_GLOBAL_CTLr_GET BCM53262_A0_CFP_GLOBAL_CTLr_GET
#define CFP_GLOBAL_CTLr_VLAN_HANDLEf_GET BCM53262_A0_CFP_GLOBAL_CTLr_VLAN_HANDLEf_GET
#define CFP_GLOBAL_CTLr_VLAN_HANDLEf_SET BCM53262_A0_CFP_GLOBAL_CTLr_VLAN_HANDLEf_SET
#define CFP_GLOBAL_CTLr_TRUNK_HANDLEf_GET BCM53262_A0_CFP_GLOBAL_CTLr_TRUNK_HANDLEf_GET
#define CFP_GLOBAL_CTLr_TRUNK_HANDLEf_SET BCM53262_A0_CFP_GLOBAL_CTLr_TRUNK_HANDLEf_SET
#define CFP_GLOBAL_CTLr_SLICE0_PRIf_GET BCM53262_A0_CFP_GLOBAL_CTLr_SLICE0_PRIf_GET
#define CFP_GLOBAL_CTLr_SLICE0_PRIf_SET BCM53262_A0_CFP_GLOBAL_CTLr_SLICE0_PRIf_SET
#define CFP_GLOBAL_CTLr_SLICE1_PRIf_GET BCM53262_A0_CFP_GLOBAL_CTLr_SLICE1_PRIf_GET
#define CFP_GLOBAL_CTLr_SLICE1_PRIf_SET BCM53262_A0_CFP_GLOBAL_CTLr_SLICE1_PRIf_SET
#define CFP_GLOBAL_CTLr_SLICE2_PRIf_GET BCM53262_A0_CFP_GLOBAL_CTLr_SLICE2_PRIf_GET
#define CFP_GLOBAL_CTLr_SLICE2_PRIf_SET BCM53262_A0_CFP_GLOBAL_CTLr_SLICE2_PRIf_SET
#define READ_CFP_GLOBAL_CTLr BCM53262_A0_READ_CFP_GLOBAL_CTLr
#define WRITE_CFP_GLOBAL_CTLr BCM53262_A0_WRITE_CFP_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_GLOBAL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_MASK
 * BLOCKS:   SYS
 * DESC:     CFP TCAM Mask X Registers
 * SIZE:     64
 * FIELDS:
 *     TCAM_MASK        TCAM Mask Register for Different Opcode .TCAM mask data field is located at {TCAM_MASK5[47:0],TCAM_MASK4-0}TCAM mask valid field is located at TCAM_MASK5[63:60].opcode = 4'b001TCAM_MASK0[63:0]  the output of TCAM MASK [63:0]TCAM_MASK1[63:0]  the output of TCAM MASK[127:64]TCAM_MASK2[63:0]  the output of TCAM MASK[191:128]TCAM_MASK3[63:0]  the output of TCAM MASK[255:192]TCAM_MASK4[63:0]  the output of TCAM MASK[319:256]TCAM_MASK5[51:0]  the output of TCAM MASK[371:320]opcode = 4'b0010TCAM_MASK0[63:0]  the input of TCAM MASK [63:0]TCAM_MASK1[63:0]  the input of TCAM MASK[127:64]TCAM_MASK2[63:0]  the input of TCAM MASK[191:128]TCAM_MASK3[63:0]  the input of TCAM MASK[255:192]TCAM_MASK4[63:0]  the input of TCAM MASK[319:256]TCAM_MASK5[51:0]  the input of TCAM MASK[371:320]opcode = 4'b0100TCAM_MASK0[63:0]  the input of TCAM valid map[447:384]TCAM_MASK1[63:0]  the input of TCAM valid map[511:448]
 */
#define BCM53262_A0_CFP_MASKr 0x00002040

#define BCM53262_A0_CFP_MASKr_SIZE 8

/*
 * This structure should be used to declare and program CFP_MASK.
 */
typedef union BCM53262_A0_CFP_MASKr_s {
	uint32_t v[2];
	uint32_t cfp_mask[2];
	uint32_t _cfp_mask;
} BCM53262_A0_CFP_MASKr_t;

#define BCM53262_A0_CFP_MASKr_CLR(r) CDK_MEMSET(&((r)._cfp_mask), 0, sizeof(BCM53262_A0_CFP_MASKr_t))
#define BCM53262_A0_CFP_MASKr_SET(r,i,d) (r).cfp_mask[i] = d
#define BCM53262_A0_CFP_MASKr_GET(r,i) (r).cfp_mask[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_MASKr_TCAM_MASKf_GET(r,a) cdk_field_get((r).cfp_mask,0,63,a)
#define BCM53262_A0_CFP_MASKr_TCAM_MASKf_SET(r,a) cdk_field_set((r).cfp_mask,0,63,a)

/*
 * These macros can be used to access CFP_MASK.
 */
#define BCM53262_A0_READ_CFP_MASKr(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_MASKr+(8*(i)),(r._cfp_mask),8)
#define BCM53262_A0_WRITE_CFP_MASKr(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_MASKr+(8*(i)),&(r._cfp_mask),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_MASKr BCM53262_A0_CFP_MASKr
#define CFP_MASKr_SIZE BCM53262_A0_CFP_MASKr_SIZE
typedef BCM53262_A0_CFP_MASKr_t CFP_MASKr_t;
#define CFP_MASKr_CLR BCM53262_A0_CFP_MASKr_CLR
#define CFP_MASKr_SET BCM53262_A0_CFP_MASKr_SET
#define CFP_MASKr_GET BCM53262_A0_CFP_MASKr_GET
#define CFP_MASKr_TCAM_MASKf_GET BCM53262_A0_CFP_MASKr_TCAM_MASKf_GET
#define CFP_MASKr_TCAM_MASKf_SET BCM53262_A0_CFP_MASKr_TCAM_MASKf_SET
#define READ_CFP_MASKr BCM53262_A0_READ_CFP_MASKr
#define WRITE_CFP_MASKr BCM53262_A0_WRITE_CFP_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_METER
 * BLOCKS:   SYS
 * DESC:     Meter RAM
 * SIZE:     32
 * FIELDS:
 *     RFSHCNT          Refresh count
 *     RFSHUNIT         Refresh unit
 *     BKTSIZE          Bucket size
 *     RESVD            Reserved
 */
#define BCM53262_A0_CFP_METERm 0x00005200

#define BCM53262_A0_CFP_METERm_MIN 0
#define BCM53262_A0_CFP_METERm_MAX 1023
#define BCM53262_A0_CFP_METERm_CMAX(u) 1023
#define BCM53262_A0_CFP_METERm_SIZE 4

/*
 * This structure should be used to declare and program CFP_METER.
 */
typedef union BCM53262_A0_CFP_METERm_s {
	uint32_t v[1];
	uint32_t cfp_meter[1];
	uint32_t _cfp_meter;
} BCM53262_A0_CFP_METERm_t;

#define BCM53262_A0_CFP_METERm_CLR(r) (r).cfp_meter[0] = 0
#define BCM53262_A0_CFP_METERm_SET(r,d) (r).cfp_meter[0] = d
#define BCM53262_A0_CFP_METERm_GET(r) (r).cfp_meter[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_METERm_RFSHCNTf_GET(r) (((r).cfp_meter[0]) & 0x3fff)
#define BCM53262_A0_CFP_METERm_RFSHCNTf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_CFP_METERm_RFSHUNITf_GET(r) ((((r).cfp_meter[0]) >> 14) & 0x1)
#define BCM53262_A0_CFP_METERm_RFSHUNITf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_CFP_METERm_BKTSIZEf_GET(r) ((((r).cfp_meter[0]) >> 15) & 0x7f)
#define BCM53262_A0_CFP_METERm_BKTSIZEf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_CFP_METERm_RESVDf_GET(r) ((((r).cfp_meter[0]) >> 22) & 0x3ff)
#define BCM53262_A0_CFP_METERm_RESVDf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CFP_METER.
 */
#define BCM53262_A0_READ_CFP_METERm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_METERm,i,(m),4)
#define BCM53262_A0_WRITE_CFP_METERm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_METERm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_METERm BCM53262_A0_CFP_METERm
#define CFP_METERm_MIN BCM53262_A0_CFP_METERm_MIN
#define CFP_METERm_MAX BCM53262_A0_CFP_METERm_MAX
#define CFP_METERm_CMAX(u) BCM53262_A0_CFP_METERm_CMAX(u)
#define CFP_METERm_SIZE BCM53262_A0_CFP_METERm_SIZE
typedef BCM53262_A0_CFP_METERm_t CFP_METERm_t;
#define CFP_METERm_CLR BCM53262_A0_CFP_METERm_CLR
#define CFP_METERm_SET BCM53262_A0_CFP_METERm_SET
#define CFP_METERm_GET BCM53262_A0_CFP_METERm_GET
#define CFP_METERm_RFSHCNTf_GET BCM53262_A0_CFP_METERm_RFSHCNTf_GET
#define CFP_METERm_RFSHCNTf_SET BCM53262_A0_CFP_METERm_RFSHCNTf_SET
#define CFP_METERm_RFSHUNITf_GET BCM53262_A0_CFP_METERm_RFSHUNITf_GET
#define CFP_METERm_RFSHUNITf_SET BCM53262_A0_CFP_METERm_RFSHUNITf_SET
#define CFP_METERm_BKTSIZEf_GET BCM53262_A0_CFP_METERm_BKTSIZEf_GET
#define CFP_METERm_BKTSIZEf_SET BCM53262_A0_CFP_METERm_BKTSIZEf_SET
#define CFP_METERm_RESVDf_GET BCM53262_A0_CFP_METERm_RESVDf_GET
#define CFP_METERm_RESVDf_SET BCM53262_A0_CFP_METERm_RESVDf_SET
#define READ_CFP_METERm BCM53262_A0_READ_CFP_METERm
#define WRITE_CFP_METERm BCM53262_A0_WRITE_CFP_METERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_METERm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_RC
 * BLOCKS:   SYS
 * DESC:     CFP Rate Meter Configuration Registers
 * SIZE:     32
 * FIELDS:
 *     RFSHCNT          refresh countfor rfshunit=0, rate=62.5Kbps X rfshcntfor rfshunit=1, rate=1Mbps X rfshcnt
 *     RFSHUNIT         Refresh Unit=0 for 62.5Kbps=1 for 1Mbps
 *     BKTSIZE          Bucket Sizeunit=8KBbucket size = 8KB X bktsize000 0000KB001 0008KB002 0016KB003 0024KB¡K.  ¡K¡K.127 1016KB
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_CFP_RCr 0x00002080

#define BCM53262_A0_CFP_RCr_SIZE 4

/*
 * This structure should be used to declare and program CFP_RC.
 */
typedef union BCM53262_A0_CFP_RCr_s {
	uint32_t v[1];
	uint32_t cfp_rc[1];
	uint32_t _cfp_rc;
} BCM53262_A0_CFP_RCr_t;

#define BCM53262_A0_CFP_RCr_CLR(r) (r).cfp_rc[0] = 0
#define BCM53262_A0_CFP_RCr_SET(r,d) (r).cfp_rc[0] = d
#define BCM53262_A0_CFP_RCr_GET(r) (r).cfp_rc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_RCr_RFSHCNTf_GET(r) (((r).cfp_rc[0]) & 0x3fff)
#define BCM53262_A0_CFP_RCr_RFSHCNTf_SET(r,f) (r).cfp_rc[0]=(((r).cfp_rc[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_CFP_RCr_RFSHUNITf_GET(r) ((((r).cfp_rc[0]) >> 14) & 0x1)
#define BCM53262_A0_CFP_RCr_RFSHUNITf_SET(r,f) (r).cfp_rc[0]=(((r).cfp_rc[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_CFP_RCr_BKTSIZEf_GET(r) ((((r).cfp_rc[0]) >> 15) & 0x7f)
#define BCM53262_A0_CFP_RCr_BKTSIZEf_SET(r,f) (r).cfp_rc[0]=(((r).cfp_rc[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_CFP_RCr_RESERVED_Rf_GET(r) ((((r).cfp_rc[0]) >> 22) & 0x3ff)
#define BCM53262_A0_CFP_RCr_RESERVED_Rf_SET(r,f) (r).cfp_rc[0]=(((r).cfp_rc[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CFP_RC.
 */
#define BCM53262_A0_READ_CFP_RCr(u,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_RCr,(r._cfp_rc),4)
#define BCM53262_A0_WRITE_CFP_RCr(u,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_RCr,&(r._cfp_rc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_RCr BCM53262_A0_CFP_RCr
#define CFP_RCr_SIZE BCM53262_A0_CFP_RCr_SIZE
typedef BCM53262_A0_CFP_RCr_t CFP_RCr_t;
#define CFP_RCr_CLR BCM53262_A0_CFP_RCr_CLR
#define CFP_RCr_SET BCM53262_A0_CFP_RCr_SET
#define CFP_RCr_GET BCM53262_A0_CFP_RCr_GET
#define CFP_RCr_RFSHCNTf_GET BCM53262_A0_CFP_RCr_RFSHCNTf_GET
#define CFP_RCr_RFSHCNTf_SET BCM53262_A0_CFP_RCr_RFSHCNTf_SET
#define CFP_RCr_RFSHUNITf_GET BCM53262_A0_CFP_RCr_RFSHUNITf_GET
#define CFP_RCr_RFSHUNITf_SET BCM53262_A0_CFP_RCr_RFSHUNITf_SET
#define CFP_RCr_BKTSIZEf_GET BCM53262_A0_CFP_RCr_BKTSIZEf_GET
#define CFP_RCr_BKTSIZEf_SET BCM53262_A0_CFP_RCr_BKTSIZEf_SET
#define CFP_RCr_RESERVED_Rf_GET BCM53262_A0_CFP_RCr_RESERVED_Rf_GET
#define CFP_RCr_RESERVED_Rf_SET BCM53262_A0_CFP_RCr_RESERVED_Rf_SET
#define READ_CFP_RCr BCM53262_A0_READ_CFP_RCr
#define WRITE_CFP_RCr BCM53262_A0_WRITE_CFP_RCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_RCr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_STAT_IB
 * BLOCKS:   SYS
 * DESC:     Statistic RAM
 * SIZE:     32
 * FIELDS:
 *     IN_BAND_CNT      In band counter
 */
#define BCM53262_A0_CFP_STAT_IBm 0x00005a00

#define BCM53262_A0_CFP_STAT_IBm_MIN 0
#define BCM53262_A0_CFP_STAT_IBm_MAX 1023
#define BCM53262_A0_CFP_STAT_IBm_CMAX(u) 1023
#define BCM53262_A0_CFP_STAT_IBm_SIZE 4

/*
 * This structure should be used to declare and program CFP_STAT_IB.
 */
typedef union BCM53262_A0_CFP_STAT_IBm_s {
	uint32_t v[1];
	uint32_t cfp_stat_ib[1];
	uint32_t _cfp_stat_ib;
} BCM53262_A0_CFP_STAT_IBm_t;

#define BCM53262_A0_CFP_STAT_IBm_CLR(r) (r).cfp_stat_ib[0] = 0
#define BCM53262_A0_CFP_STAT_IBm_SET(r,d) (r).cfp_stat_ib[0] = d
#define BCM53262_A0_CFP_STAT_IBm_GET(r) (r).cfp_stat_ib[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_STAT_IBm_IN_BAND_CNTf_GET(r) ((r).cfp_stat_ib[0])
#define BCM53262_A0_CFP_STAT_IBm_IN_BAND_CNTf_SET(r,f) (r).cfp_stat_ib[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_STAT_IB.
 */
#define BCM53262_A0_READ_CFP_STAT_IBm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_STAT_IBm,i,(m),4)
#define BCM53262_A0_WRITE_CFP_STAT_IBm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_STAT_IBm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_STAT_IBm BCM53262_A0_CFP_STAT_IBm
#define CFP_STAT_IBm_MIN BCM53262_A0_CFP_STAT_IBm_MIN
#define CFP_STAT_IBm_MAX BCM53262_A0_CFP_STAT_IBm_MAX
#define CFP_STAT_IBm_CMAX(u) BCM53262_A0_CFP_STAT_IBm_CMAX(u)
#define CFP_STAT_IBm_SIZE BCM53262_A0_CFP_STAT_IBm_SIZE
typedef BCM53262_A0_CFP_STAT_IBm_t CFP_STAT_IBm_t;
#define CFP_STAT_IBm_CLR BCM53262_A0_CFP_STAT_IBm_CLR
#define CFP_STAT_IBm_SET BCM53262_A0_CFP_STAT_IBm_SET
#define CFP_STAT_IBm_GET BCM53262_A0_CFP_STAT_IBm_GET
#define CFP_STAT_IBm_IN_BAND_CNTf_GET BCM53262_A0_CFP_STAT_IBm_IN_BAND_CNTf_GET
#define CFP_STAT_IBm_IN_BAND_CNTf_SET BCM53262_A0_CFP_STAT_IBm_IN_BAND_CNTf_SET
#define READ_CFP_STAT_IBm BCM53262_A0_READ_CFP_STAT_IBm
#define WRITE_CFP_STAT_IBm BCM53262_A0_WRITE_CFP_STAT_IBm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_STAT_IBm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_STAT_OB
 * BLOCKS:   SYS
 * DESC:     Statistic RAM
 * SIZE:     32
 * FIELDS:
 *     OUT_BAND_CNT     Out band counter
 */
#define BCM53262_A0_CFP_STAT_OBm 0x00005600

#define BCM53262_A0_CFP_STAT_OBm_MIN 0
#define BCM53262_A0_CFP_STAT_OBm_MAX 1023
#define BCM53262_A0_CFP_STAT_OBm_CMAX(u) 1023
#define BCM53262_A0_CFP_STAT_OBm_SIZE 4

/*
 * This structure should be used to declare and program CFP_STAT_OB.
 */
typedef union BCM53262_A0_CFP_STAT_OBm_s {
	uint32_t v[1];
	uint32_t cfp_stat_ob[1];
	uint32_t _cfp_stat_ob;
} BCM53262_A0_CFP_STAT_OBm_t;

#define BCM53262_A0_CFP_STAT_OBm_CLR(r) (r).cfp_stat_ob[0] = 0
#define BCM53262_A0_CFP_STAT_OBm_SET(r,d) (r).cfp_stat_ob[0] = d
#define BCM53262_A0_CFP_STAT_OBm_GET(r) (r).cfp_stat_ob[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_STAT_OBm_OUT_BAND_CNTf_GET(r) ((r).cfp_stat_ob[0])
#define BCM53262_A0_CFP_STAT_OBm_OUT_BAND_CNTf_SET(r,f) (r).cfp_stat_ob[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_STAT_OB.
 */
#define BCM53262_A0_READ_CFP_STAT_OBm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_STAT_OBm,i,(m),4)
#define BCM53262_A0_WRITE_CFP_STAT_OBm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_STAT_OBm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_STAT_OBm BCM53262_A0_CFP_STAT_OBm
#define CFP_STAT_OBm_MIN BCM53262_A0_CFP_STAT_OBm_MIN
#define CFP_STAT_OBm_MAX BCM53262_A0_CFP_STAT_OBm_MAX
#define CFP_STAT_OBm_CMAX(u) BCM53262_A0_CFP_STAT_OBm_CMAX(u)
#define CFP_STAT_OBm_SIZE BCM53262_A0_CFP_STAT_OBm_SIZE
typedef BCM53262_A0_CFP_STAT_OBm_t CFP_STAT_OBm_t;
#define CFP_STAT_OBm_CLR BCM53262_A0_CFP_STAT_OBm_CLR
#define CFP_STAT_OBm_SET BCM53262_A0_CFP_STAT_OBm_SET
#define CFP_STAT_OBm_GET BCM53262_A0_CFP_STAT_OBm_GET
#define CFP_STAT_OBm_OUT_BAND_CNTf_GET BCM53262_A0_CFP_STAT_OBm_OUT_BAND_CNTf_GET
#define CFP_STAT_OBm_OUT_BAND_CNTf_SET BCM53262_A0_CFP_STAT_OBm_OUT_BAND_CNTf_SET
#define READ_CFP_STAT_OBm BCM53262_A0_READ_CFP_STAT_OBm
#define WRITE_CFP_STAT_OBm BCM53262_A0_WRITE_CFP_STAT_OBm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_STAT_OBm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_TCAM_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     384
 * FIELDS:
 *     SLICEID          Slice ID
 *     IN_PBMP          Ingress port map
 *     SPTAGGED         Service tagged frame
 *     VLANTAGGED       802.1Q tagged frame
 *     L2_FORMAT        Select L2 frame format
 *     L3_FORMAT        Select L3 frame format
 *     L4_FORMAT        Select L4 frame format
 *     VLAN_RANGE       VLAN range
 *     L4_PORT_RANGE    L4 port range
 *     MAC_DA           Destination MAC address
 *     MAC_SA           Source MAC address
 *     SP_VID           Service provider tag VID
 *     SP_CFI           Service provider tag CFI
 *     SP_PRI           Service provider tag priority
 *     USR_VID          User tag VID
 *     USR_CFI          User tag CFI
 *     USR_PRI          User tag priority
 *     ETYPE            Ether Type
 *     IP6_FLOW_ID      IPv6 flow ID(20)
 *     IP6_SA           IPv6 SA(44)
 *     IP4TOS_IP6TRAFFICCLASS IPv4 TOS / IPv6 Traffic Class)
 *     IP4PROTOCOL_IP6NEXTHEADER IPv4 protocol / IPv6 Next Header
 *     IP4TTL_IP6HOPLIMIT IPv4 header 8 bit time to live / IPv6 HopLimit
 *     SAMEIPADDR       IP_SA is the same with IP_DA
 *     L4DST            Destination UDP/TCP port number
 *     ICMPIGMP_TYPECODE ICMP/IGMP type/code
 *     TCP_FLAG         TCP flags
 *     SAMEL4PORT       L4SRC is the same with L4DST
 *     L4SRC_LESS_1024  L4 source port less than 1024
 *     TCP_SEQUENCE_ZERO TCP sequence number equal to zero
 *     TCPHEADER_BIGICMP_CHK Min TCP header length / Big ICMP check
 *     UDFA0            User define field A0
 *     UDFA0_VLD        User define field A0 valid
 *     UDFA1            User define field A1
 *     UDFA1_VLD        User define field A1 valid
 *     UDFA2            User define field A2
 *     UDFA2_VLD        User define field A2 valid
 *     RESVD            Reserved
 *     VALID_R          Valid bits
 */
#define BCM53262_A0_CFP_TCAM_MASKm 0x00005e00

#define BCM53262_A0_CFP_TCAM_MASKm_MIN 0
#define BCM53262_A0_CFP_TCAM_MASKm_MAX 1023
#define BCM53262_A0_CFP_TCAM_MASKm_CMAX(u) 1023
#define BCM53262_A0_CFP_TCAM_MASKm_SIZE 48

/*
 * This structure should be used to declare and program CFP_TCAM_MASK.
 */
typedef union BCM53262_A0_CFP_TCAM_MASKm_s {
	uint32_t v[12];
	uint32_t cfp_tcam_mask[12];
	uint32_t _cfp_tcam_mask;
} BCM53262_A0_CFP_TCAM_MASKm_t;

#define BCM53262_A0_CFP_TCAM_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_mask), 0, sizeof(BCM53262_A0_CFP_TCAM_MASKm_t))
#define BCM53262_A0_CFP_TCAM_MASKm_SET(r,i,d) (r).cfp_tcam_mask[i] = d
#define BCM53262_A0_CFP_TCAM_MASKm_GET(r,i) (r).cfp_tcam_mask[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_TCAM_MASKm_SLICEIDf_GET(r) (((r).cfp_tcam_mask[0]) & 0x3)
#define BCM53262_A0_CFP_TCAM_MASKm_SLICEIDf_SET(r,f) (r).cfp_tcam_mask[0]=(((r).cfp_tcam_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_CFP_TCAM_MASKm_IN_PBMPf_GET(r) ((((r).cfp_tcam_mask[0]) >> 2) & 0x1fffffff)
#define BCM53262_A0_CFP_TCAM_MASKm_IN_PBMPf_SET(r,f) (r).cfp_tcam_mask[0]=(((r).cfp_tcam_mask[0] & ~((uint32_t)0x1fffffff << 2)) | ((((uint32_t)f) & 0x1fffffff) << 2))
#define BCM53262_A0_CFP_TCAM_MASKm_SPTAGGEDf_GET(r) ((((r).cfp_tcam_mask[0]) >> 31) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_SPTAGGEDf_SET(r,f) (r).cfp_tcam_mask[0]=(((r).cfp_tcam_mask[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53262_A0_CFP_TCAM_MASKm_VLANTAGGEDf_GET(r) (((r).cfp_tcam_mask[1]) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_VLANTAGGEDf_SET(r,f) (r).cfp_tcam_mask[1]=(((r).cfp_tcam_mask[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_CFP_TCAM_MASKm_L2_FORMATf_GET(r) ((((r).cfp_tcam_mask[1]) >> 1) & 0x3)
#define BCM53262_A0_CFP_TCAM_MASKm_L2_FORMATf_SET(r,f) (r).cfp_tcam_mask[1]=(((r).cfp_tcam_mask[1] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53262_A0_CFP_TCAM_MASKm_L3_FORMATf_GET(r) ((((r).cfp_tcam_mask[1]) >> 3) & 0x3)
#define BCM53262_A0_CFP_TCAM_MASKm_L3_FORMATf_SET(r,f) (r).cfp_tcam_mask[1]=(((r).cfp_tcam_mask[1] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53262_A0_CFP_TCAM_MASKm_L4_FORMATf_GET(r) ((((r).cfp_tcam_mask[1]) >> 5) & 0x3)
#define BCM53262_A0_CFP_TCAM_MASKm_L4_FORMATf_SET(r,f) (r).cfp_tcam_mask[1]=(((r).cfp_tcam_mask[1] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53262_A0_CFP_TCAM_MASKm_VLAN_RANGEf_GET(r) ((((r).cfp_tcam_mask[1]) >> 7) & 0xf)
#define BCM53262_A0_CFP_TCAM_MASKm_VLAN_RANGEf_SET(r,f) (r).cfp_tcam_mask[1]=(((r).cfp_tcam_mask[1] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53262_A0_CFP_TCAM_MASKm_L4_PORT_RANGEf_GET(r) ((((r).cfp_tcam_mask[1]) >> 11) & 0xf)
#define BCM53262_A0_CFP_TCAM_MASKm_L4_PORT_RANGEf_SET(r,f) (r).cfp_tcam_mask[1]=(((r).cfp_tcam_mask[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53262_A0_CFP_TCAM_MASKm_MAC_DAf_GET(r,a) cdk_field_get((r).cfp_tcam_mask,47,94,a)
#define BCM53262_A0_CFP_TCAM_MASKm_MAC_DAf_SET(r,a) cdk_field_set((r).cfp_tcam_mask,47,94,a)
#define BCM53262_A0_CFP_TCAM_MASKm_MAC_SAf_GET(r,a) cdk_field_get((r).cfp_tcam_mask,95,142,a)
#define BCM53262_A0_CFP_TCAM_MASKm_MAC_SAf_SET(r,a) cdk_field_set((r).cfp_tcam_mask,95,142,a)
#define BCM53262_A0_CFP_TCAM_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_mask[4]) >> 15) & 0xfff)
#define BCM53262_A0_CFP_TCAM_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_mask[4]=(((r).cfp_tcam_mask[4] & ~((uint32_t)0xfff << 15)) | ((((uint32_t)f) & 0xfff) << 15))
#define BCM53262_A0_CFP_TCAM_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_mask[4]) >> 27) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_mask[4]=(((r).cfp_tcam_mask[4] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_CFP_TCAM_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_mask[4]) >> 28) & 0x7)
#define BCM53262_A0_CFP_TCAM_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_mask[4]=(((r).cfp_tcam_mask[4] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53262_A0_CFP_TCAM_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_mask,159,170)
#define BCM53262_A0_CFP_TCAM_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,159,170,f)
#define BCM53262_A0_CFP_TCAM_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_mask[5]) >> 11) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_mask[5]=(((r).cfp_tcam_mask[5] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_CFP_TCAM_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_mask[5]) >> 12) & 0x7)
#define BCM53262_A0_CFP_TCAM_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_mask[5]=(((r).cfp_tcam_mask[5] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_CFP_TCAM_MASKm_ETYPEf_GET(r) ((((r).cfp_tcam_mask[5]) >> 15) & 0xffff)
#define BCM53262_A0_CFP_TCAM_MASKm_ETYPEf_SET(r,f) (r).cfp_tcam_mask[5]=(((r).cfp_tcam_mask[5] & ~((uint32_t)0xffff << 15)) | ((((uint32_t)f) & 0xffff) << 15))
#define BCM53262_A0_CFP_TCAM_MASKm_IP6_FLOW_IDf_GET(r) cdk_field32_get((r).cfp_tcam_mask,191,210)
#define BCM53262_A0_CFP_TCAM_MASKm_IP6_FLOW_IDf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,191,210,f)
#define BCM53262_A0_CFP_TCAM_MASKm_IP6_SAf_GET(r,a) cdk_field_get((r).cfp_tcam_mask,211,254,a)
#define BCM53262_A0_CFP_TCAM_MASKm_IP6_SAf_SET(r,a) cdk_field_set((r).cfp_tcam_mask,211,254,a)
#define BCM53262_A0_CFP_TCAM_MASKm_IP4TOS_IP6TRAFFICCLASSf_GET(r) cdk_field32_get((r).cfp_tcam_mask,255,262)
#define BCM53262_A0_CFP_TCAM_MASKm_IP4TOS_IP6TRAFFICCLASSf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,255,262,f)
#define BCM53262_A0_CFP_TCAM_MASKm_IP4PROTOCOL_IP6NEXTHEADERf_GET(r) ((((r).cfp_tcam_mask[8]) >> 7) & 0xff)
#define BCM53262_A0_CFP_TCAM_MASKm_IP4PROTOCOL_IP6NEXTHEADERf_SET(r,f) (r).cfp_tcam_mask[8]=(((r).cfp_tcam_mask[8] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7))
#define BCM53262_A0_CFP_TCAM_MASKm_IP4TTL_IP6HOPLIMITf_GET(r) ((((r).cfp_tcam_mask[8]) >> 15) & 0x3)
#define BCM53262_A0_CFP_TCAM_MASKm_IP4TTL_IP6HOPLIMITf_SET(r,f) (r).cfp_tcam_mask[8]=(((r).cfp_tcam_mask[8] & ~((uint32_t)0x3 << 15)) | ((((uint32_t)f) & 0x3) << 15))
#define BCM53262_A0_CFP_TCAM_MASKm_SAMEIPADDRf_GET(r) ((((r).cfp_tcam_mask[8]) >> 17) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_SAMEIPADDRf_SET(r,f) (r).cfp_tcam_mask[8]=(((r).cfp_tcam_mask[8] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53262_A0_CFP_TCAM_MASKm_L4DSTf_GET(r) cdk_field32_get((r).cfp_tcam_mask,274,289)
#define BCM53262_A0_CFP_TCAM_MASKm_L4DSTf_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,274,289,f)
#define BCM53262_A0_CFP_TCAM_MASKm_ICMPIGMP_TYPECODEf_GET(r) ((((r).cfp_tcam_mask[9]) >> 2) & 0xffff)
#define BCM53262_A0_CFP_TCAM_MASKm_ICMPIGMP_TYPECODEf_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53262_A0_CFP_TCAM_MASKm_TCP_FLAGf_GET(r) ((((r).cfp_tcam_mask[9]) >> 18) & 0x3f)
#define BCM53262_A0_CFP_TCAM_MASKm_TCP_FLAGf_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53262_A0_CFP_TCAM_MASKm_SAMEL4PORTf_GET(r) ((((r).cfp_tcam_mask[9]) >> 24) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_SAMEL4PORTf_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53262_A0_CFP_TCAM_MASKm_L4SRC_LESS_1024f_GET(r) ((((r).cfp_tcam_mask[9]) >> 25) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_L4SRC_LESS_1024f_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53262_A0_CFP_TCAM_MASKm_TCP_SEQUENCE_ZEROf_GET(r) ((((r).cfp_tcam_mask[9]) >> 26) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_TCP_SEQUENCE_ZEROf_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53262_A0_CFP_TCAM_MASKm_TCPHEADER_BIGICMP_CHKf_GET(r) ((((r).cfp_tcam_mask[9]) >> 27) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_TCPHEADER_BIGICMP_CHKf_SET(r,f) (r).cfp_tcam_mask[9]=(((r).cfp_tcam_mask[9] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA0f_GET(r) cdk_field32_get((r).cfp_tcam_mask,316,331)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA0f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,316,331,f)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA0_VLDf_GET(r) ((((r).cfp_tcam_mask[10]) >> 12) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA0_VLDf_SET(r,f) (r).cfp_tcam_mask[10]=(((r).cfp_tcam_mask[10] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA1f_GET(r) ((((r).cfp_tcam_mask[10]) >> 13) & 0xffff)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA1f_SET(r,f) (r).cfp_tcam_mask[10]=(((r).cfp_tcam_mask[10] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA1_VLDf_GET(r) ((((r).cfp_tcam_mask[10]) >> 29) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA1_VLDf_SET(r,f) (r).cfp_tcam_mask[10]=(((r).cfp_tcam_mask[10] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA2f_GET(r) cdk_field32_get((r).cfp_tcam_mask,350,365)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA2f_SET(r,f) cdk_field32_set((r).cfp_tcam_mask,350,365,f)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA2_VLDf_GET(r) ((((r).cfp_tcam_mask[11]) >> 14) & 0x1)
#define BCM53262_A0_CFP_TCAM_MASKm_UDFA2_VLDf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_CFP_TCAM_MASKm_RESVDf_GET(r) ((((r).cfp_tcam_mask[11]) >> 15) & 0x1fff)
#define BCM53262_A0_CFP_TCAM_MASKm_RESVDf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0x1fff << 15)) | ((((uint32_t)f) & 0x1fff) << 15))
#define BCM53262_A0_CFP_TCAM_MASKm_VALID_Rf_GET(r) ((((r).cfp_tcam_mask[11]) >> 28) & 0xf)
#define BCM53262_A0_CFP_TCAM_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_mask[11]=(((r).cfp_tcam_mask[11] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CFP_TCAM_MASK.
 */
#define BCM53262_A0_READ_CFP_TCAM_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_TCAM_MASKm,i,(m),48)
#define BCM53262_A0_WRITE_CFP_TCAM_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_TCAM_MASKm,i,&(m),48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_MASKm BCM53262_A0_CFP_TCAM_MASKm
#define CFP_TCAM_MASKm_MIN BCM53262_A0_CFP_TCAM_MASKm_MIN
#define CFP_TCAM_MASKm_MAX BCM53262_A0_CFP_TCAM_MASKm_MAX
#define CFP_TCAM_MASKm_CMAX(u) BCM53262_A0_CFP_TCAM_MASKm_CMAX(u)
#define CFP_TCAM_MASKm_SIZE BCM53262_A0_CFP_TCAM_MASKm_SIZE
typedef BCM53262_A0_CFP_TCAM_MASKm_t CFP_TCAM_MASKm_t;
#define CFP_TCAM_MASKm_CLR BCM53262_A0_CFP_TCAM_MASKm_CLR
#define CFP_TCAM_MASKm_SET BCM53262_A0_CFP_TCAM_MASKm_SET
#define CFP_TCAM_MASKm_GET BCM53262_A0_CFP_TCAM_MASKm_GET
#define CFP_TCAM_MASKm_SLICEIDf_GET BCM53262_A0_CFP_TCAM_MASKm_SLICEIDf_GET
#define CFP_TCAM_MASKm_SLICEIDf_SET BCM53262_A0_CFP_TCAM_MASKm_SLICEIDf_SET
#define CFP_TCAM_MASKm_IN_PBMPf_GET BCM53262_A0_CFP_TCAM_MASKm_IN_PBMPf_GET
#define CFP_TCAM_MASKm_IN_PBMPf_SET BCM53262_A0_CFP_TCAM_MASKm_IN_PBMPf_SET
#define CFP_TCAM_MASKm_SPTAGGEDf_GET BCM53262_A0_CFP_TCAM_MASKm_SPTAGGEDf_GET
#define CFP_TCAM_MASKm_SPTAGGEDf_SET BCM53262_A0_CFP_TCAM_MASKm_SPTAGGEDf_SET
#define CFP_TCAM_MASKm_VLANTAGGEDf_GET BCM53262_A0_CFP_TCAM_MASKm_VLANTAGGEDf_GET
#define CFP_TCAM_MASKm_VLANTAGGEDf_SET BCM53262_A0_CFP_TCAM_MASKm_VLANTAGGEDf_SET
#define CFP_TCAM_MASKm_L2_FORMATf_GET BCM53262_A0_CFP_TCAM_MASKm_L2_FORMATf_GET
#define CFP_TCAM_MASKm_L2_FORMATf_SET BCM53262_A0_CFP_TCAM_MASKm_L2_FORMATf_SET
#define CFP_TCAM_MASKm_L3_FORMATf_GET BCM53262_A0_CFP_TCAM_MASKm_L3_FORMATf_GET
#define CFP_TCAM_MASKm_L3_FORMATf_SET BCM53262_A0_CFP_TCAM_MASKm_L3_FORMATf_SET
#define CFP_TCAM_MASKm_L4_FORMATf_GET BCM53262_A0_CFP_TCAM_MASKm_L4_FORMATf_GET
#define CFP_TCAM_MASKm_L4_FORMATf_SET BCM53262_A0_CFP_TCAM_MASKm_L4_FORMATf_SET
#define CFP_TCAM_MASKm_VLAN_RANGEf_GET BCM53262_A0_CFP_TCAM_MASKm_VLAN_RANGEf_GET
#define CFP_TCAM_MASKm_VLAN_RANGEf_SET BCM53262_A0_CFP_TCAM_MASKm_VLAN_RANGEf_SET
#define CFP_TCAM_MASKm_L4_PORT_RANGEf_GET BCM53262_A0_CFP_TCAM_MASKm_L4_PORT_RANGEf_GET
#define CFP_TCAM_MASKm_L4_PORT_RANGEf_SET BCM53262_A0_CFP_TCAM_MASKm_L4_PORT_RANGEf_SET
#define CFP_TCAM_MASKm_MAC_DAf_GET BCM53262_A0_CFP_TCAM_MASKm_MAC_DAf_GET
#define CFP_TCAM_MASKm_MAC_DAf_SET BCM53262_A0_CFP_TCAM_MASKm_MAC_DAf_SET
#define CFP_TCAM_MASKm_MAC_SAf_GET BCM53262_A0_CFP_TCAM_MASKm_MAC_SAf_GET
#define CFP_TCAM_MASKm_MAC_SAf_SET BCM53262_A0_CFP_TCAM_MASKm_MAC_SAf_SET
#define CFP_TCAM_MASKm_SP_VIDf_GET BCM53262_A0_CFP_TCAM_MASKm_SP_VIDf_GET
#define CFP_TCAM_MASKm_SP_VIDf_SET BCM53262_A0_CFP_TCAM_MASKm_SP_VIDf_SET
#define CFP_TCAM_MASKm_SP_CFIf_GET BCM53262_A0_CFP_TCAM_MASKm_SP_CFIf_GET
#define CFP_TCAM_MASKm_SP_CFIf_SET BCM53262_A0_CFP_TCAM_MASKm_SP_CFIf_SET
#define CFP_TCAM_MASKm_SP_PRIf_GET BCM53262_A0_CFP_TCAM_MASKm_SP_PRIf_GET
#define CFP_TCAM_MASKm_SP_PRIf_SET BCM53262_A0_CFP_TCAM_MASKm_SP_PRIf_SET
#define CFP_TCAM_MASKm_USR_VIDf_GET BCM53262_A0_CFP_TCAM_MASKm_USR_VIDf_GET
#define CFP_TCAM_MASKm_USR_VIDf_SET BCM53262_A0_CFP_TCAM_MASKm_USR_VIDf_SET
#define CFP_TCAM_MASKm_USR_CFIf_GET BCM53262_A0_CFP_TCAM_MASKm_USR_CFIf_GET
#define CFP_TCAM_MASKm_USR_CFIf_SET BCM53262_A0_CFP_TCAM_MASKm_USR_CFIf_SET
#define CFP_TCAM_MASKm_USR_PRIf_GET BCM53262_A0_CFP_TCAM_MASKm_USR_PRIf_GET
#define CFP_TCAM_MASKm_USR_PRIf_SET BCM53262_A0_CFP_TCAM_MASKm_USR_PRIf_SET
#define CFP_TCAM_MASKm_ETYPEf_GET BCM53262_A0_CFP_TCAM_MASKm_ETYPEf_GET
#define CFP_TCAM_MASKm_ETYPEf_SET BCM53262_A0_CFP_TCAM_MASKm_ETYPEf_SET
#define CFP_TCAM_MASKm_IP6_FLOW_IDf_GET BCM53262_A0_CFP_TCAM_MASKm_IP6_FLOW_IDf_GET
#define CFP_TCAM_MASKm_IP6_FLOW_IDf_SET BCM53262_A0_CFP_TCAM_MASKm_IP6_FLOW_IDf_SET
#define CFP_TCAM_MASKm_IP6_SAf_GET BCM53262_A0_CFP_TCAM_MASKm_IP6_SAf_GET
#define CFP_TCAM_MASKm_IP6_SAf_SET BCM53262_A0_CFP_TCAM_MASKm_IP6_SAf_SET
#define CFP_TCAM_MASKm_IP4TOS_IP6TRAFFICCLASSf_GET BCM53262_A0_CFP_TCAM_MASKm_IP4TOS_IP6TRAFFICCLASSf_GET
#define CFP_TCAM_MASKm_IP4TOS_IP6TRAFFICCLASSf_SET BCM53262_A0_CFP_TCAM_MASKm_IP4TOS_IP6TRAFFICCLASSf_SET
#define CFP_TCAM_MASKm_IP4PROTOCOL_IP6NEXTHEADERf_GET BCM53262_A0_CFP_TCAM_MASKm_IP4PROTOCOL_IP6NEXTHEADERf_GET
#define CFP_TCAM_MASKm_IP4PROTOCOL_IP6NEXTHEADERf_SET BCM53262_A0_CFP_TCAM_MASKm_IP4PROTOCOL_IP6NEXTHEADERf_SET
#define CFP_TCAM_MASKm_IP4TTL_IP6HOPLIMITf_GET BCM53262_A0_CFP_TCAM_MASKm_IP4TTL_IP6HOPLIMITf_GET
#define CFP_TCAM_MASKm_IP4TTL_IP6HOPLIMITf_SET BCM53262_A0_CFP_TCAM_MASKm_IP4TTL_IP6HOPLIMITf_SET
#define CFP_TCAM_MASKm_SAMEIPADDRf_GET BCM53262_A0_CFP_TCAM_MASKm_SAMEIPADDRf_GET
#define CFP_TCAM_MASKm_SAMEIPADDRf_SET BCM53262_A0_CFP_TCAM_MASKm_SAMEIPADDRf_SET
#define CFP_TCAM_MASKm_L4DSTf_GET BCM53262_A0_CFP_TCAM_MASKm_L4DSTf_GET
#define CFP_TCAM_MASKm_L4DSTf_SET BCM53262_A0_CFP_TCAM_MASKm_L4DSTf_SET
#define CFP_TCAM_MASKm_ICMPIGMP_TYPECODEf_GET BCM53262_A0_CFP_TCAM_MASKm_ICMPIGMP_TYPECODEf_GET
#define CFP_TCAM_MASKm_ICMPIGMP_TYPECODEf_SET BCM53262_A0_CFP_TCAM_MASKm_ICMPIGMP_TYPECODEf_SET
#define CFP_TCAM_MASKm_TCP_FLAGf_GET BCM53262_A0_CFP_TCAM_MASKm_TCP_FLAGf_GET
#define CFP_TCAM_MASKm_TCP_FLAGf_SET BCM53262_A0_CFP_TCAM_MASKm_TCP_FLAGf_SET
#define CFP_TCAM_MASKm_SAMEL4PORTf_GET BCM53262_A0_CFP_TCAM_MASKm_SAMEL4PORTf_GET
#define CFP_TCAM_MASKm_SAMEL4PORTf_SET BCM53262_A0_CFP_TCAM_MASKm_SAMEL4PORTf_SET
#define CFP_TCAM_MASKm_L4SRC_LESS_1024f_GET BCM53262_A0_CFP_TCAM_MASKm_L4SRC_LESS_1024f_GET
#define CFP_TCAM_MASKm_L4SRC_LESS_1024f_SET BCM53262_A0_CFP_TCAM_MASKm_L4SRC_LESS_1024f_SET
#define CFP_TCAM_MASKm_TCP_SEQUENCE_ZEROf_GET BCM53262_A0_CFP_TCAM_MASKm_TCP_SEQUENCE_ZEROf_GET
#define CFP_TCAM_MASKm_TCP_SEQUENCE_ZEROf_SET BCM53262_A0_CFP_TCAM_MASKm_TCP_SEQUENCE_ZEROf_SET
#define CFP_TCAM_MASKm_TCPHEADER_BIGICMP_CHKf_GET BCM53262_A0_CFP_TCAM_MASKm_TCPHEADER_BIGICMP_CHKf_GET
#define CFP_TCAM_MASKm_TCPHEADER_BIGICMP_CHKf_SET BCM53262_A0_CFP_TCAM_MASKm_TCPHEADER_BIGICMP_CHKf_SET
#define CFP_TCAM_MASKm_UDFA0f_GET BCM53262_A0_CFP_TCAM_MASKm_UDFA0f_GET
#define CFP_TCAM_MASKm_UDFA0f_SET BCM53262_A0_CFP_TCAM_MASKm_UDFA0f_SET
#define CFP_TCAM_MASKm_UDFA0_VLDf_GET BCM53262_A0_CFP_TCAM_MASKm_UDFA0_VLDf_GET
#define CFP_TCAM_MASKm_UDFA0_VLDf_SET BCM53262_A0_CFP_TCAM_MASKm_UDFA0_VLDf_SET
#define CFP_TCAM_MASKm_UDFA1f_GET BCM53262_A0_CFP_TCAM_MASKm_UDFA1f_GET
#define CFP_TCAM_MASKm_UDFA1f_SET BCM53262_A0_CFP_TCAM_MASKm_UDFA1f_SET
#define CFP_TCAM_MASKm_UDFA1_VLDf_GET BCM53262_A0_CFP_TCAM_MASKm_UDFA1_VLDf_GET
#define CFP_TCAM_MASKm_UDFA1_VLDf_SET BCM53262_A0_CFP_TCAM_MASKm_UDFA1_VLDf_SET
#define CFP_TCAM_MASKm_UDFA2f_GET BCM53262_A0_CFP_TCAM_MASKm_UDFA2f_GET
#define CFP_TCAM_MASKm_UDFA2f_SET BCM53262_A0_CFP_TCAM_MASKm_UDFA2f_SET
#define CFP_TCAM_MASKm_UDFA2_VLDf_GET BCM53262_A0_CFP_TCAM_MASKm_UDFA2_VLDf_GET
#define CFP_TCAM_MASKm_UDFA2_VLDf_SET BCM53262_A0_CFP_TCAM_MASKm_UDFA2_VLDf_SET
#define CFP_TCAM_MASKm_RESVDf_GET BCM53262_A0_CFP_TCAM_MASKm_RESVDf_GET
#define CFP_TCAM_MASKm_RESVDf_SET BCM53262_A0_CFP_TCAM_MASKm_RESVDf_SET
#define CFP_TCAM_MASKm_VALID_Rf_GET BCM53262_A0_CFP_TCAM_MASKm_VALID_Rf_GET
#define CFP_TCAM_MASKm_VALID_Rf_SET BCM53262_A0_CFP_TCAM_MASKm_VALID_Rf_SET
#define READ_CFP_TCAM_MASKm BCM53262_A0_READ_CFP_TCAM_MASKm
#define WRITE_CFP_TCAM_MASKm BCM53262_A0_WRITE_CFP_TCAM_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_TCAM_MASKm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_TCAM_S0
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     384
 * FIELDS:
 *     SLICEID          Slice ID
 *     IN_PBMP          Ingress port map
 *     SPTAGGED         Service tagged frame
 *     VLANTAGGED       802.1Q tagged frame
 *     L2_FORMAT        Select L2 frame format
 *     L3_FORMAT        Select L3 frame format
 *     L4_FORMAT        Select L4 frame format
 *     VLAN_RANGE       VLAN range
 *     L4_PORT_RANGE    L4 port range
 *     MAC_DA           Destination MAC address
 *     MAC_SA           Source MAC address
 *     SP_VID           Service provider tag VID
 *     SP_CFI           Service provider tag CFI
 *     SP_PRI           Service provider tag priority
 *     USR_VID          User tag VID
 *     USR_CFI          User tag CFI
 *     USR_PRI          User tag priority
 *     ETYPE            Ether Type
 *     IP6_FLOW_ID      IPv6 flow ID(20)
 *     IP6_SA           IPv6 SA(44)
 *     IP4TOS_IP6TRAFFICCLASS IPv4 TOS / IPv6 Traffic Class)
 *     IP4PROTOCOL_IP6NEXTHEADER IPv4 protocol / IPv6 Next Header
 *     IP4TTL_IP6HOPLIMIT IPv4 header 8 bit time to live / IPv6 HopLimit
 *     SAMEIPADDR       IP_SA is the same with IP_DA
 *     L4DST            Destination UDP/TCP port number
 *     ICMPIGMP_TYPECODE ICMP/IGMP type/code
 *     TCP_FLAG         TCP flags
 *     SAMEL4PORT       L4SRC is the same with L4DST
 *     L4SRC_LESS_1024  L4 source port less than 1024
 *     TCP_SEQUENCE_ZERO TCP sequence number equal to zero
 *     TCPHEADER_BIGICMP_CHK Min TCP header length / Big ICMP check
 *     UDFA0            User define field A0
 *     UDFA0_VLD        User define field A0 valid
 *     UDFA1            User define field A1
 *     UDFA1_VLD        User define field A1 valid
 *     UDFA2            User define field A2
 *     UDFA2_VLD        User define field A2 valid
 *     RESVD            Reserved
 *     VALID_R          Valid bits
 */
#define BCM53262_A0_CFP_TCAM_S0m 0x00004200

#define BCM53262_A0_CFP_TCAM_S0m_MIN 0
#define BCM53262_A0_CFP_TCAM_S0m_MAX 1023
#define BCM53262_A0_CFP_TCAM_S0m_CMAX(u) 1023
#define BCM53262_A0_CFP_TCAM_S0m_SIZE 48

/*
 * This structure should be used to declare and program CFP_TCAM_S0.
 */
typedef union BCM53262_A0_CFP_TCAM_S0m_s {
	uint32_t v[12];
	uint32_t cfp_tcam_s0[12];
	uint32_t _cfp_tcam_s0;
} BCM53262_A0_CFP_TCAM_S0m_t;

#define BCM53262_A0_CFP_TCAM_S0m_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_s0), 0, sizeof(BCM53262_A0_CFP_TCAM_S0m_t))
#define BCM53262_A0_CFP_TCAM_S0m_SET(r,i,d) (r).cfp_tcam_s0[i] = d
#define BCM53262_A0_CFP_TCAM_S0m_GET(r,i) (r).cfp_tcam_s0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_TCAM_S0m_SLICEIDf_GET(r) (((r).cfp_tcam_s0[0]) & 0x3)
#define BCM53262_A0_CFP_TCAM_S0m_SLICEIDf_SET(r,f) (r).cfp_tcam_s0[0]=(((r).cfp_tcam_s0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_CFP_TCAM_S0m_IN_PBMPf_GET(r) ((((r).cfp_tcam_s0[0]) >> 2) & 0x1fffffff)
#define BCM53262_A0_CFP_TCAM_S0m_IN_PBMPf_SET(r,f) (r).cfp_tcam_s0[0]=(((r).cfp_tcam_s0[0] & ~((uint32_t)0x1fffffff << 2)) | ((((uint32_t)f) & 0x1fffffff) << 2))
#define BCM53262_A0_CFP_TCAM_S0m_SPTAGGEDf_GET(r) ((((r).cfp_tcam_s0[0]) >> 31) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_SPTAGGEDf_SET(r,f) (r).cfp_tcam_s0[0]=(((r).cfp_tcam_s0[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53262_A0_CFP_TCAM_S0m_VLANTAGGEDf_GET(r) (((r).cfp_tcam_s0[1]) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_VLANTAGGEDf_SET(r,f) (r).cfp_tcam_s0[1]=(((r).cfp_tcam_s0[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_CFP_TCAM_S0m_L2_FORMATf_GET(r) ((((r).cfp_tcam_s0[1]) >> 1) & 0x3)
#define BCM53262_A0_CFP_TCAM_S0m_L2_FORMATf_SET(r,f) (r).cfp_tcam_s0[1]=(((r).cfp_tcam_s0[1] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53262_A0_CFP_TCAM_S0m_L3_FORMATf_GET(r) ((((r).cfp_tcam_s0[1]) >> 3) & 0x3)
#define BCM53262_A0_CFP_TCAM_S0m_L3_FORMATf_SET(r,f) (r).cfp_tcam_s0[1]=(((r).cfp_tcam_s0[1] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53262_A0_CFP_TCAM_S0m_L4_FORMATf_GET(r) ((((r).cfp_tcam_s0[1]) >> 5) & 0x3)
#define BCM53262_A0_CFP_TCAM_S0m_L4_FORMATf_SET(r,f) (r).cfp_tcam_s0[1]=(((r).cfp_tcam_s0[1] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53262_A0_CFP_TCAM_S0m_VLAN_RANGEf_GET(r) ((((r).cfp_tcam_s0[1]) >> 7) & 0xf)
#define BCM53262_A0_CFP_TCAM_S0m_VLAN_RANGEf_SET(r,f) (r).cfp_tcam_s0[1]=(((r).cfp_tcam_s0[1] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53262_A0_CFP_TCAM_S0m_L4_PORT_RANGEf_GET(r) ((((r).cfp_tcam_s0[1]) >> 11) & 0xf)
#define BCM53262_A0_CFP_TCAM_S0m_L4_PORT_RANGEf_SET(r,f) (r).cfp_tcam_s0[1]=(((r).cfp_tcam_s0[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53262_A0_CFP_TCAM_S0m_MAC_DAf_GET(r,a) cdk_field_get((r).cfp_tcam_s0,47,94,a)
#define BCM53262_A0_CFP_TCAM_S0m_MAC_DAf_SET(r,a) cdk_field_set((r).cfp_tcam_s0,47,94,a)
#define BCM53262_A0_CFP_TCAM_S0m_MAC_SAf_GET(r,a) cdk_field_get((r).cfp_tcam_s0,95,142,a)
#define BCM53262_A0_CFP_TCAM_S0m_MAC_SAf_SET(r,a) cdk_field_set((r).cfp_tcam_s0,95,142,a)
#define BCM53262_A0_CFP_TCAM_S0m_SP_VIDf_GET(r) ((((r).cfp_tcam_s0[4]) >> 15) & 0xfff)
#define BCM53262_A0_CFP_TCAM_S0m_SP_VIDf_SET(r,f) (r).cfp_tcam_s0[4]=(((r).cfp_tcam_s0[4] & ~((uint32_t)0xfff << 15)) | ((((uint32_t)f) & 0xfff) << 15))
#define BCM53262_A0_CFP_TCAM_S0m_SP_CFIf_GET(r) ((((r).cfp_tcam_s0[4]) >> 27) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_SP_CFIf_SET(r,f) (r).cfp_tcam_s0[4]=(((r).cfp_tcam_s0[4] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_CFP_TCAM_S0m_SP_PRIf_GET(r) ((((r).cfp_tcam_s0[4]) >> 28) & 0x7)
#define BCM53262_A0_CFP_TCAM_S0m_SP_PRIf_SET(r,f) (r).cfp_tcam_s0[4]=(((r).cfp_tcam_s0[4] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53262_A0_CFP_TCAM_S0m_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_s0,159,170)
#define BCM53262_A0_CFP_TCAM_S0m_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_s0,159,170,f)
#define BCM53262_A0_CFP_TCAM_S0m_USR_CFIf_GET(r) ((((r).cfp_tcam_s0[5]) >> 11) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_USR_CFIf_SET(r,f) (r).cfp_tcam_s0[5]=(((r).cfp_tcam_s0[5] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_CFP_TCAM_S0m_USR_PRIf_GET(r) ((((r).cfp_tcam_s0[5]) >> 12) & 0x7)
#define BCM53262_A0_CFP_TCAM_S0m_USR_PRIf_SET(r,f) (r).cfp_tcam_s0[5]=(((r).cfp_tcam_s0[5] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_CFP_TCAM_S0m_ETYPEf_GET(r) ((((r).cfp_tcam_s0[5]) >> 15) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S0m_ETYPEf_SET(r,f) (r).cfp_tcam_s0[5]=(((r).cfp_tcam_s0[5] & ~((uint32_t)0xffff << 15)) | ((((uint32_t)f) & 0xffff) << 15))
#define BCM53262_A0_CFP_TCAM_S0m_IP6_FLOW_IDf_GET(r) cdk_field32_get((r).cfp_tcam_s0,191,210)
#define BCM53262_A0_CFP_TCAM_S0m_IP6_FLOW_IDf_SET(r,f) cdk_field32_set((r).cfp_tcam_s0,191,210,f)
#define BCM53262_A0_CFP_TCAM_S0m_IP6_SAf_GET(r,a) cdk_field_get((r).cfp_tcam_s0,211,254,a)
#define BCM53262_A0_CFP_TCAM_S0m_IP6_SAf_SET(r,a) cdk_field_set((r).cfp_tcam_s0,211,254,a)
#define BCM53262_A0_CFP_TCAM_S0m_IP4TOS_IP6TRAFFICCLASSf_GET(r) cdk_field32_get((r).cfp_tcam_s0,255,262)
#define BCM53262_A0_CFP_TCAM_S0m_IP4TOS_IP6TRAFFICCLASSf_SET(r,f) cdk_field32_set((r).cfp_tcam_s0,255,262,f)
#define BCM53262_A0_CFP_TCAM_S0m_IP4PROTOCOL_IP6NEXTHEADERf_GET(r) ((((r).cfp_tcam_s0[8]) >> 7) & 0xff)
#define BCM53262_A0_CFP_TCAM_S0m_IP4PROTOCOL_IP6NEXTHEADERf_SET(r,f) (r).cfp_tcam_s0[8]=(((r).cfp_tcam_s0[8] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7))
#define BCM53262_A0_CFP_TCAM_S0m_IP4TTL_IP6HOPLIMITf_GET(r) ((((r).cfp_tcam_s0[8]) >> 15) & 0x3)
#define BCM53262_A0_CFP_TCAM_S0m_IP4TTL_IP6HOPLIMITf_SET(r,f) (r).cfp_tcam_s0[8]=(((r).cfp_tcam_s0[8] & ~((uint32_t)0x3 << 15)) | ((((uint32_t)f) & 0x3) << 15))
#define BCM53262_A0_CFP_TCAM_S0m_SAMEIPADDRf_GET(r) ((((r).cfp_tcam_s0[8]) >> 17) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_SAMEIPADDRf_SET(r,f) (r).cfp_tcam_s0[8]=(((r).cfp_tcam_s0[8] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53262_A0_CFP_TCAM_S0m_L4DSTf_GET(r) cdk_field32_get((r).cfp_tcam_s0,274,289)
#define BCM53262_A0_CFP_TCAM_S0m_L4DSTf_SET(r,f) cdk_field32_set((r).cfp_tcam_s0,274,289,f)
#define BCM53262_A0_CFP_TCAM_S0m_ICMPIGMP_TYPECODEf_GET(r) ((((r).cfp_tcam_s0[9]) >> 2) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S0m_ICMPIGMP_TYPECODEf_SET(r,f) (r).cfp_tcam_s0[9]=(((r).cfp_tcam_s0[9] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53262_A0_CFP_TCAM_S0m_TCP_FLAGf_GET(r) ((((r).cfp_tcam_s0[9]) >> 18) & 0x3f)
#define BCM53262_A0_CFP_TCAM_S0m_TCP_FLAGf_SET(r,f) (r).cfp_tcam_s0[9]=(((r).cfp_tcam_s0[9] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53262_A0_CFP_TCAM_S0m_SAMEL4PORTf_GET(r) ((((r).cfp_tcam_s0[9]) >> 24) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_SAMEL4PORTf_SET(r,f) (r).cfp_tcam_s0[9]=(((r).cfp_tcam_s0[9] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53262_A0_CFP_TCAM_S0m_L4SRC_LESS_1024f_GET(r) ((((r).cfp_tcam_s0[9]) >> 25) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_L4SRC_LESS_1024f_SET(r,f) (r).cfp_tcam_s0[9]=(((r).cfp_tcam_s0[9] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53262_A0_CFP_TCAM_S0m_TCP_SEQUENCE_ZEROf_GET(r) ((((r).cfp_tcam_s0[9]) >> 26) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_TCP_SEQUENCE_ZEROf_SET(r,f) (r).cfp_tcam_s0[9]=(((r).cfp_tcam_s0[9] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53262_A0_CFP_TCAM_S0m_TCPHEADER_BIGICMP_CHKf_GET(r) ((((r).cfp_tcam_s0[9]) >> 27) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_TCPHEADER_BIGICMP_CHKf_SET(r,f) (r).cfp_tcam_s0[9]=(((r).cfp_tcam_s0[9] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_CFP_TCAM_S0m_UDFA0f_GET(r) cdk_field32_get((r).cfp_tcam_s0,316,331)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA0f_SET(r,f) cdk_field32_set((r).cfp_tcam_s0,316,331,f)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA0_VLDf_GET(r) ((((r).cfp_tcam_s0[10]) >> 12) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA0_VLDf_SET(r,f) (r).cfp_tcam_s0[10]=(((r).cfp_tcam_s0[10] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_CFP_TCAM_S0m_UDFA1f_GET(r) ((((r).cfp_tcam_s0[10]) >> 13) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA1f_SET(r,f) (r).cfp_tcam_s0[10]=(((r).cfp_tcam_s0[10] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))
#define BCM53262_A0_CFP_TCAM_S0m_UDFA1_VLDf_GET(r) ((((r).cfp_tcam_s0[10]) >> 29) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA1_VLDf_SET(r,f) (r).cfp_tcam_s0[10]=(((r).cfp_tcam_s0[10] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53262_A0_CFP_TCAM_S0m_UDFA2f_GET(r) cdk_field32_get((r).cfp_tcam_s0,350,365)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA2f_SET(r,f) cdk_field32_set((r).cfp_tcam_s0,350,365,f)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA2_VLDf_GET(r) ((((r).cfp_tcam_s0[11]) >> 14) & 0x1)
#define BCM53262_A0_CFP_TCAM_S0m_UDFA2_VLDf_SET(r,f) (r).cfp_tcam_s0[11]=(((r).cfp_tcam_s0[11] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_CFP_TCAM_S0m_RESVDf_GET(r) ((((r).cfp_tcam_s0[11]) >> 15) & 0x1fff)
#define BCM53262_A0_CFP_TCAM_S0m_RESVDf_SET(r,f) (r).cfp_tcam_s0[11]=(((r).cfp_tcam_s0[11] & ~((uint32_t)0x1fff << 15)) | ((((uint32_t)f) & 0x1fff) << 15))
#define BCM53262_A0_CFP_TCAM_S0m_VALID_Rf_GET(r) ((((r).cfp_tcam_s0[11]) >> 28) & 0xf)
#define BCM53262_A0_CFP_TCAM_S0m_VALID_Rf_SET(r,f) (r).cfp_tcam_s0[11]=(((r).cfp_tcam_s0[11] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CFP_TCAM_S0.
 */
#define BCM53262_A0_READ_CFP_TCAM_S0m(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_TCAM_S0m,i,(m),48)
#define BCM53262_A0_WRITE_CFP_TCAM_S0m(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_TCAM_S0m,i,&(m),48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_S0m BCM53262_A0_CFP_TCAM_S0m
#define CFP_TCAM_S0m_MIN BCM53262_A0_CFP_TCAM_S0m_MIN
#define CFP_TCAM_S0m_MAX BCM53262_A0_CFP_TCAM_S0m_MAX
#define CFP_TCAM_S0m_CMAX(u) BCM53262_A0_CFP_TCAM_S0m_CMAX(u)
#define CFP_TCAM_S0m_SIZE BCM53262_A0_CFP_TCAM_S0m_SIZE
typedef BCM53262_A0_CFP_TCAM_S0m_t CFP_TCAM_S0m_t;
#define CFP_TCAM_S0m_CLR BCM53262_A0_CFP_TCAM_S0m_CLR
#define CFP_TCAM_S0m_SET BCM53262_A0_CFP_TCAM_S0m_SET
#define CFP_TCAM_S0m_GET BCM53262_A0_CFP_TCAM_S0m_GET
#define CFP_TCAM_S0m_SLICEIDf_GET BCM53262_A0_CFP_TCAM_S0m_SLICEIDf_GET
#define CFP_TCAM_S0m_SLICEIDf_SET BCM53262_A0_CFP_TCAM_S0m_SLICEIDf_SET
#define CFP_TCAM_S0m_IN_PBMPf_GET BCM53262_A0_CFP_TCAM_S0m_IN_PBMPf_GET
#define CFP_TCAM_S0m_IN_PBMPf_SET BCM53262_A0_CFP_TCAM_S0m_IN_PBMPf_SET
#define CFP_TCAM_S0m_SPTAGGEDf_GET BCM53262_A0_CFP_TCAM_S0m_SPTAGGEDf_GET
#define CFP_TCAM_S0m_SPTAGGEDf_SET BCM53262_A0_CFP_TCAM_S0m_SPTAGGEDf_SET
#define CFP_TCAM_S0m_VLANTAGGEDf_GET BCM53262_A0_CFP_TCAM_S0m_VLANTAGGEDf_GET
#define CFP_TCAM_S0m_VLANTAGGEDf_SET BCM53262_A0_CFP_TCAM_S0m_VLANTAGGEDf_SET
#define CFP_TCAM_S0m_L2_FORMATf_GET BCM53262_A0_CFP_TCAM_S0m_L2_FORMATf_GET
#define CFP_TCAM_S0m_L2_FORMATf_SET BCM53262_A0_CFP_TCAM_S0m_L2_FORMATf_SET
#define CFP_TCAM_S0m_L3_FORMATf_GET BCM53262_A0_CFP_TCAM_S0m_L3_FORMATf_GET
#define CFP_TCAM_S0m_L3_FORMATf_SET BCM53262_A0_CFP_TCAM_S0m_L3_FORMATf_SET
#define CFP_TCAM_S0m_L4_FORMATf_GET BCM53262_A0_CFP_TCAM_S0m_L4_FORMATf_GET
#define CFP_TCAM_S0m_L4_FORMATf_SET BCM53262_A0_CFP_TCAM_S0m_L4_FORMATf_SET
#define CFP_TCAM_S0m_VLAN_RANGEf_GET BCM53262_A0_CFP_TCAM_S0m_VLAN_RANGEf_GET
#define CFP_TCAM_S0m_VLAN_RANGEf_SET BCM53262_A0_CFP_TCAM_S0m_VLAN_RANGEf_SET
#define CFP_TCAM_S0m_L4_PORT_RANGEf_GET BCM53262_A0_CFP_TCAM_S0m_L4_PORT_RANGEf_GET
#define CFP_TCAM_S0m_L4_PORT_RANGEf_SET BCM53262_A0_CFP_TCAM_S0m_L4_PORT_RANGEf_SET
#define CFP_TCAM_S0m_MAC_DAf_GET BCM53262_A0_CFP_TCAM_S0m_MAC_DAf_GET
#define CFP_TCAM_S0m_MAC_DAf_SET BCM53262_A0_CFP_TCAM_S0m_MAC_DAf_SET
#define CFP_TCAM_S0m_MAC_SAf_GET BCM53262_A0_CFP_TCAM_S0m_MAC_SAf_GET
#define CFP_TCAM_S0m_MAC_SAf_SET BCM53262_A0_CFP_TCAM_S0m_MAC_SAf_SET
#define CFP_TCAM_S0m_SP_VIDf_GET BCM53262_A0_CFP_TCAM_S0m_SP_VIDf_GET
#define CFP_TCAM_S0m_SP_VIDf_SET BCM53262_A0_CFP_TCAM_S0m_SP_VIDf_SET
#define CFP_TCAM_S0m_SP_CFIf_GET BCM53262_A0_CFP_TCAM_S0m_SP_CFIf_GET
#define CFP_TCAM_S0m_SP_CFIf_SET BCM53262_A0_CFP_TCAM_S0m_SP_CFIf_SET
#define CFP_TCAM_S0m_SP_PRIf_GET BCM53262_A0_CFP_TCAM_S0m_SP_PRIf_GET
#define CFP_TCAM_S0m_SP_PRIf_SET BCM53262_A0_CFP_TCAM_S0m_SP_PRIf_SET
#define CFP_TCAM_S0m_USR_VIDf_GET BCM53262_A0_CFP_TCAM_S0m_USR_VIDf_GET
#define CFP_TCAM_S0m_USR_VIDf_SET BCM53262_A0_CFP_TCAM_S0m_USR_VIDf_SET
#define CFP_TCAM_S0m_USR_CFIf_GET BCM53262_A0_CFP_TCAM_S0m_USR_CFIf_GET
#define CFP_TCAM_S0m_USR_CFIf_SET BCM53262_A0_CFP_TCAM_S0m_USR_CFIf_SET
#define CFP_TCAM_S0m_USR_PRIf_GET BCM53262_A0_CFP_TCAM_S0m_USR_PRIf_GET
#define CFP_TCAM_S0m_USR_PRIf_SET BCM53262_A0_CFP_TCAM_S0m_USR_PRIf_SET
#define CFP_TCAM_S0m_ETYPEf_GET BCM53262_A0_CFP_TCAM_S0m_ETYPEf_GET
#define CFP_TCAM_S0m_ETYPEf_SET BCM53262_A0_CFP_TCAM_S0m_ETYPEf_SET
#define CFP_TCAM_S0m_IP6_FLOW_IDf_GET BCM53262_A0_CFP_TCAM_S0m_IP6_FLOW_IDf_GET
#define CFP_TCAM_S0m_IP6_FLOW_IDf_SET BCM53262_A0_CFP_TCAM_S0m_IP6_FLOW_IDf_SET
#define CFP_TCAM_S0m_IP6_SAf_GET BCM53262_A0_CFP_TCAM_S0m_IP6_SAf_GET
#define CFP_TCAM_S0m_IP6_SAf_SET BCM53262_A0_CFP_TCAM_S0m_IP6_SAf_SET
#define CFP_TCAM_S0m_IP4TOS_IP6TRAFFICCLASSf_GET BCM53262_A0_CFP_TCAM_S0m_IP4TOS_IP6TRAFFICCLASSf_GET
#define CFP_TCAM_S0m_IP4TOS_IP6TRAFFICCLASSf_SET BCM53262_A0_CFP_TCAM_S0m_IP4TOS_IP6TRAFFICCLASSf_SET
#define CFP_TCAM_S0m_IP4PROTOCOL_IP6NEXTHEADERf_GET BCM53262_A0_CFP_TCAM_S0m_IP4PROTOCOL_IP6NEXTHEADERf_GET
#define CFP_TCAM_S0m_IP4PROTOCOL_IP6NEXTHEADERf_SET BCM53262_A0_CFP_TCAM_S0m_IP4PROTOCOL_IP6NEXTHEADERf_SET
#define CFP_TCAM_S0m_IP4TTL_IP6HOPLIMITf_GET BCM53262_A0_CFP_TCAM_S0m_IP4TTL_IP6HOPLIMITf_GET
#define CFP_TCAM_S0m_IP4TTL_IP6HOPLIMITf_SET BCM53262_A0_CFP_TCAM_S0m_IP4TTL_IP6HOPLIMITf_SET
#define CFP_TCAM_S0m_SAMEIPADDRf_GET BCM53262_A0_CFP_TCAM_S0m_SAMEIPADDRf_GET
#define CFP_TCAM_S0m_SAMEIPADDRf_SET BCM53262_A0_CFP_TCAM_S0m_SAMEIPADDRf_SET
#define CFP_TCAM_S0m_L4DSTf_GET BCM53262_A0_CFP_TCAM_S0m_L4DSTf_GET
#define CFP_TCAM_S0m_L4DSTf_SET BCM53262_A0_CFP_TCAM_S0m_L4DSTf_SET
#define CFP_TCAM_S0m_ICMPIGMP_TYPECODEf_GET BCM53262_A0_CFP_TCAM_S0m_ICMPIGMP_TYPECODEf_GET
#define CFP_TCAM_S0m_ICMPIGMP_TYPECODEf_SET BCM53262_A0_CFP_TCAM_S0m_ICMPIGMP_TYPECODEf_SET
#define CFP_TCAM_S0m_TCP_FLAGf_GET BCM53262_A0_CFP_TCAM_S0m_TCP_FLAGf_GET
#define CFP_TCAM_S0m_TCP_FLAGf_SET BCM53262_A0_CFP_TCAM_S0m_TCP_FLAGf_SET
#define CFP_TCAM_S0m_SAMEL4PORTf_GET BCM53262_A0_CFP_TCAM_S0m_SAMEL4PORTf_GET
#define CFP_TCAM_S0m_SAMEL4PORTf_SET BCM53262_A0_CFP_TCAM_S0m_SAMEL4PORTf_SET
#define CFP_TCAM_S0m_L4SRC_LESS_1024f_GET BCM53262_A0_CFP_TCAM_S0m_L4SRC_LESS_1024f_GET
#define CFP_TCAM_S0m_L4SRC_LESS_1024f_SET BCM53262_A0_CFP_TCAM_S0m_L4SRC_LESS_1024f_SET
#define CFP_TCAM_S0m_TCP_SEQUENCE_ZEROf_GET BCM53262_A0_CFP_TCAM_S0m_TCP_SEQUENCE_ZEROf_GET
#define CFP_TCAM_S0m_TCP_SEQUENCE_ZEROf_SET BCM53262_A0_CFP_TCAM_S0m_TCP_SEQUENCE_ZEROf_SET
#define CFP_TCAM_S0m_TCPHEADER_BIGICMP_CHKf_GET BCM53262_A0_CFP_TCAM_S0m_TCPHEADER_BIGICMP_CHKf_GET
#define CFP_TCAM_S0m_TCPHEADER_BIGICMP_CHKf_SET BCM53262_A0_CFP_TCAM_S0m_TCPHEADER_BIGICMP_CHKf_SET
#define CFP_TCAM_S0m_UDFA0f_GET BCM53262_A0_CFP_TCAM_S0m_UDFA0f_GET
#define CFP_TCAM_S0m_UDFA0f_SET BCM53262_A0_CFP_TCAM_S0m_UDFA0f_SET
#define CFP_TCAM_S0m_UDFA0_VLDf_GET BCM53262_A0_CFP_TCAM_S0m_UDFA0_VLDf_GET
#define CFP_TCAM_S0m_UDFA0_VLDf_SET BCM53262_A0_CFP_TCAM_S0m_UDFA0_VLDf_SET
#define CFP_TCAM_S0m_UDFA1f_GET BCM53262_A0_CFP_TCAM_S0m_UDFA1f_GET
#define CFP_TCAM_S0m_UDFA1f_SET BCM53262_A0_CFP_TCAM_S0m_UDFA1f_SET
#define CFP_TCAM_S0m_UDFA1_VLDf_GET BCM53262_A0_CFP_TCAM_S0m_UDFA1_VLDf_GET
#define CFP_TCAM_S0m_UDFA1_VLDf_SET BCM53262_A0_CFP_TCAM_S0m_UDFA1_VLDf_SET
#define CFP_TCAM_S0m_UDFA2f_GET BCM53262_A0_CFP_TCAM_S0m_UDFA2f_GET
#define CFP_TCAM_S0m_UDFA2f_SET BCM53262_A0_CFP_TCAM_S0m_UDFA2f_SET
#define CFP_TCAM_S0m_UDFA2_VLDf_GET BCM53262_A0_CFP_TCAM_S0m_UDFA2_VLDf_GET
#define CFP_TCAM_S0m_UDFA2_VLDf_SET BCM53262_A0_CFP_TCAM_S0m_UDFA2_VLDf_SET
#define CFP_TCAM_S0m_RESVDf_GET BCM53262_A0_CFP_TCAM_S0m_RESVDf_GET
#define CFP_TCAM_S0m_RESVDf_SET BCM53262_A0_CFP_TCAM_S0m_RESVDf_SET
#define CFP_TCAM_S0m_VALID_Rf_GET BCM53262_A0_CFP_TCAM_S0m_VALID_Rf_GET
#define CFP_TCAM_S0m_VALID_Rf_SET BCM53262_A0_CFP_TCAM_S0m_VALID_Rf_SET
#define READ_CFP_TCAM_S0m BCM53262_A0_READ_CFP_TCAM_S0m
#define WRITE_CFP_TCAM_S0m BCM53262_A0_WRITE_CFP_TCAM_S0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_TCAM_S0m'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_TCAM_S1
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     384
 * FIELDS:
 *     SLICEID          Slice ID
 *     IN_PBMP          Ingress port map
 *     SPTAGGED         Service tagged frame
 *     VLANTAGGED       802.1Q tagged frame
 *     L2_FORMAT        Select L2 frame format
 *     L3_FORMAT        Select L3 frame format
 *     L4_FORMAT        Select L4 frame format
 *     VLAN_RANGE       VLAN range
 *     L4_PORT_RANGE    L4 port range
 *     MAC_DA           Destination MAC address
 *     MAC_SA           Source MAC address
 *     SP_VID           Service provider tag VID
 *     SP_CFI           Service provider tag CFI
 *     SP_PRI           Service provider tag priority
 *     USR_VID          User tag VID
 *     USR_CFI          User tag CFI
 *     USR_PRI          User tag priority
 *     UDFB0            User define field B0
 *     UDFB0_VLD        User define field B0 valid
 *     UDFB1            User define field B1
 *     UDFB1_VLD        User define field B1 valid
 *     UDFB2            User define field B2
 *     UDFB2_VLD        User define field B2 valid
 *     UDFB3            User define field B3
 *     UDFB3_VLD        User define field B3 valid
 *     UDFB4            User define field B4
 *     UDFB4_VLD        User define field B4 valid
 *     UDFB5            User define field B5
 *     UDFB5_VLD        User define field B51 valid
 *     UDFB6            User define field B6
 *     UDFB6_VLD        User define field B6 valid
 *     UDFB7            User define field B7
 *     UDFB7_VLD        User define field B7 valid
 *     UDFB8            User define field B8
 *     UDFB8_VLD        User define field B8 valid
 *     UDFB9            User define field B9
 *     UDFB9_VLD        User define field B9 valid
 *     UDFB10           User define field B10
 *     UDFB10_VLD       User define field B10 valid
 *     RESVD            Reserved
 *     VALID_R          Valid bits
 */
#define BCM53262_A0_CFP_TCAM_S1m 0x00004600

#define BCM53262_A0_CFP_TCAM_S1m_MIN 0
#define BCM53262_A0_CFP_TCAM_S1m_MAX 1023
#define BCM53262_A0_CFP_TCAM_S1m_CMAX(u) 1023
#define BCM53262_A0_CFP_TCAM_S1m_SIZE 48

/*
 * This structure should be used to declare and program CFP_TCAM_S1.
 */
typedef union BCM53262_A0_CFP_TCAM_S1m_s {
	uint32_t v[12];
	uint32_t cfp_tcam_s1[12];
	uint32_t _cfp_tcam_s1;
} BCM53262_A0_CFP_TCAM_S1m_t;

#define BCM53262_A0_CFP_TCAM_S1m_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_s1), 0, sizeof(BCM53262_A0_CFP_TCAM_S1m_t))
#define BCM53262_A0_CFP_TCAM_S1m_SET(r,i,d) (r).cfp_tcam_s1[i] = d
#define BCM53262_A0_CFP_TCAM_S1m_GET(r,i) (r).cfp_tcam_s1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_TCAM_S1m_SLICEIDf_GET(r) (((r).cfp_tcam_s1[0]) & 0x3)
#define BCM53262_A0_CFP_TCAM_S1m_SLICEIDf_SET(r,f) (r).cfp_tcam_s1[0]=(((r).cfp_tcam_s1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_CFP_TCAM_S1m_IN_PBMPf_GET(r) ((((r).cfp_tcam_s1[0]) >> 2) & 0x1fffffff)
#define BCM53262_A0_CFP_TCAM_S1m_IN_PBMPf_SET(r,f) (r).cfp_tcam_s1[0]=(((r).cfp_tcam_s1[0] & ~((uint32_t)0x1fffffff << 2)) | ((((uint32_t)f) & 0x1fffffff) << 2))
#define BCM53262_A0_CFP_TCAM_S1m_SPTAGGEDf_GET(r) ((((r).cfp_tcam_s1[0]) >> 31) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_SPTAGGEDf_SET(r,f) (r).cfp_tcam_s1[0]=(((r).cfp_tcam_s1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53262_A0_CFP_TCAM_S1m_VLANTAGGEDf_GET(r) (((r).cfp_tcam_s1[1]) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_VLANTAGGEDf_SET(r,f) (r).cfp_tcam_s1[1]=(((r).cfp_tcam_s1[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_CFP_TCAM_S1m_L2_FORMATf_GET(r) ((((r).cfp_tcam_s1[1]) >> 1) & 0x3)
#define BCM53262_A0_CFP_TCAM_S1m_L2_FORMATf_SET(r,f) (r).cfp_tcam_s1[1]=(((r).cfp_tcam_s1[1] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53262_A0_CFP_TCAM_S1m_L3_FORMATf_GET(r) ((((r).cfp_tcam_s1[1]) >> 3) & 0x3)
#define BCM53262_A0_CFP_TCAM_S1m_L3_FORMATf_SET(r,f) (r).cfp_tcam_s1[1]=(((r).cfp_tcam_s1[1] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53262_A0_CFP_TCAM_S1m_L4_FORMATf_GET(r) ((((r).cfp_tcam_s1[1]) >> 5) & 0x3)
#define BCM53262_A0_CFP_TCAM_S1m_L4_FORMATf_SET(r,f) (r).cfp_tcam_s1[1]=(((r).cfp_tcam_s1[1] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53262_A0_CFP_TCAM_S1m_VLAN_RANGEf_GET(r) ((((r).cfp_tcam_s1[1]) >> 7) & 0xf)
#define BCM53262_A0_CFP_TCAM_S1m_VLAN_RANGEf_SET(r,f) (r).cfp_tcam_s1[1]=(((r).cfp_tcam_s1[1] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53262_A0_CFP_TCAM_S1m_L4_PORT_RANGEf_GET(r) ((((r).cfp_tcam_s1[1]) >> 11) & 0xf)
#define BCM53262_A0_CFP_TCAM_S1m_L4_PORT_RANGEf_SET(r,f) (r).cfp_tcam_s1[1]=(((r).cfp_tcam_s1[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53262_A0_CFP_TCAM_S1m_MAC_DAf_GET(r,a) cdk_field_get((r).cfp_tcam_s1,47,94,a)
#define BCM53262_A0_CFP_TCAM_S1m_MAC_DAf_SET(r,a) cdk_field_set((r).cfp_tcam_s1,47,94,a)
#define BCM53262_A0_CFP_TCAM_S1m_MAC_SAf_GET(r,a) cdk_field_get((r).cfp_tcam_s1,95,142,a)
#define BCM53262_A0_CFP_TCAM_S1m_MAC_SAf_SET(r,a) cdk_field_set((r).cfp_tcam_s1,95,142,a)
#define BCM53262_A0_CFP_TCAM_S1m_SP_VIDf_GET(r) ((((r).cfp_tcam_s1[4]) >> 15) & 0xfff)
#define BCM53262_A0_CFP_TCAM_S1m_SP_VIDf_SET(r,f) (r).cfp_tcam_s1[4]=(((r).cfp_tcam_s1[4] & ~((uint32_t)0xfff << 15)) | ((((uint32_t)f) & 0xfff) << 15))
#define BCM53262_A0_CFP_TCAM_S1m_SP_CFIf_GET(r) ((((r).cfp_tcam_s1[4]) >> 27) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_SP_CFIf_SET(r,f) (r).cfp_tcam_s1[4]=(((r).cfp_tcam_s1[4] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_CFP_TCAM_S1m_SP_PRIf_GET(r) ((((r).cfp_tcam_s1[4]) >> 28) & 0x7)
#define BCM53262_A0_CFP_TCAM_S1m_SP_PRIf_SET(r,f) (r).cfp_tcam_s1[4]=(((r).cfp_tcam_s1[4] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53262_A0_CFP_TCAM_S1m_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_s1,159,170)
#define BCM53262_A0_CFP_TCAM_S1m_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_s1,159,170,f)
#define BCM53262_A0_CFP_TCAM_S1m_USR_CFIf_GET(r) ((((r).cfp_tcam_s1[5]) >> 11) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_USR_CFIf_SET(r,f) (r).cfp_tcam_s1[5]=(((r).cfp_tcam_s1[5] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_CFP_TCAM_S1m_USR_PRIf_GET(r) ((((r).cfp_tcam_s1[5]) >> 12) & 0x7)
#define BCM53262_A0_CFP_TCAM_S1m_USR_PRIf_SET(r,f) (r).cfp_tcam_s1[5]=(((r).cfp_tcam_s1[5] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB0f_GET(r) ((((r).cfp_tcam_s1[5]) >> 15) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB0f_SET(r,f) (r).cfp_tcam_s1[5]=(((r).cfp_tcam_s1[5] & ~((uint32_t)0xffff << 15)) | ((((uint32_t)f) & 0xffff) << 15))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB0_VLDf_GET(r) ((((r).cfp_tcam_s1[5]) >> 31) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB0_VLDf_SET(r,f) (r).cfp_tcam_s1[5]=(((r).cfp_tcam_s1[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB1f_GET(r) (((r).cfp_tcam_s1[6]) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB1f_SET(r,f) (r).cfp_tcam_s1[6]=(((r).cfp_tcam_s1[6] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB1_VLDf_GET(r) ((((r).cfp_tcam_s1[6]) >> 16) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB1_VLDf_SET(r,f) (r).cfp_tcam_s1[6]=(((r).cfp_tcam_s1[6] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB2f_GET(r) cdk_field32_get((r).cfp_tcam_s1,209,224)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB2f_SET(r,f) cdk_field32_set((r).cfp_tcam_s1,209,224,f)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB2_VLDf_GET(r) ((((r).cfp_tcam_s1[7]) >> 1) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB2_VLDf_SET(r,f) (r).cfp_tcam_s1[7]=(((r).cfp_tcam_s1[7] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB3f_GET(r) ((((r).cfp_tcam_s1[7]) >> 2) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB3f_SET(r,f) (r).cfp_tcam_s1[7]=(((r).cfp_tcam_s1[7] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB3_VLDf_GET(r) ((((r).cfp_tcam_s1[7]) >> 18) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB3_VLDf_SET(r,f) (r).cfp_tcam_s1[7]=(((r).cfp_tcam_s1[7] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB4f_GET(r) cdk_field32_get((r).cfp_tcam_s1,243,258)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB4f_SET(r,f) cdk_field32_set((r).cfp_tcam_s1,243,258,f)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB4_VLDf_GET(r) ((((r).cfp_tcam_s1[8]) >> 3) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB4_VLDf_SET(r,f) (r).cfp_tcam_s1[8]=(((r).cfp_tcam_s1[8] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB5f_GET(r) ((((r).cfp_tcam_s1[8]) >> 4) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB5f_SET(r,f) (r).cfp_tcam_s1[8]=(((r).cfp_tcam_s1[8] & ~((uint32_t)0xffff << 4)) | ((((uint32_t)f) & 0xffff) << 4))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB5_VLDf_GET(r) ((((r).cfp_tcam_s1[8]) >> 20) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB5_VLDf_SET(r,f) (r).cfp_tcam_s1[8]=(((r).cfp_tcam_s1[8] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB6f_GET(r) cdk_field32_get((r).cfp_tcam_s1,277,292)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB6f_SET(r,f) cdk_field32_set((r).cfp_tcam_s1,277,292,f)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB6_VLDf_GET(r) ((((r).cfp_tcam_s1[9]) >> 5) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB6_VLDf_SET(r,f) (r).cfp_tcam_s1[9]=(((r).cfp_tcam_s1[9] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB7f_GET(r) ((((r).cfp_tcam_s1[9]) >> 6) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB7f_SET(r,f) (r).cfp_tcam_s1[9]=(((r).cfp_tcam_s1[9] & ~((uint32_t)0xffff << 6)) | ((((uint32_t)f) & 0xffff) << 6))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB7_VLDf_GET(r) ((((r).cfp_tcam_s1[9]) >> 22) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB7_VLDf_SET(r,f) (r).cfp_tcam_s1[9]=(((r).cfp_tcam_s1[9] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB8f_GET(r) cdk_field32_get((r).cfp_tcam_s1,311,326)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB8f_SET(r,f) cdk_field32_set((r).cfp_tcam_s1,311,326,f)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB8_VLDf_GET(r) ((((r).cfp_tcam_s1[10]) >> 7) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB8_VLDf_SET(r,f) (r).cfp_tcam_s1[10]=(((r).cfp_tcam_s1[10] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB9f_GET(r) ((((r).cfp_tcam_s1[10]) >> 8) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB9f_SET(r,f) (r).cfp_tcam_s1[10]=(((r).cfp_tcam_s1[10] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB9_VLDf_GET(r) ((((r).cfp_tcam_s1[10]) >> 24) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB9_VLDf_SET(r,f) (r).cfp_tcam_s1[10]=(((r).cfp_tcam_s1[10] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53262_A0_CFP_TCAM_S1m_UDFB10f_GET(r) cdk_field32_get((r).cfp_tcam_s1,345,360)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB10f_SET(r,f) cdk_field32_set((r).cfp_tcam_s1,345,360,f)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB10_VLDf_GET(r) ((((r).cfp_tcam_s1[11]) >> 9) & 0x1)
#define BCM53262_A0_CFP_TCAM_S1m_UDFB10_VLDf_SET(r,f) (r).cfp_tcam_s1[11]=(((r).cfp_tcam_s1[11] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_CFP_TCAM_S1m_RESVDf_GET(r) ((((r).cfp_tcam_s1[11]) >> 10) & 0x3ffff)
#define BCM53262_A0_CFP_TCAM_S1m_RESVDf_SET(r,f) (r).cfp_tcam_s1[11]=(((r).cfp_tcam_s1[11] & ~((uint32_t)0x3ffff << 10)) | ((((uint32_t)f) & 0x3ffff) << 10))
#define BCM53262_A0_CFP_TCAM_S1m_VALID_Rf_GET(r) ((((r).cfp_tcam_s1[11]) >> 28) & 0xf)
#define BCM53262_A0_CFP_TCAM_S1m_VALID_Rf_SET(r,f) (r).cfp_tcam_s1[11]=(((r).cfp_tcam_s1[11] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CFP_TCAM_S1.
 */
#define BCM53262_A0_READ_CFP_TCAM_S1m(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_TCAM_S1m,i,(m),48)
#define BCM53262_A0_WRITE_CFP_TCAM_S1m(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_TCAM_S1m,i,&(m),48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_S1m BCM53262_A0_CFP_TCAM_S1m
#define CFP_TCAM_S1m_MIN BCM53262_A0_CFP_TCAM_S1m_MIN
#define CFP_TCAM_S1m_MAX BCM53262_A0_CFP_TCAM_S1m_MAX
#define CFP_TCAM_S1m_CMAX(u) BCM53262_A0_CFP_TCAM_S1m_CMAX(u)
#define CFP_TCAM_S1m_SIZE BCM53262_A0_CFP_TCAM_S1m_SIZE
typedef BCM53262_A0_CFP_TCAM_S1m_t CFP_TCAM_S1m_t;
#define CFP_TCAM_S1m_CLR BCM53262_A0_CFP_TCAM_S1m_CLR
#define CFP_TCAM_S1m_SET BCM53262_A0_CFP_TCAM_S1m_SET
#define CFP_TCAM_S1m_GET BCM53262_A0_CFP_TCAM_S1m_GET
#define CFP_TCAM_S1m_SLICEIDf_GET BCM53262_A0_CFP_TCAM_S1m_SLICEIDf_GET
#define CFP_TCAM_S1m_SLICEIDf_SET BCM53262_A0_CFP_TCAM_S1m_SLICEIDf_SET
#define CFP_TCAM_S1m_IN_PBMPf_GET BCM53262_A0_CFP_TCAM_S1m_IN_PBMPf_GET
#define CFP_TCAM_S1m_IN_PBMPf_SET BCM53262_A0_CFP_TCAM_S1m_IN_PBMPf_SET
#define CFP_TCAM_S1m_SPTAGGEDf_GET BCM53262_A0_CFP_TCAM_S1m_SPTAGGEDf_GET
#define CFP_TCAM_S1m_SPTAGGEDf_SET BCM53262_A0_CFP_TCAM_S1m_SPTAGGEDf_SET
#define CFP_TCAM_S1m_VLANTAGGEDf_GET BCM53262_A0_CFP_TCAM_S1m_VLANTAGGEDf_GET
#define CFP_TCAM_S1m_VLANTAGGEDf_SET BCM53262_A0_CFP_TCAM_S1m_VLANTAGGEDf_SET
#define CFP_TCAM_S1m_L2_FORMATf_GET BCM53262_A0_CFP_TCAM_S1m_L2_FORMATf_GET
#define CFP_TCAM_S1m_L2_FORMATf_SET BCM53262_A0_CFP_TCAM_S1m_L2_FORMATf_SET
#define CFP_TCAM_S1m_L3_FORMATf_GET BCM53262_A0_CFP_TCAM_S1m_L3_FORMATf_GET
#define CFP_TCAM_S1m_L3_FORMATf_SET BCM53262_A0_CFP_TCAM_S1m_L3_FORMATf_SET
#define CFP_TCAM_S1m_L4_FORMATf_GET BCM53262_A0_CFP_TCAM_S1m_L4_FORMATf_GET
#define CFP_TCAM_S1m_L4_FORMATf_SET BCM53262_A0_CFP_TCAM_S1m_L4_FORMATf_SET
#define CFP_TCAM_S1m_VLAN_RANGEf_GET BCM53262_A0_CFP_TCAM_S1m_VLAN_RANGEf_GET
#define CFP_TCAM_S1m_VLAN_RANGEf_SET BCM53262_A0_CFP_TCAM_S1m_VLAN_RANGEf_SET
#define CFP_TCAM_S1m_L4_PORT_RANGEf_GET BCM53262_A0_CFP_TCAM_S1m_L4_PORT_RANGEf_GET
#define CFP_TCAM_S1m_L4_PORT_RANGEf_SET BCM53262_A0_CFP_TCAM_S1m_L4_PORT_RANGEf_SET
#define CFP_TCAM_S1m_MAC_DAf_GET BCM53262_A0_CFP_TCAM_S1m_MAC_DAf_GET
#define CFP_TCAM_S1m_MAC_DAf_SET BCM53262_A0_CFP_TCAM_S1m_MAC_DAf_SET
#define CFP_TCAM_S1m_MAC_SAf_GET BCM53262_A0_CFP_TCAM_S1m_MAC_SAf_GET
#define CFP_TCAM_S1m_MAC_SAf_SET BCM53262_A0_CFP_TCAM_S1m_MAC_SAf_SET
#define CFP_TCAM_S1m_SP_VIDf_GET BCM53262_A0_CFP_TCAM_S1m_SP_VIDf_GET
#define CFP_TCAM_S1m_SP_VIDf_SET BCM53262_A0_CFP_TCAM_S1m_SP_VIDf_SET
#define CFP_TCAM_S1m_SP_CFIf_GET BCM53262_A0_CFP_TCAM_S1m_SP_CFIf_GET
#define CFP_TCAM_S1m_SP_CFIf_SET BCM53262_A0_CFP_TCAM_S1m_SP_CFIf_SET
#define CFP_TCAM_S1m_SP_PRIf_GET BCM53262_A0_CFP_TCAM_S1m_SP_PRIf_GET
#define CFP_TCAM_S1m_SP_PRIf_SET BCM53262_A0_CFP_TCAM_S1m_SP_PRIf_SET
#define CFP_TCAM_S1m_USR_VIDf_GET BCM53262_A0_CFP_TCAM_S1m_USR_VIDf_GET
#define CFP_TCAM_S1m_USR_VIDf_SET BCM53262_A0_CFP_TCAM_S1m_USR_VIDf_SET
#define CFP_TCAM_S1m_USR_CFIf_GET BCM53262_A0_CFP_TCAM_S1m_USR_CFIf_GET
#define CFP_TCAM_S1m_USR_CFIf_SET BCM53262_A0_CFP_TCAM_S1m_USR_CFIf_SET
#define CFP_TCAM_S1m_USR_PRIf_GET BCM53262_A0_CFP_TCAM_S1m_USR_PRIf_GET
#define CFP_TCAM_S1m_USR_PRIf_SET BCM53262_A0_CFP_TCAM_S1m_USR_PRIf_SET
#define CFP_TCAM_S1m_UDFB0f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB0f_GET
#define CFP_TCAM_S1m_UDFB0f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB0f_SET
#define CFP_TCAM_S1m_UDFB0_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB0_VLDf_GET
#define CFP_TCAM_S1m_UDFB0_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB0_VLDf_SET
#define CFP_TCAM_S1m_UDFB1f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB1f_GET
#define CFP_TCAM_S1m_UDFB1f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB1f_SET
#define CFP_TCAM_S1m_UDFB1_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB1_VLDf_GET
#define CFP_TCAM_S1m_UDFB1_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB1_VLDf_SET
#define CFP_TCAM_S1m_UDFB2f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB2f_GET
#define CFP_TCAM_S1m_UDFB2f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB2f_SET
#define CFP_TCAM_S1m_UDFB2_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB2_VLDf_GET
#define CFP_TCAM_S1m_UDFB2_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB2_VLDf_SET
#define CFP_TCAM_S1m_UDFB3f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB3f_GET
#define CFP_TCAM_S1m_UDFB3f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB3f_SET
#define CFP_TCAM_S1m_UDFB3_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB3_VLDf_GET
#define CFP_TCAM_S1m_UDFB3_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB3_VLDf_SET
#define CFP_TCAM_S1m_UDFB4f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB4f_GET
#define CFP_TCAM_S1m_UDFB4f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB4f_SET
#define CFP_TCAM_S1m_UDFB4_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB4_VLDf_GET
#define CFP_TCAM_S1m_UDFB4_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB4_VLDf_SET
#define CFP_TCAM_S1m_UDFB5f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB5f_GET
#define CFP_TCAM_S1m_UDFB5f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB5f_SET
#define CFP_TCAM_S1m_UDFB5_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB5_VLDf_GET
#define CFP_TCAM_S1m_UDFB5_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB5_VLDf_SET
#define CFP_TCAM_S1m_UDFB6f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB6f_GET
#define CFP_TCAM_S1m_UDFB6f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB6f_SET
#define CFP_TCAM_S1m_UDFB6_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB6_VLDf_GET
#define CFP_TCAM_S1m_UDFB6_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB6_VLDf_SET
#define CFP_TCAM_S1m_UDFB7f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB7f_GET
#define CFP_TCAM_S1m_UDFB7f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB7f_SET
#define CFP_TCAM_S1m_UDFB7_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB7_VLDf_GET
#define CFP_TCAM_S1m_UDFB7_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB7_VLDf_SET
#define CFP_TCAM_S1m_UDFB8f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB8f_GET
#define CFP_TCAM_S1m_UDFB8f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB8f_SET
#define CFP_TCAM_S1m_UDFB8_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB8_VLDf_GET
#define CFP_TCAM_S1m_UDFB8_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB8_VLDf_SET
#define CFP_TCAM_S1m_UDFB9f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB9f_GET
#define CFP_TCAM_S1m_UDFB9f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB9f_SET
#define CFP_TCAM_S1m_UDFB9_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB9_VLDf_GET
#define CFP_TCAM_S1m_UDFB9_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB9_VLDf_SET
#define CFP_TCAM_S1m_UDFB10f_GET BCM53262_A0_CFP_TCAM_S1m_UDFB10f_GET
#define CFP_TCAM_S1m_UDFB10f_SET BCM53262_A0_CFP_TCAM_S1m_UDFB10f_SET
#define CFP_TCAM_S1m_UDFB10_VLDf_GET BCM53262_A0_CFP_TCAM_S1m_UDFB10_VLDf_GET
#define CFP_TCAM_S1m_UDFB10_VLDf_SET BCM53262_A0_CFP_TCAM_S1m_UDFB10_VLDf_SET
#define CFP_TCAM_S1m_RESVDf_GET BCM53262_A0_CFP_TCAM_S1m_RESVDf_GET
#define CFP_TCAM_S1m_RESVDf_SET BCM53262_A0_CFP_TCAM_S1m_RESVDf_SET
#define CFP_TCAM_S1m_VALID_Rf_GET BCM53262_A0_CFP_TCAM_S1m_VALID_Rf_GET
#define CFP_TCAM_S1m_VALID_Rf_SET BCM53262_A0_CFP_TCAM_S1m_VALID_Rf_SET
#define READ_CFP_TCAM_S1m BCM53262_A0_READ_CFP_TCAM_S1m
#define WRITE_CFP_TCAM_S1m BCM53262_A0_WRITE_CFP_TCAM_S1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_TCAM_S1m'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  CFP_TCAM_S2
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     384
 * FIELDS:
 *     SLICEID          Slice ID
 *     IN_PBMP          Ingress port map
 *     SPTAGGED         Service tagged frame
 *     VLANTAGGED       802.1Q tagged frame
 *     L2_FORMAT        Select L2 frame format
 *     L3_FORMAT        Select L3 frame format
 *     L4_FORMAT        Select L4 frame format
 *     VLAN_RANGE       VLAN range
 *     L4_PORT_RANGE    L4 port range
 *     UDFC0            User define field C0
 *     UDFC0_VLD        User define field C0 valid
 *     UDFC1            User define field C1
 *     UDFC1_VLD        User define field C1 valid
 *     UDFC2            User define field C2
 *     UDFC2_VLD        User define field C2 valid
 *     UDFD0            User define field D0
 *     UDFD0_VLD        User define field D0 valid
 *     UDFD1            User define field D1
 *     UDFD1_VLD        User define field D1 valid
 *     UDFD2            User define field D2
 *     UDFD2_VLD        User define field D2 valid
 *     UDFD3            User define field D3
 *     UDFD3_VLD        User define field D3 valid
 *     UDFD4            User define field D4
 *     UDFD4_VLD        User define field D4 valid
 *     UDFD5            User define field D5
 *     UDFD5_VLD        User define field D5 valid
 *     UDFD6            User define field D6
 *     UDFD6_VLD        User define field D64 valid
 *     UDFD7            User define field D7
 *     UDFD7_VLD        User define field D74 valid
 *     RESVD            Reserved
 *     VALID_R          Valid bits
 */
#define BCM53262_A0_CFP_TCAM_S2m 0x00004a00

#define BCM53262_A0_CFP_TCAM_S2m_MIN 0
#define BCM53262_A0_CFP_TCAM_S2m_MAX 1023
#define BCM53262_A0_CFP_TCAM_S2m_CMAX(u) 1023
#define BCM53262_A0_CFP_TCAM_S2m_SIZE 48

/*
 * This structure should be used to declare and program CFP_TCAM_S2.
 */
typedef union BCM53262_A0_CFP_TCAM_S2m_s {
	uint32_t v[12];
	uint32_t cfp_tcam_s2[12];
	uint32_t _cfp_tcam_s2;
} BCM53262_A0_CFP_TCAM_S2m_t;

#define BCM53262_A0_CFP_TCAM_S2m_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_s2), 0, sizeof(BCM53262_A0_CFP_TCAM_S2m_t))
#define BCM53262_A0_CFP_TCAM_S2m_SET(r,i,d) (r).cfp_tcam_s2[i] = d
#define BCM53262_A0_CFP_TCAM_S2m_GET(r,i) (r).cfp_tcam_s2[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_TCAM_S2m_SLICEIDf_GET(r) (((r).cfp_tcam_s2[0]) & 0x3)
#define BCM53262_A0_CFP_TCAM_S2m_SLICEIDf_SET(r,f) (r).cfp_tcam_s2[0]=(((r).cfp_tcam_s2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_CFP_TCAM_S2m_IN_PBMPf_GET(r) ((((r).cfp_tcam_s2[0]) >> 2) & 0x1fffffff)
#define BCM53262_A0_CFP_TCAM_S2m_IN_PBMPf_SET(r,f) (r).cfp_tcam_s2[0]=(((r).cfp_tcam_s2[0] & ~((uint32_t)0x1fffffff << 2)) | ((((uint32_t)f) & 0x1fffffff) << 2))
#define BCM53262_A0_CFP_TCAM_S2m_SPTAGGEDf_GET(r) ((((r).cfp_tcam_s2[0]) >> 31) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_SPTAGGEDf_SET(r,f) (r).cfp_tcam_s2[0]=(((r).cfp_tcam_s2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53262_A0_CFP_TCAM_S2m_VLANTAGGEDf_GET(r) (((r).cfp_tcam_s2[1]) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_VLANTAGGEDf_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_CFP_TCAM_S2m_L2_FORMATf_GET(r) ((((r).cfp_tcam_s2[1]) >> 1) & 0x3)
#define BCM53262_A0_CFP_TCAM_S2m_L2_FORMATf_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53262_A0_CFP_TCAM_S2m_L3_FORMATf_GET(r) ((((r).cfp_tcam_s2[1]) >> 3) & 0x3)
#define BCM53262_A0_CFP_TCAM_S2m_L3_FORMATf_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53262_A0_CFP_TCAM_S2m_L4_FORMATf_GET(r) ((((r).cfp_tcam_s2[1]) >> 5) & 0x3)
#define BCM53262_A0_CFP_TCAM_S2m_L4_FORMATf_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53262_A0_CFP_TCAM_S2m_VLAN_RANGEf_GET(r) ((((r).cfp_tcam_s2[1]) >> 7) & 0xf)
#define BCM53262_A0_CFP_TCAM_S2m_VLAN_RANGEf_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53262_A0_CFP_TCAM_S2m_L4_PORT_RANGEf_GET(r) ((((r).cfp_tcam_s2[1]) >> 11) & 0xf)
#define BCM53262_A0_CFP_TCAM_S2m_L4_PORT_RANGEf_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53262_A0_CFP_TCAM_S2m_UDFC0f_GET(r) ((((r).cfp_tcam_s2[1]) >> 15) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S2m_UDFC0f_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0xffff << 15)) | ((((uint32_t)f) & 0xffff) << 15))
#define BCM53262_A0_CFP_TCAM_S2m_UDFC0_VLDf_GET(r) ((((r).cfp_tcam_s2[1]) >> 31) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFC0_VLDf_SET(r,f) (r).cfp_tcam_s2[1]=(((r).cfp_tcam_s2[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53262_A0_CFP_TCAM_S2m_UDFC1f_GET(r) (((r).cfp_tcam_s2[2]) & 0xffff)
#define BCM53262_A0_CFP_TCAM_S2m_UDFC1f_SET(r,f) (r).cfp_tcam_s2[2]=(((r).cfp_tcam_s2[2] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53262_A0_CFP_TCAM_S2m_UDFC1_VLDf_GET(r) ((((r).cfp_tcam_s2[2]) >> 16) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFC1_VLDf_SET(r,f) (r).cfp_tcam_s2[2]=(((r).cfp_tcam_s2[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53262_A0_CFP_TCAM_S2m_UDFC2f_GET(r) cdk_field32_get((r).cfp_tcam_s2,81,96)
#define BCM53262_A0_CFP_TCAM_S2m_UDFC2f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,81,96,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFC2_VLDf_GET(r) ((((r).cfp_tcam_s2[3]) >> 1) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFC2_VLDf_SET(r,f) (r).cfp_tcam_s2[3]=(((r).cfp_tcam_s2[3] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD0f_GET(r) cdk_field32_get((r).cfp_tcam_s2,98,129)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD0f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,98,129,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD0_VLDf_GET(r) ((((r).cfp_tcam_s2[4]) >> 2) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD0_VLDf_SET(r,f) (r).cfp_tcam_s2[4]=(((r).cfp_tcam_s2[4] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD1f_GET(r) cdk_field32_get((r).cfp_tcam_s2,131,162)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD1f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,131,162,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD1_VLDf_GET(r) ((((r).cfp_tcam_s2[5]) >> 3) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD1_VLDf_SET(r,f) (r).cfp_tcam_s2[5]=(((r).cfp_tcam_s2[5] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD2f_GET(r) cdk_field32_get((r).cfp_tcam_s2,164,195)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD2f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,164,195,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD2_VLDf_GET(r) ((((r).cfp_tcam_s2[6]) >> 4) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD2_VLDf_SET(r,f) (r).cfp_tcam_s2[6]=(((r).cfp_tcam_s2[6] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD3f_GET(r) cdk_field32_get((r).cfp_tcam_s2,197,228)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD3f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,197,228,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD3_VLDf_GET(r) ((((r).cfp_tcam_s2[7]) >> 5) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD3_VLDf_SET(r,f) (r).cfp_tcam_s2[7]=(((r).cfp_tcam_s2[7] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD4f_GET(r) cdk_field32_get((r).cfp_tcam_s2,230,261)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD4f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,230,261,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD4_VLDf_GET(r) ((((r).cfp_tcam_s2[8]) >> 6) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD4_VLDf_SET(r,f) (r).cfp_tcam_s2[8]=(((r).cfp_tcam_s2[8] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD5f_GET(r) cdk_field32_get((r).cfp_tcam_s2,263,294)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD5f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,263,294,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD5_VLDf_GET(r) ((((r).cfp_tcam_s2[9]) >> 7) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD5_VLDf_SET(r,f) (r).cfp_tcam_s2[9]=(((r).cfp_tcam_s2[9] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD6f_GET(r) cdk_field32_get((r).cfp_tcam_s2,296,327)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD6f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,296,327,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD6_VLDf_GET(r) ((((r).cfp_tcam_s2[10]) >> 8) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD6_VLDf_SET(r,f) (r).cfp_tcam_s2[10]=(((r).cfp_tcam_s2[10] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_CFP_TCAM_S2m_UDFD7f_GET(r) cdk_field32_get((r).cfp_tcam_s2,329,360)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD7f_SET(r,f) cdk_field32_set((r).cfp_tcam_s2,329,360,f)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD7_VLDf_GET(r) ((((r).cfp_tcam_s2[11]) >> 9) & 0x1)
#define BCM53262_A0_CFP_TCAM_S2m_UDFD7_VLDf_SET(r,f) (r).cfp_tcam_s2[11]=(((r).cfp_tcam_s2[11] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_CFP_TCAM_S2m_RESVDf_GET(r) ((((r).cfp_tcam_s2[11]) >> 10) & 0x3ffff)
#define BCM53262_A0_CFP_TCAM_S2m_RESVDf_SET(r,f) (r).cfp_tcam_s2[11]=(((r).cfp_tcam_s2[11] & ~((uint32_t)0x3ffff << 10)) | ((((uint32_t)f) & 0x3ffff) << 10))
#define BCM53262_A0_CFP_TCAM_S2m_VALID_Rf_GET(r) ((((r).cfp_tcam_s2[11]) >> 28) & 0xf)
#define BCM53262_A0_CFP_TCAM_S2m_VALID_Rf_SET(r,f) (r).cfp_tcam_s2[11]=(((r).cfp_tcam_s2[11] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CFP_TCAM_S2.
 */
#define BCM53262_A0_READ_CFP_TCAM_S2m(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_CFP_TCAM_S2m,i,(m),48)
#define BCM53262_A0_WRITE_CFP_TCAM_S2m(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_CFP_TCAM_S2m,i,&(m),48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_S2m BCM53262_A0_CFP_TCAM_S2m
#define CFP_TCAM_S2m_MIN BCM53262_A0_CFP_TCAM_S2m_MIN
#define CFP_TCAM_S2m_MAX BCM53262_A0_CFP_TCAM_S2m_MAX
#define CFP_TCAM_S2m_CMAX(u) BCM53262_A0_CFP_TCAM_S2m_CMAX(u)
#define CFP_TCAM_S2m_SIZE BCM53262_A0_CFP_TCAM_S2m_SIZE
typedef BCM53262_A0_CFP_TCAM_S2m_t CFP_TCAM_S2m_t;
#define CFP_TCAM_S2m_CLR BCM53262_A0_CFP_TCAM_S2m_CLR
#define CFP_TCAM_S2m_SET BCM53262_A0_CFP_TCAM_S2m_SET
#define CFP_TCAM_S2m_GET BCM53262_A0_CFP_TCAM_S2m_GET
#define CFP_TCAM_S2m_SLICEIDf_GET BCM53262_A0_CFP_TCAM_S2m_SLICEIDf_GET
#define CFP_TCAM_S2m_SLICEIDf_SET BCM53262_A0_CFP_TCAM_S2m_SLICEIDf_SET
#define CFP_TCAM_S2m_IN_PBMPf_GET BCM53262_A0_CFP_TCAM_S2m_IN_PBMPf_GET
#define CFP_TCAM_S2m_IN_PBMPf_SET BCM53262_A0_CFP_TCAM_S2m_IN_PBMPf_SET
#define CFP_TCAM_S2m_SPTAGGEDf_GET BCM53262_A0_CFP_TCAM_S2m_SPTAGGEDf_GET
#define CFP_TCAM_S2m_SPTAGGEDf_SET BCM53262_A0_CFP_TCAM_S2m_SPTAGGEDf_SET
#define CFP_TCAM_S2m_VLANTAGGEDf_GET BCM53262_A0_CFP_TCAM_S2m_VLANTAGGEDf_GET
#define CFP_TCAM_S2m_VLANTAGGEDf_SET BCM53262_A0_CFP_TCAM_S2m_VLANTAGGEDf_SET
#define CFP_TCAM_S2m_L2_FORMATf_GET BCM53262_A0_CFP_TCAM_S2m_L2_FORMATf_GET
#define CFP_TCAM_S2m_L2_FORMATf_SET BCM53262_A0_CFP_TCAM_S2m_L2_FORMATf_SET
#define CFP_TCAM_S2m_L3_FORMATf_GET BCM53262_A0_CFP_TCAM_S2m_L3_FORMATf_GET
#define CFP_TCAM_S2m_L3_FORMATf_SET BCM53262_A0_CFP_TCAM_S2m_L3_FORMATf_SET
#define CFP_TCAM_S2m_L4_FORMATf_GET BCM53262_A0_CFP_TCAM_S2m_L4_FORMATf_GET
#define CFP_TCAM_S2m_L4_FORMATf_SET BCM53262_A0_CFP_TCAM_S2m_L4_FORMATf_SET
#define CFP_TCAM_S2m_VLAN_RANGEf_GET BCM53262_A0_CFP_TCAM_S2m_VLAN_RANGEf_GET
#define CFP_TCAM_S2m_VLAN_RANGEf_SET BCM53262_A0_CFP_TCAM_S2m_VLAN_RANGEf_SET
#define CFP_TCAM_S2m_L4_PORT_RANGEf_GET BCM53262_A0_CFP_TCAM_S2m_L4_PORT_RANGEf_GET
#define CFP_TCAM_S2m_L4_PORT_RANGEf_SET BCM53262_A0_CFP_TCAM_S2m_L4_PORT_RANGEf_SET
#define CFP_TCAM_S2m_UDFC0f_GET BCM53262_A0_CFP_TCAM_S2m_UDFC0f_GET
#define CFP_TCAM_S2m_UDFC0f_SET BCM53262_A0_CFP_TCAM_S2m_UDFC0f_SET
#define CFP_TCAM_S2m_UDFC0_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFC0_VLDf_GET
#define CFP_TCAM_S2m_UDFC0_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFC0_VLDf_SET
#define CFP_TCAM_S2m_UDFC1f_GET BCM53262_A0_CFP_TCAM_S2m_UDFC1f_GET
#define CFP_TCAM_S2m_UDFC1f_SET BCM53262_A0_CFP_TCAM_S2m_UDFC1f_SET
#define CFP_TCAM_S2m_UDFC1_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFC1_VLDf_GET
#define CFP_TCAM_S2m_UDFC1_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFC1_VLDf_SET
#define CFP_TCAM_S2m_UDFC2f_GET BCM53262_A0_CFP_TCAM_S2m_UDFC2f_GET
#define CFP_TCAM_S2m_UDFC2f_SET BCM53262_A0_CFP_TCAM_S2m_UDFC2f_SET
#define CFP_TCAM_S2m_UDFC2_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFC2_VLDf_GET
#define CFP_TCAM_S2m_UDFC2_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFC2_VLDf_SET
#define CFP_TCAM_S2m_UDFD0f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD0f_GET
#define CFP_TCAM_S2m_UDFD0f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD0f_SET
#define CFP_TCAM_S2m_UDFD0_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD0_VLDf_GET
#define CFP_TCAM_S2m_UDFD0_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD0_VLDf_SET
#define CFP_TCAM_S2m_UDFD1f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD1f_GET
#define CFP_TCAM_S2m_UDFD1f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD1f_SET
#define CFP_TCAM_S2m_UDFD1_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD1_VLDf_GET
#define CFP_TCAM_S2m_UDFD1_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD1_VLDf_SET
#define CFP_TCAM_S2m_UDFD2f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD2f_GET
#define CFP_TCAM_S2m_UDFD2f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD2f_SET
#define CFP_TCAM_S2m_UDFD2_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD2_VLDf_GET
#define CFP_TCAM_S2m_UDFD2_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD2_VLDf_SET
#define CFP_TCAM_S2m_UDFD3f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD3f_GET
#define CFP_TCAM_S2m_UDFD3f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD3f_SET
#define CFP_TCAM_S2m_UDFD3_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD3_VLDf_GET
#define CFP_TCAM_S2m_UDFD3_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD3_VLDf_SET
#define CFP_TCAM_S2m_UDFD4f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD4f_GET
#define CFP_TCAM_S2m_UDFD4f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD4f_SET
#define CFP_TCAM_S2m_UDFD4_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD4_VLDf_GET
#define CFP_TCAM_S2m_UDFD4_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD4_VLDf_SET
#define CFP_TCAM_S2m_UDFD5f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD5f_GET
#define CFP_TCAM_S2m_UDFD5f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD5f_SET
#define CFP_TCAM_S2m_UDFD5_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD5_VLDf_GET
#define CFP_TCAM_S2m_UDFD5_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD5_VLDf_SET
#define CFP_TCAM_S2m_UDFD6f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD6f_GET
#define CFP_TCAM_S2m_UDFD6f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD6f_SET
#define CFP_TCAM_S2m_UDFD6_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD6_VLDf_GET
#define CFP_TCAM_S2m_UDFD6_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD6_VLDf_SET
#define CFP_TCAM_S2m_UDFD7f_GET BCM53262_A0_CFP_TCAM_S2m_UDFD7f_GET
#define CFP_TCAM_S2m_UDFD7f_SET BCM53262_A0_CFP_TCAM_S2m_UDFD7f_SET
#define CFP_TCAM_S2m_UDFD7_VLDf_GET BCM53262_A0_CFP_TCAM_S2m_UDFD7_VLDf_GET
#define CFP_TCAM_S2m_UDFD7_VLDf_SET BCM53262_A0_CFP_TCAM_S2m_UDFD7_VLDf_SET
#define CFP_TCAM_S2m_RESVDf_GET BCM53262_A0_CFP_TCAM_S2m_RESVDf_GET
#define CFP_TCAM_S2m_RESVDf_SET BCM53262_A0_CFP_TCAM_S2m_RESVDf_SET
#define CFP_TCAM_S2m_VALID_Rf_GET BCM53262_A0_CFP_TCAM_S2m_VALID_Rf_GET
#define CFP_TCAM_S2m_VALID_Rf_SET BCM53262_A0_CFP_TCAM_S2m_VALID_Rf_SET
#define READ_CFP_TCAM_S2m BCM53262_A0_READ_CFP_TCAM_S2m
#define WRITE_CFP_TCAM_S2m BCM53262_A0_WRITE_CFP_TCAM_S2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_TCAM_S2m'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_UDF_A
 * BLOCKS:   SYS
 * DESC:     CFP User define A control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_A_OFFSET     The offset used for UDF_Ax which is used in slice 0. The number is counting from the reference port of frame.  Rx port will extract 16 bits data from the corresponding location for CFP lookup.UNIT : 16-bit (2-byte)
 *     UDF_A_REF        Based flag to select the base address is starting from : - 00: End of Tag, - 01: End of EtherType, - 10: End of IP header (including IPv4 option)- 11: Reserved.
 */
#define BCM53262_A0_CFP_UDF_Ar 0x00002200

#define BCM53262_A0_CFP_UDF_Ar_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_A.
 */
typedef union BCM53262_A0_CFP_UDF_Ar_s {
	uint32_t v[1];
	uint32_t cfp_udf_a[1];
	uint32_t _cfp_udf_a;
} BCM53262_A0_CFP_UDF_Ar_t;

#define BCM53262_A0_CFP_UDF_Ar_CLR(r) (r).cfp_udf_a[0] = 0
#define BCM53262_A0_CFP_UDF_Ar_SET(r,d) (r).cfp_udf_a[0] = d
#define BCM53262_A0_CFP_UDF_Ar_GET(r) (r).cfp_udf_a[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_UDF_Ar_UDF_A_OFFSETf_GET(r) (((r).cfp_udf_a[0]) & 0x3f)
#define BCM53262_A0_CFP_UDF_Ar_UDF_A_OFFSETf_SET(r,f) (r).cfp_udf_a[0]=(((r).cfp_udf_a[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_CFP_UDF_Ar_UDF_A_REFf_GET(r) ((((r).cfp_udf_a[0]) >> 6) & 0x3)
#define BCM53262_A0_CFP_UDF_Ar_UDF_A_REFf_SET(r,f) (r).cfp_udf_a[0]=(((r).cfp_udf_a[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access CFP_UDF_A.
 */
#define BCM53262_A0_READ_CFP_UDF_Ar(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_UDF_Ar+(1*(i)),(r._cfp_udf_a),1)
#define BCM53262_A0_WRITE_CFP_UDF_Ar(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_UDF_Ar+(1*(i)),&(r._cfp_udf_a),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_Ar BCM53262_A0_CFP_UDF_Ar
#define CFP_UDF_Ar_SIZE BCM53262_A0_CFP_UDF_Ar_SIZE
typedef BCM53262_A0_CFP_UDF_Ar_t CFP_UDF_Ar_t;
#define CFP_UDF_Ar_CLR BCM53262_A0_CFP_UDF_Ar_CLR
#define CFP_UDF_Ar_SET BCM53262_A0_CFP_UDF_Ar_SET
#define CFP_UDF_Ar_GET BCM53262_A0_CFP_UDF_Ar_GET
#define CFP_UDF_Ar_UDF_A_OFFSETf_GET BCM53262_A0_CFP_UDF_Ar_UDF_A_OFFSETf_GET
#define CFP_UDF_Ar_UDF_A_OFFSETf_SET BCM53262_A0_CFP_UDF_Ar_UDF_A_OFFSETf_SET
#define CFP_UDF_Ar_UDF_A_REFf_GET BCM53262_A0_CFP_UDF_Ar_UDF_A_REFf_GET
#define CFP_UDF_Ar_UDF_A_REFf_SET BCM53262_A0_CFP_UDF_Ar_UDF_A_REFf_SET
#define READ_CFP_UDF_Ar BCM53262_A0_READ_CFP_UDF_Ar
#define WRITE_CFP_UDF_Ar BCM53262_A0_WRITE_CFP_UDF_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_UDF_Ar'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_UDF_B
 * BLOCKS:   SYS
 * DESC:     CFP User define B control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_B_OFFSET     The offset used for UDF_Bx which is used in slice 1. The number is counting from the reference port of frame.  Rx port will extract 16 bits data from the corresponding location for CFP lookup.UNIT : 16-bit (2-byte)
 *     UDF_B_REF        Based flag to select the base address is starting from : - 00: End of Tag, - 01: End of EtherType, - 10: End of IP header (including IPv4 option)- 11: Reserved.
 */
#define BCM53262_A0_CFP_UDF_Br 0x00002210

#define BCM53262_A0_CFP_UDF_Br_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_B.
 */
typedef union BCM53262_A0_CFP_UDF_Br_s {
	uint32_t v[1];
	uint32_t cfp_udf_b[1];
	uint32_t _cfp_udf_b;
} BCM53262_A0_CFP_UDF_Br_t;

#define BCM53262_A0_CFP_UDF_Br_CLR(r) (r).cfp_udf_b[0] = 0
#define BCM53262_A0_CFP_UDF_Br_SET(r,d) (r).cfp_udf_b[0] = d
#define BCM53262_A0_CFP_UDF_Br_GET(r) (r).cfp_udf_b[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_UDF_Br_UDF_B_OFFSETf_GET(r) (((r).cfp_udf_b[0]) & 0x3f)
#define BCM53262_A0_CFP_UDF_Br_UDF_B_OFFSETf_SET(r,f) (r).cfp_udf_b[0]=(((r).cfp_udf_b[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_CFP_UDF_Br_UDF_B_REFf_GET(r) ((((r).cfp_udf_b[0]) >> 6) & 0x3)
#define BCM53262_A0_CFP_UDF_Br_UDF_B_REFf_SET(r,f) (r).cfp_udf_b[0]=(((r).cfp_udf_b[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access CFP_UDF_B.
 */
#define BCM53262_A0_READ_CFP_UDF_Br(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_UDF_Br+(1*(i)),(r._cfp_udf_b),1)
#define BCM53262_A0_WRITE_CFP_UDF_Br(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_UDF_Br+(1*(i)),&(r._cfp_udf_b),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_Br BCM53262_A0_CFP_UDF_Br
#define CFP_UDF_Br_SIZE BCM53262_A0_CFP_UDF_Br_SIZE
typedef BCM53262_A0_CFP_UDF_Br_t CFP_UDF_Br_t;
#define CFP_UDF_Br_CLR BCM53262_A0_CFP_UDF_Br_CLR
#define CFP_UDF_Br_SET BCM53262_A0_CFP_UDF_Br_SET
#define CFP_UDF_Br_GET BCM53262_A0_CFP_UDF_Br_GET
#define CFP_UDF_Br_UDF_B_OFFSETf_GET BCM53262_A0_CFP_UDF_Br_UDF_B_OFFSETf_GET
#define CFP_UDF_Br_UDF_B_OFFSETf_SET BCM53262_A0_CFP_UDF_Br_UDF_B_OFFSETf_SET
#define CFP_UDF_Br_UDF_B_REFf_GET BCM53262_A0_CFP_UDF_Br_UDF_B_REFf_GET
#define CFP_UDF_Br_UDF_B_REFf_SET BCM53262_A0_CFP_UDF_Br_UDF_B_REFf_SET
#define READ_CFP_UDF_Br BCM53262_A0_READ_CFP_UDF_Br
#define WRITE_CFP_UDF_Br BCM53262_A0_WRITE_CFP_UDF_Br

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_UDF_Br'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_UDF_C
 * BLOCKS:   SYS
 * DESC:     CFP User define C control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_C_OFFSET     The offset used for UDF_Cx which is used in slice 2. The number is counting from the reference port of frame.  Rx port will extract 16 bits data from the corresponding location for CFP lookup.UNIT : 16-bit (2-byte)
 *     UDF_C_REF        Based flag to select the base address is starting from : - 00: End of Tag, - 01: End of EtherType, - 10: End of IP header (including IPv4 option)- 11: Reserved.
 */
#define BCM53262_A0_CFP_UDF_Cr 0x00002220

#define BCM53262_A0_CFP_UDF_Cr_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_C.
 */
typedef union BCM53262_A0_CFP_UDF_Cr_s {
	uint32_t v[1];
	uint32_t cfp_udf_c[1];
	uint32_t _cfp_udf_c;
} BCM53262_A0_CFP_UDF_Cr_t;

#define BCM53262_A0_CFP_UDF_Cr_CLR(r) (r).cfp_udf_c[0] = 0
#define BCM53262_A0_CFP_UDF_Cr_SET(r,d) (r).cfp_udf_c[0] = d
#define BCM53262_A0_CFP_UDF_Cr_GET(r) (r).cfp_udf_c[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_UDF_Cr_UDF_C_OFFSETf_GET(r) (((r).cfp_udf_c[0]) & 0x3f)
#define BCM53262_A0_CFP_UDF_Cr_UDF_C_OFFSETf_SET(r,f) (r).cfp_udf_c[0]=(((r).cfp_udf_c[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_CFP_UDF_Cr_UDF_C_REFf_GET(r) ((((r).cfp_udf_c[0]) >> 6) & 0x3)
#define BCM53262_A0_CFP_UDF_Cr_UDF_C_REFf_SET(r,f) (r).cfp_udf_c[0]=(((r).cfp_udf_c[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access CFP_UDF_C.
 */
#define BCM53262_A0_READ_CFP_UDF_Cr(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_UDF_Cr+(1*(i)),(r._cfp_udf_c),1)
#define BCM53262_A0_WRITE_CFP_UDF_Cr(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_UDF_Cr+(1*(i)),&(r._cfp_udf_c),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_Cr BCM53262_A0_CFP_UDF_Cr
#define CFP_UDF_Cr_SIZE BCM53262_A0_CFP_UDF_Cr_SIZE
typedef BCM53262_A0_CFP_UDF_Cr_t CFP_UDF_Cr_t;
#define CFP_UDF_Cr_CLR BCM53262_A0_CFP_UDF_Cr_CLR
#define CFP_UDF_Cr_SET BCM53262_A0_CFP_UDF_Cr_SET
#define CFP_UDF_Cr_GET BCM53262_A0_CFP_UDF_Cr_GET
#define CFP_UDF_Cr_UDF_C_OFFSETf_GET BCM53262_A0_CFP_UDF_Cr_UDF_C_OFFSETf_GET
#define CFP_UDF_Cr_UDF_C_OFFSETf_SET BCM53262_A0_CFP_UDF_Cr_UDF_C_OFFSETf_SET
#define CFP_UDF_Cr_UDF_C_REFf_GET BCM53262_A0_CFP_UDF_Cr_UDF_C_REFf_GET
#define CFP_UDF_Cr_UDF_C_REFf_SET BCM53262_A0_CFP_UDF_Cr_UDF_C_REFf_SET
#define READ_CFP_UDF_Cr BCM53262_A0_READ_CFP_UDF_Cr
#define WRITE_CFP_UDF_Cr BCM53262_A0_WRITE_CFP_UDF_Cr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_UDF_Cr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CFP_UDF_D
 * BLOCKS:   SYS
 * DESC:     CFP User define D control  Registers
 * SIZE:     8
 * FIELDS:
 *     UDF_D_OFFSET     The offset used for UDF_Cx which is used in slice 2. The number is counting from the reference port of frame.  Rx port will extract 32 bits data from the corresponding location for CFP lookup.UNIT : 32-bit (4-byte)
 *     UDF_D_REF        Based flag to select the base address is starting from : - 00: End of Tag, - 01: End of EtherType, - 10: End of IP header (including IPv4 option)- 11: Reserved.
 */
#define BCM53262_A0_CFP_UDF_Dr 0x00002230

#define BCM53262_A0_CFP_UDF_Dr_SIZE 1

/*
 * This structure should be used to declare and program CFP_UDF_D.
 */
typedef union BCM53262_A0_CFP_UDF_Dr_s {
	uint32_t v[1];
	uint32_t cfp_udf_d[1];
	uint32_t _cfp_udf_d;
} BCM53262_A0_CFP_UDF_Dr_t;

#define BCM53262_A0_CFP_UDF_Dr_CLR(r) (r).cfp_udf_d[0] = 0
#define BCM53262_A0_CFP_UDF_Dr_SET(r,d) (r).cfp_udf_d[0] = d
#define BCM53262_A0_CFP_UDF_Dr_GET(r) (r).cfp_udf_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CFP_UDF_Dr_UDF_D_OFFSETf_GET(r) (((r).cfp_udf_d[0]) & 0x3f)
#define BCM53262_A0_CFP_UDF_Dr_UDF_D_OFFSETf_SET(r,f) (r).cfp_udf_d[0]=(((r).cfp_udf_d[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_CFP_UDF_Dr_UDF_D_REFf_GET(r) ((((r).cfp_udf_d[0]) >> 6) & 0x3)
#define BCM53262_A0_CFP_UDF_Dr_UDF_D_REFf_SET(r,f) (r).cfp_udf_d[0]=(((r).cfp_udf_d[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access CFP_UDF_D.
 */
#define BCM53262_A0_READ_CFP_UDF_Dr(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_CFP_UDF_Dr+(1*(i)),(r._cfp_udf_d),1)
#define BCM53262_A0_WRITE_CFP_UDF_Dr(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_CFP_UDF_Dr+(1*(i)),&(r._cfp_udf_d),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_UDF_Dr BCM53262_A0_CFP_UDF_Dr
#define CFP_UDF_Dr_SIZE BCM53262_A0_CFP_UDF_Dr_SIZE
typedef BCM53262_A0_CFP_UDF_Dr_t CFP_UDF_Dr_t;
#define CFP_UDF_Dr_CLR BCM53262_A0_CFP_UDF_Dr_CLR
#define CFP_UDF_Dr_SET BCM53262_A0_CFP_UDF_Dr_SET
#define CFP_UDF_Dr_GET BCM53262_A0_CFP_UDF_Dr_GET
#define CFP_UDF_Dr_UDF_D_OFFSETf_GET BCM53262_A0_CFP_UDF_Dr_UDF_D_OFFSETf_GET
#define CFP_UDF_Dr_UDF_D_OFFSETf_SET BCM53262_A0_CFP_UDF_Dr_UDF_D_OFFSETf_SET
#define CFP_UDF_Dr_UDF_D_REFf_GET BCM53262_A0_CFP_UDF_Dr_UDF_D_REFf_GET
#define CFP_UDF_Dr_UDF_D_REFf_SET BCM53262_A0_CFP_UDF_Dr_UDF_D_REFf_SET
#define READ_CFP_UDF_Dr BCM53262_A0_READ_CFP_UDF_Dr
#define WRITE_CFP_UDF_Dr BCM53262_A0_WRITE_CFP_UDF_Dr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CFP_UDF_Dr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CHIP_RST_CTL
 * BLOCKS:   SYS
 * DESC:     FULL Chip Reset Control Register
 * SIZE:     8
 * FIELDS:
 *     RST_CHIP         Write 1'b1 to reset the full chip.
 *     RESERVED_0R      Reserved.
 *     CLR_BUFCON_ONLY  Internal use only.
 *     RST_SWITCH       Internal use only.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_CHIP_RST_CTLr 0x0000037c

#define BCM53262_A0_CHIP_RST_CTLr_SIZE 1

/*
 * This structure should be used to declare and program CHIP_RST_CTL.
 */
typedef union BCM53262_A0_CHIP_RST_CTLr_s {
	uint32_t v[1];
	uint32_t chip_rst_ctl[1];
	uint32_t _chip_rst_ctl;
} BCM53262_A0_CHIP_RST_CTLr_t;

#define BCM53262_A0_CHIP_RST_CTLr_CLR(r) (r).chip_rst_ctl[0] = 0
#define BCM53262_A0_CHIP_RST_CTLr_SET(r,d) (r).chip_rst_ctl[0] = d
#define BCM53262_A0_CHIP_RST_CTLr_GET(r) (r).chip_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CHIP_RST_CTLr_RST_CHIPf_GET(r) (((r).chip_rst_ctl[0]) & 0x1)
#define BCM53262_A0_CHIP_RST_CTLr_RST_CHIPf_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_CHIP_RST_CTLr_RESERVED_0Rf_GET(r) ((((r).chip_rst_ctl[0]) >> 1) & 0x7)
#define BCM53262_A0_CHIP_RST_CTLr_RESERVED_0Rf_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53262_A0_CHIP_RST_CTLr_CLR_BUFCON_ONLYf_GET(r) ((((r).chip_rst_ctl[0]) >> 4) & 0x1)
#define BCM53262_A0_CHIP_RST_CTLr_CLR_BUFCON_ONLYf_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_CHIP_RST_CTLr_RST_SWITCHf_GET(r) ((((r).chip_rst_ctl[0]) >> 5) & 0x1)
#define BCM53262_A0_CHIP_RST_CTLr_RST_SWITCHf_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_CHIP_RST_CTLr_RESERVED_1Rf_GET(r) ((((r).chip_rst_ctl[0]) >> 6) & 0x3)
#define BCM53262_A0_CHIP_RST_CTLr_RESERVED_1Rf_SET(r,f) (r).chip_rst_ctl[0]=(((r).chip_rst_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access CHIP_RST_CTL.
 */
#define BCM53262_A0_READ_CHIP_RST_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_CHIP_RST_CTLr,(r._chip_rst_ctl),1)
#define BCM53262_A0_WRITE_CHIP_RST_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_CHIP_RST_CTLr,&(r._chip_rst_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CHIP_RST_CTLr BCM53262_A0_CHIP_RST_CTLr
#define CHIP_RST_CTLr_SIZE BCM53262_A0_CHIP_RST_CTLr_SIZE
typedef BCM53262_A0_CHIP_RST_CTLr_t CHIP_RST_CTLr_t;
#define CHIP_RST_CTLr_CLR BCM53262_A0_CHIP_RST_CTLr_CLR
#define CHIP_RST_CTLr_SET BCM53262_A0_CHIP_RST_CTLr_SET
#define CHIP_RST_CTLr_GET BCM53262_A0_CHIP_RST_CTLr_GET
#define CHIP_RST_CTLr_RST_CHIPf_GET BCM53262_A0_CHIP_RST_CTLr_RST_CHIPf_GET
#define CHIP_RST_CTLr_RST_CHIPf_SET BCM53262_A0_CHIP_RST_CTLr_RST_CHIPf_SET
#define CHIP_RST_CTLr_RESERVED_0Rf_GET BCM53262_A0_CHIP_RST_CTLr_RESERVED_0Rf_GET
#define CHIP_RST_CTLr_RESERVED_0Rf_SET BCM53262_A0_CHIP_RST_CTLr_RESERVED_0Rf_SET
#define CHIP_RST_CTLr_CLR_BUFCON_ONLYf_GET BCM53262_A0_CHIP_RST_CTLr_CLR_BUFCON_ONLYf_GET
#define CHIP_RST_CTLr_CLR_BUFCON_ONLYf_SET BCM53262_A0_CHIP_RST_CTLr_CLR_BUFCON_ONLYf_SET
#define CHIP_RST_CTLr_RST_SWITCHf_GET BCM53262_A0_CHIP_RST_CTLr_RST_SWITCHf_GET
#define CHIP_RST_CTLr_RST_SWITCHf_SET BCM53262_A0_CHIP_RST_CTLr_RST_SWITCHf_SET
#define CHIP_RST_CTLr_RESERVED_1Rf_GET BCM53262_A0_CHIP_RST_CTLr_RESERVED_1Rf_GET
#define CHIP_RST_CTLr_RESERVED_1Rf_SET BCM53262_A0_CHIP_RST_CTLr_RESERVED_1Rf_SET
#define READ_CHIP_RST_CTLr BCM53262_A0_READ_CHIP_RST_CTLr
#define WRITE_CHIP_RST_CTLr BCM53262_A0_WRITE_CHIP_RST_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CHIP_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  CRC16_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port SGMII CRC16 Register
 * SIZE:     16
 * FIELDS:
 *     SGMII_CRC16      Send 16 bit CRC value.It will be cleared by crc16_clear_n or during the preamble in the next packet.Calculation is valid for GMII/MII packets with preamble and SFD.
 */
#define BCM53262_A0_CRC16_GPr 0x00190d5c

#define BCM53262_A0_CRC16_GPr_SIZE 2

/*
 * This structure should be used to declare and program CRC16_GP.
 */
typedef union BCM53262_A0_CRC16_GPr_s {
	uint32_t v[1];
	uint32_t crc16_gp[1];
	uint32_t _crc16_gp;
} BCM53262_A0_CRC16_GPr_t;

#define BCM53262_A0_CRC16_GPr_CLR(r) (r).crc16_gp[0] = 0
#define BCM53262_A0_CRC16_GPr_SET(r,d) (r).crc16_gp[0] = d
#define BCM53262_A0_CRC16_GPr_GET(r) (r).crc16_gp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_CRC16_GPr_SGMII_CRC16f_GET(r) (((r).crc16_gp[0]) & 0xffff)
#define BCM53262_A0_CRC16_GPr_SGMII_CRC16f_SET(r,f) (r).crc16_gp[0]=(((r).crc16_gp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CRC16_GP.
 */
#define BCM53262_A0_READ_CRC16_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_CRC16_GPr,(r._crc16_gp),2)
#define BCM53262_A0_WRITE_CRC16_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_CRC16_GPr,&(r._crc16_gp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CRC16_GPr BCM53262_A0_CRC16_GPr
#define CRC16_GPr_SIZE BCM53262_A0_CRC16_GPr_SIZE
typedef BCM53262_A0_CRC16_GPr_t CRC16_GPr_t;
#define CRC16_GPr_CLR BCM53262_A0_CRC16_GPr_CLR
#define CRC16_GPr_SET BCM53262_A0_CRC16_GPr_SET
#define CRC16_GPr_GET BCM53262_A0_CRC16_GPr_GET
#define CRC16_GPr_SGMII_CRC16f_GET BCM53262_A0_CRC16_GPr_SGMII_CRC16f_GET
#define CRC16_GPr_SGMII_CRC16f_SET BCM53262_A0_CRC16_GPr_SGMII_CRC16f_SET
#define READ_CRC16_GPr BCM53262_A0_READ_CRC16_GPr
#define WRITE_CRC16_GPr BCM53262_A0_WRITE_CRC16_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_CRC16_GPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  DEBUG_REG
 * BLOCKS:   SYS
 * DESC:     Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     DBG_SEL          debug_sel[5:1] : bus selection00000 : p24_tvrx1(temp)00100 : p24_tvrx2(temp)01000 : p24_tvrx3(temp)01100 : p24_tvtx1(temp)10000 : p24_tvtx2(temp)00001 : p48_tvrx100101 : p48_tvrx201001 : p48_tvrx301101 : p48_tvtx110001 : p48_tvtx200010 : p49_tvrx100110 : p49_tvrx201010 : p49_tvrx301110 : p49_tvtx110010 : p49_tvtx200011 : global_txq_wr_req00111 : global_txq_wr_gnt01011 : global_txq_rd_req01111 : global_txq_rd_gnt10011 : global_txq_rd_giga10111 : cfp_debug[23:0]11011 : cfp_debug[32:24]11111 : debug_trunkdebug_sel[0] :unused
 *     DBG_RESERVED     Reserved
 */
#define BCM53262_A0_DEBUG_REGr 0x0000001a

#define BCM53262_A0_DEBUG_REGr_SIZE 1

/*
 * This structure should be used to declare and program DEBUG_REG.
 */
typedef union BCM53262_A0_DEBUG_REGr_s {
	uint32_t v[1];
	uint32_t debug_reg[1];
	uint32_t _debug_reg;
} BCM53262_A0_DEBUG_REGr_t;

#define BCM53262_A0_DEBUG_REGr_CLR(r) (r).debug_reg[0] = 0
#define BCM53262_A0_DEBUG_REGr_SET(r,d) (r).debug_reg[0] = d
#define BCM53262_A0_DEBUG_REGr_GET(r) (r).debug_reg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_DEBUG_REGr_DBG_SELf_GET(r) (((r).debug_reg[0]) & 0x3f)
#define BCM53262_A0_DEBUG_REGr_DBG_SELf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_DEBUG_REGr_DBG_RESERVEDf_GET(r) ((((r).debug_reg[0]) >> 6) & 0x3)
#define BCM53262_A0_DEBUG_REGr_DBG_RESERVEDf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access DEBUG_REG.
 */
#define BCM53262_A0_READ_DEBUG_REGr(u,r) cdk_robo_reg_read(u,BCM53262_A0_DEBUG_REGr,(r._debug_reg),1)
#define BCM53262_A0_WRITE_DEBUG_REGr(u,r) cdk_robo_reg_write(u,BCM53262_A0_DEBUG_REGr,&(r._debug_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG_REGr BCM53262_A0_DEBUG_REGr
#define DEBUG_REGr_SIZE BCM53262_A0_DEBUG_REGr_SIZE
typedef BCM53262_A0_DEBUG_REGr_t DEBUG_REGr_t;
#define DEBUG_REGr_CLR BCM53262_A0_DEBUG_REGr_CLR
#define DEBUG_REGr_SET BCM53262_A0_DEBUG_REGr_SET
#define DEBUG_REGr_GET BCM53262_A0_DEBUG_REGr_GET
#define DEBUG_REGr_DBG_SELf_GET BCM53262_A0_DEBUG_REGr_DBG_SELf_GET
#define DEBUG_REGr_DBG_SELf_SET BCM53262_A0_DEBUG_REGr_DBG_SELf_SET
#define DEBUG_REGr_DBG_RESERVEDf_GET BCM53262_A0_DEBUG_REGr_DBG_RESERVEDf_GET
#define DEBUG_REGr_DBG_RESERVEDf_SET BCM53262_A0_DEBUG_REGr_DBG_RESERVEDf_SET
#define READ_DEBUG_REGr BCM53262_A0_READ_DEBUG_REGr
#define WRITE_DEBUG_REGr BCM53262_A0_WRITE_DEBUG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_DEBUG_REGr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  DEBUG_STS
 * BLOCKS:   SYS
 * DESC:     Debug Status Register
 * SIZE:     24
 * FIELDS:
 *     DEBUS_STS        Debug Bus Status
 */
#define BCM53262_A0_DEBUG_STSr 0x0000001c

#define BCM53262_A0_DEBUG_STSr_SIZE 3

/*
 * This structure should be used to declare and program DEBUG_STS.
 */
typedef union BCM53262_A0_DEBUG_STSr_s {
	uint32_t v[1];
	uint32_t debug_sts[1];
	uint32_t _debug_sts;
} BCM53262_A0_DEBUG_STSr_t;

#define BCM53262_A0_DEBUG_STSr_CLR(r) (r).debug_sts[0] = 0
#define BCM53262_A0_DEBUG_STSr_SET(r,d) (r).debug_sts[0] = d
#define BCM53262_A0_DEBUG_STSr_GET(r) (r).debug_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_DEBUG_STSr_DEBUS_STSf_GET(r) (((r).debug_sts[0]) & 0xffffff)
#define BCM53262_A0_DEBUG_STSr_DEBUS_STSf_SET(r,f) (r).debug_sts[0]=(((r).debug_sts[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access DEBUG_STS.
 */
#define BCM53262_A0_READ_DEBUG_STSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_DEBUG_STSr,(r._debug_sts),3)
#define BCM53262_A0_WRITE_DEBUG_STSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_DEBUG_STSr,&(r._debug_sts),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG_STSr BCM53262_A0_DEBUG_STSr
#define DEBUG_STSr_SIZE BCM53262_A0_DEBUG_STSr_SIZE
typedef BCM53262_A0_DEBUG_STSr_t DEBUG_STSr_t;
#define DEBUG_STSr_CLR BCM53262_A0_DEBUG_STSr_CLR
#define DEBUG_STSr_SET BCM53262_A0_DEBUG_STSr_SET
#define DEBUG_STSr_GET BCM53262_A0_DEBUG_STSr_GET
#define DEBUG_STSr_DEBUS_STSf_GET BCM53262_A0_DEBUG_STSr_DEBUS_STSf_GET
#define DEBUG_STSr_DEBUS_STSf_SET BCM53262_A0_DEBUG_STSr_DEBUS_STSf_SET
#define READ_DEBUG_STSr BCM53262_A0_READ_DEBUG_STSr
#define WRITE_DEBUG_STSr BCM53262_A0_WRITE_DEBUG_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_DEBUG_STSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  DEFAULT_1Q_TAG
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     802.1Q Default Port Tag Registers
 * SIZE:     16
 * FIELDS:
 *     DEF_TAG          Deafult 802.1Q Tag for port x.
 */
#define BCM53262_A0_DEFAULT_1Q_TAGr 0x00003440

#define BCM53262_A0_DEFAULT_1Q_TAGr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG.
 */
typedef union BCM53262_A0_DEFAULT_1Q_TAGr_s {
	uint32_t v[1];
	uint32_t default_1q_tag[1];
	uint32_t _default_1q_tag;
} BCM53262_A0_DEFAULT_1Q_TAGr_t;

#define BCM53262_A0_DEFAULT_1Q_TAGr_CLR(r) (r).default_1q_tag[0] = 0
#define BCM53262_A0_DEFAULT_1Q_TAGr_SET(r,d) (r).default_1q_tag[0] = d
#define BCM53262_A0_DEFAULT_1Q_TAGr_GET(r) (r).default_1q_tag[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_DEFAULT_1Q_TAGr_DEF_TAGf_GET(r) (((r).default_1q_tag[0]) & 0xffff)
#define BCM53262_A0_DEFAULT_1Q_TAGr_DEF_TAGf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DEFAULT_1Q_TAG.
 */
#define BCM53262_A0_READ_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_DEFAULT_1Q_TAGr,(r._default_1q_tag),2)
#define BCM53262_A0_WRITE_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_DEFAULT_1Q_TAGr,&(r._default_1q_tag),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAGr BCM53262_A0_DEFAULT_1Q_TAGr
#define DEFAULT_1Q_TAGr_SIZE BCM53262_A0_DEFAULT_1Q_TAGr_SIZE
typedef BCM53262_A0_DEFAULT_1Q_TAGr_t DEFAULT_1Q_TAGr_t;
#define DEFAULT_1Q_TAGr_CLR BCM53262_A0_DEFAULT_1Q_TAGr_CLR
#define DEFAULT_1Q_TAGr_SET BCM53262_A0_DEFAULT_1Q_TAGr_SET
#define DEFAULT_1Q_TAGr_GET BCM53262_A0_DEFAULT_1Q_TAGr_GET
#define DEFAULT_1Q_TAGr_DEF_TAGf_GET BCM53262_A0_DEFAULT_1Q_TAGr_DEF_TAGf_GET
#define DEFAULT_1Q_TAGr_DEF_TAGf_SET BCM53262_A0_DEFAULT_1Q_TAGr_DEF_TAGf_SET
#define READ_DEFAULT_1Q_TAGr BCM53262_A0_READ_DEFAULT_1Q_TAGr
#define WRITE_DEFAULT_1Q_TAGr BCM53262_A0_WRITE_DEFAULT_1Q_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_DEFAULT_1Q_TAGr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  DIAGNOSIS
 * BLOCKS:   SYS
 * DESC:     Diagnosis Registers
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_DIAGNOSISr 0x00000910

#define BCM53262_A0_DIAGNOSISr_SIZE 2

/*
 * This structure should be used to declare and program DIAGNOSIS.
 */
typedef union BCM53262_A0_DIAGNOSISr_s {
	uint32_t v[1];
	uint32_t diagnosis[1];
	uint32_t _diagnosis;
} BCM53262_A0_DIAGNOSISr_t;

#define BCM53262_A0_DIAGNOSISr_CLR(r) (r).diagnosis[0] = 0
#define BCM53262_A0_DIAGNOSISr_SET(r,d) (r).diagnosis[0] = d
#define BCM53262_A0_DIAGNOSISr_GET(r) (r).diagnosis[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_DIAGNOSISr_RESERVED_Rf_GET(r) (((r).diagnosis[0]) & 0xffff)
#define BCM53262_A0_DIAGNOSISr_RESERVED_Rf_SET(r,f) (r).diagnosis[0]=(((r).diagnosis[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DIAGNOSIS.
 */
#define BCM53262_A0_READ_DIAGNOSISr(u,r) cdk_robo_reg_read(u,BCM53262_A0_DIAGNOSISr,(r._diagnosis),2)
#define BCM53262_A0_WRITE_DIAGNOSISr(u,r) cdk_robo_reg_write(u,BCM53262_A0_DIAGNOSISr,&(r._diagnosis),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIAGNOSISr BCM53262_A0_DIAGNOSISr
#define DIAGNOSISr_SIZE BCM53262_A0_DIAGNOSISr_SIZE
typedef BCM53262_A0_DIAGNOSISr_t DIAGNOSISr_t;
#define DIAGNOSISr_CLR BCM53262_A0_DIAGNOSISr_CLR
#define DIAGNOSISr_SET BCM53262_A0_DIAGNOSISr_SET
#define DIAGNOSISr_GET BCM53262_A0_DIAGNOSISr_GET
#define DIAGNOSISr_RESERVED_Rf_GET BCM53262_A0_DIAGNOSISr_RESERVED_Rf_GET
#define DIAGNOSISr_RESERVED_Rf_SET BCM53262_A0_DIAGNOSISr_RESERVED_Rf_SET
#define READ_DIAGNOSISr BCM53262_A0_READ_DIAGNOSISr
#define WRITE_DIAGNOSISr BCM53262_A0_WRITE_DIAGNOSISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_DIAGNOSISr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  DTAG_GLO_CTL
 * BLOCKS:   SYS
 * DESC:     Global Double Tagging Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESV_MCAST_FLOOD When chip is at double tag mode and also in management mode.1 = the reserved mcast frame will be flood per the VLAN rule.0 = the reserved mcast frame will be trap to CPU.Note reserved mcast frame does noe include pause frame.We still need to honor pause frame.
 *     EN_DTAG_ISP      Enable double ISP tag.
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_DTAG_GLO_CTLr 0x00003490

#define BCM53262_A0_DTAG_GLO_CTLr_SIZE 1

/*
 * This structure should be used to declare and program DTAG_GLO_CTL.
 */
typedef union BCM53262_A0_DTAG_GLO_CTLr_s {
	uint32_t v[1];
	uint32_t dtag_glo_ctl[1];
	uint32_t _dtag_glo_ctl;
} BCM53262_A0_DTAG_GLO_CTLr_t;

#define BCM53262_A0_DTAG_GLO_CTLr_CLR(r) (r).dtag_glo_ctl[0] = 0
#define BCM53262_A0_DTAG_GLO_CTLr_SET(r,d) (r).dtag_glo_ctl[0] = d
#define BCM53262_A0_DTAG_GLO_CTLr_GET(r) (r).dtag_glo_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_DTAG_GLO_CTLr_RESV_MCAST_FLOODf_GET(r) (((r).dtag_glo_ctl[0]) & 0x1)
#define BCM53262_A0_DTAG_GLO_CTLr_RESV_MCAST_FLOODf_SET(r,f) (r).dtag_glo_ctl[0]=(((r).dtag_glo_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_DTAG_GLO_CTLr_EN_DTAG_ISPf_GET(r) ((((r).dtag_glo_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_DTAG_GLO_CTLr_EN_DTAG_ISPf_SET(r,f) (r).dtag_glo_ctl[0]=(((r).dtag_glo_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_DTAG_GLO_CTLr_RESERVED_Rf_GET(r) ((((r).dtag_glo_ctl[0]) >> 2) & 0x3f)
#define BCM53262_A0_DTAG_GLO_CTLr_RESERVED_Rf_SET(r,f) (r).dtag_glo_ctl[0]=(((r).dtag_glo_ctl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access DTAG_GLO_CTL.
 */
#define BCM53262_A0_READ_DTAG_GLO_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_DTAG_GLO_CTLr,(r._dtag_glo_ctl),1)
#define BCM53262_A0_WRITE_DTAG_GLO_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_DTAG_GLO_CTLr,&(r._dtag_glo_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DTAG_GLO_CTLr BCM53262_A0_DTAG_GLO_CTLr
#define DTAG_GLO_CTLr_SIZE BCM53262_A0_DTAG_GLO_CTLr_SIZE
typedef BCM53262_A0_DTAG_GLO_CTLr_t DTAG_GLO_CTLr_t;
#define DTAG_GLO_CTLr_CLR BCM53262_A0_DTAG_GLO_CTLr_CLR
#define DTAG_GLO_CTLr_SET BCM53262_A0_DTAG_GLO_CTLr_SET
#define DTAG_GLO_CTLr_GET BCM53262_A0_DTAG_GLO_CTLr_GET
#define DTAG_GLO_CTLr_RESV_MCAST_FLOODf_GET BCM53262_A0_DTAG_GLO_CTLr_RESV_MCAST_FLOODf_GET
#define DTAG_GLO_CTLr_RESV_MCAST_FLOODf_SET BCM53262_A0_DTAG_GLO_CTLr_RESV_MCAST_FLOODf_SET
#define DTAG_GLO_CTLr_EN_DTAG_ISPf_GET BCM53262_A0_DTAG_GLO_CTLr_EN_DTAG_ISPf_GET
#define DTAG_GLO_CTLr_EN_DTAG_ISPf_SET BCM53262_A0_DTAG_GLO_CTLr_EN_DTAG_ISPf_SET
#define DTAG_GLO_CTLr_RESERVED_Rf_GET BCM53262_A0_DTAG_GLO_CTLr_RESERVED_Rf_GET
#define DTAG_GLO_CTLr_RESERVED_Rf_SET BCM53262_A0_DTAG_GLO_CTLr_RESERVED_Rf_SET
#define READ_DTAG_GLO_CTLr BCM53262_A0_READ_DTAG_GLO_CTLr
#define WRITE_DTAG_GLO_CTLr BCM53262_A0_WRITE_DTAG_GLO_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_DTAG_GLO_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  DUPSTS
 * BLOCKS:   SYS
 * DESC:     Duplex status SummaryRegister
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     DUP_STS          Duplex State.53 bit field indicating the half/full duplex state for each 10/100BASE-T port and the IMP port and two giga port g0, g1(bits 0-47 = 10/ 100BASE-T ports, bit 48 = MII Port, bit 49 = Giga port go, bit 50 = Giga port g1, bit 51 = Giga port g2, bit 52 = Giga port g3).0 = Half Duplex1 = Full DuplexNote that duplex state for the IMP port can only be reported for an external transceiver by:(a) using the FDX# strap option to pass the transceiver's default state to the BCM5348M:(b) using the CPU to read the half/full duplex state via the MDC/MDIO interface and write this back to the MII Port Status Override register.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_DUPSTSr 0x00000228

#define BCM53262_A0_DUPSTSr_SIZE 8

/*
 * This structure should be used to declare and program DUPSTS.
 */
typedef union BCM53262_A0_DUPSTSr_s {
	uint32_t v[2];
	uint32_t dupsts[2];
	uint32_t _dupsts;
} BCM53262_A0_DUPSTSr_t;

#define BCM53262_A0_DUPSTSr_CLR(r) CDK_MEMSET(&((r)._dupsts), 0, sizeof(BCM53262_A0_DUPSTSr_t))
#define BCM53262_A0_DUPSTSr_SET(r,i,d) (r).dupsts[i] = d
#define BCM53262_A0_DUPSTSr_GET(r,i) (r).dupsts[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_DUPSTSr_RESERVED_0Rf_GET(r) (((r).dupsts[0]) & 0xffffff)
#define BCM53262_A0_DUPSTSr_RESERVED_0Rf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_DUPSTSr_DUP_STSf_GET(r) cdk_field32_get((r).dupsts,24,52)
#define BCM53262_A0_DUPSTSr_DUP_STSf_SET(r,f) cdk_field32_set((r).dupsts,24,52,f)
#define BCM53262_A0_DUPSTSr_RESERVED_1Rf_GET(r) ((((r).dupsts[1]) >> 21) & 0x7ff)
#define BCM53262_A0_DUPSTSr_RESERVED_1Rf_SET(r,f) (r).dupsts[1]=(((r).dupsts[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access DUPSTS.
 */
#define BCM53262_A0_READ_DUPSTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_DUPSTSr,(r._dupsts),8)
#define BCM53262_A0_WRITE_DUPSTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_DUPSTSr,&(r._dupsts),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DUPSTSr BCM53262_A0_DUPSTSr
#define DUPSTSr_SIZE BCM53262_A0_DUPSTSr_SIZE
typedef BCM53262_A0_DUPSTSr_t DUPSTSr_t;
#define DUPSTSr_CLR BCM53262_A0_DUPSTSr_CLR
#define DUPSTSr_SET BCM53262_A0_DUPSTSr_SET
#define DUPSTSr_GET BCM53262_A0_DUPSTSr_GET
#define DUPSTSr_RESERVED_0Rf_GET BCM53262_A0_DUPSTSr_RESERVED_0Rf_GET
#define DUPSTSr_RESERVED_0Rf_SET BCM53262_A0_DUPSTSr_RESERVED_0Rf_SET
#define DUPSTSr_DUP_STSf_GET BCM53262_A0_DUPSTSr_DUP_STSf_GET
#define DUPSTSr_DUP_STSf_SET BCM53262_A0_DUPSTSr_DUP_STSf_SET
#define DUPSTSr_RESERVED_1Rf_GET BCM53262_A0_DUPSTSr_RESERVED_1Rf_GET
#define DUPSTSr_RESERVED_1Rf_SET BCM53262_A0_DUPSTSr_RESERVED_1Rf_SET
#define READ_DUPSTSr BCM53262_A0_READ_DUPSTSr
#define WRITE_DUPSTSr BCM53262_A0_WRITE_DUPSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_DUPSTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EAP_GLO_CON
 * BLOCKS:   SYS
 * DESC:     EAP Global Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     EN_EAP_PT_CHK    Option to control EAP packet checking.0 : Only check DA=01-80-c2-00-00-03 and user's DA. (default)1 : Full check, including DA, EtherType, Packet Type, non-1Q.
 *     EAP_GLO_CON_RSRV_0 Reserved
 *     EN_MAC_BPDU      Enable BPDU frame passed when EAP_BLK_MODE is set.
 *     EN_MAC_02_04_0F  Enable(DA=01-80-c2-00-00-02)or (DA=01-80-c2-00-00-04,03,....,0f) frame passed when EAP_BLK_MODE is set.
 *     EN_MAC_10        Enable(DA=01-80-c2-00-00-10) frame passed when EAP_BLK_MODE is set.
 *     EN_MAC_11_1F     Enable(DA=01-80-c2-00-00-11,12,....,1f) frame passed when EAP_BLK_MODE is set.
 *     EN_MAC_20        Enable(DA=01-80-c2-00-00-20) frame passed when EAP_BLK_MODE is set.
 *     EN_MAC_21        Enable(DA=01-80-c2-00-00-21) frame passed when EAP_BLK_MODE is set.
 *     EN_MAC_22_2F     Enable(DA=01-80-c2-00-00-22,23,....,2f) frame passed when EAP_BLK_MODE is set.
 *     EN_ARP           Enable ARP frame when EAP_BLK_MODE is setWhen set, ARP frame (DA=FF-FF-FF-FF-FF-FF & LT=08-06) will pass.
 *     EN_DIP_0         Enable Destination IP Address when EAP_BLK_MODE is set.When set, IPv4 packet with destination IP address matched with EAP Destination IP Register 0 will pass.
 *     EN_DIP_1         Enable Destination IP Address when EAP_BLK_MODE is set.When set, IPv4 packet with destination IP address matched with EAP Destination IP Register 1 will pass.
 *     EN_DHCP          optional bit enable DHCP frame when EAP_BLK_MODE is set1'b0 : reject DHCP frame.1'b1 : accept DHCP frame.
 *     EAP_GLO_CON_RSRV_1 Reserved
 */
#define BCM53262_A0_EAP_GLO_CONr 0x00004110

#define BCM53262_A0_EAP_GLO_CONr_SIZE 2

/*
 * This structure should be used to declare and program EAP_GLO_CON.
 */
typedef union BCM53262_A0_EAP_GLO_CONr_s {
	uint32_t v[1];
	uint32_t eap_glo_con[1];
	uint32_t _eap_glo_con;
} BCM53262_A0_EAP_GLO_CONr_t;

#define BCM53262_A0_EAP_GLO_CONr_CLR(r) (r).eap_glo_con[0] = 0
#define BCM53262_A0_EAP_GLO_CONr_SET(r,d) (r).eap_glo_con[0] = d
#define BCM53262_A0_EAP_GLO_CONr_GET(r) (r).eap_glo_con[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EAP_GLO_CONr_EN_EAP_PT_CHKf_GET(r) (((r).eap_glo_con[0]) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_EAP_PT_CHKf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_0f_GET(r) ((((r).eap_glo_con[0]) >> 1) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_0f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_BPDUf_GET(r) ((((r).eap_glo_con[0]) >> 2) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_BPDUf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_02_04_0Ff_GET(r) ((((r).eap_glo_con[0]) >> 3) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_02_04_0Ff_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_10f_GET(r) ((((r).eap_glo_con[0]) >> 4) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_10f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_11_1Ff_GET(r) ((((r).eap_glo_con[0]) >> 5) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_11_1Ff_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_20f_GET(r) ((((r).eap_glo_con[0]) >> 6) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_20f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_21f_GET(r) ((((r).eap_glo_con[0]) >> 7) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_21f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_22_2Ff_GET(r) ((((r).eap_glo_con[0]) >> 8) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_MAC_22_2Ff_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_EAP_GLO_CONr_EN_ARPf_GET(r) ((((r).eap_glo_con[0]) >> 9) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_ARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_EAP_GLO_CONr_EN_DIP_0f_GET(r) ((((r).eap_glo_con[0]) >> 10) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_DIP_0f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_EAP_GLO_CONr_EN_DIP_1f_GET(r) ((((r).eap_glo_con[0]) >> 11) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_DIP_1f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_EAP_GLO_CONr_EN_DHCPf_GET(r) ((((r).eap_glo_con[0]) >> 12) & 0x1)
#define BCM53262_A0_EAP_GLO_CONr_EN_DHCPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_1f_GET(r) ((((r).eap_glo_con[0]) >> 13) & 0x7)
#define BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_1f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access EAP_GLO_CON.
 */
#define BCM53262_A0_READ_EAP_GLO_CONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EAP_GLO_CONr,(r._eap_glo_con),2)
#define BCM53262_A0_WRITE_EAP_GLO_CONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EAP_GLO_CONr,&(r._eap_glo_con),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_GLO_CONr BCM53262_A0_EAP_GLO_CONr
#define EAP_GLO_CONr_SIZE BCM53262_A0_EAP_GLO_CONr_SIZE
typedef BCM53262_A0_EAP_GLO_CONr_t EAP_GLO_CONr_t;
#define EAP_GLO_CONr_CLR BCM53262_A0_EAP_GLO_CONr_CLR
#define EAP_GLO_CONr_SET BCM53262_A0_EAP_GLO_CONr_SET
#define EAP_GLO_CONr_GET BCM53262_A0_EAP_GLO_CONr_GET
#define EAP_GLO_CONr_EN_EAP_PT_CHKf_GET BCM53262_A0_EAP_GLO_CONr_EN_EAP_PT_CHKf_GET
#define EAP_GLO_CONr_EN_EAP_PT_CHKf_SET BCM53262_A0_EAP_GLO_CONr_EN_EAP_PT_CHKf_SET
#define EAP_GLO_CONr_EAP_GLO_CON_RSRV_0f_GET BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_0f_GET
#define EAP_GLO_CONr_EAP_GLO_CON_RSRV_0f_SET BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_0f_SET
#define EAP_GLO_CONr_EN_MAC_BPDUf_GET BCM53262_A0_EAP_GLO_CONr_EN_MAC_BPDUf_GET
#define EAP_GLO_CONr_EN_MAC_BPDUf_SET BCM53262_A0_EAP_GLO_CONr_EN_MAC_BPDUf_SET
#define EAP_GLO_CONr_EN_MAC_02_04_0Ff_GET BCM53262_A0_EAP_GLO_CONr_EN_MAC_02_04_0Ff_GET
#define EAP_GLO_CONr_EN_MAC_02_04_0Ff_SET BCM53262_A0_EAP_GLO_CONr_EN_MAC_02_04_0Ff_SET
#define EAP_GLO_CONr_EN_MAC_10f_GET BCM53262_A0_EAP_GLO_CONr_EN_MAC_10f_GET
#define EAP_GLO_CONr_EN_MAC_10f_SET BCM53262_A0_EAP_GLO_CONr_EN_MAC_10f_SET
#define EAP_GLO_CONr_EN_MAC_11_1Ff_GET BCM53262_A0_EAP_GLO_CONr_EN_MAC_11_1Ff_GET
#define EAP_GLO_CONr_EN_MAC_11_1Ff_SET BCM53262_A0_EAP_GLO_CONr_EN_MAC_11_1Ff_SET
#define EAP_GLO_CONr_EN_MAC_20f_GET BCM53262_A0_EAP_GLO_CONr_EN_MAC_20f_GET
#define EAP_GLO_CONr_EN_MAC_20f_SET BCM53262_A0_EAP_GLO_CONr_EN_MAC_20f_SET
#define EAP_GLO_CONr_EN_MAC_21f_GET BCM53262_A0_EAP_GLO_CONr_EN_MAC_21f_GET
#define EAP_GLO_CONr_EN_MAC_21f_SET BCM53262_A0_EAP_GLO_CONr_EN_MAC_21f_SET
#define EAP_GLO_CONr_EN_MAC_22_2Ff_GET BCM53262_A0_EAP_GLO_CONr_EN_MAC_22_2Ff_GET
#define EAP_GLO_CONr_EN_MAC_22_2Ff_SET BCM53262_A0_EAP_GLO_CONr_EN_MAC_22_2Ff_SET
#define EAP_GLO_CONr_EN_ARPf_GET BCM53262_A0_EAP_GLO_CONr_EN_ARPf_GET
#define EAP_GLO_CONr_EN_ARPf_SET BCM53262_A0_EAP_GLO_CONr_EN_ARPf_SET
#define EAP_GLO_CONr_EN_DIP_0f_GET BCM53262_A0_EAP_GLO_CONr_EN_DIP_0f_GET
#define EAP_GLO_CONr_EN_DIP_0f_SET BCM53262_A0_EAP_GLO_CONr_EN_DIP_0f_SET
#define EAP_GLO_CONr_EN_DIP_1f_GET BCM53262_A0_EAP_GLO_CONr_EN_DIP_1f_GET
#define EAP_GLO_CONr_EN_DIP_1f_SET BCM53262_A0_EAP_GLO_CONr_EN_DIP_1f_SET
#define EAP_GLO_CONr_EN_DHCPf_GET BCM53262_A0_EAP_GLO_CONr_EN_DHCPf_GET
#define EAP_GLO_CONr_EN_DHCPf_SET BCM53262_A0_EAP_GLO_CONr_EN_DHCPf_SET
#define EAP_GLO_CONr_EAP_GLO_CON_RSRV_1f_GET BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_1f_GET
#define EAP_GLO_CONr_EAP_GLO_CON_RSRV_1f_SET BCM53262_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRV_1f_SET
#define READ_EAP_GLO_CONr BCM53262_A0_READ_EAP_GLO_CONr
#define WRITE_EAP_GLO_CONr BCM53262_A0_WRITE_EAP_GLO_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EAP_GLO_CONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Control Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     OUT_MIR_MSK      Egress Mirror Port Mask11 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIR_CAP_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIR_CAP_PORT.Bits 0-47 = 10/100BASE-T PortsBit 48= IMPBit 49 = Giga Port g0Bit 50 = Giga Port g1Bit 51 = Giga Port g2Bit 52 = Giga Port g3
 *     EGMIRCTL_RSRV0   Reserved
 *     OUT_DIV_EN       Egress Divider EnableMirror every nth transmitted frame (n=OUT_MIR_DIV) that has passed through the OUT_MIR_FLTR.
 *     OUT_MIR_FLTR     Egress Mirror FilterDefines the conditions under which frames transmitted on a port that has been selected in the OUT_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIR_CAP_PORT.00: Mirror all egress frames01: Mirror all transmitted frames with DA = IN_MIROR_MAC10: Mirror all transmitted frames with SA = IN_MIRROR_MAC11: Reserved
 */
#define BCM53262_A0_EGMIRCTLr 0x00000328

#define BCM53262_A0_EGMIRCTLr_SIZE 8

/*
 * This structure should be used to declare and program EGMIRCTL.
 */
typedef union BCM53262_A0_EGMIRCTLr_s {
	uint32_t v[2];
	uint32_t egmirctl[2];
	uint32_t _egmirctl;
} BCM53262_A0_EGMIRCTLr_t;

#define BCM53262_A0_EGMIRCTLr_CLR(r) CDK_MEMSET(&((r)._egmirctl), 0, sizeof(BCM53262_A0_EGMIRCTLr_t))
#define BCM53262_A0_EGMIRCTLr_SET(r,i,d) (r).egmirctl[i] = d
#define BCM53262_A0_EGMIRCTLr_GET(r,i) (r).egmirctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EGMIRCTLr_RESERVED_Rf_GET(r) (((r).egmirctl[0]) & 0xffffff)
#define BCM53262_A0_EGMIRCTLr_RESERVED_Rf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_EGMIRCTLr_OUT_MIR_MSKf_GET(r) cdk_field32_get((r).egmirctl,24,52)
#define BCM53262_A0_EGMIRCTLr_OUT_MIR_MSKf_SET(r,f) cdk_field32_set((r).egmirctl,24,52,f)
#define BCM53262_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_GET(r) ((((r).egmirctl[1]) >> 21) & 0xff)
#define BCM53262_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_SET(r,f) (r).egmirctl[1]=(((r).egmirctl[1] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))
#define BCM53262_A0_EGMIRCTLr_OUT_DIV_ENf_GET(r) ((((r).egmirctl[1]) >> 29) & 0x1)
#define BCM53262_A0_EGMIRCTLr_OUT_DIV_ENf_SET(r,f) (r).egmirctl[1]=(((r).egmirctl[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53262_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET(r) ((((r).egmirctl[1]) >> 30) & 0x3)
#define BCM53262_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET(r,f) (r).egmirctl[1]=(((r).egmirctl[1] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access EGMIRCTL.
 */
#define BCM53262_A0_READ_EGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EGMIRCTLr,(r._egmirctl),8)
#define BCM53262_A0_WRITE_EGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EGMIRCTLr,&(r._egmirctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRCTLr BCM53262_A0_EGMIRCTLr
#define EGMIRCTLr_SIZE BCM53262_A0_EGMIRCTLr_SIZE
typedef BCM53262_A0_EGMIRCTLr_t EGMIRCTLr_t;
#define EGMIRCTLr_CLR BCM53262_A0_EGMIRCTLr_CLR
#define EGMIRCTLr_SET BCM53262_A0_EGMIRCTLr_SET
#define EGMIRCTLr_GET BCM53262_A0_EGMIRCTLr_GET
#define EGMIRCTLr_RESERVED_Rf_GET BCM53262_A0_EGMIRCTLr_RESERVED_Rf_GET
#define EGMIRCTLr_RESERVED_Rf_SET BCM53262_A0_EGMIRCTLr_RESERVED_Rf_SET
#define EGMIRCTLr_OUT_MIR_MSKf_GET BCM53262_A0_EGMIRCTLr_OUT_MIR_MSKf_GET
#define EGMIRCTLr_OUT_MIR_MSKf_SET BCM53262_A0_EGMIRCTLr_OUT_MIR_MSKf_SET
#define EGMIRCTLr_EGMIRCTL_RSRV0f_GET BCM53262_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_GET
#define EGMIRCTLr_EGMIRCTL_RSRV0f_SET BCM53262_A0_EGMIRCTLr_EGMIRCTL_RSRV0f_SET
#define EGMIRCTLr_OUT_DIV_ENf_GET BCM53262_A0_EGMIRCTLr_OUT_DIV_ENf_GET
#define EGMIRCTLr_OUT_DIV_ENf_SET BCM53262_A0_EGMIRCTLr_OUT_DIV_ENf_SET
#define EGMIRCTLr_OUT_MIR_FLTRf_GET BCM53262_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET
#define EGMIRCTLr_OUT_MIR_FLTRf_SET BCM53262_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET
#define READ_EGMIRCTLr BCM53262_A0_READ_EGMIRCTLr
#define WRITE_EGMIRCTLr BCM53262_A0_WRITE_EGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EGMIRCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_DIV      Egress Mirror Divider.Transmit frames that have passed the OUT_MIR_FLTR rule can further be pruned to reduce the overall number of frames returned to the MIR_CAP_PORT. When the OUT_DIV_EN bit in the Egress Mirror Control register is set, frames that pass the OUT_MIR_FLTR rule are further divided by the value loaded into this register, so that only one in n frames (where n = OUT_MIR_DIV) will be mirrored.
 *     EGMIRDIV_RSRV0   Reserved
 */
#define BCM53262_A0_EGMIRDIVr 0x00000330

#define BCM53262_A0_EGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRDIV.
 */
typedef union BCM53262_A0_EGMIRDIVr_s {
	uint32_t v[1];
	uint32_t egmirdiv[1];
	uint32_t _egmirdiv;
} BCM53262_A0_EGMIRDIVr_t;

#define BCM53262_A0_EGMIRDIVr_CLR(r) (r).egmirdiv[0] = 0
#define BCM53262_A0_EGMIRDIVr_SET(r,d) (r).egmirdiv[0] = d
#define BCM53262_A0_EGMIRDIVr_GET(r) (r).egmirdiv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EGMIRDIVr_OUT_MIR_DIVf_GET(r) (((r).egmirdiv[0]) & 0x3ff)
#define BCM53262_A0_EGMIRDIVr_OUT_MIR_DIVf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53262_A0_EGMIRDIVr_EGMIRDIV_RSRV0f_GET(r) ((((r).egmirdiv[0]) >> 10) & 0x3f)
#define BCM53262_A0_EGMIRDIVr_EGMIRDIV_RSRV0f_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EGMIRDIV.
 */
#define BCM53262_A0_READ_EGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EGMIRDIVr,(r._egmirdiv),2)
#define BCM53262_A0_WRITE_EGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EGMIRDIVr,&(r._egmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRDIVr BCM53262_A0_EGMIRDIVr
#define EGMIRDIVr_SIZE BCM53262_A0_EGMIRDIVr_SIZE
typedef BCM53262_A0_EGMIRDIVr_t EGMIRDIVr_t;
#define EGMIRDIVr_CLR BCM53262_A0_EGMIRDIVr_CLR
#define EGMIRDIVr_SET BCM53262_A0_EGMIRDIVr_SET
#define EGMIRDIVr_GET BCM53262_A0_EGMIRDIVr_GET
#define EGMIRDIVr_OUT_MIR_DIVf_GET BCM53262_A0_EGMIRDIVr_OUT_MIR_DIVf_GET
#define EGMIRDIVr_OUT_MIR_DIVf_SET BCM53262_A0_EGMIRDIVr_OUT_MIR_DIVf_SET
#define EGMIRDIVr_EGMIRDIV_RSRV0f_GET BCM53262_A0_EGMIRDIVr_EGMIRDIV_RSRV0f_GET
#define EGMIRDIVr_EGMIRDIV_RSRV0f_SET BCM53262_A0_EGMIRDIVr_EGMIRDIV_RSRV0f_SET
#define READ_EGMIRDIVr BCM53262_A0_READ_EGMIRDIVr
#define WRITE_EGMIRDIVr BCM53262_A0_WRITE_EGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EGMIRDIVr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Egress Mirror MAC Address Register
 * SIZE:     48
 * FIELDS:
 *     OUT_MIR_MAC      Egress Mirror MAC Address.MAC address that will be compared against engress frames in accordance with the OUT_MIR_FLTR rules.
 */
#define BCM53262_A0_EGMIRMACr 0x00000332

#define BCM53262_A0_EGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program EGMIRMAC.
 */
typedef union BCM53262_A0_EGMIRMACr_s {
	uint32_t v[2];
	uint32_t egmirmac[2];
	uint32_t _egmirmac;
} BCM53262_A0_EGMIRMACr_t;

#define BCM53262_A0_EGMIRMACr_CLR(r) CDK_MEMSET(&((r)._egmirmac), 0, sizeof(BCM53262_A0_EGMIRMACr_t))
#define BCM53262_A0_EGMIRMACr_SET(r,i,d) (r).egmirmac[i] = d
#define BCM53262_A0_EGMIRMACr_GET(r,i) (r).egmirmac[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EGMIRMACr_OUT_MIR_MACf_GET(r,a) cdk_field_get((r).egmirmac,0,47,a)
#define BCM53262_A0_EGMIRMACr_OUT_MIR_MACf_SET(r,a) cdk_field_set((r).egmirmac,0,47,a)

/*
 * These macros can be used to access EGMIRMAC.
 */
#define BCM53262_A0_READ_EGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EGMIRMACr,(r._egmirmac),6)
#define BCM53262_A0_WRITE_EGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EGMIRMACr,&(r._egmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRMACr BCM53262_A0_EGMIRMACr
#define EGMIRMACr_SIZE BCM53262_A0_EGMIRMACr_SIZE
typedef BCM53262_A0_EGMIRMACr_t EGMIRMACr_t;
#define EGMIRMACr_CLR BCM53262_A0_EGMIRMACr_CLR
#define EGMIRMACr_SET BCM53262_A0_EGMIRMACr_SET
#define EGMIRMACr_GET BCM53262_A0_EGMIRMACr_GET
#define EGMIRMACr_OUT_MIR_MACf_GET BCM53262_A0_EGMIRMACr_OUT_MIR_MACf_GET
#define EGMIRMACr_OUT_MIR_MACf_SET BCM53262_A0_EGMIRMACr_OUT_MIR_MACf_SET
#define READ_EGMIRMACr BCM53262_A0_READ_EGMIRMACr
#define WRITE_EGMIRMACr BCM53262_A0_WRITE_EGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EGMIRMACr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EGRESS_RMON
 * BLOCKS:   SYS
 * DESC:     Extend Egress RMON Register
 * SIZE:     16
 * FIELDS:
 *     EGRESS_P         Egress RMON Port.
 *     EN_EGRESS_RMON   Enable Egress RMON.1'b1 : Enable this feature.1'b0 : Disable this feature.
 *     RESERVED_R       Reserved.
 *     EGRESS_PRI       Egress RMON Priority.Indicates the priority queue to use for egress extended RMON packets.
 *     EGRESS_CFG       Egress RMON Setting.A exponential value indicating the percentage of traffic that will be sent to CPU due to egress extended RMON.percentage = 1/(2^value).
 */
#define BCM53262_A0_EGRESS_RMONr 0x00000368

#define BCM53262_A0_EGRESS_RMONr_SIZE 2

/*
 * This structure should be used to declare and program EGRESS_RMON.
 */
typedef union BCM53262_A0_EGRESS_RMONr_s {
	uint32_t v[1];
	uint32_t egress_rmon[1];
	uint32_t _egress_rmon;
} BCM53262_A0_EGRESS_RMONr_t;

#define BCM53262_A0_EGRESS_RMONr_CLR(r) (r).egress_rmon[0] = 0
#define BCM53262_A0_EGRESS_RMONr_SET(r,d) (r).egress_rmon[0] = d
#define BCM53262_A0_EGRESS_RMONr_GET(r) (r).egress_rmon[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EGRESS_RMONr_EGRESS_Pf_GET(r) (((r).egress_rmon[0]) & 0x3f)
#define BCM53262_A0_EGRESS_RMONr_EGRESS_Pf_SET(r,f) (r).egress_rmon[0]=(((r).egress_rmon[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_EGRESS_RMONr_EN_EGRESS_RMONf_GET(r) ((((r).egress_rmon[0]) >> 6) & 0x1)
#define BCM53262_A0_EGRESS_RMONr_EN_EGRESS_RMONf_SET(r,f) (r).egress_rmon[0]=(((r).egress_rmon[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_EGRESS_RMONr_RESERVED_Rf_GET(r) ((((r).egress_rmon[0]) >> 7) & 0x7)
#define BCM53262_A0_EGRESS_RMONr_RESERVED_Rf_SET(r,f) (r).egress_rmon[0]=(((r).egress_rmon[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53262_A0_EGRESS_RMONr_EGRESS_PRIf_GET(r) ((((r).egress_rmon[0]) >> 10) & 0x3)
#define BCM53262_A0_EGRESS_RMONr_EGRESS_PRIf_SET(r,f) (r).egress_rmon[0]=(((r).egress_rmon[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_EGRESS_RMONr_EGRESS_CFGf_GET(r) ((((r).egress_rmon[0]) >> 12) & 0xf)
#define BCM53262_A0_EGRESS_RMONr_EGRESS_CFGf_SET(r,f) (r).egress_rmon[0]=(((r).egress_rmon[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access EGRESS_RMON.
 */
#define BCM53262_A0_READ_EGRESS_RMONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EGRESS_RMONr,(r._egress_rmon),2)
#define BCM53262_A0_WRITE_EGRESS_RMONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EGRESS_RMONr,&(r._egress_rmon),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_RMONr BCM53262_A0_EGRESS_RMONr
#define EGRESS_RMONr_SIZE BCM53262_A0_EGRESS_RMONr_SIZE
typedef BCM53262_A0_EGRESS_RMONr_t EGRESS_RMONr_t;
#define EGRESS_RMONr_CLR BCM53262_A0_EGRESS_RMONr_CLR
#define EGRESS_RMONr_SET BCM53262_A0_EGRESS_RMONr_SET
#define EGRESS_RMONr_GET BCM53262_A0_EGRESS_RMONr_GET
#define EGRESS_RMONr_EGRESS_Pf_GET BCM53262_A0_EGRESS_RMONr_EGRESS_Pf_GET
#define EGRESS_RMONr_EGRESS_Pf_SET BCM53262_A0_EGRESS_RMONr_EGRESS_Pf_SET
#define EGRESS_RMONr_EN_EGRESS_RMONf_GET BCM53262_A0_EGRESS_RMONr_EN_EGRESS_RMONf_GET
#define EGRESS_RMONr_EN_EGRESS_RMONf_SET BCM53262_A0_EGRESS_RMONr_EN_EGRESS_RMONf_SET
#define EGRESS_RMONr_RESERVED_Rf_GET BCM53262_A0_EGRESS_RMONr_RESERVED_Rf_GET
#define EGRESS_RMONr_RESERVED_Rf_SET BCM53262_A0_EGRESS_RMONr_RESERVED_Rf_SET
#define EGRESS_RMONr_EGRESS_PRIf_GET BCM53262_A0_EGRESS_RMONr_EGRESS_PRIf_GET
#define EGRESS_RMONr_EGRESS_PRIf_SET BCM53262_A0_EGRESS_RMONr_EGRESS_PRIf_SET
#define EGRESS_RMONr_EGRESS_CFGf_GET BCM53262_A0_EGRESS_RMONr_EGRESS_CFGf_GET
#define EGRESS_RMONr_EGRESS_CFGf_SET BCM53262_A0_EGRESS_RMONr_EGRESS_CFGf_SET
#define READ_EGRESS_RMONr BCM53262_A0_READ_EGRESS_RMONr
#define WRITE_EGRESS_RMONr BCM53262_A0_WRITE_EGRESS_RMONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EGRESS_RMONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EN_IMP_CONG_REMAP
 * BLOCKS:   SYS
 * DESC:     LAN_to_IMP Unicast Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_REMAP_PAUSE2DROP reserved for internal test only, default is 1'b1 and remap pause to drop, 1'b0 will remap pause to hyst
 *     RESERVED_R       Reserved
 *     EN_IMP_CONG_REMAP 1'b1 to remap IMP-port congestion status from pause to drop.
 */
#define BCM53262_A0_EN_IMP_CONG_REMAPr 0x00000aa0

#define BCM53262_A0_EN_IMP_CONG_REMAPr_SIZE 2

/*
 * This structure should be used to declare and program EN_IMP_CONG_REMAP.
 */
typedef union BCM53262_A0_EN_IMP_CONG_REMAPr_s {
	uint32_t v[1];
	uint32_t en_imp_cong_remap[1];
	uint32_t _en_imp_cong_remap;
} BCM53262_A0_EN_IMP_CONG_REMAPr_t;

#define BCM53262_A0_EN_IMP_CONG_REMAPr_CLR(r) (r).en_imp_cong_remap[0] = 0
#define BCM53262_A0_EN_IMP_CONG_REMAPr_SET(r,d) (r).en_imp_cong_remap[0] = d
#define BCM53262_A0_EN_IMP_CONG_REMAPr_GET(r) (r).en_imp_cong_remap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EN_IMP_CONG_REMAPr_EN_REMAP_PAUSE2DROPf_GET(r) (((r).en_imp_cong_remap[0]) & 0x1)
#define BCM53262_A0_EN_IMP_CONG_REMAPr_EN_REMAP_PAUSE2DROPf_SET(r,f) (r).en_imp_cong_remap[0]=(((r).en_imp_cong_remap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_EN_IMP_CONG_REMAPr_RESERVED_Rf_GET(r) ((((r).en_imp_cong_remap[0]) >> 1) & 0x3fff)
#define BCM53262_A0_EN_IMP_CONG_REMAPr_RESERVED_Rf_SET(r,f) (r).en_imp_cong_remap[0]=(((r).en_imp_cong_remap[0] & ~((uint32_t)0x3fff << 1)) | ((((uint32_t)f) & 0x3fff) << 1))
#define BCM53262_A0_EN_IMP_CONG_REMAPr_EN_IMP_CONG_REMAPf_GET(r) ((((r).en_imp_cong_remap[0]) >> 15) & 0x1)
#define BCM53262_A0_EN_IMP_CONG_REMAPr_EN_IMP_CONG_REMAPf_SET(r,f) (r).en_imp_cong_remap[0]=(((r).en_imp_cong_remap[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access EN_IMP_CONG_REMAP.
 */
#define BCM53262_A0_READ_EN_IMP_CONG_REMAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EN_IMP_CONG_REMAPr,(r._en_imp_cong_remap),2)
#define BCM53262_A0_WRITE_EN_IMP_CONG_REMAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EN_IMP_CONG_REMAPr,&(r._en_imp_cong_remap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EN_IMP_CONG_REMAPr BCM53262_A0_EN_IMP_CONG_REMAPr
#define EN_IMP_CONG_REMAPr_SIZE BCM53262_A0_EN_IMP_CONG_REMAPr_SIZE
typedef BCM53262_A0_EN_IMP_CONG_REMAPr_t EN_IMP_CONG_REMAPr_t;
#define EN_IMP_CONG_REMAPr_CLR BCM53262_A0_EN_IMP_CONG_REMAPr_CLR
#define EN_IMP_CONG_REMAPr_SET BCM53262_A0_EN_IMP_CONG_REMAPr_SET
#define EN_IMP_CONG_REMAPr_GET BCM53262_A0_EN_IMP_CONG_REMAPr_GET
#define EN_IMP_CONG_REMAPr_EN_REMAP_PAUSE2DROPf_GET BCM53262_A0_EN_IMP_CONG_REMAPr_EN_REMAP_PAUSE2DROPf_GET
#define EN_IMP_CONG_REMAPr_EN_REMAP_PAUSE2DROPf_SET BCM53262_A0_EN_IMP_CONG_REMAPr_EN_REMAP_PAUSE2DROPf_SET
#define EN_IMP_CONG_REMAPr_RESERVED_Rf_GET BCM53262_A0_EN_IMP_CONG_REMAPr_RESERVED_Rf_GET
#define EN_IMP_CONG_REMAPr_RESERVED_Rf_SET BCM53262_A0_EN_IMP_CONG_REMAPr_RESERVED_Rf_SET
#define EN_IMP_CONG_REMAPr_EN_IMP_CONG_REMAPf_GET BCM53262_A0_EN_IMP_CONG_REMAPr_EN_IMP_CONG_REMAPf_GET
#define EN_IMP_CONG_REMAPr_EN_IMP_CONG_REMAPf_SET BCM53262_A0_EN_IMP_CONG_REMAPr_EN_IMP_CONG_REMAPf_SET
#define READ_EN_IMP_CONG_REMAPr BCM53262_A0_READ_EN_IMP_CONG_REMAPr
#define WRITE_EN_IMP_CONG_REMAPr BCM53262_A0_WRITE_EN_IMP_CONG_REMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EN_IMP_CONG_REMAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EN_IMP_HIGH_RATE
 * BLOCKS:   SYS
 * DESC:     IMP_to_LAN Control1 Register
 * SIZE:     16
 * FIELDS:
 *     EN_IMP_HIGH_RATE 1'b1 to remap LAN-ports congestion status (observed by IMP) from drop/pause to pause/hyst
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_EN_IMP_HIGH_RATEr 0x00000ab0

#define BCM53262_A0_EN_IMP_HIGH_RATEr_SIZE 2

/*
 * This structure should be used to declare and program EN_IMP_HIGH_RATE.
 */
typedef union BCM53262_A0_EN_IMP_HIGH_RATEr_s {
	uint32_t v[1];
	uint32_t en_imp_high_rate[1];
	uint32_t _en_imp_high_rate;
} BCM53262_A0_EN_IMP_HIGH_RATEr_t;

#define BCM53262_A0_EN_IMP_HIGH_RATEr_CLR(r) (r).en_imp_high_rate[0] = 0
#define BCM53262_A0_EN_IMP_HIGH_RATEr_SET(r,d) (r).en_imp_high_rate[0] = d
#define BCM53262_A0_EN_IMP_HIGH_RATEr_GET(r) (r).en_imp_high_rate[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EN_IMP_HIGH_RATEr_EN_IMP_HIGH_RATEf_GET(r) (((r).en_imp_high_rate[0]) & 0x1)
#define BCM53262_A0_EN_IMP_HIGH_RATEr_EN_IMP_HIGH_RATEf_SET(r,f) (r).en_imp_high_rate[0]=(((r).en_imp_high_rate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_EN_IMP_HIGH_RATEr_RESERVED_Rf_GET(r) ((((r).en_imp_high_rate[0]) >> 1) & 0x7fff)
#define BCM53262_A0_EN_IMP_HIGH_RATEr_RESERVED_Rf_SET(r,f) (r).en_imp_high_rate[0]=(((r).en_imp_high_rate[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access EN_IMP_HIGH_RATE.
 */
#define BCM53262_A0_READ_EN_IMP_HIGH_RATEr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EN_IMP_HIGH_RATEr,(r._en_imp_high_rate),2)
#define BCM53262_A0_WRITE_EN_IMP_HIGH_RATEr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EN_IMP_HIGH_RATEr,&(r._en_imp_high_rate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EN_IMP_HIGH_RATEr BCM53262_A0_EN_IMP_HIGH_RATEr
#define EN_IMP_HIGH_RATEr_SIZE BCM53262_A0_EN_IMP_HIGH_RATEr_SIZE
typedef BCM53262_A0_EN_IMP_HIGH_RATEr_t EN_IMP_HIGH_RATEr_t;
#define EN_IMP_HIGH_RATEr_CLR BCM53262_A0_EN_IMP_HIGH_RATEr_CLR
#define EN_IMP_HIGH_RATEr_SET BCM53262_A0_EN_IMP_HIGH_RATEr_SET
#define EN_IMP_HIGH_RATEr_GET BCM53262_A0_EN_IMP_HIGH_RATEr_GET
#define EN_IMP_HIGH_RATEr_EN_IMP_HIGH_RATEf_GET BCM53262_A0_EN_IMP_HIGH_RATEr_EN_IMP_HIGH_RATEf_GET
#define EN_IMP_HIGH_RATEr_EN_IMP_HIGH_RATEf_SET BCM53262_A0_EN_IMP_HIGH_RATEr_EN_IMP_HIGH_RATEf_SET
#define EN_IMP_HIGH_RATEr_RESERVED_Rf_GET BCM53262_A0_EN_IMP_HIGH_RATEr_RESERVED_Rf_GET
#define EN_IMP_HIGH_RATEr_RESERVED_Rf_SET BCM53262_A0_EN_IMP_HIGH_RATEr_RESERVED_Rf_SET
#define READ_EN_IMP_HIGH_RATEr BCM53262_A0_READ_EN_IMP_HIGH_RATEr
#define WRITE_EN_IMP_HIGH_RATEr BCM53262_A0_WRITE_EN_IMP_HIGH_RATEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EN_IMP_HIGH_RATEr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  EN_TOTAL_MC_DROP_IMP
 * BLOCKS:   SYS
 * DESC:     LAN_to_IMP Multicast Control1 Register
 * SIZE:     16
 * FIELDS:
 *     EN_TL_MC_DROP_IMP 1'b1 to activate total_mc_drop_imp_thresh in offset A4.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr 0x00000aa2

#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_SIZE 2

/*
 * This structure should be used to declare and program EN_TOTAL_MC_DROP_IMP.
 */
typedef union BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_s {
	uint32_t v[1];
	uint32_t en_total_mc_drop_imp[1];
	uint32_t _en_total_mc_drop_imp;
} BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_t;

#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_CLR(r) (r).en_total_mc_drop_imp[0] = 0
#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_SET(r,d) (r).en_total_mc_drop_imp[0] = d
#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_GET(r) (r).en_total_mc_drop_imp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_EN_TL_MC_DROP_IMPf_GET(r) (((r).en_total_mc_drop_imp[0]) & 0x1)
#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_EN_TL_MC_DROP_IMPf_SET(r,f) (r).en_total_mc_drop_imp[0]=(((r).en_total_mc_drop_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_RESERVED_Rf_GET(r) ((((r).en_total_mc_drop_imp[0]) >> 1) & 0x7fff)
#define BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_RESERVED_Rf_SET(r,f) (r).en_total_mc_drop_imp[0]=(((r).en_total_mc_drop_imp[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access EN_TOTAL_MC_DROP_IMP.
 */
#define BCM53262_A0_READ_EN_TOTAL_MC_DROP_IMPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_EN_TOTAL_MC_DROP_IMPr,(r._en_total_mc_drop_imp),2)
#define BCM53262_A0_WRITE_EN_TOTAL_MC_DROP_IMPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_EN_TOTAL_MC_DROP_IMPr,&(r._en_total_mc_drop_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EN_TOTAL_MC_DROP_IMPr BCM53262_A0_EN_TOTAL_MC_DROP_IMPr
#define EN_TOTAL_MC_DROP_IMPr_SIZE BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_SIZE
typedef BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_t EN_TOTAL_MC_DROP_IMPr_t;
#define EN_TOTAL_MC_DROP_IMPr_CLR BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_CLR
#define EN_TOTAL_MC_DROP_IMPr_SET BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_SET
#define EN_TOTAL_MC_DROP_IMPr_GET BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_GET
#define EN_TOTAL_MC_DROP_IMPr_EN_TL_MC_DROP_IMPf_GET BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_EN_TL_MC_DROP_IMPf_GET
#define EN_TOTAL_MC_DROP_IMPr_EN_TL_MC_DROP_IMPf_SET BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_EN_TL_MC_DROP_IMPf_SET
#define EN_TOTAL_MC_DROP_IMPr_RESERVED_Rf_GET BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_RESERVED_Rf_GET
#define EN_TOTAL_MC_DROP_IMPr_RESERVED_Rf_SET BCM53262_A0_EN_TOTAL_MC_DROP_IMPr_RESERVED_Rf_SET
#define READ_EN_TOTAL_MC_DROP_IMPr BCM53262_A0_READ_EN_TOTAL_MC_DROP_IMPr
#define WRITE_EN_TOTAL_MC_DROP_IMPr BCM53262_A0_WRITE_EN_TOTAL_MC_DROP_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_EN_TOTAL_MC_DROP_IMPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_BCST_TH_CTRL
 * BLOCKS:   SYS
 * DESC:     Bcst Threshold Drop Register
 * SIZE:     16
 * FIELDS:
 *     INDV_BCSTTH_DROP Indvidual broadcast drop threshold.Flowcon will use this as drop threshold on BCST frame only when en_indv_dlf_bcst_drop_thresh is assert
 *     TOTAL_INDV_BCSTTH_DROP Total indvidual broadcast drop threshold. The effective number is this register times 8.Flowcon will use this as drop threshold on BCST frame only when en_indv_dlf_bcst_drop_thresh is assert
 */
#define BCM53262_A0_FCON_BCST_TH_CTRLr 0x00000a96

#define BCM53262_A0_FCON_BCST_TH_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FCON_BCST_TH_CTRL.
 */
typedef union BCM53262_A0_FCON_BCST_TH_CTRLr_s {
	uint32_t v[1];
	uint32_t fcon_bcst_th_ctrl[1];
	uint32_t _fcon_bcst_th_ctrl;
} BCM53262_A0_FCON_BCST_TH_CTRLr_t;

#define BCM53262_A0_FCON_BCST_TH_CTRLr_CLR(r) (r).fcon_bcst_th_ctrl[0] = 0
#define BCM53262_A0_FCON_BCST_TH_CTRLr_SET(r,d) (r).fcon_bcst_th_ctrl[0] = d
#define BCM53262_A0_FCON_BCST_TH_CTRLr_GET(r) (r).fcon_bcst_th_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_BCST_TH_CTRLr_INDV_BCSTTH_DROPf_GET(r) (((r).fcon_bcst_th_ctrl[0]) & 0xff)
#define BCM53262_A0_FCON_BCST_TH_CTRLr_INDV_BCSTTH_DROPf_SET(r,f) (r).fcon_bcst_th_ctrl[0]=(((r).fcon_bcst_th_ctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_BCST_TH_CTRLr_TOTAL_INDV_BCSTTH_DROPf_GET(r) ((((r).fcon_bcst_th_ctrl[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_BCST_TH_CTRLr_TOTAL_INDV_BCSTTH_DROPf_SET(r,f) (r).fcon_bcst_th_ctrl[0]=(((r).fcon_bcst_th_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_BCST_TH_CTRL.
 */
#define BCM53262_A0_READ_FCON_BCST_TH_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_BCST_TH_CTRLr,(r._fcon_bcst_th_ctrl),2)
#define BCM53262_A0_WRITE_FCON_BCST_TH_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_BCST_TH_CTRLr,&(r._fcon_bcst_th_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_BCST_TH_CTRLr BCM53262_A0_FCON_BCST_TH_CTRLr
#define FCON_BCST_TH_CTRLr_SIZE BCM53262_A0_FCON_BCST_TH_CTRLr_SIZE
typedef BCM53262_A0_FCON_BCST_TH_CTRLr_t FCON_BCST_TH_CTRLr_t;
#define FCON_BCST_TH_CTRLr_CLR BCM53262_A0_FCON_BCST_TH_CTRLr_CLR
#define FCON_BCST_TH_CTRLr_SET BCM53262_A0_FCON_BCST_TH_CTRLr_SET
#define FCON_BCST_TH_CTRLr_GET BCM53262_A0_FCON_BCST_TH_CTRLr_GET
#define FCON_BCST_TH_CTRLr_INDV_BCSTTH_DROPf_GET BCM53262_A0_FCON_BCST_TH_CTRLr_INDV_BCSTTH_DROPf_GET
#define FCON_BCST_TH_CTRLr_INDV_BCSTTH_DROPf_SET BCM53262_A0_FCON_BCST_TH_CTRLr_INDV_BCSTTH_DROPf_SET
#define FCON_BCST_TH_CTRLr_TOTAL_INDV_BCSTTH_DROPf_GET BCM53262_A0_FCON_BCST_TH_CTRLr_TOTAL_INDV_BCSTTH_DROPf_GET
#define FCON_BCST_TH_CTRLr_TOTAL_INDV_BCSTTH_DROPf_SET BCM53262_A0_FCON_BCST_TH_CTRLr_TOTAL_INDV_BCSTTH_DROPf_SET
#define READ_FCON_BCST_TH_CTRLr BCM53262_A0_READ_FCON_BCST_TH_CTRLr
#define WRITE_FCON_BCST_TH_CTRLr BCM53262_A0_WRITE_FCON_BCST_TH_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_BCST_TH_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_DIAG_CTRL
 * BLOCKS:   SYS
 * DESC:     Flowcon Diagnosis Control Register
 * SIZE:     16
 * FIELDS:
 *     DIG_FLOWCON_PROT Select which port to be monitored.5'd0 : port 0; 5'd1: port1; 5'd 49: giga port 1
 *     FCON_PRIQ_SEL    00: Select lowest queue01:10:11: Select highest queue.
 *     DIAG_TX_CON_SEL  Diagnosis only. Select which txq content to be monitored.
 *     DIAG_HIST_SEL    Diagnosis only: Select which hist value to be reported.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_DIAG_CTRLr 0x00000a00

#define BCM53262_A0_FCON_DIAG_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FCON_DIAG_CTRL.
 */
typedef union BCM53262_A0_FCON_DIAG_CTRLr_s {
	uint32_t v[1];
	uint32_t fcon_diag_ctrl[1];
	uint32_t _fcon_diag_ctrl;
} BCM53262_A0_FCON_DIAG_CTRLr_t;

#define BCM53262_A0_FCON_DIAG_CTRLr_CLR(r) (r).fcon_diag_ctrl[0] = 0
#define BCM53262_A0_FCON_DIAG_CTRLr_SET(r,d) (r).fcon_diag_ctrl[0] = d
#define BCM53262_A0_FCON_DIAG_CTRLr_GET(r) (r).fcon_diag_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET(r) (((r).fcon_diag_ctrl[0]) & 0x3f)
#define BCM53262_A0_FCON_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET(r,f) (r).fcon_diag_ctrl[0]=(((r).fcon_diag_ctrl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_FCON_DIAG_CTRLr_FCON_PRIQ_SELf_GET(r) ((((r).fcon_diag_ctrl[0]) >> 6) & 0x3)
#define BCM53262_A0_FCON_DIAG_CTRLr_FCON_PRIQ_SELf_SET(r,f) (r).fcon_diag_ctrl[0]=(((r).fcon_diag_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_FCON_DIAG_CTRLr_DIAG_TX_CON_SELf_GET(r) ((((r).fcon_diag_ctrl[0]) >> 8) & 0xf)
#define BCM53262_A0_FCON_DIAG_CTRLr_DIAG_TX_CON_SELf_SET(r,f) (r).fcon_diag_ctrl[0]=(((r).fcon_diag_ctrl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53262_A0_FCON_DIAG_CTRLr_DIAG_HIST_SELf_GET(r) ((((r).fcon_diag_ctrl[0]) >> 12) & 0x3)
#define BCM53262_A0_FCON_DIAG_CTRLr_DIAG_HIST_SELf_SET(r,f) (r).fcon_diag_ctrl[0]=(((r).fcon_diag_ctrl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_FCON_DIAG_CTRLr_RESERVED_Rf_GET(r) ((((r).fcon_diag_ctrl[0]) >> 14) & 0x3)
#define BCM53262_A0_FCON_DIAG_CTRLr_RESERVED_Rf_SET(r,f) (r).fcon_diag_ctrl[0]=(((r).fcon_diag_ctrl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access FCON_DIAG_CTRL.
 */
#define BCM53262_A0_READ_FCON_DIAG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_DIAG_CTRLr,(r._fcon_diag_ctrl),2)
#define BCM53262_A0_WRITE_FCON_DIAG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_DIAG_CTRLr,&(r._fcon_diag_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_DIAG_CTRLr BCM53262_A0_FCON_DIAG_CTRLr
#define FCON_DIAG_CTRLr_SIZE BCM53262_A0_FCON_DIAG_CTRLr_SIZE
typedef BCM53262_A0_FCON_DIAG_CTRLr_t FCON_DIAG_CTRLr_t;
#define FCON_DIAG_CTRLr_CLR BCM53262_A0_FCON_DIAG_CTRLr_CLR
#define FCON_DIAG_CTRLr_SET BCM53262_A0_FCON_DIAG_CTRLr_SET
#define FCON_DIAG_CTRLr_GET BCM53262_A0_FCON_DIAG_CTRLr_GET
#define FCON_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET BCM53262_A0_FCON_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET
#define FCON_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET BCM53262_A0_FCON_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET
#define FCON_DIAG_CTRLr_FCON_PRIQ_SELf_GET BCM53262_A0_FCON_DIAG_CTRLr_FCON_PRIQ_SELf_GET
#define FCON_DIAG_CTRLr_FCON_PRIQ_SELf_SET BCM53262_A0_FCON_DIAG_CTRLr_FCON_PRIQ_SELf_SET
#define FCON_DIAG_CTRLr_DIAG_TX_CON_SELf_GET BCM53262_A0_FCON_DIAG_CTRLr_DIAG_TX_CON_SELf_GET
#define FCON_DIAG_CTRLr_DIAG_TX_CON_SELf_SET BCM53262_A0_FCON_DIAG_CTRLr_DIAG_TX_CON_SELf_SET
#define FCON_DIAG_CTRLr_DIAG_HIST_SELf_GET BCM53262_A0_FCON_DIAG_CTRLr_DIAG_HIST_SELf_GET
#define FCON_DIAG_CTRLr_DIAG_HIST_SELf_SET BCM53262_A0_FCON_DIAG_CTRLr_DIAG_HIST_SELf_SET
#define FCON_DIAG_CTRLr_RESERVED_Rf_GET BCM53262_A0_FCON_DIAG_CTRLr_RESERVED_Rf_GET
#define FCON_DIAG_CTRLr_RESERVED_Rf_SET BCM53262_A0_FCON_DIAG_CTRLr_RESERVED_Rf_SET
#define READ_FCON_DIAG_CTRLr BCM53262_A0_READ_FCON_DIAG_CTRLr
#define WRITE_FCON_DIAG_CTRLr BCM53262_A0_WRITE_FCON_DIAG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_DIAG_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_DLF_TH_CTRL
 * BLOCKS:   SYS
 * DESC:     DLF Threshold Drop Register
 * SIZE:     16
 * FIELDS:
 *     INDV_DLFTH_DROP  Indvidual DLF drop threshold.Flowcon will use this as drop threshold on DLF frame only when en_indv_dlf_bcst_drop_thresh is assert
 *     TOTAL_INDV_DLFTH_DROP Total indvidual DLF drop threshold. The effective number is this register times 8.Flowcon will use this as drop threshold on DLF frame only when en_indv_dlf_bcst_drop_thresh is assert.
 */
#define BCM53262_A0_FCON_DLF_TH_CTRLr 0x00000a94

#define BCM53262_A0_FCON_DLF_TH_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FCON_DLF_TH_CTRL.
 */
typedef union BCM53262_A0_FCON_DLF_TH_CTRLr_s {
	uint32_t v[1];
	uint32_t fcon_dlf_th_ctrl[1];
	uint32_t _fcon_dlf_th_ctrl;
} BCM53262_A0_FCON_DLF_TH_CTRLr_t;

#define BCM53262_A0_FCON_DLF_TH_CTRLr_CLR(r) (r).fcon_dlf_th_ctrl[0] = 0
#define BCM53262_A0_FCON_DLF_TH_CTRLr_SET(r,d) (r).fcon_dlf_th_ctrl[0] = d
#define BCM53262_A0_FCON_DLF_TH_CTRLr_GET(r) (r).fcon_dlf_th_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_DLF_TH_CTRLr_INDV_DLFTH_DROPf_GET(r) (((r).fcon_dlf_th_ctrl[0]) & 0xff)
#define BCM53262_A0_FCON_DLF_TH_CTRLr_INDV_DLFTH_DROPf_SET(r,f) (r).fcon_dlf_th_ctrl[0]=(((r).fcon_dlf_th_ctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_DLF_TH_CTRLr_TOTAL_INDV_DLFTH_DROPf_GET(r) ((((r).fcon_dlf_th_ctrl[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_DLF_TH_CTRLr_TOTAL_INDV_DLFTH_DROPf_SET(r,f) (r).fcon_dlf_th_ctrl[0]=(((r).fcon_dlf_th_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_DLF_TH_CTRL.
 */
#define BCM53262_A0_READ_FCON_DLF_TH_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_DLF_TH_CTRLr,(r._fcon_dlf_th_ctrl),2)
#define BCM53262_A0_WRITE_FCON_DLF_TH_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_DLF_TH_CTRLr,&(r._fcon_dlf_th_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_DLF_TH_CTRLr BCM53262_A0_FCON_DLF_TH_CTRLr
#define FCON_DLF_TH_CTRLr_SIZE BCM53262_A0_FCON_DLF_TH_CTRLr_SIZE
typedef BCM53262_A0_FCON_DLF_TH_CTRLr_t FCON_DLF_TH_CTRLr_t;
#define FCON_DLF_TH_CTRLr_CLR BCM53262_A0_FCON_DLF_TH_CTRLr_CLR
#define FCON_DLF_TH_CTRLr_SET BCM53262_A0_FCON_DLF_TH_CTRLr_SET
#define FCON_DLF_TH_CTRLr_GET BCM53262_A0_FCON_DLF_TH_CTRLr_GET
#define FCON_DLF_TH_CTRLr_INDV_DLFTH_DROPf_GET BCM53262_A0_FCON_DLF_TH_CTRLr_INDV_DLFTH_DROPf_GET
#define FCON_DLF_TH_CTRLr_INDV_DLFTH_DROPf_SET BCM53262_A0_FCON_DLF_TH_CTRLr_INDV_DLFTH_DROPf_SET
#define FCON_DLF_TH_CTRLr_TOTAL_INDV_DLFTH_DROPf_GET BCM53262_A0_FCON_DLF_TH_CTRLr_TOTAL_INDV_DLFTH_DROPf_GET
#define FCON_DLF_TH_CTRLr_TOTAL_INDV_DLFTH_DROPf_SET BCM53262_A0_FCON_DLF_TH_CTRLr_TOTAL_INDV_DLFTH_DROPf_SET
#define READ_FCON_DLF_TH_CTRLr BCM53262_A0_READ_FCON_DLF_TH_CTRLr
#define WRITE_FCON_DLF_TH_CTRLr BCM53262_A0_WRITE_FCON_DLF_TH_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_DLF_TH_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS10
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 10
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ_CNT     
 *     FLOWCON_STATUS10_RSRV0 
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS10r 0x00000a2c

#define BCM53262_A0_FCON_FLOWCON_STATUS10r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS10.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS10r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status10[1];
	uint32_t _fcon_flowcon_status10;
} BCM53262_A0_FCON_FLOWCON_STATUS10r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS10r_CLR(r) (r).fcon_flowcon_status10[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS10r_SET(r,d) (r).fcon_flowcon_status10[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS10r_GET(r) (r).fcon_flowcon_status10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS10r_PEAK_TXQ_CNTf_GET(r) (((r).fcon_flowcon_status10[0]) & 0x7ff)
#define BCM53262_A0_FCON_FLOWCON_STATUS10r_PEAK_TXQ_CNTf_SET(r,f) (r).fcon_flowcon_status10[0]=(((r).fcon_flowcon_status10[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53262_A0_FCON_FLOWCON_STATUS10r_FLOWCON_STATUS10_RSRV0f_GET(r) ((((r).fcon_flowcon_status10[0]) >> 11) & 0x1f)
#define BCM53262_A0_FCON_FLOWCON_STATUS10r_FLOWCON_STATUS10_RSRV0f_SET(r,f) (r).fcon_flowcon_status10[0]=(((r).fcon_flowcon_status10[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS10.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS10r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS10r,(r._fcon_flowcon_status10),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS10r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS10r,&(r._fcon_flowcon_status10),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS10r BCM53262_A0_FCON_FLOWCON_STATUS10r
#define FCON_FLOWCON_STATUS10r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS10r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS10r_t FCON_FLOWCON_STATUS10r_t;
#define FCON_FLOWCON_STATUS10r_CLR BCM53262_A0_FCON_FLOWCON_STATUS10r_CLR
#define FCON_FLOWCON_STATUS10r_SET BCM53262_A0_FCON_FLOWCON_STATUS10r_SET
#define FCON_FLOWCON_STATUS10r_GET BCM53262_A0_FCON_FLOWCON_STATUS10r_GET
#define FCON_FLOWCON_STATUS10r_PEAK_TXQ_CNTf_GET BCM53262_A0_FCON_FLOWCON_STATUS10r_PEAK_TXQ_CNTf_GET
#define FCON_FLOWCON_STATUS10r_PEAK_TXQ_CNTf_SET BCM53262_A0_FCON_FLOWCON_STATUS10r_PEAK_TXQ_CNTf_SET
#define FCON_FLOWCON_STATUS10r_FLOWCON_STATUS10_RSRV0f_GET BCM53262_A0_FCON_FLOWCON_STATUS10r_FLOWCON_STATUS10_RSRV0f_GET
#define FCON_FLOWCON_STATUS10r_FLOWCON_STATUS10_RSRV0f_SET BCM53262_A0_FCON_FLOWCON_STATUS10r_FLOWCON_STATUS10_RSRV0f_SET
#define READ_FCON_FLOWCON_STATUS10r BCM53262_A0_READ_FCON_FLOWCON_STATUS10r
#define WRITE_FCON_FLOWCON_STATUS10r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS10r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS10r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS11
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 11
 * SIZE:     16
 * FIELDS:
 *     PEAK_RXBCNT      Diagnosis only: read on clearBased on mon-flowcon_reg_bus,, it keeps track the peak txq count on the monitored port since last read.
 *     RESERVED_R       
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS11r 0x00000a2e

#define BCM53262_A0_FCON_FLOWCON_STATUS11r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS11.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS11r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status11[1];
	uint32_t _fcon_flowcon_status11;
} BCM53262_A0_FCON_FLOWCON_STATUS11r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS11r_CLR(r) (r).fcon_flowcon_status11[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS11r_SET(r,d) (r).fcon_flowcon_status11[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS11r_GET(r) (r).fcon_flowcon_status11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS11r_PEAK_RXBCNTf_GET(r) (((r).fcon_flowcon_status11[0]) & 0x7ff)
#define BCM53262_A0_FCON_FLOWCON_STATUS11r_PEAK_RXBCNTf_SET(r,f) (r).fcon_flowcon_status11[0]=(((r).fcon_flowcon_status11[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53262_A0_FCON_FLOWCON_STATUS11r_RESERVED_Rf_GET(r) ((((r).fcon_flowcon_status11[0]) >> 11) & 0x1f)
#define BCM53262_A0_FCON_FLOWCON_STATUS11r_RESERVED_Rf_SET(r,f) (r).fcon_flowcon_status11[0]=(((r).fcon_flowcon_status11[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS11.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS11r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS11r,(r._fcon_flowcon_status11),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS11r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS11r,&(r._fcon_flowcon_status11),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS11r BCM53262_A0_FCON_FLOWCON_STATUS11r
#define FCON_FLOWCON_STATUS11r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS11r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS11r_t FCON_FLOWCON_STATUS11r_t;
#define FCON_FLOWCON_STATUS11r_CLR BCM53262_A0_FCON_FLOWCON_STATUS11r_CLR
#define FCON_FLOWCON_STATUS11r_SET BCM53262_A0_FCON_FLOWCON_STATUS11r_SET
#define FCON_FLOWCON_STATUS11r_GET BCM53262_A0_FCON_FLOWCON_STATUS11r_GET
#define FCON_FLOWCON_STATUS11r_PEAK_RXBCNTf_GET BCM53262_A0_FCON_FLOWCON_STATUS11r_PEAK_RXBCNTf_GET
#define FCON_FLOWCON_STATUS11r_PEAK_RXBCNTf_SET BCM53262_A0_FCON_FLOWCON_STATUS11r_PEAK_RXBCNTf_SET
#define FCON_FLOWCON_STATUS11r_RESERVED_Rf_GET BCM53262_A0_FCON_FLOWCON_STATUS11r_RESERVED_Rf_GET
#define FCON_FLOWCON_STATUS11r_RESERVED_Rf_SET BCM53262_A0_FCON_FLOWCON_STATUS11r_RESERVED_Rf_SET
#define READ_FCON_FLOWCON_STATUS11r BCM53262_A0_READ_FCON_FLOWCON_STATUS11r
#define WRITE_FCON_FLOWCON_STATUS11r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS11r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS11r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS12
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 12
 * SIZE:     16
 * FIELDS:
 *     RXBUF_ERR_HIS    When diag_hist_sel = 01 :Receive buffer error for pre-port : read on clear for port 31 to port 24;When diag_hist_sel = 10 :Receive buffer error for pre-port : read on clear for port 47 to port 32;When diag_hist_sel = 11 :Receive buffer error for pre-port : read on clear for port 52 to port 48;
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS12r 0x00000a3c

#define BCM53262_A0_FCON_FLOWCON_STATUS12r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS12.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS12r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status12[1];
	uint32_t _fcon_flowcon_status12;
} BCM53262_A0_FCON_FLOWCON_STATUS12r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS12r_CLR(r) (r).fcon_flowcon_status12[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS12r_SET(r,d) (r).fcon_flowcon_status12[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS12r_GET(r) (r).fcon_flowcon_status12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS12r_RXBUF_ERR_HISf_GET(r) (((r).fcon_flowcon_status12[0]) & 0xffff)
#define BCM53262_A0_FCON_FLOWCON_STATUS12r_RXBUF_ERR_HISf_SET(r,f) (r).fcon_flowcon_status12[0]=(((r).fcon_flowcon_status12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS12.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS12r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS12r,(r._fcon_flowcon_status12),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS12r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS12r,&(r._fcon_flowcon_status12),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS12r BCM53262_A0_FCON_FLOWCON_STATUS12r
#define FCON_FLOWCON_STATUS12r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS12r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS12r_t FCON_FLOWCON_STATUS12r_t;
#define FCON_FLOWCON_STATUS12r_CLR BCM53262_A0_FCON_FLOWCON_STATUS12r_CLR
#define FCON_FLOWCON_STATUS12r_SET BCM53262_A0_FCON_FLOWCON_STATUS12r_SET
#define FCON_FLOWCON_STATUS12r_GET BCM53262_A0_FCON_FLOWCON_STATUS12r_GET
#define FCON_FLOWCON_STATUS12r_RXBUF_ERR_HISf_GET BCM53262_A0_FCON_FLOWCON_STATUS12r_RXBUF_ERR_HISf_GET
#define FCON_FLOWCON_STATUS12r_RXBUF_ERR_HISf_SET BCM53262_A0_FCON_FLOWCON_STATUS12r_RXBUF_ERR_HISf_SET
#define READ_FCON_FLOWCON_STATUS12r BCM53262_A0_READ_FCON_FLOWCON_STATUS12r
#define WRITE_FCON_FLOWCON_STATUS12r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS12r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS2
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 2
 * SIZE:     16
 * FIELDS:
 *     MON_TXQ_CNT      Diagnosis only: txq_cnt in the monitored port.
 *     FLOWCON_STATUS2_RSRV0 Reserved.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS2r 0x00000a1c

#define BCM53262_A0_FCON_FLOWCON_STATUS2r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS2.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS2r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status2[1];
	uint32_t _fcon_flowcon_status2;
} BCM53262_A0_FCON_FLOWCON_STATUS2r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS2r_CLR(r) (r).fcon_flowcon_status2[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS2r_SET(r,d) (r).fcon_flowcon_status2[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS2r_GET(r) (r).fcon_flowcon_status2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS2r_MON_TXQ_CNTf_GET(r) (((r).fcon_flowcon_status2[0]) & 0x7ff)
#define BCM53262_A0_FCON_FLOWCON_STATUS2r_MON_TXQ_CNTf_SET(r,f) (r).fcon_flowcon_status2[0]=(((r).fcon_flowcon_status2[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53262_A0_FCON_FLOWCON_STATUS2r_FLOWCON_STATUS2_RSRV0f_GET(r) ((((r).fcon_flowcon_status2[0]) >> 11) & 0x1f)
#define BCM53262_A0_FCON_FLOWCON_STATUS2r_FLOWCON_STATUS2_RSRV0f_SET(r,f) (r).fcon_flowcon_status2[0]=(((r).fcon_flowcon_status2[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS2.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS2r,(r._fcon_flowcon_status2),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS2r,&(r._fcon_flowcon_status2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS2r BCM53262_A0_FCON_FLOWCON_STATUS2r
#define FCON_FLOWCON_STATUS2r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS2r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS2r_t FCON_FLOWCON_STATUS2r_t;
#define FCON_FLOWCON_STATUS2r_CLR BCM53262_A0_FCON_FLOWCON_STATUS2r_CLR
#define FCON_FLOWCON_STATUS2r_SET BCM53262_A0_FCON_FLOWCON_STATUS2r_SET
#define FCON_FLOWCON_STATUS2r_GET BCM53262_A0_FCON_FLOWCON_STATUS2r_GET
#define FCON_FLOWCON_STATUS2r_MON_TXQ_CNTf_GET BCM53262_A0_FCON_FLOWCON_STATUS2r_MON_TXQ_CNTf_GET
#define FCON_FLOWCON_STATUS2r_MON_TXQ_CNTf_SET BCM53262_A0_FCON_FLOWCON_STATUS2r_MON_TXQ_CNTf_SET
#define FCON_FLOWCON_STATUS2r_FLOWCON_STATUS2_RSRV0f_GET BCM53262_A0_FCON_FLOWCON_STATUS2r_FLOWCON_STATUS2_RSRV0f_GET
#define FCON_FLOWCON_STATUS2r_FLOWCON_STATUS2_RSRV0f_SET BCM53262_A0_FCON_FLOWCON_STATUS2r_FLOWCON_STATUS2_RSRV0f_SET
#define READ_FCON_FLOWCON_STATUS2r BCM53262_A0_READ_FCON_FLOWCON_STATUS2r
#define WRITE_FCON_FLOWCON_STATUS2r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS3
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 3
 * SIZE:     16
 * FIELDS:
 *     TXQ_FULL_HIST    Diagnosis only, Txq_full_hist on the monitored ports. When set to one means the corresponding port has reach txq_full condition since previous readWhen read out zero means the corresponding port has not reach txq_full condition since previous read.Note: the port map depends on diag_hist_sel.When diag_hist_sel is one.Txq_full_hist[15:0] => {5'b0. pt26"pt16}When diag_hist_sel is zero:Txq_full_hist[15:0] => {pt15: pt0}
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS3r 0x00000a1e

#define BCM53262_A0_FCON_FLOWCON_STATUS3r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS3.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS3r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status3[1];
	uint32_t _fcon_flowcon_status3;
} BCM53262_A0_FCON_FLOWCON_STATUS3r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS3r_CLR(r) (r).fcon_flowcon_status3[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS3r_SET(r,d) (r).fcon_flowcon_status3[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS3r_GET(r) (r).fcon_flowcon_status3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS3r_TXQ_FULL_HISTf_GET(r) (((r).fcon_flowcon_status3[0]) & 0xffff)
#define BCM53262_A0_FCON_FLOWCON_STATUS3r_TXQ_FULL_HISTf_SET(r,f) (r).fcon_flowcon_status3[0]=(((r).fcon_flowcon_status3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS3.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS3r,(r._fcon_flowcon_status3),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS3r,&(r._fcon_flowcon_status3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS3r BCM53262_A0_FCON_FLOWCON_STATUS3r
#define FCON_FLOWCON_STATUS3r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS3r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS3r_t FCON_FLOWCON_STATUS3r_t;
#define FCON_FLOWCON_STATUS3r_CLR BCM53262_A0_FCON_FLOWCON_STATUS3r_CLR
#define FCON_FLOWCON_STATUS3r_SET BCM53262_A0_FCON_FLOWCON_STATUS3r_SET
#define FCON_FLOWCON_STATUS3r_GET BCM53262_A0_FCON_FLOWCON_STATUS3r_GET
#define FCON_FLOWCON_STATUS3r_TXQ_FULL_HISTf_GET BCM53262_A0_FCON_FLOWCON_STATUS3r_TXQ_FULL_HISTf_GET
#define FCON_FLOWCON_STATUS3r_TXQ_FULL_HISTf_SET BCM53262_A0_FCON_FLOWCON_STATUS3r_TXQ_FULL_HISTf_SET
#define READ_FCON_FLOWCON_STATUS3r BCM53262_A0_READ_FCON_FLOWCON_STATUS3r
#define WRITE_FCON_FLOWCON_STATUS3r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS4
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 4
 * SIZE:     16
 * FIELDS:
 *     QOS_TX_DEBUG     Diannosis only. Qos_tx_debug_busIt provides debug info state on the txq fsm
 *     FLOWCON_STATUS4_RSRV0 
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS4r 0x00000a20

#define BCM53262_A0_FCON_FLOWCON_STATUS4r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS4.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS4r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status4[1];
	uint32_t _fcon_flowcon_status4;
} BCM53262_A0_FCON_FLOWCON_STATUS4r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS4r_CLR(r) (r).fcon_flowcon_status4[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS4r_SET(r,d) (r).fcon_flowcon_status4[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS4r_GET(r) (r).fcon_flowcon_status4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS4r_QOS_TX_DEBUGf_GET(r) (((r).fcon_flowcon_status4[0]) & 0xff)
#define BCM53262_A0_FCON_FLOWCON_STATUS4r_QOS_TX_DEBUGf_SET(r,f) (r).fcon_flowcon_status4[0]=(((r).fcon_flowcon_status4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_FLOWCON_STATUS4r_FLOWCON_STATUS4_RSRV0f_GET(r) ((((r).fcon_flowcon_status4[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_FLOWCON_STATUS4r_FLOWCON_STATUS4_RSRV0f_SET(r,f) (r).fcon_flowcon_status4[0]=(((r).fcon_flowcon_status4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS4.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS4r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS4r,(r._fcon_flowcon_status4),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS4r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS4r,&(r._fcon_flowcon_status4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS4r BCM53262_A0_FCON_FLOWCON_STATUS4r
#define FCON_FLOWCON_STATUS4r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS4r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS4r_t FCON_FLOWCON_STATUS4r_t;
#define FCON_FLOWCON_STATUS4r_CLR BCM53262_A0_FCON_FLOWCON_STATUS4r_CLR
#define FCON_FLOWCON_STATUS4r_SET BCM53262_A0_FCON_FLOWCON_STATUS4r_SET
#define FCON_FLOWCON_STATUS4r_GET BCM53262_A0_FCON_FLOWCON_STATUS4r_GET
#define FCON_FLOWCON_STATUS4r_QOS_TX_DEBUGf_GET BCM53262_A0_FCON_FLOWCON_STATUS4r_QOS_TX_DEBUGf_GET
#define FCON_FLOWCON_STATUS4r_QOS_TX_DEBUGf_SET BCM53262_A0_FCON_FLOWCON_STATUS4r_QOS_TX_DEBUGf_SET
#define FCON_FLOWCON_STATUS4r_FLOWCON_STATUS4_RSRV0f_GET BCM53262_A0_FCON_FLOWCON_STATUS4r_FLOWCON_STATUS4_RSRV0f_GET
#define FCON_FLOWCON_STATUS4r_FLOWCON_STATUS4_RSRV0f_SET BCM53262_A0_FCON_FLOWCON_STATUS4r_FLOWCON_STATUS4_RSRV0f_SET
#define READ_FCON_FLOWCON_STATUS4r BCM53262_A0_READ_FCON_FLOWCON_STATUS4r
#define WRITE_FCON_FLOWCON_STATUS4r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS4r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS5
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 5
 * SIZE:     16
 * FIELDS:
 *     DROP_HIST        Diagnosis only, drop_hist on the monitored ports. When set to one means the corresponding port has reach drop condition since previous readWhen read out zero means the corresponding port has not reach drop condition since previous read.Note: the port map depends on diag_hist_sel.When diag_hist_sel is one.drop_hist[15:0] => {5'b0. pt26"pt16}When diag_hist_sel is zero:drop_hist[15:0] => {pt15: pt0}
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS5r 0x00000a22

#define BCM53262_A0_FCON_FLOWCON_STATUS5r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS5.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS5r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status5[1];
	uint32_t _fcon_flowcon_status5;
} BCM53262_A0_FCON_FLOWCON_STATUS5r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS5r_CLR(r) (r).fcon_flowcon_status5[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS5r_SET(r,d) (r).fcon_flowcon_status5[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS5r_GET(r) (r).fcon_flowcon_status5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS5r_DROP_HISTf_GET(r) (((r).fcon_flowcon_status5[0]) & 0xffff)
#define BCM53262_A0_FCON_FLOWCON_STATUS5r_DROP_HISTf_SET(r,f) (r).fcon_flowcon_status5[0]=(((r).fcon_flowcon_status5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS5.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS5r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS5r,(r._fcon_flowcon_status5),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS5r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS5r,&(r._fcon_flowcon_status5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS5r BCM53262_A0_FCON_FLOWCON_STATUS5r
#define FCON_FLOWCON_STATUS5r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS5r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS5r_t FCON_FLOWCON_STATUS5r_t;
#define FCON_FLOWCON_STATUS5r_CLR BCM53262_A0_FCON_FLOWCON_STATUS5r_CLR
#define FCON_FLOWCON_STATUS5r_SET BCM53262_A0_FCON_FLOWCON_STATUS5r_SET
#define FCON_FLOWCON_STATUS5r_GET BCM53262_A0_FCON_FLOWCON_STATUS5r_GET
#define FCON_FLOWCON_STATUS5r_DROP_HISTf_GET BCM53262_A0_FCON_FLOWCON_STATUS5r_DROP_HISTf_GET
#define FCON_FLOWCON_STATUS5r_DROP_HISTf_SET BCM53262_A0_FCON_FLOWCON_STATUS5r_DROP_HISTf_SET
#define READ_FCON_FLOWCON_STATUS5r BCM53262_A0_READ_FCON_FLOWCON_STATUS5r
#define WRITE_FCON_FLOWCON_STATUS5r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS5r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS7
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 7
 * SIZE:     16
 * FIELDS:
 *     PAUSE_HIST       Diagnosis only, pause_hist on the monitored ports. When set to one means the corresponding port has reach pause condition since previous readWhen read out zero means the corresponding port has not reach pause condition since previous read.Note: the port map depends on diag_hist_sel.When diag_hist_sel is one.pause_hist[15:0] => {5'b0. pt26"pt16}When diag_hist_sel is zero:pause_hist[15:0] => {pt15: pt0}
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS7r 0x00000a26

#define BCM53262_A0_FCON_FLOWCON_STATUS7r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS7.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS7r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status7[1];
	uint32_t _fcon_flowcon_status7;
} BCM53262_A0_FCON_FLOWCON_STATUS7r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS7r_CLR(r) (r).fcon_flowcon_status7[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS7r_SET(r,d) (r).fcon_flowcon_status7[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS7r_GET(r) (r).fcon_flowcon_status7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS7r_PAUSE_HISTf_GET(r) (((r).fcon_flowcon_status7[0]) & 0xffff)
#define BCM53262_A0_FCON_FLOWCON_STATUS7r_PAUSE_HISTf_SET(r,f) (r).fcon_flowcon_status7[0]=(((r).fcon_flowcon_status7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS7.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS7r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS7r,(r._fcon_flowcon_status7),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS7r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS7r,&(r._fcon_flowcon_status7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS7r BCM53262_A0_FCON_FLOWCON_STATUS7r
#define FCON_FLOWCON_STATUS7r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS7r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS7r_t FCON_FLOWCON_STATUS7r_t;
#define FCON_FLOWCON_STATUS7r_CLR BCM53262_A0_FCON_FLOWCON_STATUS7r_CLR
#define FCON_FLOWCON_STATUS7r_SET BCM53262_A0_FCON_FLOWCON_STATUS7r_SET
#define FCON_FLOWCON_STATUS7r_GET BCM53262_A0_FCON_FLOWCON_STATUS7r_GET
#define FCON_FLOWCON_STATUS7r_PAUSE_HISTf_GET BCM53262_A0_FCON_FLOWCON_STATUS7r_PAUSE_HISTf_GET
#define FCON_FLOWCON_STATUS7r_PAUSE_HISTf_SET BCM53262_A0_FCON_FLOWCON_STATUS7r_PAUSE_HISTf_SET
#define READ_FCON_FLOWCON_STATUS7r BCM53262_A0_READ_FCON_FLOWCON_STATUS7r
#define WRITE_FCON_FLOWCON_STATUS7r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS7r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWCON_STATUS9
 * BLOCKS:   SYS
 * DESC:     Flow Control Status Register 9
 * SIZE:     16
 * FIELDS:
 *     PEAK_TOTAL_USED  Diagnosis only: read on clearIt keeps track the peak total used pointer in the whole sytem since last read
 *     FLOWCON_STATUS9_RSRV0 Reserved.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS9r 0x00000a2a

#define BCM53262_A0_FCON_FLOWCON_STATUS9r_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWCON_STATUS9.
 */
typedef union BCM53262_A0_FCON_FLOWCON_STATUS9r_s {
	uint32_t v[1];
	uint32_t fcon_flowcon_status9[1];
	uint32_t _fcon_flowcon_status9;
} BCM53262_A0_FCON_FLOWCON_STATUS9r_t;

#define BCM53262_A0_FCON_FLOWCON_STATUS9r_CLR(r) (r).fcon_flowcon_status9[0] = 0
#define BCM53262_A0_FCON_FLOWCON_STATUS9r_SET(r,d) (r).fcon_flowcon_status9[0] = d
#define BCM53262_A0_FCON_FLOWCON_STATUS9r_GET(r) (r).fcon_flowcon_status9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWCON_STATUS9r_PEAK_TOTAL_USEDf_GET(r) (((r).fcon_flowcon_status9[0]) & 0x3ff)
#define BCM53262_A0_FCON_FLOWCON_STATUS9r_PEAK_TOTAL_USEDf_SET(r,f) (r).fcon_flowcon_status9[0]=(((r).fcon_flowcon_status9[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53262_A0_FCON_FLOWCON_STATUS9r_FLOWCON_STATUS9_RSRV0f_GET(r) ((((r).fcon_flowcon_status9[0]) >> 10) & 0x3f)
#define BCM53262_A0_FCON_FLOWCON_STATUS9r_FLOWCON_STATUS9_RSRV0f_SET(r,f) (r).fcon_flowcon_status9[0]=(((r).fcon_flowcon_status9[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FCON_FLOWCON_STATUS9.
 */
#define BCM53262_A0_READ_FCON_FLOWCON_STATUS9r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWCON_STATUS9r,(r._fcon_flowcon_status9),2)
#define BCM53262_A0_WRITE_FCON_FLOWCON_STATUS9r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWCON_STATUS9r,&(r._fcon_flowcon_status9),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWCON_STATUS9r BCM53262_A0_FCON_FLOWCON_STATUS9r
#define FCON_FLOWCON_STATUS9r_SIZE BCM53262_A0_FCON_FLOWCON_STATUS9r_SIZE
typedef BCM53262_A0_FCON_FLOWCON_STATUS9r_t FCON_FLOWCON_STATUS9r_t;
#define FCON_FLOWCON_STATUS9r_CLR BCM53262_A0_FCON_FLOWCON_STATUS9r_CLR
#define FCON_FLOWCON_STATUS9r_SET BCM53262_A0_FCON_FLOWCON_STATUS9r_SET
#define FCON_FLOWCON_STATUS9r_GET BCM53262_A0_FCON_FLOWCON_STATUS9r_GET
#define FCON_FLOWCON_STATUS9r_PEAK_TOTAL_USEDf_GET BCM53262_A0_FCON_FLOWCON_STATUS9r_PEAK_TOTAL_USEDf_GET
#define FCON_FLOWCON_STATUS9r_PEAK_TOTAL_USEDf_SET BCM53262_A0_FCON_FLOWCON_STATUS9r_PEAK_TOTAL_USEDf_SET
#define FCON_FLOWCON_STATUS9r_FLOWCON_STATUS9_RSRV0f_GET BCM53262_A0_FCON_FLOWCON_STATUS9r_FLOWCON_STATUS9_RSRV0f_GET
#define FCON_FLOWCON_STATUS9r_FLOWCON_STATUS9_RSRV0f_SET BCM53262_A0_FCON_FLOWCON_STATUS9r_FLOWCON_STATUS9_RSRV0f_SET
#define READ_FCON_FLOWCON_STATUS9r BCM53262_A0_READ_FCON_FLOWCON_STATUS9r
#define WRITE_FCON_FLOWCON_STATUS9r BCM53262_A0_WRITE_FCON_FLOWCON_STATUS9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWCON_STATUS9r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_FLOWMIX
 * BLOCKS:   SYS
 * DESC:     Global Option Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_RX_PAUSE      enable unicast pause frame generation  due to rx base flow control scheme.
 *     EN_RX_DROP       enable unicast drop feature due to rx base  flow control scheme.
 *     EN_TXQ_PAUSE     enable unicast pause frame generation  due to tx base flow control scheme.
 *     EN_UCAST_DROP    enable unicast drop feature due to  tx base flow control scheme.defualt value is 1 when QOS on,default value is 0 if QOS off .
 *     EN_MCAST_DROP    enable mcast drop feature due to rx base and tx base flow control scheme.
 *     EN_TXQ_FULL      
 *     EN_QUARTER_DROP  enable dropping when a TXQ reaches Txq Full threshold. It is not recommend to turn on this feature at all.Note: it is recommended not release  this  register to our customers
 *     AGGRESSIVE_DROP  Aggressive drop mode.
 *     EN_RSRV_DROP     
 *     RESERVED_1R      Reserved.
 *     EN_MCAST_BLANCE  Enable multicast traffic balance1 : use hund_pause and hund_unpause0 : use mcast_drop threshold
 *     EN_PARKING_PREVENTION when enable, flowcon can handle parking condition and prevent unfairness,when disable, the behavior is same as bcm5324.
 *     QOS_RSRV_QUOTA_OPT 00: Reserved quota Q3:Q2:Q1:Q0=64:32:16:8(suggested setting for QoS mode and flow control off) (default value)01: Reserved quota Q3:Q2:Q1:Q0=32:16:8:410: Reserved quota Q3:Q2:Q1:Q0=14:6:3:2(suggested setting for none-QoS mode or flow control on)11: Reserved quota of all queues are the sameas reserve balance (offset 4A, bit[7:0])
 *     EN_INDV_DLF_BCATDROP_TH Enable local port individual DLF and broadcast drop threshold.
 *     RESERVED_4R      Reserved.
 */
#define BCM53262_A0_FCON_FLOWMIXr 0x00000a30

#define BCM53262_A0_FCON_FLOWMIXr_SIZE 2

/*
 * This structure should be used to declare and program FCON_FLOWMIX.
 */
typedef union BCM53262_A0_FCON_FLOWMIXr_s {
	uint32_t v[1];
	uint32_t fcon_flowmix[1];
	uint32_t _fcon_flowmix;
} BCM53262_A0_FCON_FLOWMIXr_t;

#define BCM53262_A0_FCON_FLOWMIXr_CLR(r) (r).fcon_flowmix[0] = 0
#define BCM53262_A0_FCON_FLOWMIXr_SET(r,d) (r).fcon_flowmix[0] = d
#define BCM53262_A0_FCON_FLOWMIXr_GET(r) (r).fcon_flowmix[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_FLOWMIXr_EN_RX_PAUSEf_GET(r) (((r).fcon_flowmix[0]) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_RX_PAUSEf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_FCON_FLOWMIXr_EN_RX_DROPf_GET(r) ((((r).fcon_flowmix[0]) >> 1) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_RX_DROPf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_PAUSEf_GET(r) ((((r).fcon_flowmix[0]) >> 2) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_PAUSEf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_FCON_FLOWMIXr_EN_UCAST_DROPf_GET(r) ((((r).fcon_flowmix[0]) >> 3) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_UCAST_DROPf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_DROPf_GET(r) ((((r).fcon_flowmix[0]) >> 4) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_DROPf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_FULLf_GET(r) ((((r).fcon_flowmix[0]) >> 5) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_FULLf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_FCON_FLOWMIXr_EN_QUARTER_DROPf_GET(r) ((((r).fcon_flowmix[0]) >> 6) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_QUARTER_DROPf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_FCON_FLOWMIXr_AGGRESSIVE_DROPf_GET(r) ((((r).fcon_flowmix[0]) >> 7) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_AGGRESSIVE_DROPf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_FCON_FLOWMIXr_EN_RSRV_DROPf_GET(r) ((((r).fcon_flowmix[0]) >> 8) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_RSRV_DROPf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_FCON_FLOWMIXr_RESERVED_1Rf_GET(r) ((((r).fcon_flowmix[0]) >> 9) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_RESERVED_1Rf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_BLANCEf_GET(r) ((((r).fcon_flowmix[0]) >> 10) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_BLANCEf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_FCON_FLOWMIXr_EN_PARKING_PREVENTIONf_GET(r) ((((r).fcon_flowmix[0]) >> 11) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_PARKING_PREVENTIONf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_FCON_FLOWMIXr_QOS_RSRV_QUOTA_OPTf_GET(r) ((((r).fcon_flowmix[0]) >> 12) & 0x3)
#define BCM53262_A0_FCON_FLOWMIXr_QOS_RSRV_QUOTA_OPTf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_FCON_FLOWMIXr_EN_INDV_DLF_BCATDROP_THf_GET(r) ((((r).fcon_flowmix[0]) >> 14) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_EN_INDV_DLF_BCATDROP_THf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_FCON_FLOWMIXr_RESERVED_4Rf_GET(r) ((((r).fcon_flowmix[0]) >> 15) & 0x1)
#define BCM53262_A0_FCON_FLOWMIXr_RESERVED_4Rf_SET(r,f) (r).fcon_flowmix[0]=(((r).fcon_flowmix[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FCON_FLOWMIX.
 */
#define BCM53262_A0_READ_FCON_FLOWMIXr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_FLOWMIXr,(r._fcon_flowmix),2)
#define BCM53262_A0_WRITE_FCON_FLOWMIXr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_FLOWMIXr,&(r._fcon_flowmix),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_FLOWMIXr BCM53262_A0_FCON_FLOWMIXr
#define FCON_FLOWMIXr_SIZE BCM53262_A0_FCON_FLOWMIXr_SIZE
typedef BCM53262_A0_FCON_FLOWMIXr_t FCON_FLOWMIXr_t;
#define FCON_FLOWMIXr_CLR BCM53262_A0_FCON_FLOWMIXr_CLR
#define FCON_FLOWMIXr_SET BCM53262_A0_FCON_FLOWMIXr_SET
#define FCON_FLOWMIXr_GET BCM53262_A0_FCON_FLOWMIXr_GET
#define FCON_FLOWMIXr_EN_RX_PAUSEf_GET BCM53262_A0_FCON_FLOWMIXr_EN_RX_PAUSEf_GET
#define FCON_FLOWMIXr_EN_RX_PAUSEf_SET BCM53262_A0_FCON_FLOWMIXr_EN_RX_PAUSEf_SET
#define FCON_FLOWMIXr_EN_RX_DROPf_GET BCM53262_A0_FCON_FLOWMIXr_EN_RX_DROPf_GET
#define FCON_FLOWMIXr_EN_RX_DROPf_SET BCM53262_A0_FCON_FLOWMIXr_EN_RX_DROPf_SET
#define FCON_FLOWMIXr_EN_TXQ_PAUSEf_GET BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_PAUSEf_GET
#define FCON_FLOWMIXr_EN_TXQ_PAUSEf_SET BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_PAUSEf_SET
#define FCON_FLOWMIXr_EN_UCAST_DROPf_GET BCM53262_A0_FCON_FLOWMIXr_EN_UCAST_DROPf_GET
#define FCON_FLOWMIXr_EN_UCAST_DROPf_SET BCM53262_A0_FCON_FLOWMIXr_EN_UCAST_DROPf_SET
#define FCON_FLOWMIXr_EN_MCAST_DROPf_GET BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_DROPf_GET
#define FCON_FLOWMIXr_EN_MCAST_DROPf_SET BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_DROPf_SET
#define FCON_FLOWMIXr_EN_TXQ_FULLf_GET BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_FULLf_GET
#define FCON_FLOWMIXr_EN_TXQ_FULLf_SET BCM53262_A0_FCON_FLOWMIXr_EN_TXQ_FULLf_SET
#define FCON_FLOWMIXr_EN_QUARTER_DROPf_GET BCM53262_A0_FCON_FLOWMIXr_EN_QUARTER_DROPf_GET
#define FCON_FLOWMIXr_EN_QUARTER_DROPf_SET BCM53262_A0_FCON_FLOWMIXr_EN_QUARTER_DROPf_SET
#define FCON_FLOWMIXr_AGGRESSIVE_DROPf_GET BCM53262_A0_FCON_FLOWMIXr_AGGRESSIVE_DROPf_GET
#define FCON_FLOWMIXr_AGGRESSIVE_DROPf_SET BCM53262_A0_FCON_FLOWMIXr_AGGRESSIVE_DROPf_SET
#define FCON_FLOWMIXr_EN_RSRV_DROPf_GET BCM53262_A0_FCON_FLOWMIXr_EN_RSRV_DROPf_GET
#define FCON_FLOWMIXr_EN_RSRV_DROPf_SET BCM53262_A0_FCON_FLOWMIXr_EN_RSRV_DROPf_SET
#define FCON_FLOWMIXr_RESERVED_1Rf_GET BCM53262_A0_FCON_FLOWMIXr_RESERVED_1Rf_GET
#define FCON_FLOWMIXr_RESERVED_1Rf_SET BCM53262_A0_FCON_FLOWMIXr_RESERVED_1Rf_SET
#define FCON_FLOWMIXr_EN_MCAST_BLANCEf_GET BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_BLANCEf_GET
#define FCON_FLOWMIXr_EN_MCAST_BLANCEf_SET BCM53262_A0_FCON_FLOWMIXr_EN_MCAST_BLANCEf_SET
#define FCON_FLOWMIXr_EN_PARKING_PREVENTIONf_GET BCM53262_A0_FCON_FLOWMIXr_EN_PARKING_PREVENTIONf_GET
#define FCON_FLOWMIXr_EN_PARKING_PREVENTIONf_SET BCM53262_A0_FCON_FLOWMIXr_EN_PARKING_PREVENTIONf_SET
#define FCON_FLOWMIXr_QOS_RSRV_QUOTA_OPTf_GET BCM53262_A0_FCON_FLOWMIXr_QOS_RSRV_QUOTA_OPTf_GET
#define FCON_FLOWMIXr_QOS_RSRV_QUOTA_OPTf_SET BCM53262_A0_FCON_FLOWMIXr_QOS_RSRV_QUOTA_OPTf_SET
#define FCON_FLOWMIXr_EN_INDV_DLF_BCATDROP_THf_GET BCM53262_A0_FCON_FLOWMIXr_EN_INDV_DLF_BCATDROP_THf_GET
#define FCON_FLOWMIXr_EN_INDV_DLF_BCATDROP_THf_SET BCM53262_A0_FCON_FLOWMIXr_EN_INDV_DLF_BCATDROP_THf_SET
#define FCON_FLOWMIXr_RESERVED_4Rf_GET BCM53262_A0_FCON_FLOWMIXr_RESERVED_4Rf_GET
#define FCON_FLOWMIXr_RESERVED_4Rf_SET BCM53262_A0_FCON_FLOWMIXr_RESERVED_4Rf_SET
#define READ_FCON_FLOWMIXr BCM53262_A0_READ_FCON_FLOWMIXr
#define WRITE_FCON_FLOWMIXr BCM53262_A0_WRITE_FCON_FLOWMIXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_FLOWMIXr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_GLOB_TH_CTRL_1
 * BLOCKS:   SYS
 * DESC:     Total-Q0 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     FCON_GLOB_PAUSE_TH The pause threshold for txq base flow control when checking the total txq occupiency. The effective threshold is this register value times 8. When the number of  pointers that is queued up in all  txqs rises above this threhold , a pause frame will be sent out.
 *     FCON_GLOB_HYST_TH The unpause threshold for txq base flow control when checking the total txq occupiency. The effective threshold is this register value times 8. After  a pause condition is met, when the number of  pointers that is queued up in all  txqs falls below this threhold , an unpause frame will be sent out.
 */
#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r 0x00000a0e

#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_SIZE 2

/*
 * This structure should be used to declare and program FCON_GLOB_TH_CTRL_1.
 */
typedef union BCM53262_A0_FCON_GLOB_TH_CTRL_1r_s {
	uint32_t v[1];
	uint32_t fcon_glob_th_ctrl_1[1];
	uint32_t _fcon_glob_th_ctrl_1;
} BCM53262_A0_FCON_GLOB_TH_CTRL_1r_t;

#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_CLR(r) (r).fcon_glob_th_ctrl_1[0] = 0
#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_SET(r,d) (r).fcon_glob_th_ctrl_1[0] = d
#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_GET(r) (r).fcon_glob_th_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_PAUSE_THf_GET(r) (((r).fcon_glob_th_ctrl_1[0]) & 0xff)
#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_PAUSE_THf_SET(r,f) (r).fcon_glob_th_ctrl_1[0]=(((r).fcon_glob_th_ctrl_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_HYST_THf_GET(r) ((((r).fcon_glob_th_ctrl_1[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_HYST_THf_SET(r,f) (r).fcon_glob_th_ctrl_1[0]=(((r).fcon_glob_th_ctrl_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_GLOB_TH_CTRL_1.
 */
#define BCM53262_A0_READ_FCON_GLOB_TH_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_GLOB_TH_CTRL_1r,(r._fcon_glob_th_ctrl_1),2)
#define BCM53262_A0_WRITE_FCON_GLOB_TH_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_GLOB_TH_CTRL_1r,&(r._fcon_glob_th_ctrl_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_GLOB_TH_CTRL_1r BCM53262_A0_FCON_GLOB_TH_CTRL_1r
#define FCON_GLOB_TH_CTRL_1r_SIZE BCM53262_A0_FCON_GLOB_TH_CTRL_1r_SIZE
typedef BCM53262_A0_FCON_GLOB_TH_CTRL_1r_t FCON_GLOB_TH_CTRL_1r_t;
#define FCON_GLOB_TH_CTRL_1r_CLR BCM53262_A0_FCON_GLOB_TH_CTRL_1r_CLR
#define FCON_GLOB_TH_CTRL_1r_SET BCM53262_A0_FCON_GLOB_TH_CTRL_1r_SET
#define FCON_GLOB_TH_CTRL_1r_GET BCM53262_A0_FCON_GLOB_TH_CTRL_1r_GET
#define FCON_GLOB_TH_CTRL_1r_FCON_GLOB_PAUSE_THf_GET BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_PAUSE_THf_GET
#define FCON_GLOB_TH_CTRL_1r_FCON_GLOB_PAUSE_THf_SET BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_PAUSE_THf_SET
#define FCON_GLOB_TH_CTRL_1r_FCON_GLOB_HYST_THf_GET BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_HYST_THf_GET
#define FCON_GLOB_TH_CTRL_1r_FCON_GLOB_HYST_THf_SET BCM53262_A0_FCON_GLOB_TH_CTRL_1r_FCON_GLOB_HYST_THf_SET
#define READ_FCON_GLOB_TH_CTRL_1r BCM53262_A0_READ_FCON_GLOB_TH_CTRL_1r
#define WRITE_FCON_GLOB_TH_CTRL_1r BCM53262_A0_WRITE_FCON_GLOB_TH_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_GLOB_TH_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_GLOB_TH_CTRL_2
 * BLOCKS:   SYS
 * DESC:     Total-Q0 UC/MC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     FCON_GLOB_MCDROP_TH The mcast drop threshold for txq base flow control when checking the total txq occupiency. The effective threshold is this register value times 8. When the number of  pointers that is queued up in all  txqs rises above this threhold , the incoming mcast frame will be drop.
 *     FCON_GLOB_DROP_TH The unicast drop threshold for txq base flow control when checking the total txq occupiency. The effective threshold is this register value times 8. When the number of  pointers that is queued up in all  txqs rises above this threhold , the incoming unicast frame will be drop.
 */
#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r 0x00000a10

#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_SIZE 2

/*
 * This structure should be used to declare and program FCON_GLOB_TH_CTRL_2.
 */
typedef union BCM53262_A0_FCON_GLOB_TH_CTRL_2r_s {
	uint32_t v[1];
	uint32_t fcon_glob_th_ctrl_2[1];
	uint32_t _fcon_glob_th_ctrl_2;
} BCM53262_A0_FCON_GLOB_TH_CTRL_2r_t;

#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_CLR(r) (r).fcon_glob_th_ctrl_2[0] = 0
#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_SET(r,d) (r).fcon_glob_th_ctrl_2[0] = d
#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_GET(r) (r).fcon_glob_th_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_MCDROP_THf_GET(r) (((r).fcon_glob_th_ctrl_2[0]) & 0xff)
#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_MCDROP_THf_SET(r,f) (r).fcon_glob_th_ctrl_2[0]=(((r).fcon_glob_th_ctrl_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_DROP_THf_GET(r) ((((r).fcon_glob_th_ctrl_2[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_DROP_THf_SET(r,f) (r).fcon_glob_th_ctrl_2[0]=(((r).fcon_glob_th_ctrl_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_GLOB_TH_CTRL_2.
 */
#define BCM53262_A0_READ_FCON_GLOB_TH_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_GLOB_TH_CTRL_2r,(r._fcon_glob_th_ctrl_2),2)
#define BCM53262_A0_WRITE_FCON_GLOB_TH_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_GLOB_TH_CTRL_2r,&(r._fcon_glob_th_ctrl_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_GLOB_TH_CTRL_2r BCM53262_A0_FCON_GLOB_TH_CTRL_2r
#define FCON_GLOB_TH_CTRL_2r_SIZE BCM53262_A0_FCON_GLOB_TH_CTRL_2r_SIZE
typedef BCM53262_A0_FCON_GLOB_TH_CTRL_2r_t FCON_GLOB_TH_CTRL_2r_t;
#define FCON_GLOB_TH_CTRL_2r_CLR BCM53262_A0_FCON_GLOB_TH_CTRL_2r_CLR
#define FCON_GLOB_TH_CTRL_2r_SET BCM53262_A0_FCON_GLOB_TH_CTRL_2r_SET
#define FCON_GLOB_TH_CTRL_2r_GET BCM53262_A0_FCON_GLOB_TH_CTRL_2r_GET
#define FCON_GLOB_TH_CTRL_2r_FCON_GLOB_MCDROP_THf_GET BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_MCDROP_THf_GET
#define FCON_GLOB_TH_CTRL_2r_FCON_GLOB_MCDROP_THf_SET BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_MCDROP_THf_SET
#define FCON_GLOB_TH_CTRL_2r_FCON_GLOB_DROP_THf_GET BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_DROP_THf_GET
#define FCON_GLOB_TH_CTRL_2r_FCON_GLOB_DROP_THf_SET BCM53262_A0_FCON_GLOB_TH_CTRL_2r_FCON_GLOB_DROP_THf_SET
#define READ_FCON_GLOB_TH_CTRL_2r BCM53262_A0_READ_FCON_GLOB_TH_CTRL_2r
#define WRITE_FCON_GLOB_TH_CTRL_2r BCM53262_A0_WRITE_FCON_GLOB_TH_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_GLOB_TH_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_MISC_CTRL
 * BLOCKS:   SYS
 * DESC:     CPU/MII Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MII_TH_SEL    Enable MII Threshold select
 *     RESERVED_0R      Reserved
 *     QUEUE_TH_SEL     00 : same as ten or hund01 : 1/2 as ten or hund10 : 1/4 as ten or hund11 : 1/8 as ten or hund
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_FCON_MISC_CTRLr 0x00000a32

#define BCM53262_A0_FCON_MISC_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FCON_MISC_CTRL.
 */
typedef union BCM53262_A0_FCON_MISC_CTRLr_s {
	uint32_t v[1];
	uint32_t fcon_misc_ctrl[1];
	uint32_t _fcon_misc_ctrl;
} BCM53262_A0_FCON_MISC_CTRLr_t;

#define BCM53262_A0_FCON_MISC_CTRLr_CLR(r) (r).fcon_misc_ctrl[0] = 0
#define BCM53262_A0_FCON_MISC_CTRLr_SET(r,d) (r).fcon_misc_ctrl[0] = d
#define BCM53262_A0_FCON_MISC_CTRLr_GET(r) (r).fcon_misc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_MISC_CTRLr_EN_MII_TH_SELf_GET(r) (((r).fcon_misc_ctrl[0]) & 0x1)
#define BCM53262_A0_FCON_MISC_CTRLr_EN_MII_TH_SELf_SET(r,f) (r).fcon_misc_ctrl[0]=(((r).fcon_misc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_FCON_MISC_CTRLr_RESERVED_0Rf_GET(r) ((((r).fcon_misc_ctrl[0]) >> 1) & 0x1)
#define BCM53262_A0_FCON_MISC_CTRLr_RESERVED_0Rf_SET(r,f) (r).fcon_misc_ctrl[0]=(((r).fcon_misc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_FCON_MISC_CTRLr_QUEUE_TH_SELf_GET(r) ((((r).fcon_misc_ctrl[0]) >> 2) & 0x3)
#define BCM53262_A0_FCON_MISC_CTRLr_QUEUE_TH_SELf_SET(r,f) (r).fcon_misc_ctrl[0]=(((r).fcon_misc_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_FCON_MISC_CTRLr_RESERVED_1Rf_GET(r) ((((r).fcon_misc_ctrl[0]) >> 4) & 0xfff)
#define BCM53262_A0_FCON_MISC_CTRLr_RESERVED_1Rf_SET(r,f) (r).fcon_misc_ctrl[0]=(((r).fcon_misc_ctrl[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access FCON_MISC_CTRL.
 */
#define BCM53262_A0_READ_FCON_MISC_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_MISC_CTRLr,(r._fcon_misc_ctrl),2)
#define BCM53262_A0_WRITE_FCON_MISC_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_MISC_CTRLr,&(r._fcon_misc_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_MISC_CTRLr BCM53262_A0_FCON_MISC_CTRLr
#define FCON_MISC_CTRLr_SIZE BCM53262_A0_FCON_MISC_CTRLr_SIZE
typedef BCM53262_A0_FCON_MISC_CTRLr_t FCON_MISC_CTRLr_t;
#define FCON_MISC_CTRLr_CLR BCM53262_A0_FCON_MISC_CTRLr_CLR
#define FCON_MISC_CTRLr_SET BCM53262_A0_FCON_MISC_CTRLr_SET
#define FCON_MISC_CTRLr_GET BCM53262_A0_FCON_MISC_CTRLr_GET
#define FCON_MISC_CTRLr_EN_MII_TH_SELf_GET BCM53262_A0_FCON_MISC_CTRLr_EN_MII_TH_SELf_GET
#define FCON_MISC_CTRLr_EN_MII_TH_SELf_SET BCM53262_A0_FCON_MISC_CTRLr_EN_MII_TH_SELf_SET
#define FCON_MISC_CTRLr_RESERVED_0Rf_GET BCM53262_A0_FCON_MISC_CTRLr_RESERVED_0Rf_GET
#define FCON_MISC_CTRLr_RESERVED_0Rf_SET BCM53262_A0_FCON_MISC_CTRLr_RESERVED_0Rf_SET
#define FCON_MISC_CTRLr_QUEUE_TH_SELf_GET BCM53262_A0_FCON_MISC_CTRLr_QUEUE_TH_SELf_GET
#define FCON_MISC_CTRLr_QUEUE_TH_SELf_SET BCM53262_A0_FCON_MISC_CTRLr_QUEUE_TH_SELf_SET
#define FCON_MISC_CTRLr_RESERVED_1Rf_GET BCM53262_A0_FCON_MISC_CTRLr_RESERVED_1Rf_GET
#define FCON_MISC_CTRLr_RESERVED_1Rf_SET BCM53262_A0_FCON_MISC_CTRLr_RESERVED_1Rf_SET
#define READ_FCON_MISC_CTRLr BCM53262_A0_READ_FCON_MISC_CTRLr
#define WRITE_FCON_MISC_CTRLr BCM53262_A0_WRITE_FCON_MISC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_MISC_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_MISC_TXFLOW_CTRL
 * BLOCKS:   SYS
 * DESC:     Miscellaneous Tx Flow Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVE_BLANCE   The reserved txq threshold. When the number of  pointers that is queued up in corresponding txq falls below this threshold, no pause/ drop operation will be applied. This is used to provide HOL prevention feature.default value : 2, when QOS = 1;                6, when QOS = 0.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr 0x00000a4a

#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FCON_MISC_TXFLOW_CTRL.
 */
typedef union BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_s {
	uint32_t v[1];
	uint32_t fcon_misc_txflow_ctrl[1];
	uint32_t _fcon_misc_txflow_ctrl;
} BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_t;

#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_CLR(r) (r).fcon_misc_txflow_ctrl[0] = 0
#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_SET(r,d) (r).fcon_misc_txflow_ctrl[0] = d
#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_GET(r) (r).fcon_misc_txflow_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVE_BLANCEf_GET(r) (((r).fcon_misc_txflow_ctrl[0]) & 0xff)
#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVE_BLANCEf_SET(r,f) (r).fcon_misc_txflow_ctrl[0]=(((r).fcon_misc_txflow_ctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVED_Rf_GET(r) ((((r).fcon_misc_txflow_ctrl[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVED_Rf_SET(r,f) (r).fcon_misc_txflow_ctrl[0]=(((r).fcon_misc_txflow_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_MISC_TXFLOW_CTRL.
 */
#define BCM53262_A0_READ_FCON_MISC_TXFLOW_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_MISC_TXFLOW_CTRLr,(r._fcon_misc_txflow_ctrl),2)
#define BCM53262_A0_WRITE_FCON_MISC_TXFLOW_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_MISC_TXFLOW_CTRLr,&(r._fcon_misc_txflow_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_MISC_TXFLOW_CTRLr BCM53262_A0_FCON_MISC_TXFLOW_CTRLr
#define FCON_MISC_TXFLOW_CTRLr_SIZE BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_SIZE
typedef BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_t FCON_MISC_TXFLOW_CTRLr_t;
#define FCON_MISC_TXFLOW_CTRLr_CLR BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_CLR
#define FCON_MISC_TXFLOW_CTRLr_SET BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_SET
#define FCON_MISC_TXFLOW_CTRLr_GET BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_GET
#define FCON_MISC_TXFLOW_CTRLr_RESERVE_BLANCEf_GET BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVE_BLANCEf_GET
#define FCON_MISC_TXFLOW_CTRLr_RESERVE_BLANCEf_SET BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVE_BLANCEf_SET
#define FCON_MISC_TXFLOW_CTRLr_RESERVED_Rf_GET BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVED_Rf_GET
#define FCON_MISC_TXFLOW_CTRLr_RESERVED_Rf_SET BCM53262_A0_FCON_MISC_TXFLOW_CTRLr_RESERVED_Rf_SET
#define READ_FCON_MISC_TXFLOW_CTRLr BCM53262_A0_READ_FCON_MISC_TXFLOW_CTRLr
#define WRITE_FCON_MISC_TXFLOW_CTRLr BCM53262_A0_WRITE_FCON_MISC_TXFLOW_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_MISC_TXFLOW_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_PERQ_TXDROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Pre-Queue Tx-Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     LOC_TXDROP       Local port tx-drop for each queue.
 *     MII_TXDROP       IMP port tx-drop for each queue.
 *     RESERVED_1R      Reserved.
 *     EN_PREQ_TXDROP   Enable per-queue tx-drop.
 *     RESERVED_2R      Reserved
 */
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr 0x00000a34

#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FCON_PERQ_TXDROP_CTRL.
 */
typedef union BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fcon_perq_txdrop_ctrl[1];
	uint32_t _fcon_perq_txdrop_ctrl;
} BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_t;

#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_CLR(r) (r).fcon_perq_txdrop_ctrl[0] = 0
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_SET(r,d) (r).fcon_perq_txdrop_ctrl[0] = d
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_GET(r) (r).fcon_perq_txdrop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_LOC_TXDROPf_GET(r) (((r).fcon_perq_txdrop_ctrl[0]) & 0xf)
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_LOC_TXDROPf_SET(r,f) (r).fcon_perq_txdrop_ctrl[0]=(((r).fcon_perq_txdrop_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_MII_TXDROPf_GET(r) ((((r).fcon_perq_txdrop_ctrl[0]) >> 4) & 0xf)
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_MII_TXDROPf_SET(r,f) (r).fcon_perq_txdrop_ctrl[0]=(((r).fcon_perq_txdrop_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_1Rf_GET(r) ((((r).fcon_perq_txdrop_ctrl[0]) >> 8) & 0xf)
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_1Rf_SET(r,f) (r).fcon_perq_txdrop_ctrl[0]=(((r).fcon_perq_txdrop_ctrl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_EN_PREQ_TXDROPf_GET(r) ((((r).fcon_perq_txdrop_ctrl[0]) >> 12) & 0x1)
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_EN_PREQ_TXDROPf_SET(r,f) (r).fcon_perq_txdrop_ctrl[0]=(((r).fcon_perq_txdrop_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_2Rf_GET(r) ((((r).fcon_perq_txdrop_ctrl[0]) >> 13) & 0x7)
#define BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_2Rf_SET(r,f) (r).fcon_perq_txdrop_ctrl[0]=(((r).fcon_perq_txdrop_ctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access FCON_PERQ_TXDROP_CTRL.
 */
#define BCM53262_A0_READ_FCON_PERQ_TXDROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_PERQ_TXDROP_CTRLr,(r._fcon_perq_txdrop_ctrl),2)
#define BCM53262_A0_WRITE_FCON_PERQ_TXDROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_PERQ_TXDROP_CTRLr,&(r._fcon_perq_txdrop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_PERQ_TXDROP_CTRLr BCM53262_A0_FCON_PERQ_TXDROP_CTRLr
#define FCON_PERQ_TXDROP_CTRLr_SIZE BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_SIZE
typedef BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_t FCON_PERQ_TXDROP_CTRLr_t;
#define FCON_PERQ_TXDROP_CTRLr_CLR BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_CLR
#define FCON_PERQ_TXDROP_CTRLr_SET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_SET
#define FCON_PERQ_TXDROP_CTRLr_GET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_GET
#define FCON_PERQ_TXDROP_CTRLr_LOC_TXDROPf_GET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_LOC_TXDROPf_GET
#define FCON_PERQ_TXDROP_CTRLr_LOC_TXDROPf_SET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_LOC_TXDROPf_SET
#define FCON_PERQ_TXDROP_CTRLr_MII_TXDROPf_GET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_MII_TXDROPf_GET
#define FCON_PERQ_TXDROP_CTRLr_MII_TXDROPf_SET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_MII_TXDROPf_SET
#define FCON_PERQ_TXDROP_CTRLr_RESERVED_1Rf_GET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_1Rf_GET
#define FCON_PERQ_TXDROP_CTRLr_RESERVED_1Rf_SET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_1Rf_SET
#define FCON_PERQ_TXDROP_CTRLr_EN_PREQ_TXDROPf_GET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_EN_PREQ_TXDROPf_GET
#define FCON_PERQ_TXDROP_CTRLr_EN_PREQ_TXDROPf_SET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_EN_PREQ_TXDROPf_SET
#define FCON_PERQ_TXDROP_CTRLr_RESERVED_2Rf_GET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_2Rf_GET
#define FCON_PERQ_TXDROP_CTRLr_RESERVED_2Rf_SET BCM53262_A0_FCON_PERQ_TXDROP_CTRLr_RESERVED_2Rf_SET
#define READ_FCON_PERQ_TXDROP_CTRLr BCM53262_A0_READ_FCON_PERQ_TXDROP_CTRLr
#define WRITE_FCON_PERQ_TXDROP_CTRLr BCM53262_A0_WRITE_FCON_PERQ_TXDROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_PERQ_TXDROP_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q0_100_TH_CTRL_1
 * BLOCKS:   SYS
 * DESC:     TXQ-Q0 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_PAUS_THRS  The pause threshold of priority queue 0  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q0)rises above this threhold , a pause frame will be sent out.
 *     BT100_HYST_THRS  The unpause threshold of priority queue 0  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q0) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r 0x00000a06

#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q0_100_TH_CTRL_1.
 */
typedef union BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_s {
	uint32_t v[1];
	uint32_t fcon_q0_100_th_ctrl_1[1];
	uint32_t _fcon_q0_100_th_ctrl_1;
} BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_t;

#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_CLR(r) (r).fcon_q0_100_th_ctrl_1[0] = 0
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_SET(r,d) (r).fcon_q0_100_th_ctrl_1[0] = d
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_GET(r) (r).fcon_q0_100_th_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET(r) (((r).fcon_q0_100_th_ctrl_1[0]) & 0xff)
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET(r,f) (r).fcon_q0_100_th_ctrl_1[0]=(((r).fcon_q0_100_th_ctrl_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_HYST_THRSf_GET(r) ((((r).fcon_q0_100_th_ctrl_1[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_HYST_THRSf_SET(r,f) (r).fcon_q0_100_th_ctrl_1[0]=(((r).fcon_q0_100_th_ctrl_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q0_100_TH_CTRL_1.
 */
#define BCM53262_A0_READ_FCON_Q0_100_TH_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q0_100_TH_CTRL_1r,(r._fcon_q0_100_th_ctrl_1),2)
#define BCM53262_A0_WRITE_FCON_Q0_100_TH_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q0_100_TH_CTRL_1r,&(r._fcon_q0_100_th_ctrl_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q0_100_TH_CTRL_1r BCM53262_A0_FCON_Q0_100_TH_CTRL_1r
#define FCON_Q0_100_TH_CTRL_1r_SIZE BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_SIZE
typedef BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_t FCON_Q0_100_TH_CTRL_1r_t;
#define FCON_Q0_100_TH_CTRL_1r_CLR BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_CLR
#define FCON_Q0_100_TH_CTRL_1r_SET BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_SET
#define FCON_Q0_100_TH_CTRL_1r_GET BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_GET
#define FCON_Q0_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET
#define FCON_Q0_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET
#define FCON_Q0_100_TH_CTRL_1r_BT100_HYST_THRSf_GET BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_HYST_THRSf_GET
#define FCON_Q0_100_TH_CTRL_1r_BT100_HYST_THRSf_SET BCM53262_A0_FCON_Q0_100_TH_CTRL_1r_BT100_HYST_THRSf_SET
#define READ_FCON_Q0_100_TH_CTRL_1r BCM53262_A0_READ_FCON_Q0_100_TH_CTRL_1r
#define WRITE_FCON_Q0_100_TH_CTRL_1r BCM53262_A0_WRITE_FCON_Q0_100_TH_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q0_100_TH_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q0_100_TH_CTRL_2
 * BLOCKS:   SYS
 * DESC:     TXQ-Q0 UC/MC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_MCDROP_THRS The mcast drop threshold of priority queue 0  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q0)rises above this threhold , a pause frame will be sent out.
 *     BT100_DROP_THRS  The nuicast drop threshold of priority queue 0  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q0) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r 0x00000a08

#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q0_100_TH_CTRL_2.
 */
typedef union BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_s {
	uint32_t v[1];
	uint32_t fcon_q0_100_th_ctrl_2[1];
	uint32_t _fcon_q0_100_th_ctrl_2;
} BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_t;

#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_CLR(r) (r).fcon_q0_100_th_ctrl_2[0] = 0
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_SET(r,d) (r).fcon_q0_100_th_ctrl_2[0] = d
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_GET(r) (r).fcon_q0_100_th_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET(r) (((r).fcon_q0_100_th_ctrl_2[0]) & 0xff)
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET(r,f) (r).fcon_q0_100_th_ctrl_2[0]=(((r).fcon_q0_100_th_ctrl_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_DROP_THRSf_GET(r) ((((r).fcon_q0_100_th_ctrl_2[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_DROP_THRSf_SET(r,f) (r).fcon_q0_100_th_ctrl_2[0]=(((r).fcon_q0_100_th_ctrl_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q0_100_TH_CTRL_2.
 */
#define BCM53262_A0_READ_FCON_Q0_100_TH_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q0_100_TH_CTRL_2r,(r._fcon_q0_100_th_ctrl_2),2)
#define BCM53262_A0_WRITE_FCON_Q0_100_TH_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q0_100_TH_CTRL_2r,&(r._fcon_q0_100_th_ctrl_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q0_100_TH_CTRL_2r BCM53262_A0_FCON_Q0_100_TH_CTRL_2r
#define FCON_Q0_100_TH_CTRL_2r_SIZE BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_SIZE
typedef BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_t FCON_Q0_100_TH_CTRL_2r_t;
#define FCON_Q0_100_TH_CTRL_2r_CLR BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_CLR
#define FCON_Q0_100_TH_CTRL_2r_SET BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_SET
#define FCON_Q0_100_TH_CTRL_2r_GET BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_GET
#define FCON_Q0_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET
#define FCON_Q0_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET
#define FCON_Q0_100_TH_CTRL_2r_BT100_DROP_THRSf_GET BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_DROP_THRSf_GET
#define FCON_Q0_100_TH_CTRL_2r_BT100_DROP_THRSf_SET BCM53262_A0_FCON_Q0_100_TH_CTRL_2r_BT100_DROP_THRSf_SET
#define READ_FCON_Q0_100_TH_CTRL_2r BCM53262_A0_READ_FCON_Q0_100_TH_CTRL_2r
#define WRITE_FCON_Q0_100_TH_CTRL_2r BCM53262_A0_WRITE_FCON_Q0_100_TH_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q0_100_TH_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q0_TXDSC_CTRL_3
 * BLOCKS:   SYS
 * DESC:     Queue 0 TxDsc Control 3 Register
 * SIZE:     16
 * FIELDS:
 *     Q0_QUOTA_SIZE    The round robin weight for priority queue 0 (valid value : 01-56).
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r 0x00000a64

#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q0_TXDSC_CTRL_3.
 */
typedef union BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_s {
	uint32_t v[1];
	uint32_t fcon_q0_txdsc_ctrl_3[1];
	uint32_t _fcon_q0_txdsc_ctrl_3;
} BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_t;

#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_CLR(r) (r).fcon_q0_txdsc_ctrl_3[0] = 0
#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_SET(r,d) (r).fcon_q0_txdsc_ctrl_3[0] = d
#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_GET(r) (r).fcon_q0_txdsc_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_Q0_QUOTA_SIZEf_GET(r) (((r).fcon_q0_txdsc_ctrl_3[0]) & 0x3f)
#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_Q0_QUOTA_SIZEf_SET(r,f) (r).fcon_q0_txdsc_ctrl_3[0]=(((r).fcon_q0_txdsc_ctrl_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_RESERVED_Rf_GET(r) ((((r).fcon_q0_txdsc_ctrl_3[0]) >> 6) & 0x3ff)
#define BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_RESERVED_Rf_SET(r,f) (r).fcon_q0_txdsc_ctrl_3[0]=(((r).fcon_q0_txdsc_ctrl_3[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access FCON_Q0_TXDSC_CTRL_3.
 */
#define BCM53262_A0_READ_FCON_Q0_TXDSC_CTRL_3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r,(r._fcon_q0_txdsc_ctrl_3),2)
#define BCM53262_A0_WRITE_FCON_Q0_TXDSC_CTRL_3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r,&(r._fcon_q0_txdsc_ctrl_3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q0_TXDSC_CTRL_3r BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r
#define FCON_Q0_TXDSC_CTRL_3r_SIZE BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_SIZE
typedef BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_t FCON_Q0_TXDSC_CTRL_3r_t;
#define FCON_Q0_TXDSC_CTRL_3r_CLR BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_CLR
#define FCON_Q0_TXDSC_CTRL_3r_SET BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_SET
#define FCON_Q0_TXDSC_CTRL_3r_GET BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_GET
#define FCON_Q0_TXDSC_CTRL_3r_Q0_QUOTA_SIZEf_GET BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_Q0_QUOTA_SIZEf_GET
#define FCON_Q0_TXDSC_CTRL_3r_Q0_QUOTA_SIZEf_SET BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_Q0_QUOTA_SIZEf_SET
#define FCON_Q0_TXDSC_CTRL_3r_RESERVED_Rf_GET BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_RESERVED_Rf_GET
#define FCON_Q0_TXDSC_CTRL_3r_RESERVED_Rf_SET BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r_RESERVED_Rf_SET
#define READ_FCON_Q0_TXDSC_CTRL_3r BCM53262_A0_READ_FCON_Q0_TXDSC_CTRL_3r
#define WRITE_FCON_Q0_TXDSC_CTRL_3r BCM53262_A0_WRITE_FCON_Q0_TXDSC_CTRL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q0_TXDSC_CTRL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q1_100_TH_CTRL_1
 * BLOCKS:   SYS
 * DESC:     TXQ-Q1 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_PAUS_THRS  The pause threshold of priority queue 1  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q1)rises above this threhold , a pause frame will be sent out.
 *     BT100_HYST_THRS  The unpause threshold of priority queue 1  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q1) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r 0x00000a6a

#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q1_100_TH_CTRL_1.
 */
typedef union BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_s {
	uint32_t v[1];
	uint32_t fcon_q1_100_th_ctrl_1[1];
	uint32_t _fcon_q1_100_th_ctrl_1;
} BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_t;

#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_CLR(r) (r).fcon_q1_100_th_ctrl_1[0] = 0
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_SET(r,d) (r).fcon_q1_100_th_ctrl_1[0] = d
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_GET(r) (r).fcon_q1_100_th_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET(r) (((r).fcon_q1_100_th_ctrl_1[0]) & 0xff)
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET(r,f) (r).fcon_q1_100_th_ctrl_1[0]=(((r).fcon_q1_100_th_ctrl_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_HYST_THRSf_GET(r) ((((r).fcon_q1_100_th_ctrl_1[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_HYST_THRSf_SET(r,f) (r).fcon_q1_100_th_ctrl_1[0]=(((r).fcon_q1_100_th_ctrl_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q1_100_TH_CTRL_1.
 */
#define BCM53262_A0_READ_FCON_Q1_100_TH_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q1_100_TH_CTRL_1r,(r._fcon_q1_100_th_ctrl_1),2)
#define BCM53262_A0_WRITE_FCON_Q1_100_TH_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q1_100_TH_CTRL_1r,&(r._fcon_q1_100_th_ctrl_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q1_100_TH_CTRL_1r BCM53262_A0_FCON_Q1_100_TH_CTRL_1r
#define FCON_Q1_100_TH_CTRL_1r_SIZE BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_SIZE
typedef BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_t FCON_Q1_100_TH_CTRL_1r_t;
#define FCON_Q1_100_TH_CTRL_1r_CLR BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_CLR
#define FCON_Q1_100_TH_CTRL_1r_SET BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_SET
#define FCON_Q1_100_TH_CTRL_1r_GET BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_GET
#define FCON_Q1_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET
#define FCON_Q1_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET
#define FCON_Q1_100_TH_CTRL_1r_BT100_HYST_THRSf_GET BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_HYST_THRSf_GET
#define FCON_Q1_100_TH_CTRL_1r_BT100_HYST_THRSf_SET BCM53262_A0_FCON_Q1_100_TH_CTRL_1r_BT100_HYST_THRSf_SET
#define READ_FCON_Q1_100_TH_CTRL_1r BCM53262_A0_READ_FCON_Q1_100_TH_CTRL_1r
#define WRITE_FCON_Q1_100_TH_CTRL_1r BCM53262_A0_WRITE_FCON_Q1_100_TH_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q1_100_TH_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q1_100_TH_CTRL_2
 * BLOCKS:   SYS
 * DESC:     TXQ-Q1 UC/MC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_MCDROP_THRS The mcast drop threshold of priority queue 1  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q1)rises above this threhold , a pause frame will be sent out.
 *     BT100_DROP_THRS  The nuicast drop threshold of priority queue 1  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q1) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r 0x00000a6c

#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q1_100_TH_CTRL_2.
 */
typedef union BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_s {
	uint32_t v[1];
	uint32_t fcon_q1_100_th_ctrl_2[1];
	uint32_t _fcon_q1_100_th_ctrl_2;
} BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_t;

#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_CLR(r) (r).fcon_q1_100_th_ctrl_2[0] = 0
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_SET(r,d) (r).fcon_q1_100_th_ctrl_2[0] = d
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_GET(r) (r).fcon_q1_100_th_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET(r) (((r).fcon_q1_100_th_ctrl_2[0]) & 0xff)
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET(r,f) (r).fcon_q1_100_th_ctrl_2[0]=(((r).fcon_q1_100_th_ctrl_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_DROP_THRSf_GET(r) ((((r).fcon_q1_100_th_ctrl_2[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_DROP_THRSf_SET(r,f) (r).fcon_q1_100_th_ctrl_2[0]=(((r).fcon_q1_100_th_ctrl_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q1_100_TH_CTRL_2.
 */
#define BCM53262_A0_READ_FCON_Q1_100_TH_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q1_100_TH_CTRL_2r,(r._fcon_q1_100_th_ctrl_2),2)
#define BCM53262_A0_WRITE_FCON_Q1_100_TH_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q1_100_TH_CTRL_2r,&(r._fcon_q1_100_th_ctrl_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q1_100_TH_CTRL_2r BCM53262_A0_FCON_Q1_100_TH_CTRL_2r
#define FCON_Q1_100_TH_CTRL_2r_SIZE BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_SIZE
typedef BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_t FCON_Q1_100_TH_CTRL_2r_t;
#define FCON_Q1_100_TH_CTRL_2r_CLR BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_CLR
#define FCON_Q1_100_TH_CTRL_2r_SET BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_SET
#define FCON_Q1_100_TH_CTRL_2r_GET BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_GET
#define FCON_Q1_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET
#define FCON_Q1_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET
#define FCON_Q1_100_TH_CTRL_2r_BT100_DROP_THRSf_GET BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_DROP_THRSf_GET
#define FCON_Q1_100_TH_CTRL_2r_BT100_DROP_THRSf_SET BCM53262_A0_FCON_Q1_100_TH_CTRL_2r_BT100_DROP_THRSf_SET
#define READ_FCON_Q1_100_TH_CTRL_2r BCM53262_A0_READ_FCON_Q1_100_TH_CTRL_2r
#define WRITE_FCON_Q1_100_TH_CTRL_2r BCM53262_A0_WRITE_FCON_Q1_100_TH_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q1_100_TH_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q1_TXDSC_CTRL_3
 * BLOCKS:   SYS
 * DESC:     Queue 1 TxDsc Control 3 Register
 * SIZE:     16
 * FIELDS:
 *     Q1_QUOTA_SIZE    The round robin weight for priority queue 1 (valid value : 01-56).
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r 0x00000a72

#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q1_TXDSC_CTRL_3.
 */
typedef union BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_s {
	uint32_t v[1];
	uint32_t fcon_q1_txdsc_ctrl_3[1];
	uint32_t _fcon_q1_txdsc_ctrl_3;
} BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_t;

#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_CLR(r) (r).fcon_q1_txdsc_ctrl_3[0] = 0
#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_SET(r,d) (r).fcon_q1_txdsc_ctrl_3[0] = d
#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_GET(r) (r).fcon_q1_txdsc_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_Q1_QUOTA_SIZEf_GET(r) (((r).fcon_q1_txdsc_ctrl_3[0]) & 0x3f)
#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_Q1_QUOTA_SIZEf_SET(r,f) (r).fcon_q1_txdsc_ctrl_3[0]=(((r).fcon_q1_txdsc_ctrl_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_RESERVED_Rf_GET(r) ((((r).fcon_q1_txdsc_ctrl_3[0]) >> 6) & 0x3ff)
#define BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_RESERVED_Rf_SET(r,f) (r).fcon_q1_txdsc_ctrl_3[0]=(((r).fcon_q1_txdsc_ctrl_3[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access FCON_Q1_TXDSC_CTRL_3.
 */
#define BCM53262_A0_READ_FCON_Q1_TXDSC_CTRL_3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r,(r._fcon_q1_txdsc_ctrl_3),2)
#define BCM53262_A0_WRITE_FCON_Q1_TXDSC_CTRL_3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r,&(r._fcon_q1_txdsc_ctrl_3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q1_TXDSC_CTRL_3r BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r
#define FCON_Q1_TXDSC_CTRL_3r_SIZE BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_SIZE
typedef BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_t FCON_Q1_TXDSC_CTRL_3r_t;
#define FCON_Q1_TXDSC_CTRL_3r_CLR BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_CLR
#define FCON_Q1_TXDSC_CTRL_3r_SET BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_SET
#define FCON_Q1_TXDSC_CTRL_3r_GET BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_GET
#define FCON_Q1_TXDSC_CTRL_3r_Q1_QUOTA_SIZEf_GET BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_Q1_QUOTA_SIZEf_GET
#define FCON_Q1_TXDSC_CTRL_3r_Q1_QUOTA_SIZEf_SET BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_Q1_QUOTA_SIZEf_SET
#define FCON_Q1_TXDSC_CTRL_3r_RESERVED_Rf_GET BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_RESERVED_Rf_GET
#define FCON_Q1_TXDSC_CTRL_3r_RESERVED_Rf_SET BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r_RESERVED_Rf_SET
#define READ_FCON_Q1_TXDSC_CTRL_3r BCM53262_A0_READ_FCON_Q1_TXDSC_CTRL_3r
#define WRITE_FCON_Q1_TXDSC_CTRL_3r BCM53262_A0_WRITE_FCON_Q1_TXDSC_CTRL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q1_TXDSC_CTRL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q2_100_TH_CTRL_1
 * BLOCKS:   SYS
 * DESC:     TXQ-Q2 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_PAUS_THRS  The pause threshold of priority queue 2  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q2)rises above this threhold , a pause frame will be sent out.
 *     BT100_HYST_THRS  The unpause threshold of priority queue 2  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q2) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r 0x00000a78

#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q2_100_TH_CTRL_1.
 */
typedef union BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_s {
	uint32_t v[1];
	uint32_t fcon_q2_100_th_ctrl_1[1];
	uint32_t _fcon_q2_100_th_ctrl_1;
} BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_t;

#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_CLR(r) (r).fcon_q2_100_th_ctrl_1[0] = 0
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_SET(r,d) (r).fcon_q2_100_th_ctrl_1[0] = d
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_GET(r) (r).fcon_q2_100_th_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET(r) (((r).fcon_q2_100_th_ctrl_1[0]) & 0xff)
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET(r,f) (r).fcon_q2_100_th_ctrl_1[0]=(((r).fcon_q2_100_th_ctrl_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_HYST_THRSf_GET(r) ((((r).fcon_q2_100_th_ctrl_1[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_HYST_THRSf_SET(r,f) (r).fcon_q2_100_th_ctrl_1[0]=(((r).fcon_q2_100_th_ctrl_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q2_100_TH_CTRL_1.
 */
#define BCM53262_A0_READ_FCON_Q2_100_TH_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q2_100_TH_CTRL_1r,(r._fcon_q2_100_th_ctrl_1),2)
#define BCM53262_A0_WRITE_FCON_Q2_100_TH_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q2_100_TH_CTRL_1r,&(r._fcon_q2_100_th_ctrl_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q2_100_TH_CTRL_1r BCM53262_A0_FCON_Q2_100_TH_CTRL_1r
#define FCON_Q2_100_TH_CTRL_1r_SIZE BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_SIZE
typedef BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_t FCON_Q2_100_TH_CTRL_1r_t;
#define FCON_Q2_100_TH_CTRL_1r_CLR BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_CLR
#define FCON_Q2_100_TH_CTRL_1r_SET BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_SET
#define FCON_Q2_100_TH_CTRL_1r_GET BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_GET
#define FCON_Q2_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET
#define FCON_Q2_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET
#define FCON_Q2_100_TH_CTRL_1r_BT100_HYST_THRSf_GET BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_HYST_THRSf_GET
#define FCON_Q2_100_TH_CTRL_1r_BT100_HYST_THRSf_SET BCM53262_A0_FCON_Q2_100_TH_CTRL_1r_BT100_HYST_THRSf_SET
#define READ_FCON_Q2_100_TH_CTRL_1r BCM53262_A0_READ_FCON_Q2_100_TH_CTRL_1r
#define WRITE_FCON_Q2_100_TH_CTRL_1r BCM53262_A0_WRITE_FCON_Q2_100_TH_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q2_100_TH_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q2_100_TH_CTRL_2
 * BLOCKS:   SYS
 * DESC:     TXQ-Q2 UC/MC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_MCDROP_THRS The mcast drop threshold of priority queue 2  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q2)rises above this threhold , a pause frame will be sent out.
 *     BT100_DROP_THRS  The nuicast drop threshold of priority queue 2  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q2) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r 0x00000a7a

#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q2_100_TH_CTRL_2.
 */
typedef union BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_s {
	uint32_t v[1];
	uint32_t fcon_q2_100_th_ctrl_2[1];
	uint32_t _fcon_q2_100_th_ctrl_2;
} BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_t;

#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_CLR(r) (r).fcon_q2_100_th_ctrl_2[0] = 0
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_SET(r,d) (r).fcon_q2_100_th_ctrl_2[0] = d
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_GET(r) (r).fcon_q2_100_th_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET(r) (((r).fcon_q2_100_th_ctrl_2[0]) & 0xff)
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET(r,f) (r).fcon_q2_100_th_ctrl_2[0]=(((r).fcon_q2_100_th_ctrl_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_DROP_THRSf_GET(r) ((((r).fcon_q2_100_th_ctrl_2[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_DROP_THRSf_SET(r,f) (r).fcon_q2_100_th_ctrl_2[0]=(((r).fcon_q2_100_th_ctrl_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q2_100_TH_CTRL_2.
 */
#define BCM53262_A0_READ_FCON_Q2_100_TH_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q2_100_TH_CTRL_2r,(r._fcon_q2_100_th_ctrl_2),2)
#define BCM53262_A0_WRITE_FCON_Q2_100_TH_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q2_100_TH_CTRL_2r,&(r._fcon_q2_100_th_ctrl_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q2_100_TH_CTRL_2r BCM53262_A0_FCON_Q2_100_TH_CTRL_2r
#define FCON_Q2_100_TH_CTRL_2r_SIZE BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_SIZE
typedef BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_t FCON_Q2_100_TH_CTRL_2r_t;
#define FCON_Q2_100_TH_CTRL_2r_CLR BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_CLR
#define FCON_Q2_100_TH_CTRL_2r_SET BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_SET
#define FCON_Q2_100_TH_CTRL_2r_GET BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_GET
#define FCON_Q2_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET
#define FCON_Q2_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET
#define FCON_Q2_100_TH_CTRL_2r_BT100_DROP_THRSf_GET BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_DROP_THRSf_GET
#define FCON_Q2_100_TH_CTRL_2r_BT100_DROP_THRSf_SET BCM53262_A0_FCON_Q2_100_TH_CTRL_2r_BT100_DROP_THRSf_SET
#define READ_FCON_Q2_100_TH_CTRL_2r BCM53262_A0_READ_FCON_Q2_100_TH_CTRL_2r
#define WRITE_FCON_Q2_100_TH_CTRL_2r BCM53262_A0_WRITE_FCON_Q2_100_TH_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q2_100_TH_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q2_TXDSC_CTRL_3
 * BLOCKS:   SYS
 * DESC:     Queue 2 TxDsc Control 3 Register
 * SIZE:     16
 * FIELDS:
 *     Q2_QUOTA_SIZE    The round robin weight for priority queue 2 (valid value : 01-56).
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r 0x00000a80

#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q2_TXDSC_CTRL_3.
 */
typedef union BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_s {
	uint32_t v[1];
	uint32_t fcon_q2_txdsc_ctrl_3[1];
	uint32_t _fcon_q2_txdsc_ctrl_3;
} BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_t;

#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_CLR(r) (r).fcon_q2_txdsc_ctrl_3[0] = 0
#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_SET(r,d) (r).fcon_q2_txdsc_ctrl_3[0] = d
#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_GET(r) (r).fcon_q2_txdsc_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_Q2_QUOTA_SIZEf_GET(r) (((r).fcon_q2_txdsc_ctrl_3[0]) & 0x3f)
#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_Q2_QUOTA_SIZEf_SET(r,f) (r).fcon_q2_txdsc_ctrl_3[0]=(((r).fcon_q2_txdsc_ctrl_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_RESERVED_Rf_GET(r) ((((r).fcon_q2_txdsc_ctrl_3[0]) >> 6) & 0x3ff)
#define BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_RESERVED_Rf_SET(r,f) (r).fcon_q2_txdsc_ctrl_3[0]=(((r).fcon_q2_txdsc_ctrl_3[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access FCON_Q2_TXDSC_CTRL_3.
 */
#define BCM53262_A0_READ_FCON_Q2_TXDSC_CTRL_3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r,(r._fcon_q2_txdsc_ctrl_3),2)
#define BCM53262_A0_WRITE_FCON_Q2_TXDSC_CTRL_3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r,&(r._fcon_q2_txdsc_ctrl_3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q2_TXDSC_CTRL_3r BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r
#define FCON_Q2_TXDSC_CTRL_3r_SIZE BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_SIZE
typedef BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_t FCON_Q2_TXDSC_CTRL_3r_t;
#define FCON_Q2_TXDSC_CTRL_3r_CLR BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_CLR
#define FCON_Q2_TXDSC_CTRL_3r_SET BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_SET
#define FCON_Q2_TXDSC_CTRL_3r_GET BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_GET
#define FCON_Q2_TXDSC_CTRL_3r_Q2_QUOTA_SIZEf_GET BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_Q2_QUOTA_SIZEf_GET
#define FCON_Q2_TXDSC_CTRL_3r_Q2_QUOTA_SIZEf_SET BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_Q2_QUOTA_SIZEf_SET
#define FCON_Q2_TXDSC_CTRL_3r_RESERVED_Rf_GET BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_RESERVED_Rf_GET
#define FCON_Q2_TXDSC_CTRL_3r_RESERVED_Rf_SET BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r_RESERVED_Rf_SET
#define READ_FCON_Q2_TXDSC_CTRL_3r BCM53262_A0_READ_FCON_Q2_TXDSC_CTRL_3r
#define WRITE_FCON_Q2_TXDSC_CTRL_3r BCM53262_A0_WRITE_FCON_Q2_TXDSC_CTRL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q2_TXDSC_CTRL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q3_100_TH_CTRL_1
 * BLOCKS:   SYS
 * DESC:     TXQ-Q3 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_PAUS_THRS  The pause threshold of priority queue 3  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q3)rises above this threhold , a pause frame will be sent out.
 *     BT100_HYST_THRS  The unpause threshold of priority queue 3  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q3) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r 0x00000a86

#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q3_100_TH_CTRL_1.
 */
typedef union BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_s {
	uint32_t v[1];
	uint32_t fcon_q3_100_th_ctrl_1[1];
	uint32_t _fcon_q3_100_th_ctrl_1;
} BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_t;

#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_CLR(r) (r).fcon_q3_100_th_ctrl_1[0] = 0
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_SET(r,d) (r).fcon_q3_100_th_ctrl_1[0] = d
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_GET(r) (r).fcon_q3_100_th_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET(r) (((r).fcon_q3_100_th_ctrl_1[0]) & 0xff)
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET(r,f) (r).fcon_q3_100_th_ctrl_1[0]=(((r).fcon_q3_100_th_ctrl_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_HYST_THRSf_GET(r) ((((r).fcon_q3_100_th_ctrl_1[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_HYST_THRSf_SET(r,f) (r).fcon_q3_100_th_ctrl_1[0]=(((r).fcon_q3_100_th_ctrl_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q3_100_TH_CTRL_1.
 */
#define BCM53262_A0_READ_FCON_Q3_100_TH_CTRL_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q3_100_TH_CTRL_1r,(r._fcon_q3_100_th_ctrl_1),2)
#define BCM53262_A0_WRITE_FCON_Q3_100_TH_CTRL_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q3_100_TH_CTRL_1r,&(r._fcon_q3_100_th_ctrl_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q3_100_TH_CTRL_1r BCM53262_A0_FCON_Q3_100_TH_CTRL_1r
#define FCON_Q3_100_TH_CTRL_1r_SIZE BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_SIZE
typedef BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_t FCON_Q3_100_TH_CTRL_1r_t;
#define FCON_Q3_100_TH_CTRL_1r_CLR BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_CLR
#define FCON_Q3_100_TH_CTRL_1r_SET BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_SET
#define FCON_Q3_100_TH_CTRL_1r_GET BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_GET
#define FCON_Q3_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_PAUS_THRSf_GET
#define FCON_Q3_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_PAUS_THRSf_SET
#define FCON_Q3_100_TH_CTRL_1r_BT100_HYST_THRSf_GET BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_HYST_THRSf_GET
#define FCON_Q3_100_TH_CTRL_1r_BT100_HYST_THRSf_SET BCM53262_A0_FCON_Q3_100_TH_CTRL_1r_BT100_HYST_THRSf_SET
#define READ_FCON_Q3_100_TH_CTRL_1r BCM53262_A0_READ_FCON_Q3_100_TH_CTRL_1r
#define WRITE_FCON_Q3_100_TH_CTRL_1r BCM53262_A0_WRITE_FCON_Q3_100_TH_CTRL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q3_100_TH_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q3_100_TH_CTRL_2
 * BLOCKS:   SYS
 * DESC:     TXQ-Q3 UC/BC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     BT100_MCDROP_THRS The mcast drop threshold of priority queue 3  for txq base flow control when atmix speed mode. The effective threshold is this register value times 8.When the number of  pointers that is queued up in corresponding txq(Q3)rises above this threhold , a pause frame will be sent out.
 *     BT100_DROP_THRS  The nuicast drop threshold of priority queue 3  for txq base flow control whenat mix speed mode. The effective threshold is this register value times 8.After  a pause condition is met, when the number of  pointers that is queuedup in corresponding  txq (Q3) falls below this threhold , an unpause framewill be sent out.
 */
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r 0x00000a88

#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q3_100_TH_CTRL_2.
 */
typedef union BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_s {
	uint32_t v[1];
	uint32_t fcon_q3_100_th_ctrl_2[1];
	uint32_t _fcon_q3_100_th_ctrl_2;
} BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_t;

#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_CLR(r) (r).fcon_q3_100_th_ctrl_2[0] = 0
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_SET(r,d) (r).fcon_q3_100_th_ctrl_2[0] = d
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_GET(r) (r).fcon_q3_100_th_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET(r) (((r).fcon_q3_100_th_ctrl_2[0]) & 0xff)
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET(r,f) (r).fcon_q3_100_th_ctrl_2[0]=(((r).fcon_q3_100_th_ctrl_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_DROP_THRSf_GET(r) ((((r).fcon_q3_100_th_ctrl_2[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_DROP_THRSf_SET(r,f) (r).fcon_q3_100_th_ctrl_2[0]=(((r).fcon_q3_100_th_ctrl_2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_Q3_100_TH_CTRL_2.
 */
#define BCM53262_A0_READ_FCON_Q3_100_TH_CTRL_2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q3_100_TH_CTRL_2r,(r._fcon_q3_100_th_ctrl_2),2)
#define BCM53262_A0_WRITE_FCON_Q3_100_TH_CTRL_2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q3_100_TH_CTRL_2r,&(r._fcon_q3_100_th_ctrl_2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q3_100_TH_CTRL_2r BCM53262_A0_FCON_Q3_100_TH_CTRL_2r
#define FCON_Q3_100_TH_CTRL_2r_SIZE BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_SIZE
typedef BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_t FCON_Q3_100_TH_CTRL_2r_t;
#define FCON_Q3_100_TH_CTRL_2r_CLR BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_CLR
#define FCON_Q3_100_TH_CTRL_2r_SET BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_SET
#define FCON_Q3_100_TH_CTRL_2r_GET BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_GET
#define FCON_Q3_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_MCDROP_THRSf_GET
#define FCON_Q3_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_MCDROP_THRSf_SET
#define FCON_Q3_100_TH_CTRL_2r_BT100_DROP_THRSf_GET BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_DROP_THRSf_GET
#define FCON_Q3_100_TH_CTRL_2r_BT100_DROP_THRSf_SET BCM53262_A0_FCON_Q3_100_TH_CTRL_2r_BT100_DROP_THRSf_SET
#define READ_FCON_Q3_100_TH_CTRL_2r BCM53262_A0_READ_FCON_Q3_100_TH_CTRL_2r
#define WRITE_FCON_Q3_100_TH_CTRL_2r BCM53262_A0_WRITE_FCON_Q3_100_TH_CTRL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q3_100_TH_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_Q3_TXDSC_CTRL_3
 * BLOCKS:   SYS
 * DESC:     Queue 3 TxDsc Control 3 Register
 * SIZE:     16
 * FIELDS:
 *     Q3_QUOTA_SIZE    The round robin weight for priority queue 3 (valid value : 01-56).EOT
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r 0x00000a8e

#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_SIZE 2

/*
 * This structure should be used to declare and program FCON_Q3_TXDSC_CTRL_3.
 */
typedef union BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_s {
	uint32_t v[1];
	uint32_t fcon_q3_txdsc_ctrl_3[1];
	uint32_t _fcon_q3_txdsc_ctrl_3;
} BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_t;

#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_CLR(r) (r).fcon_q3_txdsc_ctrl_3[0] = 0
#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_SET(r,d) (r).fcon_q3_txdsc_ctrl_3[0] = d
#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_GET(r) (r).fcon_q3_txdsc_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_Q3_QUOTA_SIZEf_GET(r) (((r).fcon_q3_txdsc_ctrl_3[0]) & 0x3f)
#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_Q3_QUOTA_SIZEf_SET(r,f) (r).fcon_q3_txdsc_ctrl_3[0]=(((r).fcon_q3_txdsc_ctrl_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_RESERVED_Rf_GET(r) ((((r).fcon_q3_txdsc_ctrl_3[0]) >> 6) & 0x3ff)
#define BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_RESERVED_Rf_SET(r,f) (r).fcon_q3_txdsc_ctrl_3[0]=(((r).fcon_q3_txdsc_ctrl_3[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access FCON_Q3_TXDSC_CTRL_3.
 */
#define BCM53262_A0_READ_FCON_Q3_TXDSC_CTRL_3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r,(r._fcon_q3_txdsc_ctrl_3),2)
#define BCM53262_A0_WRITE_FCON_Q3_TXDSC_CTRL_3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r,&(r._fcon_q3_txdsc_ctrl_3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_Q3_TXDSC_CTRL_3r BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r
#define FCON_Q3_TXDSC_CTRL_3r_SIZE BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_SIZE
typedef BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_t FCON_Q3_TXDSC_CTRL_3r_t;
#define FCON_Q3_TXDSC_CTRL_3r_CLR BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_CLR
#define FCON_Q3_TXDSC_CTRL_3r_SET BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_SET
#define FCON_Q3_TXDSC_CTRL_3r_GET BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_GET
#define FCON_Q3_TXDSC_CTRL_3r_Q3_QUOTA_SIZEf_GET BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_Q3_QUOTA_SIZEf_GET
#define FCON_Q3_TXDSC_CTRL_3r_Q3_QUOTA_SIZEf_SET BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_Q3_QUOTA_SIZEf_SET
#define FCON_Q3_TXDSC_CTRL_3r_RESERVED_Rf_GET BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_RESERVED_Rf_GET
#define FCON_Q3_TXDSC_CTRL_3r_RESERVED_Rf_SET BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r_RESERVED_Rf_SET
#define READ_FCON_Q3_TXDSC_CTRL_3r BCM53262_A0_READ_FCON_Q3_TXDSC_CTRL_3r
#define WRITE_FCON_Q3_TXDSC_CTRL_3r BCM53262_A0_WRITE_FCON_Q3_TXDSC_CTRL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_Q3_TXDSC_CTRL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_RSRV_BUFNUM
 * BLOCKS:   SYS
 * DESC:     Reserved Buffer Number Register
 * SIZE:     16
 * FIELDS:
 *     RUNOFF           runoff.
 *     EN_TWOSEC_FLUSH  Enable two second flush function.
 *     DIS_NEW_TXDIS    Disable new tx_disable function.
 *     EN_LCOL_FLUSH    Enable local collision flush function.
 *     EN_RELOAD_ERR_PATH Enable reload error path.
 *     RESERVED_2R      Reserved.
 */
#define BCM53262_A0_FCON_RSRV_BUFNUMr 0x00000a90

#define BCM53262_A0_FCON_RSRV_BUFNUMr_SIZE 2

/*
 * This structure should be used to declare and program FCON_RSRV_BUFNUM.
 */
typedef union BCM53262_A0_FCON_RSRV_BUFNUMr_s {
	uint32_t v[1];
	uint32_t fcon_rsrv_bufnum[1];
	uint32_t _fcon_rsrv_bufnum;
} BCM53262_A0_FCON_RSRV_BUFNUMr_t;

#define BCM53262_A0_FCON_RSRV_BUFNUMr_CLR(r) (r).fcon_rsrv_bufnum[0] = 0
#define BCM53262_A0_FCON_RSRV_BUFNUMr_SET(r,d) (r).fcon_rsrv_bufnum[0] = d
#define BCM53262_A0_FCON_RSRV_BUFNUMr_GET(r) (r).fcon_rsrv_bufnum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_RSRV_BUFNUMr_RUNOFFf_GET(r) (((r).fcon_rsrv_bufnum[0]) & 0xff)
#define BCM53262_A0_FCON_RSRV_BUFNUMr_RUNOFFf_SET(r,f) (r).fcon_rsrv_bufnum[0]=(((r).fcon_rsrv_bufnum[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_RSRV_BUFNUMr_EN_TWOSEC_FLUSHf_GET(r) ((((r).fcon_rsrv_bufnum[0]) >> 8) & 0x1)
#define BCM53262_A0_FCON_RSRV_BUFNUMr_EN_TWOSEC_FLUSHf_SET(r,f) (r).fcon_rsrv_bufnum[0]=(((r).fcon_rsrv_bufnum[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_FCON_RSRV_BUFNUMr_DIS_NEW_TXDISf_GET(r) ((((r).fcon_rsrv_bufnum[0]) >> 9) & 0x1)
#define BCM53262_A0_FCON_RSRV_BUFNUMr_DIS_NEW_TXDISf_SET(r,f) (r).fcon_rsrv_bufnum[0]=(((r).fcon_rsrv_bufnum[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_FCON_RSRV_BUFNUMr_EN_LCOL_FLUSHf_GET(r) ((((r).fcon_rsrv_bufnum[0]) >> 10) & 0x1)
#define BCM53262_A0_FCON_RSRV_BUFNUMr_EN_LCOL_FLUSHf_SET(r,f) (r).fcon_rsrv_bufnum[0]=(((r).fcon_rsrv_bufnum[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_FCON_RSRV_BUFNUMr_EN_RELOAD_ERR_PATHf_GET(r) ((((r).fcon_rsrv_bufnum[0]) >> 11) & 0x1)
#define BCM53262_A0_FCON_RSRV_BUFNUMr_EN_RELOAD_ERR_PATHf_SET(r,f) (r).fcon_rsrv_bufnum[0]=(((r).fcon_rsrv_bufnum[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_FCON_RSRV_BUFNUMr_RESERVED_2Rf_GET(r) ((((r).fcon_rsrv_bufnum[0]) >> 12) & 0xf)
#define BCM53262_A0_FCON_RSRV_BUFNUMr_RESERVED_2Rf_SET(r,f) (r).fcon_rsrv_bufnum[0]=(((r).fcon_rsrv_bufnum[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access FCON_RSRV_BUFNUM.
 */
#define BCM53262_A0_READ_FCON_RSRV_BUFNUMr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_RSRV_BUFNUMr,(r._fcon_rsrv_bufnum),2)
#define BCM53262_A0_WRITE_FCON_RSRV_BUFNUMr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_RSRV_BUFNUMr,&(r._fcon_rsrv_bufnum),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_RSRV_BUFNUMr BCM53262_A0_FCON_RSRV_BUFNUMr
#define FCON_RSRV_BUFNUMr_SIZE BCM53262_A0_FCON_RSRV_BUFNUMr_SIZE
typedef BCM53262_A0_FCON_RSRV_BUFNUMr_t FCON_RSRV_BUFNUMr_t;
#define FCON_RSRV_BUFNUMr_CLR BCM53262_A0_FCON_RSRV_BUFNUMr_CLR
#define FCON_RSRV_BUFNUMr_SET BCM53262_A0_FCON_RSRV_BUFNUMr_SET
#define FCON_RSRV_BUFNUMr_GET BCM53262_A0_FCON_RSRV_BUFNUMr_GET
#define FCON_RSRV_BUFNUMr_RUNOFFf_GET BCM53262_A0_FCON_RSRV_BUFNUMr_RUNOFFf_GET
#define FCON_RSRV_BUFNUMr_RUNOFFf_SET BCM53262_A0_FCON_RSRV_BUFNUMr_RUNOFFf_SET
#define FCON_RSRV_BUFNUMr_EN_TWOSEC_FLUSHf_GET BCM53262_A0_FCON_RSRV_BUFNUMr_EN_TWOSEC_FLUSHf_GET
#define FCON_RSRV_BUFNUMr_EN_TWOSEC_FLUSHf_SET BCM53262_A0_FCON_RSRV_BUFNUMr_EN_TWOSEC_FLUSHf_SET
#define FCON_RSRV_BUFNUMr_DIS_NEW_TXDISf_GET BCM53262_A0_FCON_RSRV_BUFNUMr_DIS_NEW_TXDISf_GET
#define FCON_RSRV_BUFNUMr_DIS_NEW_TXDISf_SET BCM53262_A0_FCON_RSRV_BUFNUMr_DIS_NEW_TXDISf_SET
#define FCON_RSRV_BUFNUMr_EN_LCOL_FLUSHf_GET BCM53262_A0_FCON_RSRV_BUFNUMr_EN_LCOL_FLUSHf_GET
#define FCON_RSRV_BUFNUMr_EN_LCOL_FLUSHf_SET BCM53262_A0_FCON_RSRV_BUFNUMr_EN_LCOL_FLUSHf_SET
#define FCON_RSRV_BUFNUMr_EN_RELOAD_ERR_PATHf_GET BCM53262_A0_FCON_RSRV_BUFNUMr_EN_RELOAD_ERR_PATHf_GET
#define FCON_RSRV_BUFNUMr_EN_RELOAD_ERR_PATHf_SET BCM53262_A0_FCON_RSRV_BUFNUMr_EN_RELOAD_ERR_PATHf_SET
#define FCON_RSRV_BUFNUMr_RESERVED_2Rf_GET BCM53262_A0_FCON_RSRV_BUFNUMr_RESERVED_2Rf_GET
#define FCON_RSRV_BUFNUMr_RESERVED_2Rf_SET BCM53262_A0_FCON_RSRV_BUFNUMr_RESERVED_2Rf_SET
#define READ_FCON_RSRV_BUFNUMr BCM53262_A0_READ_FCON_RSRV_BUFNUMr
#define WRITE_FCON_RSRV_BUFNUMr BCM53262_A0_WRITE_FCON_RSRV_BUFNUMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_RSRV_BUFNUMr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_RXBASE_BUFNUM
 * BLOCKS:   SYS
 * DESC:     RxBase Buffer Number Register
 * SIZE:     16
 * FIELDS:
 *     RXBASE_HYST_BUFNUM he hyster buffer number for each port when calculate rx base flow control.
 *     RXBASE_RESV_BUFNUM The reserved buffer number for each port when calculate rx base flow control. No puase/drop action will be taken if the number of buffer used by a port is less than this register. The effective number is this register value.
 */
#define BCM53262_A0_FCON_RXBASE_BUFNUMr 0x00000a8a

#define BCM53262_A0_FCON_RXBASE_BUFNUMr_SIZE 2

/*
 * This structure should be used to declare and program FCON_RXBASE_BUFNUM.
 */
typedef union BCM53262_A0_FCON_RXBASE_BUFNUMr_s {
	uint32_t v[1];
	uint32_t fcon_rxbase_bufnum[1];
	uint32_t _fcon_rxbase_bufnum;
} BCM53262_A0_FCON_RXBASE_BUFNUMr_t;

#define BCM53262_A0_FCON_RXBASE_BUFNUMr_CLR(r) (r).fcon_rxbase_bufnum[0] = 0
#define BCM53262_A0_FCON_RXBASE_BUFNUMr_SET(r,d) (r).fcon_rxbase_bufnum[0] = d
#define BCM53262_A0_FCON_RXBASE_BUFNUMr_GET(r) (r).fcon_rxbase_bufnum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_HYST_BUFNUMf_GET(r) (((r).fcon_rxbase_bufnum[0]) & 0xff)
#define BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_HYST_BUFNUMf_SET(r,f) (r).fcon_rxbase_bufnum[0]=(((r).fcon_rxbase_bufnum[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_RESV_BUFNUMf_GET(r) ((((r).fcon_rxbase_bufnum[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_RESV_BUFNUMf_SET(r,f) (r).fcon_rxbase_bufnum[0]=(((r).fcon_rxbase_bufnum[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_RXBASE_BUFNUM.
 */
#define BCM53262_A0_READ_FCON_RXBASE_BUFNUMr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_RXBASE_BUFNUMr,(r._fcon_rxbase_bufnum),2)
#define BCM53262_A0_WRITE_FCON_RXBASE_BUFNUMr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_RXBASE_BUFNUMr,&(r._fcon_rxbase_bufnum),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_RXBASE_BUFNUMr BCM53262_A0_FCON_RXBASE_BUFNUMr
#define FCON_RXBASE_BUFNUMr_SIZE BCM53262_A0_FCON_RXBASE_BUFNUMr_SIZE
typedef BCM53262_A0_FCON_RXBASE_BUFNUMr_t FCON_RXBASE_BUFNUMr_t;
#define FCON_RXBASE_BUFNUMr_CLR BCM53262_A0_FCON_RXBASE_BUFNUMr_CLR
#define FCON_RXBASE_BUFNUMr_SET BCM53262_A0_FCON_RXBASE_BUFNUMr_SET
#define FCON_RXBASE_BUFNUMr_GET BCM53262_A0_FCON_RXBASE_BUFNUMr_GET
#define FCON_RXBASE_BUFNUMr_RXBASE_HYST_BUFNUMf_GET BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_HYST_BUFNUMf_GET
#define FCON_RXBASE_BUFNUMr_RXBASE_HYST_BUFNUMf_SET BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_HYST_BUFNUMf_SET
#define FCON_RXBASE_BUFNUMr_RXBASE_RESV_BUFNUMf_GET BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_RESV_BUFNUMf_GET
#define FCON_RXBASE_BUFNUMr_RXBASE_RESV_BUFNUMf_SET BCM53262_A0_FCON_RXBASE_BUFNUMr_RXBASE_RESV_BUFNUMf_SET
#define READ_FCON_RXBASE_BUFNUMr BCM53262_A0_READ_FCON_RXBASE_BUFNUMr
#define WRITE_FCON_RXBASE_BUFNUMr BCM53262_A0_WRITE_FCON_RXBASE_BUFNUMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_RXBASE_BUFNUMr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_RX_FCON_CTRL
 * BLOCKS:   SYS
 * DESC:     Received Base Flow Control Register
 * SIZE:     16
 * FIELDS:
 *     RXFCON_PAUSE_TH  The pause threshold to kick in flow contol. When the toal used buffer reach this threshold, all the ports use more than reserved buffer will be force to pause. The effective number is this register.
 *     EN_RXCON_PAUSE_REMAP Enable rx base flow control pause threshold remap. It will provide more control on when to  kick in flow control due to rx base scheme.
 *     EN_UNPAUSE_HDL   Enable pause-cap and pause-uncap handle.
 *     SW_ENFDFLOW      SW_ENFDFLOW is reserved for engineer test only..
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_RX_FCON_CTRLr 0x00000a92

#define BCM53262_A0_FCON_RX_FCON_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FCON_RX_FCON_CTRL.
 */
typedef union BCM53262_A0_FCON_RX_FCON_CTRLr_s {
	uint32_t v[1];
	uint32_t fcon_rx_fcon_ctrl[1];
	uint32_t _fcon_rx_fcon_ctrl;
} BCM53262_A0_FCON_RX_FCON_CTRLr_t;

#define BCM53262_A0_FCON_RX_FCON_CTRLr_CLR(r) (r).fcon_rx_fcon_ctrl[0] = 0
#define BCM53262_A0_FCON_RX_FCON_CTRLr_SET(r,d) (r).fcon_rx_fcon_ctrl[0] = d
#define BCM53262_A0_FCON_RX_FCON_CTRLr_GET(r) (r).fcon_rx_fcon_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_RX_FCON_CTRLr_RXFCON_PAUSE_THf_GET(r) (((r).fcon_rx_fcon_ctrl[0]) & 0xfff)
#define BCM53262_A0_FCON_RX_FCON_CTRLr_RXFCON_PAUSE_THf_SET(r,f) (r).fcon_rx_fcon_ctrl[0]=(((r).fcon_rx_fcon_ctrl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_FCON_RX_FCON_CTRLr_EN_RXCON_PAUSE_REMAPf_GET(r) ((((r).fcon_rx_fcon_ctrl[0]) >> 12) & 0x1)
#define BCM53262_A0_FCON_RX_FCON_CTRLr_EN_RXCON_PAUSE_REMAPf_SET(r,f) (r).fcon_rx_fcon_ctrl[0]=(((r).fcon_rx_fcon_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_FCON_RX_FCON_CTRLr_EN_UNPAUSE_HDLf_GET(r) ((((r).fcon_rx_fcon_ctrl[0]) >> 13) & 0x1)
#define BCM53262_A0_FCON_RX_FCON_CTRLr_EN_UNPAUSE_HDLf_SET(r,f) (r).fcon_rx_fcon_ctrl[0]=(((r).fcon_rx_fcon_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_FCON_RX_FCON_CTRLr_SW_ENFDFLOWf_GET(r) ((((r).fcon_rx_fcon_ctrl[0]) >> 14) & 0x1)
#define BCM53262_A0_FCON_RX_FCON_CTRLr_SW_ENFDFLOWf_SET(r,f) (r).fcon_rx_fcon_ctrl[0]=(((r).fcon_rx_fcon_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_FCON_RX_FCON_CTRLr_RESERVED_Rf_GET(r) ((((r).fcon_rx_fcon_ctrl[0]) >> 15) & 0x1)
#define BCM53262_A0_FCON_RX_FCON_CTRLr_RESERVED_Rf_SET(r,f) (r).fcon_rx_fcon_ctrl[0]=(((r).fcon_rx_fcon_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FCON_RX_FCON_CTRL.
 */
#define BCM53262_A0_READ_FCON_RX_FCON_CTRLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_RX_FCON_CTRLr,(r._fcon_rx_fcon_ctrl),2)
#define BCM53262_A0_WRITE_FCON_RX_FCON_CTRLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_RX_FCON_CTRLr,&(r._fcon_rx_fcon_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_RX_FCON_CTRLr BCM53262_A0_FCON_RX_FCON_CTRLr
#define FCON_RX_FCON_CTRLr_SIZE BCM53262_A0_FCON_RX_FCON_CTRLr_SIZE
typedef BCM53262_A0_FCON_RX_FCON_CTRLr_t FCON_RX_FCON_CTRLr_t;
#define FCON_RX_FCON_CTRLr_CLR BCM53262_A0_FCON_RX_FCON_CTRLr_CLR
#define FCON_RX_FCON_CTRLr_SET BCM53262_A0_FCON_RX_FCON_CTRLr_SET
#define FCON_RX_FCON_CTRLr_GET BCM53262_A0_FCON_RX_FCON_CTRLr_GET
#define FCON_RX_FCON_CTRLr_RXFCON_PAUSE_THf_GET BCM53262_A0_FCON_RX_FCON_CTRLr_RXFCON_PAUSE_THf_GET
#define FCON_RX_FCON_CTRLr_RXFCON_PAUSE_THf_SET BCM53262_A0_FCON_RX_FCON_CTRLr_RXFCON_PAUSE_THf_SET
#define FCON_RX_FCON_CTRLr_EN_RXCON_PAUSE_REMAPf_GET BCM53262_A0_FCON_RX_FCON_CTRLr_EN_RXCON_PAUSE_REMAPf_GET
#define FCON_RX_FCON_CTRLr_EN_RXCON_PAUSE_REMAPf_SET BCM53262_A0_FCON_RX_FCON_CTRLr_EN_RXCON_PAUSE_REMAPf_SET
#define FCON_RX_FCON_CTRLr_EN_UNPAUSE_HDLf_GET BCM53262_A0_FCON_RX_FCON_CTRLr_EN_UNPAUSE_HDLf_GET
#define FCON_RX_FCON_CTRLr_EN_UNPAUSE_HDLf_SET BCM53262_A0_FCON_RX_FCON_CTRLr_EN_UNPAUSE_HDLf_SET
#define FCON_RX_FCON_CTRLr_SW_ENFDFLOWf_GET BCM53262_A0_FCON_RX_FCON_CTRLr_SW_ENFDFLOWf_GET
#define FCON_RX_FCON_CTRLr_SW_ENFDFLOWf_SET BCM53262_A0_FCON_RX_FCON_CTRLr_SW_ENFDFLOWf_SET
#define FCON_RX_FCON_CTRLr_RESERVED_Rf_GET BCM53262_A0_FCON_RX_FCON_CTRLr_RESERVED_Rf_GET
#define FCON_RX_FCON_CTRLr_RESERVED_Rf_SET BCM53262_A0_FCON_RX_FCON_CTRLr_RESERVED_Rf_SET
#define READ_FCON_RX_FCON_CTRLr BCM53262_A0_READ_FCON_RX_FCON_CTRLr
#define WRITE_FCON_RX_FCON_CTRLr BCM53262_A0_WRITE_FCON_RX_FCON_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_RX_FCON_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_SPARE0
 * BLOCKS:   SYS
 * DESC:     Flowcon Space Register 0
 * SIZE:     16
 * FIELDS:
 *     RX_QUEUE_TIMING  RX_QUEUE_TIMING
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_FCON_SPARE0r 0x00000a14

#define BCM53262_A0_FCON_SPARE0r_SIZE 2

/*
 * This structure should be used to declare and program FCON_SPARE0.
 */
typedef union BCM53262_A0_FCON_SPARE0r_s {
	uint32_t v[1];
	uint32_t fcon_spare0[1];
	uint32_t _fcon_spare0;
} BCM53262_A0_FCON_SPARE0r_t;

#define BCM53262_A0_FCON_SPARE0r_CLR(r) (r).fcon_spare0[0] = 0
#define BCM53262_A0_FCON_SPARE0r_SET(r,d) (r).fcon_spare0[0] = d
#define BCM53262_A0_FCON_SPARE0r_GET(r) (r).fcon_spare0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_SPARE0r_RX_QUEUE_TIMINGf_GET(r) (((r).fcon_spare0[0]) & 0x1)
#define BCM53262_A0_FCON_SPARE0r_RX_QUEUE_TIMINGf_SET(r,f) (r).fcon_spare0[0]=(((r).fcon_spare0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_FCON_SPARE0r_RESERVED_Rf_GET(r) ((((r).fcon_spare0[0]) >> 1) & 0x7fff)
#define BCM53262_A0_FCON_SPARE0r_RESERVED_Rf_SET(r,f) (r).fcon_spare0[0]=(((r).fcon_spare0[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access FCON_SPARE0.
 */
#define BCM53262_A0_READ_FCON_SPARE0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_SPARE0r,(r._fcon_spare0),2)
#define BCM53262_A0_WRITE_FCON_SPARE0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_SPARE0r,&(r._fcon_spare0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_SPARE0r BCM53262_A0_FCON_SPARE0r
#define FCON_SPARE0r_SIZE BCM53262_A0_FCON_SPARE0r_SIZE
typedef BCM53262_A0_FCON_SPARE0r_t FCON_SPARE0r_t;
#define FCON_SPARE0r_CLR BCM53262_A0_FCON_SPARE0r_CLR
#define FCON_SPARE0r_SET BCM53262_A0_FCON_SPARE0r_SET
#define FCON_SPARE0r_GET BCM53262_A0_FCON_SPARE0r_GET
#define FCON_SPARE0r_RX_QUEUE_TIMINGf_GET BCM53262_A0_FCON_SPARE0r_RX_QUEUE_TIMINGf_GET
#define FCON_SPARE0r_RX_QUEUE_TIMINGf_SET BCM53262_A0_FCON_SPARE0r_RX_QUEUE_TIMINGf_SET
#define FCON_SPARE0r_RESERVED_Rf_GET BCM53262_A0_FCON_SPARE0r_RESERVED_Rf_GET
#define FCON_SPARE0r_RESERVED_Rf_SET BCM53262_A0_FCON_SPARE0r_RESERVED_Rf_SET
#define READ_FCON_SPARE0r BCM53262_A0_READ_FCON_SPARE0r
#define WRITE_FCON_SPARE0r BCM53262_A0_WRITE_FCON_SPARE0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_SPARE0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_SPARE1
 * BLOCKS:   SYS
 * DESC:     Flowcon Space Register 1
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *     IMP_REASON_ENABLE IMP Port Reason Code Enable. (Internal use only)
 */
#define BCM53262_A0_FCON_SPARE1r 0x00000a38

#define BCM53262_A0_FCON_SPARE1r_SIZE 2

/*
 * This structure should be used to declare and program FCON_SPARE1.
 */
typedef union BCM53262_A0_FCON_SPARE1r_s {
	uint32_t v[1];
	uint32_t fcon_spare1[1];
	uint32_t _fcon_spare1;
} BCM53262_A0_FCON_SPARE1r_t;

#define BCM53262_A0_FCON_SPARE1r_CLR(r) (r).fcon_spare1[0] = 0
#define BCM53262_A0_FCON_SPARE1r_SET(r,d) (r).fcon_spare1[0] = d
#define BCM53262_A0_FCON_SPARE1r_GET(r) (r).fcon_spare1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_SPARE1r_RESERVED_Rf_GET(r) (((r).fcon_spare1[0]) & 0x7fff)
#define BCM53262_A0_FCON_SPARE1r_RESERVED_Rf_SET(r,f) (r).fcon_spare1[0]=(((r).fcon_spare1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))
#define BCM53262_A0_FCON_SPARE1r_IMP_REASON_ENABLEf_GET(r) ((((r).fcon_spare1[0]) >> 15) & 0x1)
#define BCM53262_A0_FCON_SPARE1r_IMP_REASON_ENABLEf_SET(r,f) (r).fcon_spare1[0]=(((r).fcon_spare1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FCON_SPARE1.
 */
#define BCM53262_A0_READ_FCON_SPARE1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_SPARE1r,(r._fcon_spare1),2)
#define BCM53262_A0_WRITE_FCON_SPARE1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_SPARE1r,&(r._fcon_spare1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_SPARE1r BCM53262_A0_FCON_SPARE1r
#define FCON_SPARE1r_SIZE BCM53262_A0_FCON_SPARE1r_SIZE
typedef BCM53262_A0_FCON_SPARE1r_t FCON_SPARE1r_t;
#define FCON_SPARE1r_CLR BCM53262_A0_FCON_SPARE1r_CLR
#define FCON_SPARE1r_SET BCM53262_A0_FCON_SPARE1r_SET
#define FCON_SPARE1r_GET BCM53262_A0_FCON_SPARE1r_GET
#define FCON_SPARE1r_RESERVED_Rf_GET BCM53262_A0_FCON_SPARE1r_RESERVED_Rf_GET
#define FCON_SPARE1r_RESERVED_Rf_SET BCM53262_A0_FCON_SPARE1r_RESERVED_Rf_SET
#define FCON_SPARE1r_IMP_REASON_ENABLEf_GET BCM53262_A0_FCON_SPARE1r_IMP_REASON_ENABLEf_GET
#define FCON_SPARE1r_IMP_REASON_ENABLEf_SET BCM53262_A0_FCON_SPARE1r_IMP_REASON_ENABLEf_SET
#define READ_FCON_SPARE1r BCM53262_A0_READ_FCON_SPARE1r
#define WRITE_FCON_SPARE1r BCM53262_A0_WRITE_FCON_SPARE1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_SPARE1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_SPARE2
 * BLOCKS:   SYS
 * DESC:     Flowcon Space Register 2
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FCON_SPARE2r 0x00000a3a

#define BCM53262_A0_FCON_SPARE2r_SIZE 2

/*
 * This structure should be used to declare and program FCON_SPARE2.
 */
typedef union BCM53262_A0_FCON_SPARE2r_s {
	uint32_t v[1];
	uint32_t fcon_spare2[1];
	uint32_t _fcon_spare2;
} BCM53262_A0_FCON_SPARE2r_t;

#define BCM53262_A0_FCON_SPARE2r_CLR(r) (r).fcon_spare2[0] = 0
#define BCM53262_A0_FCON_SPARE2r_SET(r,d) (r).fcon_spare2[0] = d
#define BCM53262_A0_FCON_SPARE2r_GET(r) (r).fcon_spare2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_SPARE2r_RESERVED_Rf_GET(r) (((r).fcon_spare2[0]) & 0xffff)
#define BCM53262_A0_FCON_SPARE2r_RESERVED_Rf_SET(r,f) (r).fcon_spare2[0]=(((r).fcon_spare2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FCON_SPARE2.
 */
#define BCM53262_A0_READ_FCON_SPARE2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_SPARE2r,(r._fcon_spare2),2)
#define BCM53262_A0_WRITE_FCON_SPARE2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_SPARE2r,&(r._fcon_spare2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_SPARE2r BCM53262_A0_FCON_SPARE2r
#define FCON_SPARE2r_SIZE BCM53262_A0_FCON_SPARE2r_SIZE
typedef BCM53262_A0_FCON_SPARE2r_t FCON_SPARE2r_t;
#define FCON_SPARE2r_CLR BCM53262_A0_FCON_SPARE2r_CLR
#define FCON_SPARE2r_SET BCM53262_A0_FCON_SPARE2r_SET
#define FCON_SPARE2r_GET BCM53262_A0_FCON_SPARE2r_GET
#define FCON_SPARE2r_RESERVED_Rf_GET BCM53262_A0_FCON_SPARE2r_RESERVED_Rf_GET
#define FCON_SPARE2r_RESERVED_Rf_SET BCM53262_A0_FCON_SPARE2r_RESERVED_Rf_SET
#define READ_FCON_SPARE2r BCM53262_A0_READ_FCON_SPARE2r
#define WRITE_FCON_SPARE2r BCM53262_A0_WRITE_FCON_SPARE2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_SPARE2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FCON_TXQ_FULL_TH
 * BLOCKS:   SYS
 * DESC:     Transmit Queue Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_FULLTH       The threshold used to determine quarter full. Used together with en_quarter_drop. The effective threshold is this register value times 8.It Is not recommend to use this feature at all.
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_FCON_TXQ_FULL_THr 0x00000a12

#define BCM53262_A0_FCON_TXQ_FULL_THr_SIZE 2

/*
 * This structure should be used to declare and program FCON_TXQ_FULL_TH.
 */
typedef union BCM53262_A0_FCON_TXQ_FULL_THr_s {
	uint32_t v[1];
	uint32_t fcon_txq_full_th[1];
	uint32_t _fcon_txq_full_th;
} BCM53262_A0_FCON_TXQ_FULL_THr_t;

#define BCM53262_A0_FCON_TXQ_FULL_THr_CLR(r) (r).fcon_txq_full_th[0] = 0
#define BCM53262_A0_FCON_TXQ_FULL_THr_SET(r,d) (r).fcon_txq_full_th[0] = d
#define BCM53262_A0_FCON_TXQ_FULL_THr_GET(r) (r).fcon_txq_full_th[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FCON_TXQ_FULL_THr_TXQ_FULLTHf_GET(r) (((r).fcon_txq_full_th[0]) & 0xff)
#define BCM53262_A0_FCON_TXQ_FULL_THr_TXQ_FULLTHf_SET(r,f) (r).fcon_txq_full_th[0]=(((r).fcon_txq_full_th[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FCON_TXQ_FULL_THr_RESERVED_Rf_GET(r) ((((r).fcon_txq_full_th[0]) >> 8) & 0xff)
#define BCM53262_A0_FCON_TXQ_FULL_THr_RESERVED_Rf_SET(r,f) (r).fcon_txq_full_th[0]=(((r).fcon_txq_full_th[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FCON_TXQ_FULL_TH.
 */
#define BCM53262_A0_READ_FCON_TXQ_FULL_THr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FCON_TXQ_FULL_THr,(r._fcon_txq_full_th),2)
#define BCM53262_A0_WRITE_FCON_TXQ_FULL_THr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FCON_TXQ_FULL_THr,&(r._fcon_txq_full_th),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FCON_TXQ_FULL_THr BCM53262_A0_FCON_TXQ_FULL_THr
#define FCON_TXQ_FULL_THr_SIZE BCM53262_A0_FCON_TXQ_FULL_THr_SIZE
typedef BCM53262_A0_FCON_TXQ_FULL_THr_t FCON_TXQ_FULL_THr_t;
#define FCON_TXQ_FULL_THr_CLR BCM53262_A0_FCON_TXQ_FULL_THr_CLR
#define FCON_TXQ_FULL_THr_SET BCM53262_A0_FCON_TXQ_FULL_THr_SET
#define FCON_TXQ_FULL_THr_GET BCM53262_A0_FCON_TXQ_FULL_THr_GET
#define FCON_TXQ_FULL_THr_TXQ_FULLTHf_GET BCM53262_A0_FCON_TXQ_FULL_THr_TXQ_FULLTHf_GET
#define FCON_TXQ_FULL_THr_TXQ_FULLTHf_SET BCM53262_A0_FCON_TXQ_FULL_THr_TXQ_FULLTHf_SET
#define FCON_TXQ_FULL_THr_RESERVED_Rf_GET BCM53262_A0_FCON_TXQ_FULL_THr_RESERVED_Rf_GET
#define FCON_TXQ_FULL_THr_RESERVED_Rf_SET BCM53262_A0_FCON_TXQ_FULL_THr_RESERVED_Rf_SET
#define READ_FCON_TXQ_FULL_THr BCM53262_A0_READ_FCON_TXQ_FULL_THr
#define WRITE_FCON_TXQ_FULL_THr BCM53262_A0_WRITE_FCON_TXQ_FULL_THr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FCON_TXQ_FULL_THr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  FLOW2VLAN
 * BLOCKS:   SYS
 * DESC:     Statistic RAM
 * SIZE:     32
 * FIELDS:
 *     VID_R            Vlan id
 *     RESVD            Reserved
 */
#define BCM53262_A0_FLOW2VLANm 0x40070538

#define BCM53262_A0_FLOW2VLANm_MIN 0
#define BCM53262_A0_FLOW2VLANm_MAX 463
#define BCM53262_A0_FLOW2VLANm_CMAX(u) 463
#define BCM53262_A0_FLOW2VLANm_SIZE 4

/*
 * This structure should be used to declare and program FLOW2VLAN.
 */
typedef union BCM53262_A0_FLOW2VLANm_s {
	uint32_t v[1];
	uint32_t flow2vlan[1];
	uint32_t _flow2vlan;
} BCM53262_A0_FLOW2VLANm_t;

#define BCM53262_A0_FLOW2VLANm_CLR(r) (r).flow2vlan[0] = 0
#define BCM53262_A0_FLOW2VLANm_SET(r,d) (r).flow2vlan[0] = d
#define BCM53262_A0_FLOW2VLANm_GET(r) (r).flow2vlan[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FLOW2VLANm_VID_Rf_GET(r) (((r).flow2vlan[0]) & 0xfff)
#define BCM53262_A0_FLOW2VLANm_VID_Rf_SET(r,f) (r).flow2vlan[0]=(((r).flow2vlan[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_FLOW2VLANm_RESVDf_GET(r) ((((r).flow2vlan[0]) >> 12) & 0xfffff)
#define BCM53262_A0_FLOW2VLANm_RESVDf_SET(r,f) (r).flow2vlan[0]=(((r).flow2vlan[0] & ~((uint32_t)0xfffff << 12)) | ((((uint32_t)f) & 0xfffff) << 12))

/*
 * These macros can be used to access FLOW2VLAN.
 */
#define BCM53262_A0_READ_FLOW2VLANm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_FLOW2VLANm,i,(m),4)
#define BCM53262_A0_WRITE_FLOW2VLANm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_FLOW2VLANm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FLOW2VLANm BCM53262_A0_FLOW2VLANm
#define FLOW2VLANm_MIN BCM53262_A0_FLOW2VLANm_MIN
#define FLOW2VLANm_MAX BCM53262_A0_FLOW2VLANm_MAX
#define FLOW2VLANm_CMAX(u) BCM53262_A0_FLOW2VLANm_CMAX(u)
#define FLOW2VLANm_SIZE BCM53262_A0_FLOW2VLANm_SIZE
typedef BCM53262_A0_FLOW2VLANm_t FLOW2VLANm_t;
#define FLOW2VLANm_CLR BCM53262_A0_FLOW2VLANm_CLR
#define FLOW2VLANm_SET BCM53262_A0_FLOW2VLANm_SET
#define FLOW2VLANm_GET BCM53262_A0_FLOW2VLANm_GET
#define FLOW2VLANm_VID_Rf_GET BCM53262_A0_FLOW2VLANm_VID_Rf_GET
#define FLOW2VLANm_VID_Rf_SET BCM53262_A0_FLOW2VLANm_VID_Rf_SET
#define FLOW2VLANm_RESVDf_GET BCM53262_A0_FLOW2VLANm_RESVDf_GET
#define FLOW2VLANm_RESVDf_SET BCM53262_A0_FLOW2VLANm_RESVDf_SET
#define READ_FLOW2VLANm BCM53262_A0_READ_FLOW2VLANm
#define WRITE_FLOW2VLANm BCM53262_A0_WRITE_FLOW2VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FLOW2VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FLOW_MON_BUS
 * BLOCKS:   SYS
 * DESC:     MON Flowcon Reg Bus Register
 * SIZE:     16
 * FIELDS:
 *     MON_FLOWCON      Diagnosis only:Set which port to debug flowcon internal tdm bus.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_FLOW_MON_BUSr 0x00000a36

#define BCM53262_A0_FLOW_MON_BUSr_SIZE 2

/*
 * This structure should be used to declare and program FLOW_MON_BUS.
 */
typedef union BCM53262_A0_FLOW_MON_BUSr_s {
	uint32_t v[1];
	uint32_t flow_mon_bus[1];
	uint32_t _flow_mon_bus;
} BCM53262_A0_FLOW_MON_BUSr_t;

#define BCM53262_A0_FLOW_MON_BUSr_CLR(r) (r).flow_mon_bus[0] = 0
#define BCM53262_A0_FLOW_MON_BUSr_SET(r,d) (r).flow_mon_bus[0] = d
#define BCM53262_A0_FLOW_MON_BUSr_GET(r) (r).flow_mon_bus[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FLOW_MON_BUSr_MON_FLOWCONf_GET(r) (((r).flow_mon_bus[0]) & 0xff)
#define BCM53262_A0_FLOW_MON_BUSr_MON_FLOWCONf_SET(r,f) (r).flow_mon_bus[0]=(((r).flow_mon_bus[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_FLOW_MON_BUSr_RESERVED_Rf_GET(r) ((((r).flow_mon_bus[0]) >> 8) & 0xff)
#define BCM53262_A0_FLOW_MON_BUSr_RESERVED_Rf_SET(r,f) (r).flow_mon_bus[0]=(((r).flow_mon_bus[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FLOW_MON_BUS.
 */
#define BCM53262_A0_READ_FLOW_MON_BUSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FLOW_MON_BUSr,(r._flow_mon_bus),2)
#define BCM53262_A0_WRITE_FLOW_MON_BUSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FLOW_MON_BUSr,&(r._flow_mon_bus),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FLOW_MON_BUSr BCM53262_A0_FLOW_MON_BUSr
#define FLOW_MON_BUSr_SIZE BCM53262_A0_FLOW_MON_BUSr_SIZE
typedef BCM53262_A0_FLOW_MON_BUSr_t FLOW_MON_BUSr_t;
#define FLOW_MON_BUSr_CLR BCM53262_A0_FLOW_MON_BUSr_CLR
#define FLOW_MON_BUSr_SET BCM53262_A0_FLOW_MON_BUSr_SET
#define FLOW_MON_BUSr_GET BCM53262_A0_FLOW_MON_BUSr_GET
#define FLOW_MON_BUSr_MON_FLOWCONf_GET BCM53262_A0_FLOW_MON_BUSr_MON_FLOWCONf_GET
#define FLOW_MON_BUSr_MON_FLOWCONf_SET BCM53262_A0_FLOW_MON_BUSr_MON_FLOWCONf_SET
#define FLOW_MON_BUSr_RESERVED_Rf_GET BCM53262_A0_FLOW_MON_BUSr_RESERVED_Rf_GET
#define FLOW_MON_BUSr_RESERVED_Rf_SET BCM53262_A0_FLOW_MON_BUSr_RESERVED_Rf_SET
#define READ_FLOW_MON_BUSr BCM53262_A0_READ_FLOW_MON_BUSr
#define WRITE_FLOW_MON_BUSr BCM53262_A0_WRITE_FLOW_MON_BUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FLOW_MON_BUSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FM_MEMADR
 * BLOCKS:   SYS
 * DESC:     FM Memory Read/Write Control Register
 * SIZE:     32
 * FIELDS:
 *     MEM_ADR          The 14 bit memory address that points to a unique 64-bit memory entry in the internal RAM. The address location will have its contents read into the Memory Entry register, or that the contents of the Memory Entry register will be written to the internal RAM location specified. Note that the addressing format is incremented by one for every 64-bit entry.
 *     MEMADR_RSRV0     Reserved
 *     MEM_RW           Memory Read/Write1 = Read0 = Write
 *     MEM_STDN         Start/Done CommandWrite as 1 to initiate a read or write memory location after first loading the MEM_ADDR with the address which is to be read or written. The BCM5348M will reset the bit to indicate a write operation completed, or a read operation has completed and data from the memory location is available in Memory Entry register. Note that the entire 64-bit memory entry is always read/written by the BCM5348M when accessing the RAM.
 *     MEMADR_RSRV1     Reserved
 */
#define BCM53262_A0_FM_MEMADRr 0x00000800

#define BCM53262_A0_FM_MEMADRr_SIZE 4

/*
 * This structure should be used to declare and program FM_MEMADR.
 */
typedef union BCM53262_A0_FM_MEMADRr_s {
	uint32_t v[1];
	uint32_t fm_memadr[1];
	uint32_t _fm_memadr;
} BCM53262_A0_FM_MEMADRr_t;

#define BCM53262_A0_FM_MEMADRr_CLR(r) (r).fm_memadr[0] = 0
#define BCM53262_A0_FM_MEMADRr_SET(r,d) (r).fm_memadr[0] = d
#define BCM53262_A0_FM_MEMADRr_GET(r) (r).fm_memadr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FM_MEMADRr_MEM_ADRf_GET(r) (((r).fm_memadr[0]) & 0x3fff)
#define BCM53262_A0_FM_MEMADRr_MEM_ADRf_SET(r,f) (r).fm_memadr[0]=(((r).fm_memadr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_FM_MEMADRr_MEMADR_RSRV0f_GET(r) ((((r).fm_memadr[0]) >> 14) & 0xf)
#define BCM53262_A0_FM_MEMADRr_MEMADR_RSRV0f_SET(r,f) (r).fm_memadr[0]=(((r).fm_memadr[0] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))
#define BCM53262_A0_FM_MEMADRr_MEM_RWf_GET(r) ((((r).fm_memadr[0]) >> 18) & 0x1)
#define BCM53262_A0_FM_MEMADRr_MEM_RWf_SET(r,f) (r).fm_memadr[0]=(((r).fm_memadr[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53262_A0_FM_MEMADRr_MEM_STDNf_GET(r) ((((r).fm_memadr[0]) >> 19) & 0x1)
#define BCM53262_A0_FM_MEMADRr_MEM_STDNf_SET(r,f) (r).fm_memadr[0]=(((r).fm_memadr[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53262_A0_FM_MEMADRr_MEMADR_RSRV1f_GET(r) ((((r).fm_memadr[0]) >> 20) & 0xfff)
#define BCM53262_A0_FM_MEMADRr_MEMADR_RSRV1f_SET(r,f) (r).fm_memadr[0]=(((r).fm_memadr[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access FM_MEMADR.
 */
#define BCM53262_A0_READ_FM_MEMADRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_FM_MEMADRr,(r._fm_memadr),4)
#define BCM53262_A0_WRITE_FM_MEMADRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_FM_MEMADRr,&(r._fm_memadr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FM_MEMADRr BCM53262_A0_FM_MEMADRr
#define FM_MEMADRr_SIZE BCM53262_A0_FM_MEMADRr_SIZE
typedef BCM53262_A0_FM_MEMADRr_t FM_MEMADRr_t;
#define FM_MEMADRr_CLR BCM53262_A0_FM_MEMADRr_CLR
#define FM_MEMADRr_SET BCM53262_A0_FM_MEMADRr_SET
#define FM_MEMADRr_GET BCM53262_A0_FM_MEMADRr_GET
#define FM_MEMADRr_MEM_ADRf_GET BCM53262_A0_FM_MEMADRr_MEM_ADRf_GET
#define FM_MEMADRr_MEM_ADRf_SET BCM53262_A0_FM_MEMADRr_MEM_ADRf_SET
#define FM_MEMADRr_MEMADR_RSRV0f_GET BCM53262_A0_FM_MEMADRr_MEMADR_RSRV0f_GET
#define FM_MEMADRr_MEMADR_RSRV0f_SET BCM53262_A0_FM_MEMADRr_MEMADR_RSRV0f_SET
#define FM_MEMADRr_MEM_RWf_GET BCM53262_A0_FM_MEMADRr_MEM_RWf_GET
#define FM_MEMADRr_MEM_RWf_SET BCM53262_A0_FM_MEMADRr_MEM_RWf_SET
#define FM_MEMADRr_MEM_STDNf_GET BCM53262_A0_FM_MEMADRr_MEM_STDNf_GET
#define FM_MEMADRr_MEM_STDNf_SET BCM53262_A0_FM_MEMADRr_MEM_STDNf_SET
#define FM_MEMADRr_MEMADR_RSRV1f_GET BCM53262_A0_FM_MEMADRr_MEMADR_RSRV1f_GET
#define FM_MEMADRr_MEMADR_RSRV1f_SET BCM53262_A0_FM_MEMADRr_MEMADR_RSRV1f_SET
#define READ_FM_MEMADRr BCM53262_A0_READ_FM_MEMADRr
#define WRITE_FM_MEMADRr BCM53262_A0_WRITE_FM_MEMADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FM_MEMADRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FM_MEMDAT0
 * BLOCKS:   SYS
 * DESC:     FM Memory Read/Write Data 0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          63~0bits of data to be written to memory, or data that has been read from memory, as configured in the Memory Read/Write Control register, prior to setting the Start bit.
 */
#define BCM53262_A0_FM_MEMDAT0r 0x00000810

#define BCM53262_A0_FM_MEMDAT0r_SIZE 8

/*
 * This structure should be used to declare and program FM_MEMDAT0.
 */
typedef union BCM53262_A0_FM_MEMDAT0r_s {
	uint32_t v[2];
	uint32_t fm_memdat0[2];
	uint32_t _fm_memdat0;
} BCM53262_A0_FM_MEMDAT0r_t;

#define BCM53262_A0_FM_MEMDAT0r_CLR(r) CDK_MEMSET(&((r)._fm_memdat0), 0, sizeof(BCM53262_A0_FM_MEMDAT0r_t))
#define BCM53262_A0_FM_MEMDAT0r_SET(r,i,d) (r).fm_memdat0[i] = d
#define BCM53262_A0_FM_MEMDAT0r_GET(r,i) (r).fm_memdat0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FM_MEMDAT0r_MEM_DATf_GET(r,a) cdk_field_get((r).fm_memdat0,0,63,a)
#define BCM53262_A0_FM_MEMDAT0r_MEM_DATf_SET(r,a) cdk_field_set((r).fm_memdat0,0,63,a)

/*
 * These macros can be used to access FM_MEMDAT0.
 */
#define BCM53262_A0_READ_FM_MEMDAT0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FM_MEMDAT0r,(r._fm_memdat0),8)
#define BCM53262_A0_WRITE_FM_MEMDAT0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FM_MEMDAT0r,&(r._fm_memdat0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FM_MEMDAT0r BCM53262_A0_FM_MEMDAT0r
#define FM_MEMDAT0r_SIZE BCM53262_A0_FM_MEMDAT0r_SIZE
typedef BCM53262_A0_FM_MEMDAT0r_t FM_MEMDAT0r_t;
#define FM_MEMDAT0r_CLR BCM53262_A0_FM_MEMDAT0r_CLR
#define FM_MEMDAT0r_SET BCM53262_A0_FM_MEMDAT0r_SET
#define FM_MEMDAT0r_GET BCM53262_A0_FM_MEMDAT0r_GET
#define FM_MEMDAT0r_MEM_DATf_GET BCM53262_A0_FM_MEMDAT0r_MEM_DATf_GET
#define FM_MEMDAT0r_MEM_DATf_SET BCM53262_A0_FM_MEMDAT0r_MEM_DATf_SET
#define READ_FM_MEMDAT0r BCM53262_A0_READ_FM_MEMDAT0r
#define WRITE_FM_MEMDAT0r BCM53262_A0_WRITE_FM_MEMDAT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FM_MEMDAT0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FM_MEMDAT1
 * BLOCKS:   SYS
 * DESC:     FM Memory Read/Write Data 1 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          128~65bits of data to be written to memory, or data that has been read from memory, as configured in the Memory Read/Write Control register, prior to setting the Start bit.
 */
#define BCM53262_A0_FM_MEMDAT1r 0x00000818

#define BCM53262_A0_FM_MEMDAT1r_SIZE 8

/*
 * This structure should be used to declare and program FM_MEMDAT1.
 */
typedef union BCM53262_A0_FM_MEMDAT1r_s {
	uint32_t v[2];
	uint32_t fm_memdat1[2];
	uint32_t _fm_memdat1;
} BCM53262_A0_FM_MEMDAT1r_t;

#define BCM53262_A0_FM_MEMDAT1r_CLR(r) CDK_MEMSET(&((r)._fm_memdat1), 0, sizeof(BCM53262_A0_FM_MEMDAT1r_t))
#define BCM53262_A0_FM_MEMDAT1r_SET(r,i,d) (r).fm_memdat1[i] = d
#define BCM53262_A0_FM_MEMDAT1r_GET(r,i) (r).fm_memdat1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FM_MEMDAT1r_MEM_DATf_GET(r,a) cdk_field_get((r).fm_memdat1,0,63,a)
#define BCM53262_A0_FM_MEMDAT1r_MEM_DATf_SET(r,a) cdk_field_set((r).fm_memdat1,0,63,a)

/*
 * These macros can be used to access FM_MEMDAT1.
 */
#define BCM53262_A0_READ_FM_MEMDAT1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FM_MEMDAT1r,(r._fm_memdat1),8)
#define BCM53262_A0_WRITE_FM_MEMDAT1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FM_MEMDAT1r,&(r._fm_memdat1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FM_MEMDAT1r BCM53262_A0_FM_MEMDAT1r
#define FM_MEMDAT1r_SIZE BCM53262_A0_FM_MEMDAT1r_SIZE
typedef BCM53262_A0_FM_MEMDAT1r_t FM_MEMDAT1r_t;
#define FM_MEMDAT1r_CLR BCM53262_A0_FM_MEMDAT1r_CLR
#define FM_MEMDAT1r_SET BCM53262_A0_FM_MEMDAT1r_SET
#define FM_MEMDAT1r_GET BCM53262_A0_FM_MEMDAT1r_GET
#define FM_MEMDAT1r_MEM_DATf_GET BCM53262_A0_FM_MEMDAT1r_MEM_DATf_GET
#define FM_MEMDAT1r_MEM_DATf_SET BCM53262_A0_FM_MEMDAT1r_MEM_DATf_SET
#define READ_FM_MEMDAT1r BCM53262_A0_READ_FM_MEMDAT1r
#define WRITE_FM_MEMDAT1r BCM53262_A0_WRITE_FM_MEMDAT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FM_MEMDAT1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FM_MEMDAT2
 * BLOCKS:   SYS
 * DESC:     FM Memory Read/Write Data 2 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          192~127bits of data to be written to memory, or data that has been read from memory, as configured in the Memory Read/Write Control register, prior to setting the Start bit.
 */
#define BCM53262_A0_FM_MEMDAT2r 0x00000820

#define BCM53262_A0_FM_MEMDAT2r_SIZE 8

/*
 * This structure should be used to declare and program FM_MEMDAT2.
 */
typedef union BCM53262_A0_FM_MEMDAT2r_s {
	uint32_t v[2];
	uint32_t fm_memdat2[2];
	uint32_t _fm_memdat2;
} BCM53262_A0_FM_MEMDAT2r_t;

#define BCM53262_A0_FM_MEMDAT2r_CLR(r) CDK_MEMSET(&((r)._fm_memdat2), 0, sizeof(BCM53262_A0_FM_MEMDAT2r_t))
#define BCM53262_A0_FM_MEMDAT2r_SET(r,i,d) (r).fm_memdat2[i] = d
#define BCM53262_A0_FM_MEMDAT2r_GET(r,i) (r).fm_memdat2[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FM_MEMDAT2r_MEM_DATf_GET(r,a) cdk_field_get((r).fm_memdat2,0,63,a)
#define BCM53262_A0_FM_MEMDAT2r_MEM_DATf_SET(r,a) cdk_field_set((r).fm_memdat2,0,63,a)

/*
 * These macros can be used to access FM_MEMDAT2.
 */
#define BCM53262_A0_READ_FM_MEMDAT2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FM_MEMDAT2r,(r._fm_memdat2),8)
#define BCM53262_A0_WRITE_FM_MEMDAT2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FM_MEMDAT2r,&(r._fm_memdat2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FM_MEMDAT2r BCM53262_A0_FM_MEMDAT2r
#define FM_MEMDAT2r_SIZE BCM53262_A0_FM_MEMDAT2r_SIZE
typedef BCM53262_A0_FM_MEMDAT2r_t FM_MEMDAT2r_t;
#define FM_MEMDAT2r_CLR BCM53262_A0_FM_MEMDAT2r_CLR
#define FM_MEMDAT2r_SET BCM53262_A0_FM_MEMDAT2r_SET
#define FM_MEMDAT2r_GET BCM53262_A0_FM_MEMDAT2r_GET
#define FM_MEMDAT2r_MEM_DATf_GET BCM53262_A0_FM_MEMDAT2r_MEM_DATf_GET
#define FM_MEMDAT2r_MEM_DATf_SET BCM53262_A0_FM_MEMDAT2r_MEM_DATf_SET
#define READ_FM_MEMDAT2r BCM53262_A0_READ_FM_MEMDAT2r
#define WRITE_FM_MEMDAT2r BCM53262_A0_WRITE_FM_MEMDAT2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FM_MEMDAT2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  FM_MEMDAT3
 * BLOCKS:   SYS
 * DESC:     FM Memory Read/Write Data 3 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          256~193bits of data to be written to memory, or data that has been read from memory, as configured in the Memory Read/Write Control register, prior to setting the Start bit.EOT
 */
#define BCM53262_A0_FM_MEMDAT3r 0x00000828

#define BCM53262_A0_FM_MEMDAT3r_SIZE 8

/*
 * This structure should be used to declare and program FM_MEMDAT3.
 */
typedef union BCM53262_A0_FM_MEMDAT3r_s {
	uint32_t v[2];
	uint32_t fm_memdat3[2];
	uint32_t _fm_memdat3;
} BCM53262_A0_FM_MEMDAT3r_t;

#define BCM53262_A0_FM_MEMDAT3r_CLR(r) CDK_MEMSET(&((r)._fm_memdat3), 0, sizeof(BCM53262_A0_FM_MEMDAT3r_t))
#define BCM53262_A0_FM_MEMDAT3r_SET(r,i,d) (r).fm_memdat3[i] = d
#define BCM53262_A0_FM_MEMDAT3r_GET(r,i) (r).fm_memdat3[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_FM_MEMDAT3r_MEM_DATf_GET(r,a) cdk_field_get((r).fm_memdat3,0,63,a)
#define BCM53262_A0_FM_MEMDAT3r_MEM_DATf_SET(r,a) cdk_field_set((r).fm_memdat3,0,63,a)

/*
 * These macros can be used to access FM_MEMDAT3.
 */
#define BCM53262_A0_READ_FM_MEMDAT3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_FM_MEMDAT3r,(r._fm_memdat3),8)
#define BCM53262_A0_WRITE_FM_MEMDAT3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_FM_MEMDAT3r,&(r._fm_memdat3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FM_MEMDAT3r BCM53262_A0_FM_MEMDAT3r
#define FM_MEMDAT3r_SIZE BCM53262_A0_FM_MEMDAT3r_SIZE
typedef BCM53262_A0_FM_MEMDAT3r_t FM_MEMDAT3r_t;
#define FM_MEMDAT3r_CLR BCM53262_A0_FM_MEMDAT3r_CLR
#define FM_MEMDAT3r_SET BCM53262_A0_FM_MEMDAT3r_SET
#define FM_MEMDAT3r_GET BCM53262_A0_FM_MEMDAT3r_GET
#define FM_MEMDAT3r_MEM_DATf_GET BCM53262_A0_FM_MEMDAT3r_MEM_DATf_GET
#define FM_MEMDAT3r_MEM_DATf_SET BCM53262_A0_FM_MEMDAT3r_MEM_DATf_SET
#define READ_FM_MEMDAT3r BCM53262_A0_READ_FM_MEMDAT3r
#define WRITE_FM_MEMDAT3r BCM53262_A0_WRITE_FM_MEMDAT3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_FM_MEMDAT3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GARLCFG
 * BLOCKS:   SYS
 * DESC:     Global ARL Configuration Register
 * SIZE:     8
 * FIELDS:
 *     HASH_DISABLE     Disable the hash function for the ARL such that entries are direct mapped to the table. The hash function is enabled as the default for the BCM5348M ARL, but can be disabled by setting this bit.Note : Not to release.
 *     RSRV             Reserved
 *     AGE_ACC          Test only.  Not to release to customers.
 *     GARLCFG_RSRV0    Reserved
 *     MPADDR_EN        1: Multiport Address Enable. When set 1 by the host, enables the Multiport Address 1 and 2 registers, and their associated Multiport Vector 1 and 2 registers. This enables these registers in the ARL search.Note that if only one multiport address is required, the host should write both Multiport Address/Vector entries to the same value.0: More BPDUs Enable. When set 0 by the host, enables more user's BPDU on the Multiport Address 1 and 2 registers. Any incoming packet whit DA matching Multiport Address 1 and 2 registers will act as BPDU packet. Multiport Vector 1 and 2 registers are ingored.Note that if only one more BPDU address is required, the thost shouls write both Multiport Address entries to the Same value.
 *     GARLCFG_RSRV1    Reserved
 */
#define BCM53262_A0_GARLCFGr 0x00000400

#define BCM53262_A0_GARLCFGr_SIZE 1

/*
 * This structure should be used to declare and program GARLCFG.
 */
typedef union BCM53262_A0_GARLCFGr_s {
	uint32_t v[1];
	uint32_t garlcfg[1];
	uint32_t _garlcfg;
} BCM53262_A0_GARLCFGr_t;

#define BCM53262_A0_GARLCFGr_CLR(r) (r).garlcfg[0] = 0
#define BCM53262_A0_GARLCFGr_SET(r,d) (r).garlcfg[0] = d
#define BCM53262_A0_GARLCFGr_GET(r) (r).garlcfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GARLCFGr_HASH_DISABLEf_GET(r) (((r).garlcfg[0]) & 0x1)
#define BCM53262_A0_GARLCFGr_HASH_DISABLEf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_GARLCFGr_RSRVf_GET(r) ((((r).garlcfg[0]) >> 1) & 0x1)
#define BCM53262_A0_GARLCFGr_RSRVf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_GARLCFGr_AGE_ACCf_GET(r) ((((r).garlcfg[0]) >> 2) & 0x1)
#define BCM53262_A0_GARLCFGr_AGE_ACCf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_GARLCFGr_GARLCFG_RSRV0f_GET(r) ((((r).garlcfg[0]) >> 3) & 0x1)
#define BCM53262_A0_GARLCFGr_GARLCFG_RSRV0f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_GARLCFGr_MPADDR_ENf_GET(r) ((((r).garlcfg[0]) >> 4) & 0x1)
#define BCM53262_A0_GARLCFGr_MPADDR_ENf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_GARLCFGr_GARLCFG_RSRV1f_GET(r) ((((r).garlcfg[0]) >> 5) & 0x7)
#define BCM53262_A0_GARLCFGr_GARLCFG_RSRV1f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access GARLCFG.
 */
#define BCM53262_A0_READ_GARLCFGr(u,r) cdk_robo_reg_read(u,BCM53262_A0_GARLCFGr,(r._garlcfg),1)
#define BCM53262_A0_WRITE_GARLCFGr(u,r) cdk_robo_reg_write(u,BCM53262_A0_GARLCFGr,&(r._garlcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GARLCFGr BCM53262_A0_GARLCFGr
#define GARLCFGr_SIZE BCM53262_A0_GARLCFGr_SIZE
typedef BCM53262_A0_GARLCFGr_t GARLCFGr_t;
#define GARLCFGr_CLR BCM53262_A0_GARLCFGr_CLR
#define GARLCFGr_SET BCM53262_A0_GARLCFGr_SET
#define GARLCFGr_GET BCM53262_A0_GARLCFGr_GET
#define GARLCFGr_HASH_DISABLEf_GET BCM53262_A0_GARLCFGr_HASH_DISABLEf_GET
#define GARLCFGr_HASH_DISABLEf_SET BCM53262_A0_GARLCFGr_HASH_DISABLEf_SET
#define GARLCFGr_RSRVf_GET BCM53262_A0_GARLCFGr_RSRVf_GET
#define GARLCFGr_RSRVf_SET BCM53262_A0_GARLCFGr_RSRVf_SET
#define GARLCFGr_AGE_ACCf_GET BCM53262_A0_GARLCFGr_AGE_ACCf_GET
#define GARLCFGr_AGE_ACCf_SET BCM53262_A0_GARLCFGr_AGE_ACCf_SET
#define GARLCFGr_GARLCFG_RSRV0f_GET BCM53262_A0_GARLCFGr_GARLCFG_RSRV0f_GET
#define GARLCFGr_GARLCFG_RSRV0f_SET BCM53262_A0_GARLCFGr_GARLCFG_RSRV0f_SET
#define GARLCFGr_MPADDR_ENf_GET BCM53262_A0_GARLCFGr_MPADDR_ENf_GET
#define GARLCFGr_MPADDR_ENf_SET BCM53262_A0_GARLCFGr_MPADDR_ENf_SET
#define GARLCFGr_GARLCFG_RSRV1f_GET BCM53262_A0_GARLCFGr_GARLCFG_RSRV1f_GET
#define GARLCFGr_GARLCFG_RSRV1f_SET BCM53262_A0_GARLCFGr_GARLCFG_RSRV1f_SET
#define READ_GARLCFGr BCM53262_A0_READ_GARLCFGr
#define WRITE_GARLCFGr BCM53262_A0_WRITE_GARLCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GARLCFGr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GENMEM_ADDR
 * BLOCKS:   SYS
 * DESC:     Descriptor Memory Access Registers
 * SIZE:     16
 * FIELDS:
 *     GENMEM_ADDR      Generic Memory Address (bcm5348 onlu for Descriptor Memory).
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_GENMEM_ADDRr 0x00000842

#define BCM53262_A0_GENMEM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program GENMEM_ADDR.
 */
typedef union BCM53262_A0_GENMEM_ADDRr_s {
	uint32_t v[1];
	uint32_t genmem_addr[1];
	uint32_t _genmem_addr;
} BCM53262_A0_GENMEM_ADDRr_t;

#define BCM53262_A0_GENMEM_ADDRr_CLR(r) (r).genmem_addr[0] = 0
#define BCM53262_A0_GENMEM_ADDRr_SET(r,d) (r).genmem_addr[0] = d
#define BCM53262_A0_GENMEM_ADDRr_GET(r) (r).genmem_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GENMEM_ADDRr_GENMEM_ADDRf_GET(r) (((r).genmem_addr[0]) & 0x1fff)
#define BCM53262_A0_GENMEM_ADDRr_GENMEM_ADDRf_SET(r,f) (r).genmem_addr[0]=(((r).genmem_addr[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53262_A0_GENMEM_ADDRr_RESERVED_Rf_GET(r) ((((r).genmem_addr[0]) >> 13) & 0x7)
#define BCM53262_A0_GENMEM_ADDRr_RESERVED_Rf_SET(r,f) (r).genmem_addr[0]=(((r).genmem_addr[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access GENMEM_ADDR.
 */
#define BCM53262_A0_READ_GENMEM_ADDRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_GENMEM_ADDRr,(r._genmem_addr),2)
#define BCM53262_A0_WRITE_GENMEM_ADDRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_GENMEM_ADDRr,&(r._genmem_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GENMEM_ADDRr BCM53262_A0_GENMEM_ADDRr
#define GENMEM_ADDRr_SIZE BCM53262_A0_GENMEM_ADDRr_SIZE
typedef BCM53262_A0_GENMEM_ADDRr_t GENMEM_ADDRr_t;
#define GENMEM_ADDRr_CLR BCM53262_A0_GENMEM_ADDRr_CLR
#define GENMEM_ADDRr_SET BCM53262_A0_GENMEM_ADDRr_SET
#define GENMEM_ADDRr_GET BCM53262_A0_GENMEM_ADDRr_GET
#define GENMEM_ADDRr_GENMEM_ADDRf_GET BCM53262_A0_GENMEM_ADDRr_GENMEM_ADDRf_GET
#define GENMEM_ADDRr_GENMEM_ADDRf_SET BCM53262_A0_GENMEM_ADDRr_GENMEM_ADDRf_SET
#define GENMEM_ADDRr_RESERVED_Rf_GET BCM53262_A0_GENMEM_ADDRr_RESERVED_Rf_GET
#define GENMEM_ADDRr_RESERVED_Rf_SET BCM53262_A0_GENMEM_ADDRr_RESERVED_Rf_SET
#define READ_GENMEM_ADDRr BCM53262_A0_READ_GENMEM_ADDRr
#define WRITE_GENMEM_ADDRr BCM53262_A0_WRITE_GENMEM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GENMEM_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GENMEM_CTL
 * BLOCKS:   SYS
 * DESC:     Descriptor Memory Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     GENMEM_RW                        Memory Read/Write1 = Read0 = Write
 *     TXDSC_ARL                        Memory Read/Write1 = Txdsc,0 = ARL.
 *     GENMEM_RSRV0     Reserved
 *     GENMEM_STDN      Start/Done CommandWrite as 1 to initiate a read or write memory location after first loading the ADDR with the address which is to be read or written. The BCM5348M will reset the bit to indicate a write operation completed, or a read operation has completed and data from the memory location is available in Memory Entry register. Note that the entire 64-bit memory entry is always read/written by the BCM5348M when accessing the RAM.
 */
#define BCM53262_A0_GENMEM_CTLr 0x00000830

#define BCM53262_A0_GENMEM_CTLr_SIZE 1

/*
 * This structure should be used to declare and program GENMEM_CTL.
 */
typedef union BCM53262_A0_GENMEM_CTLr_s {
	uint32_t v[1];
	uint32_t genmem_ctl[1];
	uint32_t _genmem_ctl;
} BCM53262_A0_GENMEM_CTLr_t;

#define BCM53262_A0_GENMEM_CTLr_CLR(r) (r).genmem_ctl[0] = 0
#define BCM53262_A0_GENMEM_CTLr_SET(r,d) (r).genmem_ctl[0] = d
#define BCM53262_A0_GENMEM_CTLr_GET(r) (r).genmem_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GENMEM_CTLr_GENMEM_RWf_GET(r) (((r).genmem_ctl[0]) & 0x1)
#define BCM53262_A0_GENMEM_CTLr_GENMEM_RWf_SET(r,f) (r).genmem_ctl[0]=(((r).genmem_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_GENMEM_CTLr_TXDSC_ARLf_GET(r) ((((r).genmem_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_GENMEM_CTLr_TXDSC_ARLf_SET(r,f) (r).genmem_ctl[0]=(((r).genmem_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_GENMEM_CTLr_GENMEM_RSRV0f_GET(r) ((((r).genmem_ctl[0]) >> 2) & 0x1f)
#define BCM53262_A0_GENMEM_CTLr_GENMEM_RSRV0f_SET(r,f) (r).genmem_ctl[0]=(((r).genmem_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53262_A0_GENMEM_CTLr_GENMEM_STDNf_GET(r) ((((r).genmem_ctl[0]) >> 7) & 0x1)
#define BCM53262_A0_GENMEM_CTLr_GENMEM_STDNf_SET(r,f) (r).genmem_ctl[0]=(((r).genmem_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access GENMEM_CTL.
 */
#define BCM53262_A0_READ_GENMEM_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_GENMEM_CTLr,(r._genmem_ctl),1)
#define BCM53262_A0_WRITE_GENMEM_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_GENMEM_CTLr,&(r._genmem_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GENMEM_CTLr BCM53262_A0_GENMEM_CTLr
#define GENMEM_CTLr_SIZE BCM53262_A0_GENMEM_CTLr_SIZE
typedef BCM53262_A0_GENMEM_CTLr_t GENMEM_CTLr_t;
#define GENMEM_CTLr_CLR BCM53262_A0_GENMEM_CTLr_CLR
#define GENMEM_CTLr_SET BCM53262_A0_GENMEM_CTLr_SET
#define GENMEM_CTLr_GET BCM53262_A0_GENMEM_CTLr_GET
#define GENMEM_CTLr_GENMEM_RWf_GET BCM53262_A0_GENMEM_CTLr_GENMEM_RWf_GET
#define GENMEM_CTLr_GENMEM_RWf_SET BCM53262_A0_GENMEM_CTLr_GENMEM_RWf_SET
#define GENMEM_CTLr_TXDSC_ARLf_GET BCM53262_A0_GENMEM_CTLr_TXDSC_ARLf_GET
#define GENMEM_CTLr_TXDSC_ARLf_SET BCM53262_A0_GENMEM_CTLr_TXDSC_ARLf_SET
#define GENMEM_CTLr_GENMEM_RSRV0f_GET BCM53262_A0_GENMEM_CTLr_GENMEM_RSRV0f_GET
#define GENMEM_CTLr_GENMEM_RSRV0f_SET BCM53262_A0_GENMEM_CTLr_GENMEM_RSRV0f_SET
#define GENMEM_CTLr_GENMEM_STDNf_GET BCM53262_A0_GENMEM_CTLr_GENMEM_STDNf_GET
#define GENMEM_CTLr_GENMEM_STDNf_SET BCM53262_A0_GENMEM_CTLr_GENMEM_STDNf_SET
#define READ_GENMEM_CTLr BCM53262_A0_READ_GENMEM_CTLr
#define WRITE_GENMEM_CTLr BCM53262_A0_WRITE_GENMEM_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GENMEM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GENMEM_DATA0
 * BLOCKS:   SYS
 * DESC:     Global descriptor Data 0 Registers
 * SIZE:     64
 * FIELDS:
 *     GENMEM_DATA      61~0bits of data to be written to memory, or data that has been read from memory, as configured in the Memory Read/Write Control register, prior to setting the Start bit.when TXDSC_ARL = 1 (page 08h, addr 30h, bit 1)GENMEM_DATA1[63:62] : Reserved.GENMEM_DATA1[61:0] : txdsc[61:0];txdsc[61]   : Change_DSCPtxdsc[60:55]: New_DSCPtxdsc[54]   : Change_1Ptxdsc[53:51]: New_1P,txdsc[50:49]: ERMON,txdsc[48:47]: Queue[1:0],txdsc[46]   : Pre_1q,txdsc[45:40]: rxport[5:0],txdsc[39:34]: mcast[5:0],txdsc[33:22]: fmlen[11:0],txdsc[21:11]: fm_addr1[11:0],txdsc[11:0] : fm_addr0[11:0],when TXDSC_ARL = 0 (page 08h, addr 30h, bit 1)GENMEM_DATA1[63:62] : Reserved.GENMEM_DATA1[61:0] : ARL[61:0];ARL[61:60]: con[1:0],ARL[59:48]: vid[11:0],ARL[47]   : Ag,ARL[46:45]: pri[1:0],ARL[44:42]: Rev[2:0],ARL[41:36]: Rxport_num[5:0],ARL[35:0]:  Mac[47:12],
 */
#define BCM53262_A0_GENMEM_DATA0r 0x00000848

#define BCM53262_A0_GENMEM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program GENMEM_DATA0.
 */
typedef union BCM53262_A0_GENMEM_DATA0r_s {
	uint32_t v[2];
	uint32_t genmem_data0[2];
	uint32_t _genmem_data0;
} BCM53262_A0_GENMEM_DATA0r_t;

#define BCM53262_A0_GENMEM_DATA0r_CLR(r) CDK_MEMSET(&((r)._genmem_data0), 0, sizeof(BCM53262_A0_GENMEM_DATA0r_t))
#define BCM53262_A0_GENMEM_DATA0r_SET(r,i,d) (r).genmem_data0[i] = d
#define BCM53262_A0_GENMEM_DATA0r_GET(r,i) (r).genmem_data0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GENMEM_DATA0r_GENMEM_DATAf_GET(r,a) cdk_field_get((r).genmem_data0,0,63,a)
#define BCM53262_A0_GENMEM_DATA0r_GENMEM_DATAf_SET(r,a) cdk_field_set((r).genmem_data0,0,63,a)

/*
 * These macros can be used to access GENMEM_DATA0.
 */
#define BCM53262_A0_READ_GENMEM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_GENMEM_DATA0r,(r._genmem_data0),8)
#define BCM53262_A0_WRITE_GENMEM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_GENMEM_DATA0r,&(r._genmem_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GENMEM_DATA0r BCM53262_A0_GENMEM_DATA0r
#define GENMEM_DATA0r_SIZE BCM53262_A0_GENMEM_DATA0r_SIZE
typedef BCM53262_A0_GENMEM_DATA0r_t GENMEM_DATA0r_t;
#define GENMEM_DATA0r_CLR BCM53262_A0_GENMEM_DATA0r_CLR
#define GENMEM_DATA0r_SET BCM53262_A0_GENMEM_DATA0r_SET
#define GENMEM_DATA0r_GET BCM53262_A0_GENMEM_DATA0r_GET
#define GENMEM_DATA0r_GENMEM_DATAf_GET BCM53262_A0_GENMEM_DATA0r_GENMEM_DATAf_GET
#define GENMEM_DATA0r_GENMEM_DATAf_SET BCM53262_A0_GENMEM_DATA0r_GENMEM_DATAf_SET
#define READ_GENMEM_DATA0r BCM53262_A0_READ_GENMEM_DATA0r
#define WRITE_GENMEM_DATA0r BCM53262_A0_WRITE_GENMEM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GENMEM_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GENMEM_DATA1
 * BLOCKS:   SYS
 * DESC:     Global descriptor Data 1 Registers
 * SIZE:     64
 * FIELDS:
 *     GENMEM_DATA      24~0bits of data to be written to memory, or data that has been read from memory, as configured in the Memory Read/Write Control register.when TXDSC_ARL = 1 (page 08h, addr 30h, bit 1)GENMEM_DATA1[63:36]: Reserved.GENMEM_DATA1[35:0] : txdsc[97:62].txdsc[97]    : NNI.txdsc[96:95] : IPV.txdsc[94:93] : T_INFO.txdsc[92:91] : L2_INFO.txdsc[90:87] : FLOW_ID.txdsc[86:81] : Reason code.txdsc[80:79] : C_VID.txdsc[78:67] : New_VID.txdsc[66]    : Tag.txdsc[65:62] : ToBufNo[3:0].when TXDSC_ARL = 0 (page 08h, addr 30h, bit 1)GENMEM_DATA1[63:0] : ARL[63:0];ARL[63]: Va_1,ARL[62]: St_1,ARL[61:60]: con_1[1:0],ARL[59:48]: vid_1[11:0],ARL[47] : Ag_1,ARL[46:42]: Rev_1[4:0],ARL[41:36]: Rxport_num_1[5:0],ARL[35:0]: Mac_1[47:12],
 */
#define BCM53262_A0_GENMEM_DATA1r 0x00000850

#define BCM53262_A0_GENMEM_DATA1r_SIZE 8

/*
 * This structure should be used to declare and program GENMEM_DATA1.
 */
typedef union BCM53262_A0_GENMEM_DATA1r_s {
	uint32_t v[2];
	uint32_t genmem_data1[2];
	uint32_t _genmem_data1;
} BCM53262_A0_GENMEM_DATA1r_t;

#define BCM53262_A0_GENMEM_DATA1r_CLR(r) CDK_MEMSET(&((r)._genmem_data1), 0, sizeof(BCM53262_A0_GENMEM_DATA1r_t))
#define BCM53262_A0_GENMEM_DATA1r_SET(r,i,d) (r).genmem_data1[i] = d
#define BCM53262_A0_GENMEM_DATA1r_GET(r,i) (r).genmem_data1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GENMEM_DATA1r_GENMEM_DATAf_GET(r,a) cdk_field_get((r).genmem_data1,0,63,a)
#define BCM53262_A0_GENMEM_DATA1r_GENMEM_DATAf_SET(r,a) cdk_field_set((r).genmem_data1,0,63,a)

/*
 * These macros can be used to access GENMEM_DATA1.
 */
#define BCM53262_A0_READ_GENMEM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_GENMEM_DATA1r,(r._genmem_data1),8)
#define BCM53262_A0_WRITE_GENMEM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_GENMEM_DATA1r,&(r._genmem_data1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GENMEM_DATA1r BCM53262_A0_GENMEM_DATA1r
#define GENMEM_DATA1r_SIZE BCM53262_A0_GENMEM_DATA1r_SIZE
typedef BCM53262_A0_GENMEM_DATA1r_t GENMEM_DATA1r_t;
#define GENMEM_DATA1r_CLR BCM53262_A0_GENMEM_DATA1r_CLR
#define GENMEM_DATA1r_SET BCM53262_A0_GENMEM_DATA1r_SET
#define GENMEM_DATA1r_GET BCM53262_A0_GENMEM_DATA1r_GET
#define GENMEM_DATA1r_GENMEM_DATAf_GET BCM53262_A0_GENMEM_DATA1r_GENMEM_DATAf_GET
#define GENMEM_DATA1r_GENMEM_DATAf_SET BCM53262_A0_GENMEM_DATA1r_GENMEM_DATAf_SET
#define READ_GENMEM_DATA1r BCM53262_A0_READ_GENMEM_DATA1r
#define WRITE_GENMEM_DATA1r BCM53262_A0_WRITE_GENMEM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GENMEM_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GLOBAL_TRUNK_CTL
 * BLOCKS:   SYS
 * DESC:     Global Trunk Control Register
 * SIZE:     8
 * FIELDS:
 *     GLOBAL_TRUNK_CTL_RSRV0 Reserved.
 *     EN_TRUNK_LOCAL   Enable Trunk feature : boot 10/100 and giga.
 *     GLOBAL_TRUNK_CTL_RSRV1 Reserved
 *     TRUNK_SEED       Trunk hash index selection.bit 7 : IPv4_SIPbit 6 : IPv4_DIPbit 5 : MAC_SAbit 4 : MAC_DA
 */
#define BCM53262_A0_GLOBAL_TRUNK_CTLr 0x00003100

#define BCM53262_A0_GLOBAL_TRUNK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program GLOBAL_TRUNK_CTL.
 */
typedef union BCM53262_A0_GLOBAL_TRUNK_CTLr_s {
	uint32_t v[1];
	uint32_t global_trunk_ctl[1];
	uint32_t _global_trunk_ctl;
} BCM53262_A0_GLOBAL_TRUNK_CTLr_t;

#define BCM53262_A0_GLOBAL_TRUNK_CTLr_CLR(r) (r).global_trunk_ctl[0] = 0
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_SET(r,d) (r).global_trunk_ctl[0] = d
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_GET(r) (r).global_trunk_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_GET(r) (((r).global_trunk_ctl[0]) & 0x1)
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET(r) ((((r).global_trunk_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_GET(r) ((((r).global_trunk_ctl[0]) >> 2) & 0x3)
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET(r) ((((r).global_trunk_ctl[0]) >> 4) & 0xf)
#define BCM53262_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access GLOBAL_TRUNK_CTL.
 */
#define BCM53262_A0_READ_GLOBAL_TRUNK_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_GLOBAL_TRUNK_CTLr,(r._global_trunk_ctl),1)
#define BCM53262_A0_WRITE_GLOBAL_TRUNK_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_GLOBAL_TRUNK_CTLr,&(r._global_trunk_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLOBAL_TRUNK_CTLr BCM53262_A0_GLOBAL_TRUNK_CTLr
#define GLOBAL_TRUNK_CTLr_SIZE BCM53262_A0_GLOBAL_TRUNK_CTLr_SIZE
typedef BCM53262_A0_GLOBAL_TRUNK_CTLr_t GLOBAL_TRUNK_CTLr_t;
#define GLOBAL_TRUNK_CTLr_CLR BCM53262_A0_GLOBAL_TRUNK_CTLr_CLR
#define GLOBAL_TRUNK_CTLr_SET BCM53262_A0_GLOBAL_TRUNK_CTLr_SET
#define GLOBAL_TRUNK_CTLr_GET BCM53262_A0_GLOBAL_TRUNK_CTLr_GET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_GET BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_GET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_SET BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV0f_SET
#define GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET BCM53262_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET
#define GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET BCM53262_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_GET BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_GET
#define GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_SET BCM53262_A0_GLOBAL_TRUNK_CTLr_GLOBAL_TRUNK_CTL_RSRV1f_SET
#define GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET BCM53262_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET
#define GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET BCM53262_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET
#define READ_GLOBAL_TRUNK_CTLr BCM53262_A0_READ_GLOBAL_TRUNK_CTLr
#define WRITE_GLOBAL_TRUNK_CTLr BCM53262_A0_WRITE_GLOBAL_TRUNK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GLOBAL_TRUNK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GMNGCFG
 * BLOCKS:   SYS
 * DESC:     Global Management Configuration Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     RXBPDU_EN        Receive BPDU Enable.Enables all ports to receive BPDUs and forward to the defined Physical Management Port. Management CPU must set this bit to globally allow BPDUs to be received.
 *     RESERVED_1R      Reserved.
 *     IGMP_MLD_CHK     0x00 : Do not check IGMP/MLD packets. (default)0x01 : IGMP/MLD checking is enabled. IGMP/MLD packet will be forwarded to IMP port only.0x11 : IGMP/MLD checking is enabled. IGMP/MLD packet will be forwarded its original port map and send one copy to IMP port.
 *     RESERVED_2R      Reserved.
 *     FRM_MNGP         Frame Management Port.Defines the physical port used to report management frames directed to the switch.00=No Management Port01=Reserved10=MII Port (In-band Management Port - IMP)11=ReservedThese bits are ignored when SW_FWD_MODE=Unmanaged in the Switch Mode Register, and the device will behave as if there is no defined management port.
 */
#define BCM53262_A0_GMNGCFGr 0x00000300

#define BCM53262_A0_GMNGCFGr_SIZE 1

/*
 * This structure should be used to declare and program GMNGCFG.
 */
typedef union BCM53262_A0_GMNGCFGr_s {
	uint32_t v[1];
	uint32_t gmngcfg[1];
	uint32_t _gmngcfg;
} BCM53262_A0_GMNGCFGr_t;

#define BCM53262_A0_GMNGCFGr_CLR(r) (r).gmngcfg[0] = 0
#define BCM53262_A0_GMNGCFGr_SET(r,d) (r).gmngcfg[0] = d
#define BCM53262_A0_GMNGCFGr_GET(r) (r).gmngcfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GMNGCFGr_RESERVED_0Rf_GET(r) (((r).gmngcfg[0]) & 0x1)
#define BCM53262_A0_GMNGCFGr_RESERVED_0Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_GMNGCFGr_RXBPDU_ENf_GET(r) ((((r).gmngcfg[0]) >> 1) & 0x1)
#define BCM53262_A0_GMNGCFGr_RXBPDU_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_GMNGCFGr_RESERVED_1Rf_GET(r) ((((r).gmngcfg[0]) >> 2) & 0x1)
#define BCM53262_A0_GMNGCFGr_RESERVED_1Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_GMNGCFGr_IGMP_MLD_CHKf_GET(r) ((((r).gmngcfg[0]) >> 3) & 0x3)
#define BCM53262_A0_GMNGCFGr_IGMP_MLD_CHKf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53262_A0_GMNGCFGr_RESERVED_2Rf_GET(r) ((((r).gmngcfg[0]) >> 5) & 0x1)
#define BCM53262_A0_GMNGCFGr_RESERVED_2Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_GMNGCFGr_FRM_MNGPf_GET(r) ((((r).gmngcfg[0]) >> 6) & 0x3)
#define BCM53262_A0_GMNGCFGr_FRM_MNGPf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access GMNGCFG.
 */
#define BCM53262_A0_READ_GMNGCFGr(u,r) cdk_robo_reg_read(u,BCM53262_A0_GMNGCFGr,(r._gmngcfg),1)
#define BCM53262_A0_WRITE_GMNGCFGr(u,r) cdk_robo_reg_write(u,BCM53262_A0_GMNGCFGr,&(r._gmngcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMNGCFGr BCM53262_A0_GMNGCFGr
#define GMNGCFGr_SIZE BCM53262_A0_GMNGCFGr_SIZE
typedef BCM53262_A0_GMNGCFGr_t GMNGCFGr_t;
#define GMNGCFGr_CLR BCM53262_A0_GMNGCFGr_CLR
#define GMNGCFGr_SET BCM53262_A0_GMNGCFGr_SET
#define GMNGCFGr_GET BCM53262_A0_GMNGCFGr_GET
#define GMNGCFGr_RESERVED_0Rf_GET BCM53262_A0_GMNGCFGr_RESERVED_0Rf_GET
#define GMNGCFGr_RESERVED_0Rf_SET BCM53262_A0_GMNGCFGr_RESERVED_0Rf_SET
#define GMNGCFGr_RXBPDU_ENf_GET BCM53262_A0_GMNGCFGr_RXBPDU_ENf_GET
#define GMNGCFGr_RXBPDU_ENf_SET BCM53262_A0_GMNGCFGr_RXBPDU_ENf_SET
#define GMNGCFGr_RESERVED_1Rf_GET BCM53262_A0_GMNGCFGr_RESERVED_1Rf_GET
#define GMNGCFGr_RESERVED_1Rf_SET BCM53262_A0_GMNGCFGr_RESERVED_1Rf_SET
#define GMNGCFGr_IGMP_MLD_CHKf_GET BCM53262_A0_GMNGCFGr_IGMP_MLD_CHKf_GET
#define GMNGCFGr_IGMP_MLD_CHKf_SET BCM53262_A0_GMNGCFGr_IGMP_MLD_CHKf_SET
#define GMNGCFGr_RESERVED_2Rf_GET BCM53262_A0_GMNGCFGr_RESERVED_2Rf_GET
#define GMNGCFGr_RESERVED_2Rf_SET BCM53262_A0_GMNGCFGr_RESERVED_2Rf_SET
#define GMNGCFGr_FRM_MNGPf_GET BCM53262_A0_GMNGCFGr_FRM_MNGPf_GET
#define GMNGCFGr_FRM_MNGPf_SET BCM53262_A0_GMNGCFGr_FRM_MNGPf_SET
#define READ_GMNGCFGr BCM53262_A0_READ_GMNGCFGr
#define WRITE_GMNGCFGr BCM53262_A0_WRITE_GMNGCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GMNGCFGr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GRPADDR1
 * BLOCKS:   SYS
 * DESC:     Multiport Address 1 Register
 * SIZE:     48
 * FIELDS:
 *     GRP_ADDR         Multiport Address 1Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 */
#define BCM53262_A0_GRPADDR1r 0x00000410

#define BCM53262_A0_GRPADDR1r_SIZE 6

/*
 * This structure should be used to declare and program GRPADDR1.
 */
typedef union BCM53262_A0_GRPADDR1r_s {
	uint32_t v[2];
	uint32_t grpaddr1[2];
	uint32_t _grpaddr1;
} BCM53262_A0_GRPADDR1r_t;

#define BCM53262_A0_GRPADDR1r_CLR(r) CDK_MEMSET(&((r)._grpaddr1), 0, sizeof(BCM53262_A0_GRPADDR1r_t))
#define BCM53262_A0_GRPADDR1r_SET(r,i,d) (r).grpaddr1[i] = d
#define BCM53262_A0_GRPADDR1r_GET(r,i) (r).grpaddr1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GRPADDR1r_GRP_ADDRf_GET(r,a) cdk_field_get((r).grpaddr1,0,47,a)
#define BCM53262_A0_GRPADDR1r_GRP_ADDRf_SET(r,a) cdk_field_set((r).grpaddr1,0,47,a)

/*
 * These macros can be used to access GRPADDR1.
 */
#define BCM53262_A0_READ_GRPADDR1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_GRPADDR1r,(r._grpaddr1),6)
#define BCM53262_A0_WRITE_GRPADDR1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_GRPADDR1r,&(r._grpaddr1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPADDR1r BCM53262_A0_GRPADDR1r
#define GRPADDR1r_SIZE BCM53262_A0_GRPADDR1r_SIZE
typedef BCM53262_A0_GRPADDR1r_t GRPADDR1r_t;
#define GRPADDR1r_CLR BCM53262_A0_GRPADDR1r_CLR
#define GRPADDR1r_SET BCM53262_A0_GRPADDR1r_SET
#define GRPADDR1r_GET BCM53262_A0_GRPADDR1r_GET
#define GRPADDR1r_GRP_ADDRf_GET BCM53262_A0_GRPADDR1r_GRP_ADDRf_GET
#define GRPADDR1r_GRP_ADDRf_SET BCM53262_A0_GRPADDR1r_GRP_ADDRf_SET
#define READ_GRPADDR1r BCM53262_A0_READ_GRPADDR1r
#define WRITE_GRPADDR1r BCM53262_A0_WRITE_GRPADDR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GRPADDR1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  GRPADDR2
 * BLOCKS:   SYS
 * DESC:     Multiport Address 2 Register
 * SIZE:     48
 * FIELDS:
 *     GRP_ADDR         Multiport Address 2Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 */
#define BCM53262_A0_GRPADDR2r 0x00000420

#define BCM53262_A0_GRPADDR2r_SIZE 6

/*
 * This structure should be used to declare and program GRPADDR2.
 */
typedef union BCM53262_A0_GRPADDR2r_s {
	uint32_t v[2];
	uint32_t grpaddr2[2];
	uint32_t _grpaddr2;
} BCM53262_A0_GRPADDR2r_t;

#define BCM53262_A0_GRPADDR2r_CLR(r) CDK_MEMSET(&((r)._grpaddr2), 0, sizeof(BCM53262_A0_GRPADDR2r_t))
#define BCM53262_A0_GRPADDR2r_SET(r,i,d) (r).grpaddr2[i] = d
#define BCM53262_A0_GRPADDR2r_GET(r,i) (r).grpaddr2[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_GRPADDR2r_GRP_ADDRf_GET(r,a) cdk_field_get((r).grpaddr2,0,47,a)
#define BCM53262_A0_GRPADDR2r_GRP_ADDRf_SET(r,a) cdk_field_set((r).grpaddr2,0,47,a)

/*
 * These macros can be used to access GRPADDR2.
 */
#define BCM53262_A0_READ_GRPADDR2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_GRPADDR2r,(r._grpaddr2),6)
#define BCM53262_A0_WRITE_GRPADDR2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_GRPADDR2r,&(r._grpaddr2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPADDR2r BCM53262_A0_GRPADDR2r
#define GRPADDR2r_SIZE BCM53262_A0_GRPADDR2r_SIZE
typedef BCM53262_A0_GRPADDR2r_t GRPADDR2r_t;
#define GRPADDR2r_CLR BCM53262_A0_GRPADDR2r_CLR
#define GRPADDR2r_SET BCM53262_A0_GRPADDR2r_SET
#define GRPADDR2r_GET BCM53262_A0_GRPADDR2r_GET
#define GRPADDR2r_GRP_ADDRf_GET BCM53262_A0_GRPADDR2r_GRP_ADDRf_GET
#define GRPADDR2r_GRP_ADDRf_SET BCM53262_A0_GRPADDR2r_GRP_ADDRf_SET
#define READ_GRPADDR2r BCM53262_A0_READ_GRPADDR2r
#define WRITE_GRPADDR2r BCM53262_A0_WRITE_GRPADDR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_GRPADDR2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_ANADV
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100X_FDX    1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2R      write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 */
#define BCM53262_A0_G_ANADVr 0x0000d808

#define BCM53262_A0_G_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV.
 */
typedef union BCM53262_A0_G_ANADVr_s {
	uint32_t v[1];
	uint32_t g_anadv[1];
	uint32_t _g_anadv;
} BCM53262_A0_G_ANADVr_t;

#define BCM53262_A0_G_ANADVr_CLR(r) (r).g_anadv[0] = 0
#define BCM53262_A0_G_ANADVr_SET(r,d) (r).g_anadv[0] = d
#define BCM53262_A0_G_ANADVr_GET(r) (r).g_anadv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_ANADVr_PROTOCOL_SELf_GET(r) (((r).g_anadv[0]) & 0x1f)
#define BCM53262_A0_G_ANADVr_PROTOCOL_SELf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_G_ANADVr_ADV_B10Tf_GET(r) ((((r).g_anadv[0]) >> 5) & 0x1)
#define BCM53262_A0_G_ANADVr_ADV_B10Tf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv[0]) >> 6) & 0x1)
#define BCM53262_A0_G_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_G_ANADVr_ADV_B100Xf_GET(r) ((((r).g_anadv[0]) >> 7) & 0x1)
#define BCM53262_A0_G_ANADVr_ADV_B100Xf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_G_ANADVr_ADV_B100X_FDXf_GET(r) ((((r).g_anadv[0]) >> 8) & 0x1)
#define BCM53262_A0_G_ANADVr_ADV_B100X_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_G_ANADVr_B100T4f_GET(r) ((((r).g_anadv[0]) >> 9) & 0x1)
#define BCM53262_A0_G_ANADVr_B100T4f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_G_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv[0]) >> 10) & 0x1)
#define BCM53262_A0_G_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_ANADVr_ASY_PAUSEf_GET(r) ((((r).g_anadv[0]) >> 11) & 0x1)
#define BCM53262_A0_G_ANADVr_ASY_PAUSEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_ANADVr_RESERVED_1Rf_GET(r) ((((r).g_anadv[0]) >> 12) & 0x1)
#define BCM53262_A0_G_ANADVr_RESERVED_1Rf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_ANADVr_REMOTE_FAULT_Rf_GET(r) ((((r).g_anadv[0]) >> 13) & 0x1)
#define BCM53262_A0_G_ANADVr_REMOTE_FAULT_Rf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_ANADVr_RESERVED_2Rf_GET(r) ((((r).g_anadv[0]) >> 14) & 0x1)
#define BCM53262_A0_G_ANADVr_RESERVED_2Rf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_ANADVr_NEXT_PAGEf_GET(r) ((((r).g_anadv[0]) >> 15) & 0x1)
#define BCM53262_A0_G_ANADVr_NEXT_PAGEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV.
 */
#define BCM53262_A0_READ_G_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_ANADVr,(r._g_anadv),2)
#define BCM53262_A0_WRITE_G_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_ANADVr,&(r._g_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADVr BCM53262_A0_G_ANADVr
#define G_ANADVr_SIZE BCM53262_A0_G_ANADVr_SIZE
typedef BCM53262_A0_G_ANADVr_t G_ANADVr_t;
#define G_ANADVr_CLR BCM53262_A0_G_ANADVr_CLR
#define G_ANADVr_SET BCM53262_A0_G_ANADVr_SET
#define G_ANADVr_GET BCM53262_A0_G_ANADVr_GET
#define G_ANADVr_PROTOCOL_SELf_GET BCM53262_A0_G_ANADVr_PROTOCOL_SELf_GET
#define G_ANADVr_PROTOCOL_SELf_SET BCM53262_A0_G_ANADVr_PROTOCOL_SELf_SET
#define G_ANADVr_ADV_B10Tf_GET BCM53262_A0_G_ANADVr_ADV_B10Tf_GET
#define G_ANADVr_ADV_B10Tf_SET BCM53262_A0_G_ANADVr_ADV_B10Tf_SET
#define G_ANADVr_ADV_B10T_FDXf_GET BCM53262_A0_G_ANADVr_ADV_B10T_FDXf_GET
#define G_ANADVr_ADV_B10T_FDXf_SET BCM53262_A0_G_ANADVr_ADV_B10T_FDXf_SET
#define G_ANADVr_ADV_B100Xf_GET BCM53262_A0_G_ANADVr_ADV_B100Xf_GET
#define G_ANADVr_ADV_B100Xf_SET BCM53262_A0_G_ANADVr_ADV_B100Xf_SET
#define G_ANADVr_ADV_B100X_FDXf_GET BCM53262_A0_G_ANADVr_ADV_B100X_FDXf_GET
#define G_ANADVr_ADV_B100X_FDXf_SET BCM53262_A0_G_ANADVr_ADV_B100X_FDXf_SET
#define G_ANADVr_B100T4f_GET BCM53262_A0_G_ANADVr_B100T4f_GET
#define G_ANADVr_B100T4f_SET BCM53262_A0_G_ANADVr_B100T4f_SET
#define G_ANADVr_ADV_PAUSE_CAPf_GET BCM53262_A0_G_ANADVr_ADV_PAUSE_CAPf_GET
#define G_ANADVr_ADV_PAUSE_CAPf_SET BCM53262_A0_G_ANADVr_ADV_PAUSE_CAPf_SET
#define G_ANADVr_ASY_PAUSEf_GET BCM53262_A0_G_ANADVr_ASY_PAUSEf_GET
#define G_ANADVr_ASY_PAUSEf_SET BCM53262_A0_G_ANADVr_ASY_PAUSEf_SET
#define G_ANADVr_RESERVED_1Rf_GET BCM53262_A0_G_ANADVr_RESERVED_1Rf_GET
#define G_ANADVr_RESERVED_1Rf_SET BCM53262_A0_G_ANADVr_RESERVED_1Rf_SET
#define G_ANADVr_REMOTE_FAULT_Rf_GET BCM53262_A0_G_ANADVr_REMOTE_FAULT_Rf_GET
#define G_ANADVr_REMOTE_FAULT_Rf_SET BCM53262_A0_G_ANADVr_REMOTE_FAULT_Rf_SET
#define G_ANADVr_RESERVED_2Rf_GET BCM53262_A0_G_ANADVr_RESERVED_2Rf_GET
#define G_ANADVr_RESERVED_2Rf_SET BCM53262_A0_G_ANADVr_RESERVED_2Rf_SET
#define G_ANADVr_NEXT_PAGEf_GET BCM53262_A0_G_ANADVr_NEXT_PAGEf_GET
#define G_ANADVr_NEXT_PAGEf_SET BCM53262_A0_G_ANADVr_NEXT_PAGEf_SET
#define READ_G_ANADVr BCM53262_A0_READ_G_ANADVr
#define WRITE_G_ANADVr BCM53262_A0_WRITE_G_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_ANADVr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_ANEXP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1R      ignore on read.
 */
#define BCM53262_A0_G_ANEXPr 0x0000d80c

#define BCM53262_A0_G_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP.
 */
typedef union BCM53262_A0_G_ANEXPr_s {
	uint32_t v[1];
	uint32_t g_anexp[1];
	uint32_t _g_anexp;
} BCM53262_A0_G_ANEXPr_t;

#define BCM53262_A0_G_ANEXPr_CLR(r) (r).g_anexp[0] = 0
#define BCM53262_A0_G_ANEXPr_SET(r,d) (r).g_anexp[0] = d
#define BCM53262_A0_G_ANEXPr_GET(r) (r).g_anexp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_ANEXPr_LP_AN_ABIf_GET(r) (((r).g_anexp[0]) & 0x1)
#define BCM53262_A0_G_ANEXPr_LP_AN_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_G_ANEXPr_PAGE_RECf_GET(r) ((((r).g_anexp[0]) >> 1) & 0x1)
#define BCM53262_A0_G_ANEXPr_PAGE_RECf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 2) & 0x1)
#define BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 3) & 0x1)
#define BCM53262_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_G_ANEXPr_PAR_DET_FAILf_GET(r) ((((r).g_anexp[0]) >> 4) & 0x1)
#define BCM53262_A0_G_ANEXPr_PAR_DET_FAILf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_G_ANEXPr_NEXT_PAGEf_GET(r) ((((r).g_anexp[0]) >> 5) & 0x1)
#define BCM53262_A0_G_ANEXPr_NEXT_PAGEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp[0]) >> 6) & 0x1)
#define BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_G_ANEXPr_RESERVED_1Rf_GET(r) ((((r).g_anexp[0]) >> 7) & 0x1ff)
#define BCM53262_A0_G_ANEXPr_RESERVED_1Rf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP.
 */
#define BCM53262_A0_READ_G_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_ANEXPr,(r._g_anexp),2)
#define BCM53262_A0_WRITE_G_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_ANEXPr,&(r._g_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXPr BCM53262_A0_G_ANEXPr
#define G_ANEXPr_SIZE BCM53262_A0_G_ANEXPr_SIZE
typedef BCM53262_A0_G_ANEXPr_t G_ANEXPr_t;
#define G_ANEXPr_CLR BCM53262_A0_G_ANEXPr_CLR
#define G_ANEXPr_SET BCM53262_A0_G_ANEXPr_SET
#define G_ANEXPr_GET BCM53262_A0_G_ANEXPr_GET
#define G_ANEXPr_LP_AN_ABIf_GET BCM53262_A0_G_ANEXPr_LP_AN_ABIf_GET
#define G_ANEXPr_LP_AN_ABIf_SET BCM53262_A0_G_ANEXPr_LP_AN_ABIf_SET
#define G_ANEXPr_PAGE_RECf_GET BCM53262_A0_G_ANEXPr_PAGE_RECf_GET
#define G_ANEXPr_PAGE_RECf_SET BCM53262_A0_G_ANEXPr_PAGE_RECf_SET
#define G_ANEXPr_NEXT_PAGE_ABIf_GET BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_NEXT_PAGE_ABIf_SET BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_GET BCM53262_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_SET BCM53262_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_PAR_DET_FAILf_GET BCM53262_A0_G_ANEXPr_PAR_DET_FAILf_GET
#define G_ANEXPr_PAR_DET_FAILf_SET BCM53262_A0_G_ANEXPr_PAR_DET_FAILf_SET
#define G_ANEXPr_NEXT_PAGEf_GET BCM53262_A0_G_ANEXPr_NEXT_PAGEf_GET
#define G_ANEXPr_NEXT_PAGEf_SET BCM53262_A0_G_ANEXPr_NEXT_PAGEf_SET
#define G_ANEXPr_NEXT_PAGE_ABLEf_GET BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET
#define G_ANEXPr_NEXT_PAGE_ABLEf_SET BCM53262_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET
#define G_ANEXPr_RESERVED_1Rf_GET BCM53262_A0_G_ANEXPr_RESERVED_1Rf_GET
#define G_ANEXPr_RESERVED_1Rf_SET BCM53262_A0_G_ANEXPr_RESERVED_1Rf_SET
#define READ_G_ANEXPr BCM53262_A0_READ_G_ANEXPr
#define WRITE_G_ANEXPr BCM53262_A0_WRITE_G_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_ANEXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_ANLPA
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partneríªs protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partneríªs asymmetric pause bit.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 */
#define BCM53262_A0_G_ANLPAr 0x0000d80a

#define BCM53262_A0_G_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA.
 */
typedef union BCM53262_A0_G_ANLPAr_s {
	uint32_t v[1];
	uint32_t g_anlpa[1];
	uint32_t _g_anlpa;
} BCM53262_A0_G_ANLPAr_t;

#define BCM53262_A0_G_ANLPAr_CLR(r) (r).g_anlpa[0] = 0
#define BCM53262_A0_G_ANLPAr_SET(r,d) (r).g_anlpa[0] = d
#define BCM53262_A0_G_ANLPAr_GET(r) (r).g_anlpa[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_ANLPAr_PROTOCOL_SELf_GET(r) (((r).g_anlpa[0]) & 0x1f)
#define BCM53262_A0_G_ANLPAr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_G_ANLPAr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 5) & 0x1)
#define BCM53262_A0_G_ANLPAr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_ANLPAr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 7) & 0x1)
#define BCM53262_A0_G_ANLPAr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_G_ANLPAr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 8) & 0x1)
#define BCM53262_A0_G_ANLPAr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_G_ANLPAr_B100T4_CAPf_GET(r) ((((r).g_anlpa[0]) >> 9) & 0x1)
#define BCM53262_A0_G_ANLPAr_B100T4_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_G_ANLPAr_PAUSE_CAPf_GET(r) ((((r).g_anlpa[0]) >> 10) & 0x1)
#define BCM53262_A0_G_ANLPAr_PAUSE_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa[0]) >> 11) & 0x1)
#define BCM53262_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_ANLPAr_RESERVED_1Rf_GET(r) ((((r).g_anlpa[0]) >> 12) & 0x1)
#define BCM53262_A0_G_ANLPAr_RESERVED_1Rf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_ANLPAr_REMOTE_FAULT_Rf_GET(r) ((((r).g_anlpa[0]) >> 13) & 0x1)
#define BCM53262_A0_G_ANLPAr_REMOTE_FAULT_Rf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_ANLPAr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa[0]) >> 14) & 0x1)
#define BCM53262_A0_G_ANLPAr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_ANLPAr_NEXT_PAGEf_GET(r) ((((r).g_anlpa[0]) >> 15) & 0x1)
#define BCM53262_A0_G_ANLPAr_NEXT_PAGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA.
 */
#define BCM53262_A0_READ_G_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_ANLPAr,(r._g_anlpa),2)
#define BCM53262_A0_WRITE_G_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_ANLPAr,&(r._g_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPAr BCM53262_A0_G_ANLPAr
#define G_ANLPAr_SIZE BCM53262_A0_G_ANLPAr_SIZE
typedef BCM53262_A0_G_ANLPAr_t G_ANLPAr_t;
#define G_ANLPAr_CLR BCM53262_A0_G_ANLPAr_CLR
#define G_ANLPAr_SET BCM53262_A0_G_ANLPAr_SET
#define G_ANLPAr_GET BCM53262_A0_G_ANLPAr_GET
#define G_ANLPAr_PROTOCOL_SELf_GET BCM53262_A0_G_ANLPAr_PROTOCOL_SELf_GET
#define G_ANLPAr_PROTOCOL_SELf_SET BCM53262_A0_G_ANLPAr_PROTOCOL_SELf_SET
#define G_ANLPAr_B10T_FD_CAPf_GET BCM53262_A0_G_ANLPAr_B10T_FD_CAPf_GET
#define G_ANLPAr_B10T_FD_CAPf_SET BCM53262_A0_G_ANLPAr_B10T_FD_CAPf_SET
#define G_ANLPAr_B100_TXHD_CAPf_GET BCM53262_A0_G_ANLPAr_B100_TXHD_CAPf_GET
#define G_ANLPAr_B100_TXHD_CAPf_SET BCM53262_A0_G_ANLPAr_B100_TXHD_CAPf_SET
#define G_ANLPAr_B100_TXFD_CAPf_GET BCM53262_A0_G_ANLPAr_B100_TXFD_CAPf_GET
#define G_ANLPAr_B100_TXFD_CAPf_SET BCM53262_A0_G_ANLPAr_B100_TXFD_CAPf_SET
#define G_ANLPAr_B100T4_CAPf_GET BCM53262_A0_G_ANLPAr_B100T4_CAPf_GET
#define G_ANLPAr_B100T4_CAPf_SET BCM53262_A0_G_ANLPAr_B100T4_CAPf_SET
#define G_ANLPAr_PAUSE_CAPf_GET BCM53262_A0_G_ANLPAr_PAUSE_CAPf_GET
#define G_ANLPAr_PAUSE_CAPf_SET BCM53262_A0_G_ANLPAr_PAUSE_CAPf_SET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_GET BCM53262_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_SET BCM53262_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPAr_RESERVED_1Rf_GET BCM53262_A0_G_ANLPAr_RESERVED_1Rf_GET
#define G_ANLPAr_RESERVED_1Rf_SET BCM53262_A0_G_ANLPAr_RESERVED_1Rf_SET
#define G_ANLPAr_REMOTE_FAULT_Rf_GET BCM53262_A0_G_ANLPAr_REMOTE_FAULT_Rf_GET
#define G_ANLPAr_REMOTE_FAULT_Rf_SET BCM53262_A0_G_ANLPAr_REMOTE_FAULT_Rf_SET
#define G_ANLPAr_ACKNOWLEDGEf_GET BCM53262_A0_G_ANLPAr_ACKNOWLEDGEf_GET
#define G_ANLPAr_ACKNOWLEDGEf_SET BCM53262_A0_G_ANLPAr_ACKNOWLEDGEf_SET
#define G_ANLPAr_NEXT_PAGEf_GET BCM53262_A0_G_ANLPAr_NEXT_PAGEf_GET
#define G_ANLPAr_NEXT_PAGEf_SET BCM53262_A0_G_ANLPAr_NEXT_PAGEf_SET
#define READ_G_ANLPAr BCM53262_A0_READ_G_ANLPAr
#define WRITE_G_ANLPAr BCM53262_A0_WRITE_G_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_ANLPAr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_ANNXP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1R      ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 */
#define BCM53262_A0_G_ANNXPr 0x0000d80e

#define BCM53262_A0_G_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP.
 */
typedef union BCM53262_A0_G_ANNXPr_s {
	uint32_t v[1];
	uint32_t g_annxp[1];
	uint32_t _g_annxp;
} BCM53262_A0_G_ANNXPr_t;

#define BCM53262_A0_G_ANNXPr_CLR(r) (r).g_annxp[0] = 0
#define BCM53262_A0_G_ANNXPr_SET(r,d) (r).g_annxp[0] = d
#define BCM53262_A0_G_ANNXPr_GET(r) (r).g_annxp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_ANNXPr_CODE_FIELDf_GET(r) ((((r).g_annxp[0]) >> 5) & 0x1)
#define BCM53262_A0_G_ANNXPr_CODE_FIELDf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_ANNXPr_TOGGLEf_GET(r) ((((r).g_annxp[0]) >> 11) & 0x1)
#define BCM53262_A0_G_ANNXPr_TOGGLEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp[0]) >> 12) & 0x1)
#define BCM53262_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_ANNXPr_MES_PAGEf_GET(r) ((((r).g_annxp[0]) >> 13) & 0x1)
#define BCM53262_A0_G_ANNXPr_MES_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_ANNXPr_RESERVED_1Rf_GET(r) ((((r).g_annxp[0]) >> 14) & 0x1)
#define BCM53262_A0_G_ANNXPr_RESERVED_1Rf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_ANNXPr_NEXT_PAGEf_GET(r) ((((r).g_annxp[0]) >> 15) & 0x1)
#define BCM53262_A0_G_ANNXPr_NEXT_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP.
 */
#define BCM53262_A0_READ_G_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_ANNXPr,(r._g_annxp),2)
#define BCM53262_A0_WRITE_G_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_ANNXPr,&(r._g_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXPr BCM53262_A0_G_ANNXPr
#define G_ANNXPr_SIZE BCM53262_A0_G_ANNXPr_SIZE
typedef BCM53262_A0_G_ANNXPr_t G_ANNXPr_t;
#define G_ANNXPr_CLR BCM53262_A0_G_ANNXPr_CLR
#define G_ANNXPr_SET BCM53262_A0_G_ANNXPr_SET
#define G_ANNXPr_GET BCM53262_A0_G_ANNXPr_GET
#define G_ANNXPr_CODE_FIELDf_GET BCM53262_A0_G_ANNXPr_CODE_FIELDf_GET
#define G_ANNXPr_CODE_FIELDf_SET BCM53262_A0_G_ANNXPr_CODE_FIELDf_SET
#define G_ANNXPr_TOGGLEf_GET BCM53262_A0_G_ANNXPr_TOGGLEf_GET
#define G_ANNXPr_TOGGLEf_SET BCM53262_A0_G_ANNXPr_TOGGLEf_SET
#define G_ANNXPr_ACKNOWLEDGE_2f_GET BCM53262_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET
#define G_ANNXPr_ACKNOWLEDGE_2f_SET BCM53262_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET
#define G_ANNXPr_MES_PAGEf_GET BCM53262_A0_G_ANNXPr_MES_PAGEf_GET
#define G_ANNXPr_MES_PAGEf_SET BCM53262_A0_G_ANNXPr_MES_PAGEf_SET
#define G_ANNXPr_RESERVED_1Rf_GET BCM53262_A0_G_ANNXPr_RESERVED_1Rf_GET
#define G_ANNXPr_RESERVED_1Rf_SET BCM53262_A0_G_ANNXPr_RESERVED_1Rf_SET
#define G_ANNXPr_NEXT_PAGEf_GET BCM53262_A0_G_ANNXPr_NEXT_PAGEf_GET
#define G_ANNXPr_NEXT_PAGEf_SET BCM53262_A0_G_ANNXPr_NEXT_PAGEf_SET
#define READ_G_ANNXPr BCM53262_A0_READ_G_ANNXPr
#define WRITE_G_ANNXPr BCM53262_A0_WRITE_G_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_ANNXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_B1000T_CTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     PHY_TEST_MODE    1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 */
#define BCM53262_A0_G_B1000T_CTLr 0x0000d812

#define BCM53262_A0_G_B1000T_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL.
 */
typedef union BCM53262_A0_G_B1000T_CTLr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl[1];
	uint32_t _g_b1000t_ctl;
} BCM53262_A0_G_B1000T_CTLr_t;

#define BCM53262_A0_G_B1000T_CTLr_CLR(r) (r).g_b1000t_ctl[0] = 0
#define BCM53262_A0_G_B1000T_CTLr_SET(r,d) (r).g_b1000t_ctl[0] = d
#define BCM53262_A0_G_B1000T_CTLr_GET(r) (r).g_b1000t_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_B1000T_CTLr_RESERVED_Rf_GET(r) (((r).g_b1000t_ctl[0]) & 0xff)
#define BCM53262_A0_G_B1000T_CTLr_RESERVED_Rf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 8) & 0x1)
#define BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 9) & 0x1)
#define BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_G_B1000T_CTLr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 10) & 0x1)
#define BCM53262_A0_G_B1000T_CTLr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 11) & 0x1)
#define BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl[0]) >> 12) & 0x1)
#define BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_B1000T_CTLr_PHY_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 13) & 0x7)
#define BCM53262_A0_G_B1000T_CTLr_PHY_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL.
 */
#define BCM53262_A0_READ_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_B1000T_CTLr,(r._g_b1000t_ctl),2)
#define BCM53262_A0_WRITE_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_B1000T_CTLr,&(r._g_b1000t_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTLr BCM53262_A0_G_B1000T_CTLr
#define G_B1000T_CTLr_SIZE BCM53262_A0_G_B1000T_CTLr_SIZE
typedef BCM53262_A0_G_B1000T_CTLr_t G_B1000T_CTLr_t;
#define G_B1000T_CTLr_CLR BCM53262_A0_G_B1000T_CTLr_CLR
#define G_B1000T_CTLr_SET BCM53262_A0_G_B1000T_CTLr_SET
#define G_B1000T_CTLr_GET BCM53262_A0_G_B1000T_CTLr_GET
#define G_B1000T_CTLr_RESERVED_Rf_GET BCM53262_A0_G_B1000T_CTLr_RESERVED_Rf_GET
#define G_B1000T_CTLr_RESERVED_Rf_SET BCM53262_A0_G_B1000T_CTLr_RESERVED_Rf_SET
#define G_B1000T_CTLr_ADV_B1000T_HDf_GET BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET
#define G_B1000T_CTLr_ADV_B1000T_HDf_SET BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET
#define G_B1000T_CTLr_ADV_B1000T_FDf_GET BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET
#define G_B1000T_CTLr_ADV_B1000T_FDf_SET BCM53262_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET
#define G_B1000T_CTLr_REPEATER_DTEf_GET BCM53262_A0_G_B1000T_CTLr_REPEATER_DTEf_GET
#define G_B1000T_CTLr_REPEATER_DTEf_SET BCM53262_A0_G_B1000T_CTLr_REPEATER_DTEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET BCM53262_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTLr_PHY_TEST_MODEf_GET BCM53262_A0_G_B1000T_CTLr_PHY_TEST_MODEf_GET
#define G_B1000T_CTLr_PHY_TEST_MODEf_SET BCM53262_A0_G_B1000T_CTLr_PHY_TEST_MODEf_SET
#define READ_G_B1000T_CTLr BCM53262_A0_READ_G_B1000T_CTLr
#define WRITE_G_B1000T_CTLr BCM53262_A0_WRITE_G_B1000T_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_B1000T_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_B1000T_STS
 * BLOCKS:   CPIC GPIC0
 * DESC:     1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED_R       ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 */
#define BCM53262_A0_G_B1000T_STSr 0x0000d814

#define BCM53262_A0_G_B1000T_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS.
 */
typedef union BCM53262_A0_G_B1000T_STSr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts[1];
	uint32_t _g_b1000t_sts;
} BCM53262_A0_G_B1000T_STSr_t;

#define BCM53262_A0_G_B1000T_STSr_CLR(r) (r).g_b1000t_sts[0] = 0
#define BCM53262_A0_G_B1000T_STSr_SET(r,d) (r).g_b1000t_sts[0] = d
#define BCM53262_A0_G_B1000T_STSr_GET(r) (r).g_b1000t_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts[0]) & 0xff)
#define BCM53262_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_G_B1000T_STSr_RESERVED_Rf_GET(r) ((((r).g_b1000t_sts[0]) >> 8) & 0x3)
#define BCM53262_A0_G_B1000T_STSr_RESERVED_Rf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 10) & 0x1)
#define BCM53262_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 11) & 0x1)
#define BCM53262_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 12) & 0x1)
#define BCM53262_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 13) & 0x1)
#define BCM53262_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 14) & 0x1)
#define BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts[0]) >> 15) & 0x1)
#define BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS.
 */
#define BCM53262_A0_READ_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_B1000T_STSr,(r._g_b1000t_sts),2)
#define BCM53262_A0_WRITE_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_B1000T_STSr,&(r._g_b1000t_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STSr BCM53262_A0_G_B1000T_STSr
#define G_B1000T_STSr_SIZE BCM53262_A0_G_B1000T_STSr_SIZE
typedef BCM53262_A0_G_B1000T_STSr_t G_B1000T_STSr_t;
#define G_B1000T_STSr_CLR BCM53262_A0_G_B1000T_STSr_CLR
#define G_B1000T_STSr_SET BCM53262_A0_G_B1000T_STSr_SET
#define G_B1000T_STSr_GET BCM53262_A0_G_B1000T_STSr_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_GET BCM53262_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_SET BCM53262_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET
#define G_B1000T_STSr_RESERVED_Rf_GET BCM53262_A0_G_B1000T_STSr_RESERVED_Rf_GET
#define G_B1000T_STSr_RESERVED_Rf_SET BCM53262_A0_G_B1000T_STSr_RESERVED_Rf_SET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_GET BCM53262_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_SET BCM53262_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_GET BCM53262_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_SET BCM53262_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STSr_REMOTE_REC_STSf_GET BCM53262_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET
#define G_B1000T_STSr_REMOTE_REC_STSf_SET BCM53262_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET
#define G_B1000T_STSr_LOCAL_REC_STSf_GET BCM53262_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET
#define G_B1000T_STSr_LOCAL_REC_STSf_SET BCM53262_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_GET BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_SET BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET BCM53262_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STSr BCM53262_A0_READ_G_B1000T_STSr
#define WRITE_G_B1000T_STSr BCM53262_A0_WRITE_G_B1000T_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_B1000T_STSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_EXT_STS
 * BLOCKS:   CPIC GPIC0
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 */
#define BCM53262_A0_G_EXT_STSr 0x0000d81e

#define BCM53262_A0_G_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS.
 */
typedef union BCM53262_A0_G_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_ext_sts[1];
	uint32_t _g_ext_sts;
} BCM53262_A0_G_EXT_STSr_t;

#define BCM53262_A0_G_EXT_STSr_CLR(r) (r).g_ext_sts[0] = 0
#define BCM53262_A0_G_EXT_STSr_SET(r,d) (r).g_ext_sts[0] = d
#define BCM53262_A0_G_EXT_STSr_GET(r) (r).g_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_EXT_STSr_RESERVED_Rf_GET(r) (((r).g_ext_sts[0]) & 0xfff)
#define BCM53262_A0_G_EXT_STSr_RESERVED_Rf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_G_EXT_STSr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 12) & 0x1)
#define BCM53262_A0_G_EXT_STSr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_EXT_STSr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 13) & 0x1)
#define BCM53262_A0_G_EXT_STSr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_EXT_STSr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 14) & 0x1)
#define BCM53262_A0_G_EXT_STSr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_EXT_STSr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 15) & 0x1)
#define BCM53262_A0_G_EXT_STSr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS.
 */
#define BCM53262_A0_READ_G_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_EXT_STSr,(r._g_ext_sts),2)
#define BCM53262_A0_WRITE_G_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_EXT_STSr,&(r._g_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STSr BCM53262_A0_G_EXT_STSr
#define G_EXT_STSr_SIZE BCM53262_A0_G_EXT_STSr_SIZE
typedef BCM53262_A0_G_EXT_STSr_t G_EXT_STSr_t;
#define G_EXT_STSr_CLR BCM53262_A0_G_EXT_STSr_CLR
#define G_EXT_STSr_SET BCM53262_A0_G_EXT_STSr_SET
#define G_EXT_STSr_GET BCM53262_A0_G_EXT_STSr_GET
#define G_EXT_STSr_RESERVED_Rf_GET BCM53262_A0_G_EXT_STSr_RESERVED_Rf_GET
#define G_EXT_STSr_RESERVED_Rf_SET BCM53262_A0_G_EXT_STSr_RESERVED_Rf_SET
#define G_EXT_STSr_B1000T_HD_CAPf_GET BCM53262_A0_G_EXT_STSr_B1000T_HD_CAPf_GET
#define G_EXT_STSr_B1000T_HD_CAPf_SET BCM53262_A0_G_EXT_STSr_B1000T_HD_CAPf_SET
#define G_EXT_STSr_B1000T_FD_CAPf_GET BCM53262_A0_G_EXT_STSr_B1000T_FD_CAPf_GET
#define G_EXT_STSr_B1000T_FD_CAPf_SET BCM53262_A0_G_EXT_STSr_B1000T_FD_CAPf_SET
#define G_EXT_STSr_B1000X_HD_CAPf_GET BCM53262_A0_G_EXT_STSr_B1000X_HD_CAPf_GET
#define G_EXT_STSr_B1000X_HD_CAPf_SET BCM53262_A0_G_EXT_STSr_B1000X_HD_CAPf_SET
#define G_EXT_STSr_B1000X_FD_CAPf_GET BCM53262_A0_G_EXT_STSr_B1000X_FD_CAPf_GET
#define G_EXT_STSr_B1000X_FD_CAPf_SET BCM53262_A0_G_EXT_STSr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STSr BCM53262_A0_READ_G_EXT_STSr
#define WRITE_G_EXT_STSr BCM53262_A0_WRITE_G_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_EXT_STSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_FALSE_CARR_CNT
 * BLOCKS:   CPIC GPIC0
 * DESC:     False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     FALSE_CARR_CNT   
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_G_FALSE_CARR_CNTr 0x0000d836

#define BCM53262_A0_G_FALSE_CARR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT.
 */
typedef union BCM53262_A0_G_FALSE_CARR_CNTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt[1];
	uint32_t _g_false_carr_cnt;
} BCM53262_A0_G_FALSE_CARR_CNTr_t;

#define BCM53262_A0_G_FALSE_CARR_CNTr_CLR(r) (r).g_false_carr_cnt[0] = 0
#define BCM53262_A0_G_FALSE_CARR_CNTr_SET(r,d) (r).g_false_carr_cnt[0] = d
#define BCM53262_A0_G_FALSE_CARR_CNTr_GET(r) (r).g_false_carr_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_FALSE_CARR_CNTr_FALSE_CARR_CNTf_GET(r) (((r).g_false_carr_cnt[0]) & 0xff)
#define BCM53262_A0_G_FALSE_CARR_CNTr_FALSE_CARR_CNTf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_G_FALSE_CARR_CNTr_RESERVED_Rf_GET(r) ((((r).g_false_carr_cnt[0]) >> 8) & 0xff)
#define BCM53262_A0_G_FALSE_CARR_CNTr_RESERVED_Rf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT.
 */
#define BCM53262_A0_READ_G_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_FALSE_CARR_CNTr,(r._g_false_carr_cnt),2)
#define BCM53262_A0_WRITE_G_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_FALSE_CARR_CNTr,&(r._g_false_carr_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNTr BCM53262_A0_G_FALSE_CARR_CNTr
#define G_FALSE_CARR_CNTr_SIZE BCM53262_A0_G_FALSE_CARR_CNTr_SIZE
typedef BCM53262_A0_G_FALSE_CARR_CNTr_t G_FALSE_CARR_CNTr_t;
#define G_FALSE_CARR_CNTr_CLR BCM53262_A0_G_FALSE_CARR_CNTr_CLR
#define G_FALSE_CARR_CNTr_SET BCM53262_A0_G_FALSE_CARR_CNTr_SET
#define G_FALSE_CARR_CNTr_GET BCM53262_A0_G_FALSE_CARR_CNTr_GET
#define G_FALSE_CARR_CNTr_FALSE_CARR_CNTf_GET BCM53262_A0_G_FALSE_CARR_CNTr_FALSE_CARR_CNTf_GET
#define G_FALSE_CARR_CNTr_FALSE_CARR_CNTf_SET BCM53262_A0_G_FALSE_CARR_CNTr_FALSE_CARR_CNTf_SET
#define G_FALSE_CARR_CNTr_RESERVED_Rf_GET BCM53262_A0_G_FALSE_CARR_CNTr_RESERVED_Rf_GET
#define G_FALSE_CARR_CNTr_RESERVED_Rf_SET BCM53262_A0_G_FALSE_CARR_CNTr_RESERVED_Rf_SET
#define READ_G_FALSE_CARR_CNTr BCM53262_A0_READ_G_FALSE_CARR_CNTr
#define WRITE_G_FALSE_CARR_CNTr BCM53262_A0_WRITE_G_FALSE_CARR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_FALSE_CARR_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_LPNXP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 */
#define BCM53262_A0_G_LPNXPr 0x0000d810

#define BCM53262_A0_G_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP.
 */
typedef union BCM53262_A0_G_LPNXPr_s {
	uint32_t v[1];
	uint32_t g_lpnxp[1];
	uint32_t _g_lpnxp;
} BCM53262_A0_G_LPNXPr_t;

#define BCM53262_A0_G_LPNXPr_CLR(r) (r).g_lpnxp[0] = 0
#define BCM53262_A0_G_LPNXPr_SET(r,d) (r).g_lpnxp[0] = d
#define BCM53262_A0_G_LPNXPr_GET(r) (r).g_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_LPNXPr_CODE_FIELDf_GET(r) ((((r).g_lpnxp[0]) >> 5) & 0x1)
#define BCM53262_A0_G_LPNXPr_CODE_FIELDf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_LPNXPr_TOGGLEf_GET(r) ((((r).g_lpnxp[0]) >> 11) & 0x1)
#define BCM53262_A0_G_LPNXPr_TOGGLEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp[0]) >> 12) & 0x1)
#define BCM53262_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_LPNXPr_MES_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 13) & 0x1)
#define BCM53262_A0_G_LPNXPr_MES_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_LPNXPr_ACKf_GET(r) ((((r).g_lpnxp[0]) >> 14) & 0x1)
#define BCM53262_A0_G_LPNXPr_ACKf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_LPNXPr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 15) & 0x1)
#define BCM53262_A0_G_LPNXPr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP.
 */
#define BCM53262_A0_READ_G_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_LPNXPr,(r._g_lpnxp),2)
#define BCM53262_A0_WRITE_G_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_LPNXPr,&(r._g_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXPr BCM53262_A0_G_LPNXPr
#define G_LPNXPr_SIZE BCM53262_A0_G_LPNXPr_SIZE
typedef BCM53262_A0_G_LPNXPr_t G_LPNXPr_t;
#define G_LPNXPr_CLR BCM53262_A0_G_LPNXPr_CLR
#define G_LPNXPr_SET BCM53262_A0_G_LPNXPr_SET
#define G_LPNXPr_GET BCM53262_A0_G_LPNXPr_GET
#define G_LPNXPr_CODE_FIELDf_GET BCM53262_A0_G_LPNXPr_CODE_FIELDf_GET
#define G_LPNXPr_CODE_FIELDf_SET BCM53262_A0_G_LPNXPr_CODE_FIELDf_SET
#define G_LPNXPr_TOGGLEf_GET BCM53262_A0_G_LPNXPr_TOGGLEf_GET
#define G_LPNXPr_TOGGLEf_SET BCM53262_A0_G_LPNXPr_TOGGLEf_SET
#define G_LPNXPr_ACKNOWLEDGE_2f_GET BCM53262_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET
#define G_LPNXPr_ACKNOWLEDGE_2f_SET BCM53262_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET
#define G_LPNXPr_MES_PAGEf_GET BCM53262_A0_G_LPNXPr_MES_PAGEf_GET
#define G_LPNXPr_MES_PAGEf_SET BCM53262_A0_G_LPNXPr_MES_PAGEf_SET
#define G_LPNXPr_ACKf_GET BCM53262_A0_G_LPNXPr_ACKf_GET
#define G_LPNXPr_ACKf_SET BCM53262_A0_G_LPNXPr_ACKf_SET
#define G_LPNXPr_NEXT_PAGEf_GET BCM53262_A0_G_LPNXPr_NEXT_PAGEf_GET
#define G_LPNXPr_NEXT_PAGEf_SET BCM53262_A0_G_LPNXPr_NEXT_PAGEf_SET
#define READ_G_LPNXPr BCM53262_A0_READ_G_LPNXPr
#define WRITE_G_LPNXPr BCM53262_A0_WRITE_G_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_LPNXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_MIICTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET_R          1: PHY reset.0: Normal operation.
 */
#define BCM53262_A0_G_MIICTLr 0x0000d800

#define BCM53262_A0_G_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL.
 */
typedef union BCM53262_A0_G_MIICTLr_s {
	uint32_t v[1];
	uint32_t g_miictl[1];
	uint32_t _g_miictl;
} BCM53262_A0_G_MIICTLr_t;

#define BCM53262_A0_G_MIICTLr_CLR(r) (r).g_miictl[0] = 0
#define BCM53262_A0_G_MIICTLr_SET(r,d) (r).g_miictl[0] = d
#define BCM53262_A0_G_MIICTLr_GET(r) (r).g_miictl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_MIICTLr_RESERVED_Rf_GET(r) (((r).g_miictl[0]) & 0x3f)
#define BCM53262_A0_G_MIICTLr_RESERVED_Rf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_G_MIICTLr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl[0]) >> 6) & 0x1)
#define BCM53262_A0_G_MIICTLr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_G_MIICTLr_COL_TESTf_GET(r) ((((r).g_miictl[0]) >> 7) & 0x1)
#define BCM53262_A0_G_MIICTLr_COL_TESTf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_G_MIICTLr_DUPLEX_MODf_GET(r) ((((r).g_miictl[0]) >> 8) & 0x1)
#define BCM53262_A0_G_MIICTLr_DUPLEX_MODf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_G_MIICTLr_RE_ANf_GET(r) ((((r).g_miictl[0]) >> 9) & 0x1)
#define BCM53262_A0_G_MIICTLr_RE_ANf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_G_MIICTLr_ISOLATEf_GET(r) ((((r).g_miictl[0]) >> 10) & 0x1)
#define BCM53262_A0_G_MIICTLr_ISOLATEf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_MIICTLr_PWR_DOWNf_GET(r) ((((r).g_miictl[0]) >> 11) & 0x1)
#define BCM53262_A0_G_MIICTLr_PWR_DOWNf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_MIICTLr_AN_ENf_GET(r) ((((r).g_miictl[0]) >> 12) & 0x1)
#define BCM53262_A0_G_MIICTLr_AN_ENf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_MIICTLr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl[0]) >> 13) & 0x1)
#define BCM53262_A0_G_MIICTLr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_MIICTLr_LOOPBACKf_GET(r) ((((r).g_miictl[0]) >> 14) & 0x1)
#define BCM53262_A0_G_MIICTLr_LOOPBACKf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_MIICTLr_RESET_Rf_GET(r) ((((r).g_miictl[0]) >> 15) & 0x1)
#define BCM53262_A0_G_MIICTLr_RESET_Rf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL.
 */
#define BCM53262_A0_READ_G_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_MIICTLr,(r._g_miictl),2)
#define BCM53262_A0_WRITE_G_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_MIICTLr,&(r._g_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTLr BCM53262_A0_G_MIICTLr
#define G_MIICTLr_SIZE BCM53262_A0_G_MIICTLr_SIZE
typedef BCM53262_A0_G_MIICTLr_t G_MIICTLr_t;
#define G_MIICTLr_CLR BCM53262_A0_G_MIICTLr_CLR
#define G_MIICTLr_SET BCM53262_A0_G_MIICTLr_SET
#define G_MIICTLr_GET BCM53262_A0_G_MIICTLr_GET
#define G_MIICTLr_RESERVED_Rf_GET BCM53262_A0_G_MIICTLr_RESERVED_Rf_GET
#define G_MIICTLr_RESERVED_Rf_SET BCM53262_A0_G_MIICTLr_RESERVED_Rf_SET
#define G_MIICTLr_SPD_SEL_MSBf_GET BCM53262_A0_G_MIICTLr_SPD_SEL_MSBf_GET
#define G_MIICTLr_SPD_SEL_MSBf_SET BCM53262_A0_G_MIICTLr_SPD_SEL_MSBf_SET
#define G_MIICTLr_COL_TESTf_GET BCM53262_A0_G_MIICTLr_COL_TESTf_GET
#define G_MIICTLr_COL_TESTf_SET BCM53262_A0_G_MIICTLr_COL_TESTf_SET
#define G_MIICTLr_DUPLEX_MODf_GET BCM53262_A0_G_MIICTLr_DUPLEX_MODf_GET
#define G_MIICTLr_DUPLEX_MODf_SET BCM53262_A0_G_MIICTLr_DUPLEX_MODf_SET
#define G_MIICTLr_RE_ANf_GET BCM53262_A0_G_MIICTLr_RE_ANf_GET
#define G_MIICTLr_RE_ANf_SET BCM53262_A0_G_MIICTLr_RE_ANf_SET
#define G_MIICTLr_ISOLATEf_GET BCM53262_A0_G_MIICTLr_ISOLATEf_GET
#define G_MIICTLr_ISOLATEf_SET BCM53262_A0_G_MIICTLr_ISOLATEf_SET
#define G_MIICTLr_PWR_DOWNf_GET BCM53262_A0_G_MIICTLr_PWR_DOWNf_GET
#define G_MIICTLr_PWR_DOWNf_SET BCM53262_A0_G_MIICTLr_PWR_DOWNf_SET
#define G_MIICTLr_AN_ENf_GET BCM53262_A0_G_MIICTLr_AN_ENf_GET
#define G_MIICTLr_AN_ENf_SET BCM53262_A0_G_MIICTLr_AN_ENf_SET
#define G_MIICTLr_SPD_SEL_LSBf_GET BCM53262_A0_G_MIICTLr_SPD_SEL_LSBf_GET
#define G_MIICTLr_SPD_SEL_LSBf_SET BCM53262_A0_G_MIICTLr_SPD_SEL_LSBf_SET
#define G_MIICTLr_LOOPBACKf_GET BCM53262_A0_G_MIICTLr_LOOPBACKf_GET
#define G_MIICTLr_LOOPBACKf_SET BCM53262_A0_G_MIICTLr_LOOPBACKf_SET
#define G_MIICTLr_RESET_Rf_GET BCM53262_A0_G_MIICTLr_RESET_Rf_GET
#define G_MIICTLr_RESET_Rf_SET BCM53262_A0_G_MIICTLr_RESET_Rf_SET
#define READ_G_MIICTLr BCM53262_A0_READ_G_MIICTLr
#define WRITE_G_MIICTLr BCM53262_A0_WRITE_G_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_MIICTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_MIISTS
 * BLOCKS:   CPIC GPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT_R   1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED_R       Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 */
#define BCM53262_A0_G_MIISTSr 0x0000d802

#define BCM53262_A0_G_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS.
 */
typedef union BCM53262_A0_G_MIISTSr_s {
	uint32_t v[1];
	uint32_t g_miists[1];
	uint32_t _g_miists;
} BCM53262_A0_G_MIISTSr_t;

#define BCM53262_A0_G_MIISTSr_CLR(r) (r).g_miists[0] = 0
#define BCM53262_A0_G_MIISTSr_SET(r,d) (r).g_miists[0] = d
#define BCM53262_A0_G_MIISTSr_GET(r) (r).g_miists[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_MIISTSr_EXT_CAPf_GET(r) (((r).g_miists[0]) & 0x1)
#define BCM53262_A0_G_MIISTSr_EXT_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_G_MIISTSr_JABBER_DETf_GET(r) ((((r).g_miists[0]) >> 1) & 0x1)
#define BCM53262_A0_G_MIISTSr_JABBER_DETf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_G_MIISTSr_LINK_STAf_GET(r) ((((r).g_miists[0]) >> 2) & 0x1)
#define BCM53262_A0_G_MIISTSr_LINK_STAf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists[0]) >> 3) & 0x1)
#define BCM53262_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_G_MIISTSr_REMOTE_FAULT_Rf_GET(r) ((((r).g_miists[0]) >> 4) & 0x1)
#define BCM53262_A0_G_MIISTSr_REMOTE_FAULT_Rf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists[0]) >> 5) & 0x1)
#define BCM53262_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).g_miists[0]) >> 6) & 0x1)
#define BCM53262_A0_G_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_G_MIISTSr_RESERVED_Rf_GET(r) ((((r).g_miists[0]) >> 7) & 0x1)
#define BCM53262_A0_G_MIISTSr_RESERVED_Rf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_G_MIISTSr_EXT_STSf_GET(r) ((((r).g_miists[0]) >> 8) & 0x1)
#define BCM53262_A0_G_MIISTSr_EXT_STSf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_G_MIISTSr_B100T2_HD_CAPf_GET(r) ((((r).g_miists[0]) >> 9) & 0x1)
#define BCM53262_A0_G_MIISTSr_B100T2_HD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_G_MIISTSr_B100T2_FD_CAPf_GET(r) ((((r).g_miists[0]) >> 10) & 0x1)
#define BCM53262_A0_G_MIISTSr_B100T2_FD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_MIISTSr_B10T_CAPf_GET(r) ((((r).g_miists[0]) >> 11) & 0x1)
#define BCM53262_A0_G_MIISTSr_B10T_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 12) & 0x1)
#define BCM53262_A0_G_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_MIISTSr_B100TX_CAPf_GET(r) ((((r).g_miists[0]) >> 13) & 0x1)
#define BCM53262_A0_G_MIISTSr_B100TX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 14) & 0x1)
#define BCM53262_A0_G_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_MIISTSr_B100T4_CAPf_GET(r) ((((r).g_miists[0]) >> 15) & 0x1)
#define BCM53262_A0_G_MIISTSr_B100T4_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS.
 */
#define BCM53262_A0_READ_G_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_MIISTSr,(r._g_miists),2)
#define BCM53262_A0_WRITE_G_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_MIISTSr,&(r._g_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTSr BCM53262_A0_G_MIISTSr
#define G_MIISTSr_SIZE BCM53262_A0_G_MIISTSr_SIZE
typedef BCM53262_A0_G_MIISTSr_t G_MIISTSr_t;
#define G_MIISTSr_CLR BCM53262_A0_G_MIISTSr_CLR
#define G_MIISTSr_SET BCM53262_A0_G_MIISTSr_SET
#define G_MIISTSr_GET BCM53262_A0_G_MIISTSr_GET
#define G_MIISTSr_EXT_CAPf_GET BCM53262_A0_G_MIISTSr_EXT_CAPf_GET
#define G_MIISTSr_EXT_CAPf_SET BCM53262_A0_G_MIISTSr_EXT_CAPf_SET
#define G_MIISTSr_JABBER_DETf_GET BCM53262_A0_G_MIISTSr_JABBER_DETf_GET
#define G_MIISTSr_JABBER_DETf_SET BCM53262_A0_G_MIISTSr_JABBER_DETf_SET
#define G_MIISTSr_LINK_STAf_GET BCM53262_A0_G_MIISTSr_LINK_STAf_GET
#define G_MIISTSr_LINK_STAf_SET BCM53262_A0_G_MIISTSr_LINK_STAf_SET
#define G_MIISTSr_AUTO_NEGO_CAPf_GET BCM53262_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET
#define G_MIISTSr_AUTO_NEGO_CAPf_SET BCM53262_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET
#define G_MIISTSr_REMOTE_FAULT_Rf_GET BCM53262_A0_G_MIISTSr_REMOTE_FAULT_Rf_GET
#define G_MIISTSr_REMOTE_FAULT_Rf_SET BCM53262_A0_G_MIISTSr_REMOTE_FAULT_Rf_SET
#define G_MIISTSr_AUTO_NEGO_COMPf_GET BCM53262_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET
#define G_MIISTSr_AUTO_NEGO_COMPf_SET BCM53262_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET
#define G_MIISTSr_MF_PRE_SUPf_GET BCM53262_A0_G_MIISTSr_MF_PRE_SUPf_GET
#define G_MIISTSr_MF_PRE_SUPf_SET BCM53262_A0_G_MIISTSr_MF_PRE_SUPf_SET
#define G_MIISTSr_RESERVED_Rf_GET BCM53262_A0_G_MIISTSr_RESERVED_Rf_GET
#define G_MIISTSr_RESERVED_Rf_SET BCM53262_A0_G_MIISTSr_RESERVED_Rf_SET
#define G_MIISTSr_EXT_STSf_GET BCM53262_A0_G_MIISTSr_EXT_STSf_GET
#define G_MIISTSr_EXT_STSf_SET BCM53262_A0_G_MIISTSr_EXT_STSf_SET
#define G_MIISTSr_B100T2_HD_CAPf_GET BCM53262_A0_G_MIISTSr_B100T2_HD_CAPf_GET
#define G_MIISTSr_B100T2_HD_CAPf_SET BCM53262_A0_G_MIISTSr_B100T2_HD_CAPf_SET
#define G_MIISTSr_B100T2_FD_CAPf_GET BCM53262_A0_G_MIISTSr_B100T2_FD_CAPf_GET
#define G_MIISTSr_B100T2_FD_CAPf_SET BCM53262_A0_G_MIISTSr_B100T2_FD_CAPf_SET
#define G_MIISTSr_B10T_CAPf_GET BCM53262_A0_G_MIISTSr_B10T_CAPf_GET
#define G_MIISTSr_B10T_CAPf_SET BCM53262_A0_G_MIISTSr_B10T_CAPf_SET
#define G_MIISTSr_B10T_FDX_CAPf_GET BCM53262_A0_G_MIISTSr_B10T_FDX_CAPf_GET
#define G_MIISTSr_B10T_FDX_CAPf_SET BCM53262_A0_G_MIISTSr_B10T_FDX_CAPf_SET
#define G_MIISTSr_B100TX_CAPf_GET BCM53262_A0_G_MIISTSr_B100TX_CAPf_GET
#define G_MIISTSr_B100TX_CAPf_SET BCM53262_A0_G_MIISTSr_B100TX_CAPf_SET
#define G_MIISTSr_B100TX_FDX_CAPf_GET BCM53262_A0_G_MIISTSr_B100TX_FDX_CAPf_GET
#define G_MIISTSr_B100TX_FDX_CAPf_SET BCM53262_A0_G_MIISTSr_B100TX_FDX_CAPf_SET
#define G_MIISTSr_B100T4_CAPf_GET BCM53262_A0_G_MIISTSr_B100T4_CAPf_GET
#define G_MIISTSr_B100T4_CAPf_SET BCM53262_A0_G_MIISTSr_B100T4_CAPf_SET
#define READ_G_MIISTSr BCM53262_A0_READ_G_MIISTSr
#define WRITE_G_MIISTSr BCM53262_A0_WRITE_G_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_MIISTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_PCTL
 * BLOCKS:   GPIC0
 * DESC:     10/100/1000 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     MIRX_DIS         Disables the receive function of the port at the MAC level.
 *     MITX_DIS         Disables the transmit function of the port at the MAC level.
 *     RESERVED_R       Reserved
 *     G_MISTP_STATE    CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3'b000: No Spanning Tree(Unmanaged mode).3'b001: Disable State(default for managed mode).3'b010: Blocking State.3'b011: Listening State.3'b100: Learning State.3'b101: Forwarding State.3'b110 - 3'b111: Reserved.Programmed frome the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 */
#define BCM53262_A0_G_PCTLr 0x001901a1

#define BCM53262_A0_G_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program G_PCTL.
 */
typedef union BCM53262_A0_G_PCTLr_s {
	uint32_t v[1];
	uint32_t g_pctl[1];
	uint32_t _g_pctl;
} BCM53262_A0_G_PCTLr_t;

#define BCM53262_A0_G_PCTLr_CLR(r) (r).g_pctl[0] = 0
#define BCM53262_A0_G_PCTLr_SET(r,d) (r).g_pctl[0] = d
#define BCM53262_A0_G_PCTLr_GET(r) (r).g_pctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_PCTLr_MIRX_DISf_GET(r) (((r).g_pctl[0]) & 0x1)
#define BCM53262_A0_G_PCTLr_MIRX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_G_PCTLr_MITX_DISf_GET(r) ((((r).g_pctl[0]) >> 1) & 0x1)
#define BCM53262_A0_G_PCTLr_MITX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_G_PCTLr_RESERVED_Rf_GET(r) ((((r).g_pctl[0]) >> 2) & 0x7)
#define BCM53262_A0_G_PCTLr_RESERVED_Rf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53262_A0_G_PCTLr_G_MISTP_STATEf_GET(r) ((((r).g_pctl[0]) >> 5) & 0x7)
#define BCM53262_A0_G_PCTLr_G_MISTP_STATEf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access G_PCTL.
 */
#define BCM53262_A0_READ_G_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_PCTLr,(r._g_pctl),1)
#define BCM53262_A0_WRITE_G_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_PCTLr,&(r._g_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PCTLr BCM53262_A0_G_PCTLr
#define G_PCTLr_SIZE BCM53262_A0_G_PCTLr_SIZE
typedef BCM53262_A0_G_PCTLr_t G_PCTLr_t;
#define G_PCTLr_CLR BCM53262_A0_G_PCTLr_CLR
#define G_PCTLr_SET BCM53262_A0_G_PCTLr_SET
#define G_PCTLr_GET BCM53262_A0_G_PCTLr_GET
#define G_PCTLr_MIRX_DISf_GET BCM53262_A0_G_PCTLr_MIRX_DISf_GET
#define G_PCTLr_MIRX_DISf_SET BCM53262_A0_G_PCTLr_MIRX_DISf_SET
#define G_PCTLr_MITX_DISf_GET BCM53262_A0_G_PCTLr_MITX_DISf_GET
#define G_PCTLr_MITX_DISf_SET BCM53262_A0_G_PCTLr_MITX_DISf_SET
#define G_PCTLr_RESERVED_Rf_GET BCM53262_A0_G_PCTLr_RESERVED_Rf_GET
#define G_PCTLr_RESERVED_Rf_SET BCM53262_A0_G_PCTLr_RESERVED_Rf_SET
#define G_PCTLr_G_MISTP_STATEf_GET BCM53262_A0_G_PCTLr_G_MISTP_STATEf_GET
#define G_PCTLr_G_MISTP_STATEf_SET BCM53262_A0_G_PCTLr_G_MISTP_STATEf_SET
#define READ_G_PCTLr BCM53262_A0_READ_G_PCTLr
#define WRITE_G_PCTLr BCM53262_A0_WRITE_G_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_PCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_PHYIDH
 * BLOCKS:   CPIC GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI_HI           Bits 3:18 of organizationally unique identifier.
 */
#define BCM53262_A0_G_PHYIDHr 0x0000d804

#define BCM53262_A0_G_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH.
 */
typedef union BCM53262_A0_G_PHYIDHr_s {
	uint32_t v[1];
	uint32_t g_phyidh[1];
	uint32_t _g_phyidh;
} BCM53262_A0_G_PHYIDHr_t;

#define BCM53262_A0_G_PHYIDHr_CLR(r) (r).g_phyidh[0] = 0
#define BCM53262_A0_G_PHYIDHr_SET(r,d) (r).g_phyidh[0] = d
#define BCM53262_A0_G_PHYIDHr_GET(r) (r).g_phyidh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_PHYIDHr_OUI_HIf_GET(r) (((r).g_phyidh[0]) & 0xffff)
#define BCM53262_A0_G_PHYIDHr_OUI_HIf_SET(r,f) (r).g_phyidh[0]=(((r).g_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH.
 */
#define BCM53262_A0_READ_G_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_PHYIDHr,(r._g_phyidh),2)
#define BCM53262_A0_WRITE_G_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_PHYIDHr,&(r._g_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDHr BCM53262_A0_G_PHYIDHr
#define G_PHYIDHr_SIZE BCM53262_A0_G_PHYIDHr_SIZE
typedef BCM53262_A0_G_PHYIDHr_t G_PHYIDHr_t;
#define G_PHYIDHr_CLR BCM53262_A0_G_PHYIDHr_CLR
#define G_PHYIDHr_SET BCM53262_A0_G_PHYIDHr_SET
#define G_PHYIDHr_GET BCM53262_A0_G_PHYIDHr_GET
#define G_PHYIDHr_OUI_HIf_GET BCM53262_A0_G_PHYIDHr_OUI_HIf_GET
#define G_PHYIDHr_OUI_HIf_SET BCM53262_A0_G_PHYIDHr_OUI_HIf_SET
#define READ_G_PHYIDHr BCM53262_A0_READ_G_PHYIDHr
#define WRITE_G_PHYIDHr BCM53262_A0_WRITE_G_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_PHYIDHr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_PHYIDL
 * BLOCKS:   CPIC GPIC0
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI_LOW          Bits 19:24 of organizationally unique identifier.
 */
#define BCM53262_A0_G_PHYIDLr 0x0000d806

#define BCM53262_A0_G_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL.
 */
typedef union BCM53262_A0_G_PHYIDLr_s {
	uint32_t v[1];
	uint32_t g_phyidl[1];
	uint32_t _g_phyidl;
} BCM53262_A0_G_PHYIDLr_t;

#define BCM53262_A0_G_PHYIDLr_CLR(r) (r).g_phyidl[0] = 0
#define BCM53262_A0_G_PHYIDLr_SET(r,d) (r).g_phyidl[0] = d
#define BCM53262_A0_G_PHYIDLr_GET(r) (r).g_phyidl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_PHYIDLr_REVISIONf_GET(r) (((r).g_phyidl[0]) & 0xf)
#define BCM53262_A0_G_PHYIDLr_REVISIONf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53262_A0_G_PHYIDLr_MODELf_GET(r) ((((r).g_phyidl[0]) >> 4) & 0x3f)
#define BCM53262_A0_G_PHYIDLr_MODELf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53262_A0_G_PHYIDLr_OUI_LOWf_GET(r) ((((r).g_phyidl[0]) >> 10) & 0x3f)
#define BCM53262_A0_G_PHYIDLr_OUI_LOWf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL.
 */
#define BCM53262_A0_READ_G_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_PHYIDLr,(r._g_phyidl),2)
#define BCM53262_A0_WRITE_G_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_PHYIDLr,&(r._g_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDLr BCM53262_A0_G_PHYIDLr
#define G_PHYIDLr_SIZE BCM53262_A0_G_PHYIDLr_SIZE
typedef BCM53262_A0_G_PHYIDLr_t G_PHYIDLr_t;
#define G_PHYIDLr_CLR BCM53262_A0_G_PHYIDLr_CLR
#define G_PHYIDLr_SET BCM53262_A0_G_PHYIDLr_SET
#define G_PHYIDLr_GET BCM53262_A0_G_PHYIDLr_GET
#define G_PHYIDLr_REVISIONf_GET BCM53262_A0_G_PHYIDLr_REVISIONf_GET
#define G_PHYIDLr_REVISIONf_SET BCM53262_A0_G_PHYIDLr_REVISIONf_SET
#define G_PHYIDLr_MODELf_GET BCM53262_A0_G_PHYIDLr_MODELf_GET
#define G_PHYIDLr_MODELf_SET BCM53262_A0_G_PHYIDLr_MODELf_SET
#define G_PHYIDLr_OUI_LOWf_GET BCM53262_A0_G_PHYIDLr_OUI_LOWf_GET
#define G_PHYIDLr_OUI_LOWf_SET BCM53262_A0_G_PHYIDLr_OUI_LOWf_SET
#define READ_G_PHYIDLr BCM53262_A0_READ_G_PHYIDLr
#define WRITE_G_PHYIDLr BCM53262_A0_WRITE_G_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_PHYIDLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_PHY_EXT_CTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGíªs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGíªs.
 *     FORCE_LED_OFF    1 = force all LEDíªs into íºOFFí¿ state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDíªs into íºONí¿ state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1íªs state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 */
#define BCM53262_A0_G_PHY_EXT_CTLr 0x0000d820

#define BCM53262_A0_G_PHY_EXT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL.
 */
typedef union BCM53262_A0_G_PHY_EXT_CTLr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl[1];
	uint32_t _g_phy_ext_ctl;
} BCM53262_A0_G_PHY_EXT_CTLr_t;

#define BCM53262_A0_G_PHY_EXT_CTLr_CLR(r) (r).g_phy_ext_ctl[0] = 0
#define BCM53262_A0_G_PHY_EXT_CTLr_SET(r,d) (r).g_phy_ext_ctl[0] = d
#define BCM53262_A0_G_PHY_EXT_CTLr_GET(r) (r).g_phy_ext_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl[0]) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 2) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 3) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 4) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 5) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 6) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 7) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl[0]) >> 8) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 9) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 10) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 11) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 12) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 13) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 14) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 15) & 0x1)
#define BCM53262_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL.
 */
#define BCM53262_A0_READ_G_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_PHY_EXT_CTLr,(r._g_phy_ext_ctl),2)
#define BCM53262_A0_WRITE_G_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_PHY_EXT_CTLr,&(r._g_phy_ext_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTLr BCM53262_A0_G_PHY_EXT_CTLr
#define G_PHY_EXT_CTLr_SIZE BCM53262_A0_G_PHY_EXT_CTLr_SIZE
typedef BCM53262_A0_G_PHY_EXT_CTLr_t G_PHY_EXT_CTLr_t;
#define G_PHY_EXT_CTLr_CLR BCM53262_A0_G_PHY_EXT_CTLr_CLR
#define G_PHY_EXT_CTLr_SET BCM53262_A0_G_PHY_EXT_CTLr_SET
#define G_PHY_EXT_CTLr_GET BCM53262_A0_G_PHY_EXT_CTLr_GET
#define G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET BCM53262_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET BCM53262_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET BCM53262_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET BCM53262_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET BCM53262_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET BCM53262_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_GET BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_SET BCM53262_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET BCM53262_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET BCM53262_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET BCM53262_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET BCM53262_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET BCM53262_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET BCM53262_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET BCM53262_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_GET BCM53262_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_SET BCM53262_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_GET BCM53262_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_SET BCM53262_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET BCM53262_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET BCM53262_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET BCM53262_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET BCM53262_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTLr BCM53262_A0_READ_G_PHY_EXT_CTLr
#define WRITE_G_PHY_EXT_CTLr BCM53262_A0_WRITE_G_PHY_EXT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_PHY_EXT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_PHY_EXT_STS
 * BLOCKS:   CPIC GPIC0
 * DESC:     PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCKED           1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 */
#define BCM53262_A0_G_PHY_EXT_STSr 0x0000d822

#define BCM53262_A0_G_PHY_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS.
 */
typedef union BCM53262_A0_G_PHY_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts[1];
	uint32_t _g_phy_ext_sts;
} BCM53262_A0_G_PHY_EXT_STSr_t;

#define BCM53262_A0_G_PHY_EXT_STSr_CLR(r) (r).g_phy_ext_sts[0] = 0
#define BCM53262_A0_G_PHY_EXT_STSr_SET(r,d) (r).g_phy_ext_sts[0] = d
#define BCM53262_A0_G_PHY_EXT_STSr_GET(r) (r).g_phy_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts[0]) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 1) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 2) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 3) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 4) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 5) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 6) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 7) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_G_PHY_EXT_STSr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 8) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_G_PHY_EXT_STSr_LOCKEDf_GET(r) ((((r).g_phy_ext_sts[0]) >> 9) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_LOCKEDf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 10) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 11) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 12) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 13) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 14) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts[0]) >> 15) & 0x1)
#define BCM53262_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS.
 */
#define BCM53262_A0_READ_G_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_PHY_EXT_STSr,(r._g_phy_ext_sts),2)
#define BCM53262_A0_WRITE_G_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_PHY_EXT_STSr,&(r._g_phy_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STSr BCM53262_A0_G_PHY_EXT_STSr
#define G_PHY_EXT_STSr_SIZE BCM53262_A0_G_PHY_EXT_STSr_SIZE
typedef BCM53262_A0_G_PHY_EXT_STSr_t G_PHY_EXT_STSr_t;
#define G_PHY_EXT_STSr_CLR BCM53262_A0_G_PHY_EXT_STSr_CLR
#define G_PHY_EXT_STSr_SET BCM53262_A0_G_PHY_EXT_STSr_SET
#define G_PHY_EXT_STSr_GET BCM53262_A0_G_PHY_EXT_STSr_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STSr_REC_ERR_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET
#define G_PHY_EXT_STSr_REC_ERR_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_GET BCM53262_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_SET BCM53262_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STSr_LINK_STSf_GET BCM53262_A0_G_PHY_EXT_STSr_LINK_STSf_GET
#define G_PHY_EXT_STSr_LINK_STSf_SET BCM53262_A0_G_PHY_EXT_STSr_LINK_STSf_SET
#define G_PHY_EXT_STSr_LOCKEDf_GET BCM53262_A0_G_PHY_EXT_STSr_LOCKEDf_GET
#define G_PHY_EXT_STSr_LOCKEDf_SET BCM53262_A0_G_PHY_EXT_STSr_LOCKEDf_SET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_GET BCM53262_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_SET BCM53262_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_GET BCM53262_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_SET BCM53262_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_GET BCM53262_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_SET BCM53262_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_GET BCM53262_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_SET BCM53262_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET BCM53262_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET BCM53262_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET BCM53262_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET BCM53262_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STSr BCM53262_A0_READ_G_PHY_EXT_STSr
#define WRITE_G_PHY_EXT_STSr BCM53262_A0_WRITE_G_PHY_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_PHY_EXT_STSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_REC_ERR_CNT
 * BLOCKS:   CPIC GPIC0
 * DESC:     Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow íº11011í¿ bit 9 = 1 otherwise copper errors)
 */
#define BCM53262_A0_G_REC_ERR_CNTr 0x0000d824

#define BCM53262_A0_G_REC_ERR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT.
 */
typedef union BCM53262_A0_G_REC_ERR_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt[1];
	uint32_t _g_rec_err_cnt;
} BCM53262_A0_G_REC_ERR_CNTr_t;

#define BCM53262_A0_G_REC_ERR_CNTr_CLR(r) (r).g_rec_err_cnt[0] = 0
#define BCM53262_A0_G_REC_ERR_CNTr_SET(r,d) (r).g_rec_err_cnt[0] = d
#define BCM53262_A0_G_REC_ERR_CNTr_GET(r) (r).g_rec_err_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt[0]) & 0xffff)
#define BCM53262_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt[0]=(((r).g_rec_err_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT.
 */
#define BCM53262_A0_READ_G_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_REC_ERR_CNTr,(r._g_rec_err_cnt),2)
#define BCM53262_A0_WRITE_G_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_REC_ERR_CNTr,&(r._g_rec_err_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNTr BCM53262_A0_G_REC_ERR_CNTr
#define G_REC_ERR_CNTr_SIZE BCM53262_A0_G_REC_ERR_CNTr_SIZE
typedef BCM53262_A0_G_REC_ERR_CNTr_t G_REC_ERR_CNTr_t;
#define G_REC_ERR_CNTr_CLR BCM53262_A0_G_REC_ERR_CNTr_CLR
#define G_REC_ERR_CNTr_SET BCM53262_A0_G_REC_ERR_CNTr_SET
#define G_REC_ERR_CNTr_GET BCM53262_A0_G_REC_ERR_CNTr_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_GET BCM53262_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_SET BCM53262_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNTr BCM53262_A0_READ_G_REC_ERR_CNTr
#define WRITE_G_REC_ERR_CNTr BCM53262_A0_WRITE_G_REC_ERR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_REC_ERR_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  G_REC_NOTOK_CNT
 * BLOCKS:   CPIC GPIC0
 * DESC:     Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 */
#define BCM53262_A0_G_REC_NOTOK_CNTr 0x0000d828

#define BCM53262_A0_G_REC_NOTOK_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT.
 */
typedef union BCM53262_A0_G_REC_NOTOK_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt[1];
	uint32_t _g_rec_notok_cnt;
} BCM53262_A0_G_REC_NOTOK_CNTr_t;

#define BCM53262_A0_G_REC_NOTOK_CNTr_CLR(r) (r).g_rec_notok_cnt[0] = 0
#define BCM53262_A0_G_REC_NOTOK_CNTr_SET(r,d) (r).g_rec_notok_cnt[0] = d
#define BCM53262_A0_G_REC_NOTOK_CNTr_GET(r) (r).g_rec_notok_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt[0]) & 0xff)
#define BCM53262_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt[0]) >> 8) & 0xff)
#define BCM53262_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT.
 */
#define BCM53262_A0_READ_G_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_G_REC_NOTOK_CNTr,(r._g_rec_notok_cnt),2)
#define BCM53262_A0_WRITE_G_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_G_REC_NOTOK_CNTr,&(r._g_rec_notok_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNTr BCM53262_A0_G_REC_NOTOK_CNTr
#define G_REC_NOTOK_CNTr_SIZE BCM53262_A0_G_REC_NOTOK_CNTr_SIZE
typedef BCM53262_A0_G_REC_NOTOK_CNTr_t G_REC_NOTOK_CNTr_t;
#define G_REC_NOTOK_CNTr_CLR BCM53262_A0_G_REC_NOTOK_CNTr_CLR
#define G_REC_NOTOK_CNTr_SET BCM53262_A0_G_REC_NOTOK_CNTr_SET
#define G_REC_NOTOK_CNTr_GET BCM53262_A0_G_REC_NOTOK_CNTr_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET BCM53262_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET BCM53262_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET BCM53262_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET BCM53262_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNTr BCM53262_A0_READ_G_REC_NOTOK_CNTr
#define WRITE_G_REC_NOTOK_CNTr BCM53262_A0_WRITE_G_REC_NOTOK_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_G_REC_NOTOK_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  HNDRD_ACTL
 * BLOCKS:   EPIC0
 * DESC:     100Base-X Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_HNDRD_ACTLr 0x0000a020

#define BCM53262_A0_HNDRD_ACTLr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_ACTL.
 */
typedef union BCM53262_A0_HNDRD_ACTLr_s {
	uint32_t v[1];
	uint32_t hndrd_actl[1];
	uint32_t _hndrd_actl;
} BCM53262_A0_HNDRD_ACTLr_t;

#define BCM53262_A0_HNDRD_ACTLr_CLR(r) (r).hndrd_actl[0] = 0
#define BCM53262_A0_HNDRD_ACTLr_SET(r,d) (r).hndrd_actl[0] = d
#define BCM53262_A0_HNDRD_ACTLr_GET(r) (r).hndrd_actl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_HNDRD_ACTLr_RESERVED_Rf_GET(r) (((r).hndrd_actl[0]) & 0xffff)
#define BCM53262_A0_HNDRD_ACTLr_RESERVED_Rf_SET(r,f) (r).hndrd_actl[0]=(((r).hndrd_actl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_ACTL.
 */
#define BCM53262_A0_READ_HNDRD_ACTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_HNDRD_ACTLr,(r._hndrd_actl),2)
#define BCM53262_A0_WRITE_HNDRD_ACTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_HNDRD_ACTLr,&(r._hndrd_actl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_ACTLr BCM53262_A0_HNDRD_ACTLr
#define HNDRD_ACTLr_SIZE BCM53262_A0_HNDRD_ACTLr_SIZE
typedef BCM53262_A0_HNDRD_ACTLr_t HNDRD_ACTLr_t;
#define HNDRD_ACTLr_CLR BCM53262_A0_HNDRD_ACTLr_CLR
#define HNDRD_ACTLr_SET BCM53262_A0_HNDRD_ACTLr_SET
#define HNDRD_ACTLr_GET BCM53262_A0_HNDRD_ACTLr_GET
#define HNDRD_ACTLr_RESERVED_Rf_GET BCM53262_A0_HNDRD_ACTLr_RESERVED_Rf_GET
#define HNDRD_ACTLr_RESERVED_Rf_SET BCM53262_A0_HNDRD_ACTLr_RESERVED_Rf_SET
#define READ_HNDRD_ACTLr BCM53262_A0_READ_HNDRD_ACTLr
#define WRITE_HNDRD_ACTLr BCM53262_A0_WRITE_HNDRD_ACTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_HNDRD_ACTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  HNDRD_ASTS
 * BLOCKS:   EPIC0
 * DESC:     100Base-X Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_HNDRD_ASTSr 0x0000a022

#define BCM53262_A0_HNDRD_ASTSr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_ASTS.
 */
typedef union BCM53262_A0_HNDRD_ASTSr_s {
	uint32_t v[1];
	uint32_t hndrd_asts[1];
	uint32_t _hndrd_asts;
} BCM53262_A0_HNDRD_ASTSr_t;

#define BCM53262_A0_HNDRD_ASTSr_CLR(r) (r).hndrd_asts[0] = 0
#define BCM53262_A0_HNDRD_ASTSr_SET(r,d) (r).hndrd_asts[0] = d
#define BCM53262_A0_HNDRD_ASTSr_GET(r) (r).hndrd_asts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_HNDRD_ASTSr_RESERVED_Rf_GET(r) (((r).hndrd_asts[0]) & 0xffff)
#define BCM53262_A0_HNDRD_ASTSr_RESERVED_Rf_SET(r,f) (r).hndrd_asts[0]=(((r).hndrd_asts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_ASTS.
 */
#define BCM53262_A0_READ_HNDRD_ASTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_HNDRD_ASTSr,(r._hndrd_asts),2)
#define BCM53262_A0_WRITE_HNDRD_ASTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_HNDRD_ASTSr,&(r._hndrd_asts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_ASTSr BCM53262_A0_HNDRD_ASTSr
#define HNDRD_ASTSr_SIZE BCM53262_A0_HNDRD_ASTSr_SIZE
typedef BCM53262_A0_HNDRD_ASTSr_t HNDRD_ASTSr_t;
#define HNDRD_ASTSr_CLR BCM53262_A0_HNDRD_ASTSr_CLR
#define HNDRD_ASTSr_SET BCM53262_A0_HNDRD_ASTSr_SET
#define HNDRD_ASTSr_GET BCM53262_A0_HNDRD_ASTSr_GET
#define HNDRD_ASTSr_RESERVED_Rf_GET BCM53262_A0_HNDRD_ASTSr_RESERVED_Rf_GET
#define HNDRD_ASTSr_RESERVED_Rf_SET BCM53262_A0_HNDRD_ASTSr_RESERVED_Rf_SET
#define READ_HNDRD_ASTSr BCM53262_A0_READ_HNDRD_ASTSr
#define WRITE_HNDRD_ASTSr BCM53262_A0_WRITE_HNDRD_ASTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_HNDRD_ASTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  HNDRD_FCSCNT
 * BLOCKS:   EPIC0
 * DESC:     100Base-X False Carrier Sense Counter Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_HNDRD_FCSCNTr 0x0000a026

#define BCM53262_A0_HNDRD_FCSCNTr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_FCSCNT.
 */
typedef union BCM53262_A0_HNDRD_FCSCNTr_s {
	uint32_t v[1];
	uint32_t hndrd_fcscnt[1];
	uint32_t _hndrd_fcscnt;
} BCM53262_A0_HNDRD_FCSCNTr_t;

#define BCM53262_A0_HNDRD_FCSCNTr_CLR(r) (r).hndrd_fcscnt[0] = 0
#define BCM53262_A0_HNDRD_FCSCNTr_SET(r,d) (r).hndrd_fcscnt[0] = d
#define BCM53262_A0_HNDRD_FCSCNTr_GET(r) (r).hndrd_fcscnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_HNDRD_FCSCNTr_RESERVED_Rf_GET(r) (((r).hndrd_fcscnt[0]) & 0xffff)
#define BCM53262_A0_HNDRD_FCSCNTr_RESERVED_Rf_SET(r,f) (r).hndrd_fcscnt[0]=(((r).hndrd_fcscnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_FCSCNT.
 */
#define BCM53262_A0_READ_HNDRD_FCSCNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_HNDRD_FCSCNTr,(r._hndrd_fcscnt),2)
#define BCM53262_A0_WRITE_HNDRD_FCSCNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_HNDRD_FCSCNTr,&(r._hndrd_fcscnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_FCSCNTr BCM53262_A0_HNDRD_FCSCNTr
#define HNDRD_FCSCNTr_SIZE BCM53262_A0_HNDRD_FCSCNTr_SIZE
typedef BCM53262_A0_HNDRD_FCSCNTr_t HNDRD_FCSCNTr_t;
#define HNDRD_FCSCNTr_CLR BCM53262_A0_HNDRD_FCSCNTr_CLR
#define HNDRD_FCSCNTr_SET BCM53262_A0_HNDRD_FCSCNTr_SET
#define HNDRD_FCSCNTr_GET BCM53262_A0_HNDRD_FCSCNTr_GET
#define HNDRD_FCSCNTr_RESERVED_Rf_GET BCM53262_A0_HNDRD_FCSCNTr_RESERVED_Rf_GET
#define HNDRD_FCSCNTr_RESERVED_Rf_SET BCM53262_A0_HNDRD_FCSCNTr_RESERVED_Rf_SET
#define READ_HNDRD_FCSCNTr BCM53262_A0_READ_HNDRD_FCSCNTr
#define WRITE_HNDRD_FCSCNTr BCM53262_A0_WRITE_HNDRD_FCSCNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_HNDRD_FCSCNTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  HNDRD_RECNT
 * BLOCKS:   EPIC0
 * DESC:     100Base-X Receive Error Counter Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_HNDRD_RECNTr 0x0000a024

#define BCM53262_A0_HNDRD_RECNTr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_RECNT.
 */
typedef union BCM53262_A0_HNDRD_RECNTr_s {
	uint32_t v[1];
	uint32_t hndrd_recnt[1];
	uint32_t _hndrd_recnt;
} BCM53262_A0_HNDRD_RECNTr_t;

#define BCM53262_A0_HNDRD_RECNTr_CLR(r) (r).hndrd_recnt[0] = 0
#define BCM53262_A0_HNDRD_RECNTr_SET(r,d) (r).hndrd_recnt[0] = d
#define BCM53262_A0_HNDRD_RECNTr_GET(r) (r).hndrd_recnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_HNDRD_RECNTr_RESERVED_Rf_GET(r) (((r).hndrd_recnt[0]) & 0xffff)
#define BCM53262_A0_HNDRD_RECNTr_RESERVED_Rf_SET(r,f) (r).hndrd_recnt[0]=(((r).hndrd_recnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_RECNT.
 */
#define BCM53262_A0_READ_HNDRD_RECNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_HNDRD_RECNTr,(r._hndrd_recnt),2)
#define BCM53262_A0_WRITE_HNDRD_RECNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_HNDRD_RECNTr,&(r._hndrd_recnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_RECNTr BCM53262_A0_HNDRD_RECNTr
#define HNDRD_RECNTr_SIZE BCM53262_A0_HNDRD_RECNTr_SIZE
typedef BCM53262_A0_HNDRD_RECNTr_t HNDRD_RECNTr_t;
#define HNDRD_RECNTr_CLR BCM53262_A0_HNDRD_RECNTr_CLR
#define HNDRD_RECNTr_SET BCM53262_A0_HNDRD_RECNTr_SET
#define HNDRD_RECNTr_GET BCM53262_A0_HNDRD_RECNTr_GET
#define HNDRD_RECNTr_RESERVED_Rf_GET BCM53262_A0_HNDRD_RECNTr_RESERVED_Rf_GET
#define HNDRD_RECNTr_RESERVED_Rf_SET BCM53262_A0_HNDRD_RECNTr_RESERVED_Rf_SET
#define READ_HNDRD_RECNTr BCM53262_A0_READ_HNDRD_RECNTr
#define WRITE_HNDRD_RECNTr BCM53262_A0_WRITE_HNDRD_RECNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_HNDRD_RECNTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  IGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Control Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     IN_MIR_MSK       Ingress Mirror Port Mask53 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIR_CAP_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIR_CAP_PORT.Bits 0-47 = 10/100BASE-T PortsBit 48= IMP portBit 49 = Giga port g0Bit 50 = Giga port g1Bit 51 = Giga port g2Bit 52 = Giga port g3
 *     IGMIRCTL_RSRV0   Reserved
 *     IN_DIV_EN        Ingress Divider EnableMirror every nth received frame (n=IN_MIR_DIV) that has passed through the IN_MIR_FILTER.
 *     IN_MIR_FLTR      Ingress Mirror Filter.Defines the conditions under which frames received on a port that has been selected in the IN_MIR_MSK[52:0], will be compared in order to determine if they should be forwarded to the MIR_CAP_PORT.00: Mirror all ingress frames01: Mirror all received frames with DA = IN_MIR_MAC10: Mirror all received frames with SA = IN_MIR_MAC11: Reserved
 */
#define BCM53262_A0_IGMIRCTLr 0x00000318

#define BCM53262_A0_IGMIRCTLr_SIZE 8

/*
 * This structure should be used to declare and program IGMIRCTL.
 */
typedef union BCM53262_A0_IGMIRCTLr_s {
	uint32_t v[2];
	uint32_t igmirctl[2];
	uint32_t _igmirctl;
} BCM53262_A0_IGMIRCTLr_t;

#define BCM53262_A0_IGMIRCTLr_CLR(r) CDK_MEMSET(&((r)._igmirctl), 0, sizeof(BCM53262_A0_IGMIRCTLr_t))
#define BCM53262_A0_IGMIRCTLr_SET(r,i,d) (r).igmirctl[i] = d
#define BCM53262_A0_IGMIRCTLr_GET(r,i) (r).igmirctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_IGMIRCTLr_RESERVED_Rf_GET(r) (((r).igmirctl[0]) & 0xffffff)
#define BCM53262_A0_IGMIRCTLr_RESERVED_Rf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_IGMIRCTLr_IN_MIR_MSKf_GET(r) cdk_field32_get((r).igmirctl,24,52)
#define BCM53262_A0_IGMIRCTLr_IN_MIR_MSKf_SET(r,f) cdk_field32_set((r).igmirctl,24,52,f)
#define BCM53262_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_GET(r) ((((r).igmirctl[1]) >> 21) & 0xff)
#define BCM53262_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_SET(r,f) (r).igmirctl[1]=(((r).igmirctl[1] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))
#define BCM53262_A0_IGMIRCTLr_IN_DIV_ENf_GET(r) ((((r).igmirctl[1]) >> 29) & 0x1)
#define BCM53262_A0_IGMIRCTLr_IN_DIV_ENf_SET(r,f) (r).igmirctl[1]=(((r).igmirctl[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53262_A0_IGMIRCTLr_IN_MIR_FLTRf_GET(r) ((((r).igmirctl[1]) >> 30) & 0x3)
#define BCM53262_A0_IGMIRCTLr_IN_MIR_FLTRf_SET(r,f) (r).igmirctl[1]=(((r).igmirctl[1] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access IGMIRCTL.
 */
#define BCM53262_A0_READ_IGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_IGMIRCTLr,(r._igmirctl),8)
#define BCM53262_A0_WRITE_IGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_IGMIRCTLr,&(r._igmirctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRCTLr BCM53262_A0_IGMIRCTLr
#define IGMIRCTLr_SIZE BCM53262_A0_IGMIRCTLr_SIZE
typedef BCM53262_A0_IGMIRCTLr_t IGMIRCTLr_t;
#define IGMIRCTLr_CLR BCM53262_A0_IGMIRCTLr_CLR
#define IGMIRCTLr_SET BCM53262_A0_IGMIRCTLr_SET
#define IGMIRCTLr_GET BCM53262_A0_IGMIRCTLr_GET
#define IGMIRCTLr_RESERVED_Rf_GET BCM53262_A0_IGMIRCTLr_RESERVED_Rf_GET
#define IGMIRCTLr_RESERVED_Rf_SET BCM53262_A0_IGMIRCTLr_RESERVED_Rf_SET
#define IGMIRCTLr_IN_MIR_MSKf_GET BCM53262_A0_IGMIRCTLr_IN_MIR_MSKf_GET
#define IGMIRCTLr_IN_MIR_MSKf_SET BCM53262_A0_IGMIRCTLr_IN_MIR_MSKf_SET
#define IGMIRCTLr_IGMIRCTL_RSRV0f_GET BCM53262_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_GET
#define IGMIRCTLr_IGMIRCTL_RSRV0f_SET BCM53262_A0_IGMIRCTLr_IGMIRCTL_RSRV0f_SET
#define IGMIRCTLr_IN_DIV_ENf_GET BCM53262_A0_IGMIRCTLr_IN_DIV_ENf_GET
#define IGMIRCTLr_IN_DIV_ENf_SET BCM53262_A0_IGMIRCTLr_IN_DIV_ENf_SET
#define IGMIRCTLr_IN_MIR_FLTRf_GET BCM53262_A0_IGMIRCTLr_IN_MIR_FLTRf_GET
#define IGMIRCTLr_IN_MIR_FLTRf_SET BCM53262_A0_IGMIRCTLr_IN_MIR_FLTRf_SET
#define READ_IGMIRCTLr BCM53262_A0_READ_IGMIRCTLr
#define WRITE_IGMIRCTLr BCM53262_A0_WRITE_IGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_IGMIRCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  IGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_DIV       Ingress Mirror Divider.Receive frames that have passed the IN_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIR_CAP_PORT. When the IN_DIV_EN bit in the Ingress Mirror Control register is set, frames that pass the IN_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = IN_MIRROR_DIV) will be mirrored.
 *     IGMIRDIV_RSRV0   Reserved
 */
#define BCM53262_A0_IGMIRDIVr 0x00000320

#define BCM53262_A0_IGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRDIV.
 */
typedef union BCM53262_A0_IGMIRDIVr_s {
	uint32_t v[1];
	uint32_t igmirdiv[1];
	uint32_t _igmirdiv;
} BCM53262_A0_IGMIRDIVr_t;

#define BCM53262_A0_IGMIRDIVr_CLR(r) (r).igmirdiv[0] = 0
#define BCM53262_A0_IGMIRDIVr_SET(r,d) (r).igmirdiv[0] = d
#define BCM53262_A0_IGMIRDIVr_GET(r) (r).igmirdiv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_IGMIRDIVr_IN_MIR_DIVf_GET(r) (((r).igmirdiv[0]) & 0x3ff)
#define BCM53262_A0_IGMIRDIVr_IN_MIR_DIVf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53262_A0_IGMIRDIVr_IGMIRDIV_RSRV0f_GET(r) ((((r).igmirdiv[0]) >> 10) & 0x3f)
#define BCM53262_A0_IGMIRDIVr_IGMIRDIV_RSRV0f_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access IGMIRDIV.
 */
#define BCM53262_A0_READ_IGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53262_A0_IGMIRDIVr,(r._igmirdiv),2)
#define BCM53262_A0_WRITE_IGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53262_A0_IGMIRDIVr,&(r._igmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRDIVr BCM53262_A0_IGMIRDIVr
#define IGMIRDIVr_SIZE BCM53262_A0_IGMIRDIVr_SIZE
typedef BCM53262_A0_IGMIRDIVr_t IGMIRDIVr_t;
#define IGMIRDIVr_CLR BCM53262_A0_IGMIRDIVr_CLR
#define IGMIRDIVr_SET BCM53262_A0_IGMIRDIVr_SET
#define IGMIRDIVr_GET BCM53262_A0_IGMIRDIVr_GET
#define IGMIRDIVr_IN_MIR_DIVf_GET BCM53262_A0_IGMIRDIVr_IN_MIR_DIVf_GET
#define IGMIRDIVr_IN_MIR_DIVf_SET BCM53262_A0_IGMIRDIVr_IN_MIR_DIVf_SET
#define IGMIRDIVr_IGMIRDIV_RSRV0f_GET BCM53262_A0_IGMIRDIVr_IGMIRDIV_RSRV0f_GET
#define IGMIRDIVr_IGMIRDIV_RSRV0f_SET BCM53262_A0_IGMIRDIVr_IGMIRDIV_RSRV0f_SET
#define READ_IGMIRDIVr BCM53262_A0_READ_IGMIRDIVr
#define WRITE_IGMIRDIVr BCM53262_A0_WRITE_IGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_IGMIRDIVr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  IGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Mac Address Register
 * SIZE:     48
 * FIELDS:
 *     IN_MIR_MAC       Ingress Mirror MAC Address.MAC address that will be compared against ingress frames in accordance with the IN_MIRROR_FILTER rules.
 */
#define BCM53262_A0_IGMIRMACr 0x00000322

#define BCM53262_A0_IGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program IGMIRMAC.
 */
typedef union BCM53262_A0_IGMIRMACr_s {
	uint32_t v[2];
	uint32_t igmirmac[2];
	uint32_t _igmirmac;
} BCM53262_A0_IGMIRMACr_t;

#define BCM53262_A0_IGMIRMACr_CLR(r) CDK_MEMSET(&((r)._igmirmac), 0, sizeof(BCM53262_A0_IGMIRMACr_t))
#define BCM53262_A0_IGMIRMACr_SET(r,i,d) (r).igmirmac[i] = d
#define BCM53262_A0_IGMIRMACr_GET(r,i) (r).igmirmac[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_IGMIRMACr_IN_MIR_MACf_GET(r,a) cdk_field_get((r).igmirmac,0,47,a)
#define BCM53262_A0_IGMIRMACr_IN_MIR_MACf_SET(r,a) cdk_field_set((r).igmirmac,0,47,a)

/*
 * These macros can be used to access IGMIRMAC.
 */
#define BCM53262_A0_READ_IGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53262_A0_IGMIRMACr,(r._igmirmac),6)
#define BCM53262_A0_WRITE_IGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53262_A0_IGMIRMACr,&(r._igmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRMACr BCM53262_A0_IGMIRMACr
#define IGMIRMACr_SIZE BCM53262_A0_IGMIRMACr_SIZE
typedef BCM53262_A0_IGMIRMACr_t IGMIRMACr_t;
#define IGMIRMACr_CLR BCM53262_A0_IGMIRMACr_CLR
#define IGMIRMACr_SET BCM53262_A0_IGMIRMACr_SET
#define IGMIRMACr_GET BCM53262_A0_IGMIRMACr_GET
#define IGMIRMACr_IN_MIR_MACf_GET BCM53262_A0_IGMIRMACr_IN_MIR_MACf_GET
#define IGMIRMACr_IN_MIR_MACf_SET BCM53262_A0_IGMIRMACr_IN_MIR_MACf_SET
#define READ_IGMIRMACr BCM53262_A0_READ_IGMIRMACr
#define WRITE_IGMIRMACr BCM53262_A0_WRITE_IGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_IGMIRMACr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  IMP_PCTL
 * BLOCKS:   CPIC
 * DESC:     IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     MIRX_DIS         Disables the receive function of the port at the MAC level.
 *     MITX_DIS         Disables the transmit function of the port at the MAC level.
 *     MIRX_BC_EN       Receive Broadcast Enable.Ignored if the MII/IMP port is not selected as the Frame Management Port.
 *     MIRX_MC_EN       Receive Multicast Enable.Ignored if the MII/IMP port is not selected as the Frame Management Port.
 *     MIRX_UC_EN       Receive Unicast Enable.Ignored if the MII/IMP port is not selected as the Frame Management Port.
 *     MII_MISTP_STATE  CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3'b000: No Spanning Tree(Unmanaged mode).3'b001: Disable State(default for managed mode).3'b010: Blocking State.3'b011: Listening State.3'b100: Learning State.3'b101: Forwarding State.3'b110 - 3'b111: Reserved.Programmed frome the HW_FWDG_EN Strap Option.Can be overwritten subsequently.Ignored when SW_FWDG_MODE=Unmanaged.
 */
#define BCM53262_A0_IMP_PCTLr 0x000001a0

#define BCM53262_A0_IMP_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_PCTL.
 */
typedef union BCM53262_A0_IMP_PCTLr_s {
	uint32_t v[1];
	uint32_t imp_pctl[1];
	uint32_t _imp_pctl;
} BCM53262_A0_IMP_PCTLr_t;

#define BCM53262_A0_IMP_PCTLr_CLR(r) (r).imp_pctl[0] = 0
#define BCM53262_A0_IMP_PCTLr_SET(r,d) (r).imp_pctl[0] = d
#define BCM53262_A0_IMP_PCTLr_GET(r) (r).imp_pctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_IMP_PCTLr_MIRX_DISf_GET(r) (((r).imp_pctl[0]) & 0x1)
#define BCM53262_A0_IMP_PCTLr_MIRX_DISf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_IMP_PCTLr_MITX_DISf_GET(r) ((((r).imp_pctl[0]) >> 1) & 0x1)
#define BCM53262_A0_IMP_PCTLr_MITX_DISf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_IMP_PCTLr_MIRX_BC_ENf_GET(r) ((((r).imp_pctl[0]) >> 2) & 0x1)
#define BCM53262_A0_IMP_PCTLr_MIRX_BC_ENf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_IMP_PCTLr_MIRX_MC_ENf_GET(r) ((((r).imp_pctl[0]) >> 3) & 0x1)
#define BCM53262_A0_IMP_PCTLr_MIRX_MC_ENf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_IMP_PCTLr_MIRX_UC_ENf_GET(r) ((((r).imp_pctl[0]) >> 4) & 0x1)
#define BCM53262_A0_IMP_PCTLr_MIRX_UC_ENf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_IMP_PCTLr_MII_MISTP_STATEf_GET(r) ((((r).imp_pctl[0]) >> 5) & 0x7)
#define BCM53262_A0_IMP_PCTLr_MII_MISTP_STATEf_SET(r,f) (r).imp_pctl[0]=(((r).imp_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access IMP_PCTL.
 */
#define BCM53262_A0_READ_IMP_PCTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_IMP_PCTLr,(r._imp_pctl),1)
#define BCM53262_A0_WRITE_IMP_PCTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_IMP_PCTLr,&(r._imp_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_PCTLr BCM53262_A0_IMP_PCTLr
#define IMP_PCTLr_SIZE BCM53262_A0_IMP_PCTLr_SIZE
typedef BCM53262_A0_IMP_PCTLr_t IMP_PCTLr_t;
#define IMP_PCTLr_CLR BCM53262_A0_IMP_PCTLr_CLR
#define IMP_PCTLr_SET BCM53262_A0_IMP_PCTLr_SET
#define IMP_PCTLr_GET BCM53262_A0_IMP_PCTLr_GET
#define IMP_PCTLr_MIRX_DISf_GET BCM53262_A0_IMP_PCTLr_MIRX_DISf_GET
#define IMP_PCTLr_MIRX_DISf_SET BCM53262_A0_IMP_PCTLr_MIRX_DISf_SET
#define IMP_PCTLr_MITX_DISf_GET BCM53262_A0_IMP_PCTLr_MITX_DISf_GET
#define IMP_PCTLr_MITX_DISf_SET BCM53262_A0_IMP_PCTLr_MITX_DISf_SET
#define IMP_PCTLr_MIRX_BC_ENf_GET BCM53262_A0_IMP_PCTLr_MIRX_BC_ENf_GET
#define IMP_PCTLr_MIRX_BC_ENf_SET BCM53262_A0_IMP_PCTLr_MIRX_BC_ENf_SET
#define IMP_PCTLr_MIRX_MC_ENf_GET BCM53262_A0_IMP_PCTLr_MIRX_MC_ENf_GET
#define IMP_PCTLr_MIRX_MC_ENf_SET BCM53262_A0_IMP_PCTLr_MIRX_MC_ENf_SET
#define IMP_PCTLr_MIRX_UC_ENf_GET BCM53262_A0_IMP_PCTLr_MIRX_UC_ENf_GET
#define IMP_PCTLr_MIRX_UC_ENf_SET BCM53262_A0_IMP_PCTLr_MIRX_UC_ENf_SET
#define IMP_PCTLr_MII_MISTP_STATEf_GET BCM53262_A0_IMP_PCTLr_MII_MISTP_STATEf_GET
#define IMP_PCTLr_MII_MISTP_STATEf_SET BCM53262_A0_IMP_PCTLr_MII_MISTP_STATEf_SET
#define READ_IMP_PCTLr BCM53262_A0_READ_IMP_PCTLr
#define WRITE_IMP_PCTLr BCM53262_A0_WRITE_IMP_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_IMP_PCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  INGRESS_RMON
 * BLOCKS:   SYS
 * DESC:     Extend Ingress RMON Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     EN_INGRESS_PORTMAP Ingress RMON enable.Each bit is per port, but bit48 (for port 48) is reserve must set to 1'b0.A '1' indicates that the corresponding port is ingress extended RMON enable and will forward packet to thr cpu port.
 *     RESERVED_1R      Reserved.
 *     INGRESS_PRI      Ingress RMON Priority.Indicates the priority queue to use for egress extended RMON packets.
 *     INGRESS_CFG      Ingress RMON Setting.A exponential value indicating the percentage of traffic that will be sent to CPU due to Ingress extended RMON.percentage = 1/(2^value).
 */
#define BCM53262_A0_INGRESS_RMONr 0x00000360

#define BCM53262_A0_INGRESS_RMONr_SIZE 8

/*
 * This structure should be used to declare and program INGRESS_RMON.
 */
typedef union BCM53262_A0_INGRESS_RMONr_s {
	uint32_t v[2];
	uint32_t ingress_rmon[2];
	uint32_t _ingress_rmon;
} BCM53262_A0_INGRESS_RMONr_t;

#define BCM53262_A0_INGRESS_RMONr_CLR(r) CDK_MEMSET(&((r)._ingress_rmon), 0, sizeof(BCM53262_A0_INGRESS_RMONr_t))
#define BCM53262_A0_INGRESS_RMONr_SET(r,i,d) (r).ingress_rmon[i] = d
#define BCM53262_A0_INGRESS_RMONr_GET(r,i) (r).ingress_rmon[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_INGRESS_RMONr_RESERVED_0Rf_GET(r) (((r).ingress_rmon[0]) & 0xffffff)
#define BCM53262_A0_INGRESS_RMONr_RESERVED_0Rf_SET(r,f) (r).ingress_rmon[0]=(((r).ingress_rmon[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_INGRESS_RMONr_EN_INGRESS_PORTMAPf_GET(r) cdk_field32_get((r).ingress_rmon,24,52)
#define BCM53262_A0_INGRESS_RMONr_EN_INGRESS_PORTMAPf_SET(r,f) cdk_field32_set((r).ingress_rmon,24,52,f)
#define BCM53262_A0_INGRESS_RMONr_RESERVED_1Rf_GET(r) ((((r).ingress_rmon[1]) >> 21) & 0x1f)
#define BCM53262_A0_INGRESS_RMONr_RESERVED_1Rf_SET(r,f) (r).ingress_rmon[1]=(((r).ingress_rmon[1] & ~((uint32_t)0x1f << 21)) | ((((uint32_t)f) & 0x1f) << 21))
#define BCM53262_A0_INGRESS_RMONr_INGRESS_PRIf_GET(r) ((((r).ingress_rmon[1]) >> 26) & 0x3)
#define BCM53262_A0_INGRESS_RMONr_INGRESS_PRIf_SET(r,f) (r).ingress_rmon[1]=(((r).ingress_rmon[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53262_A0_INGRESS_RMONr_INGRESS_CFGf_GET(r) ((((r).ingress_rmon[1]) >> 28) & 0xf)
#define BCM53262_A0_INGRESS_RMONr_INGRESS_CFGf_SET(r,f) (r).ingress_rmon[1]=(((r).ingress_rmon[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access INGRESS_RMON.
 */
#define BCM53262_A0_READ_INGRESS_RMONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_INGRESS_RMONr,(r._ingress_rmon),8)
#define BCM53262_A0_WRITE_INGRESS_RMONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_INGRESS_RMONr,&(r._ingress_rmon),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INGRESS_RMONr BCM53262_A0_INGRESS_RMONr
#define INGRESS_RMONr_SIZE BCM53262_A0_INGRESS_RMONr_SIZE
typedef BCM53262_A0_INGRESS_RMONr_t INGRESS_RMONr_t;
#define INGRESS_RMONr_CLR BCM53262_A0_INGRESS_RMONr_CLR
#define INGRESS_RMONr_SET BCM53262_A0_INGRESS_RMONr_SET
#define INGRESS_RMONr_GET BCM53262_A0_INGRESS_RMONr_GET
#define INGRESS_RMONr_RESERVED_0Rf_GET BCM53262_A0_INGRESS_RMONr_RESERVED_0Rf_GET
#define INGRESS_RMONr_RESERVED_0Rf_SET BCM53262_A0_INGRESS_RMONr_RESERVED_0Rf_SET
#define INGRESS_RMONr_EN_INGRESS_PORTMAPf_GET BCM53262_A0_INGRESS_RMONr_EN_INGRESS_PORTMAPf_GET
#define INGRESS_RMONr_EN_INGRESS_PORTMAPf_SET BCM53262_A0_INGRESS_RMONr_EN_INGRESS_PORTMAPf_SET
#define INGRESS_RMONr_RESERVED_1Rf_GET BCM53262_A0_INGRESS_RMONr_RESERVED_1Rf_GET
#define INGRESS_RMONr_RESERVED_1Rf_SET BCM53262_A0_INGRESS_RMONr_RESERVED_1Rf_SET
#define INGRESS_RMONr_INGRESS_PRIf_GET BCM53262_A0_INGRESS_RMONr_INGRESS_PRIf_GET
#define INGRESS_RMONr_INGRESS_PRIf_SET BCM53262_A0_INGRESS_RMONr_INGRESS_PRIf_SET
#define INGRESS_RMONr_INGRESS_CFGf_GET BCM53262_A0_INGRESS_RMONr_INGRESS_CFGf_GET
#define INGRESS_RMONr_INGRESS_CFGf_SET BCM53262_A0_INGRESS_RMONr_INGRESS_CFGf_SET
#define READ_INGRESS_RMONr BCM53262_A0_READ_INGRESS_RMONr
#define WRITE_INGRESS_RMONr BCM53262_A0_WRITE_INGRESS_RMONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_INGRESS_RMONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ISP_SEL_PORTMAP
 * BLOCKS:   SYS
 * DESC:     ISP Port Selection Portmap Registers
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     ISP_PORT_PBMP    Portmap to define which port as ISP-port.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_ISP_SEL_PORTMAPr 0x00003498

#define BCM53262_A0_ISP_SEL_PORTMAPr_SIZE 8

/*
 * This structure should be used to declare and program ISP_SEL_PORTMAP.
 */
typedef union BCM53262_A0_ISP_SEL_PORTMAPr_s {
	uint32_t v[2];
	uint32_t isp_sel_portmap[2];
	uint32_t _isp_sel_portmap;
} BCM53262_A0_ISP_SEL_PORTMAPr_t;

#define BCM53262_A0_ISP_SEL_PORTMAPr_CLR(r) CDK_MEMSET(&((r)._isp_sel_portmap), 0, sizeof(BCM53262_A0_ISP_SEL_PORTMAPr_t))
#define BCM53262_A0_ISP_SEL_PORTMAPr_SET(r,i,d) (r).isp_sel_portmap[i] = d
#define BCM53262_A0_ISP_SEL_PORTMAPr_GET(r,i) (r).isp_sel_portmap[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_0Rf_GET(r) (((r).isp_sel_portmap[0]) & 0xffffff)
#define BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_0Rf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_ISP_SEL_PORTMAPr_ISP_PORT_PBMPf_GET(r) cdk_field32_get((r).isp_sel_portmap,24,52)
#define BCM53262_A0_ISP_SEL_PORTMAPr_ISP_PORT_PBMPf_SET(r,f) cdk_field32_set((r).isp_sel_portmap,24,52,f)
#define BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_1Rf_GET(r) ((((r).isp_sel_portmap[1]) >> 21) & 0x7ff)
#define BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_1Rf_SET(r,f) (r).isp_sel_portmap[1]=(((r).isp_sel_portmap[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access ISP_SEL_PORTMAP.
 */
#define BCM53262_A0_READ_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ISP_SEL_PORTMAPr,(r._isp_sel_portmap),8)
#define BCM53262_A0_WRITE_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ISP_SEL_PORTMAPr,&(r._isp_sel_portmap),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_SEL_PORTMAPr BCM53262_A0_ISP_SEL_PORTMAPr
#define ISP_SEL_PORTMAPr_SIZE BCM53262_A0_ISP_SEL_PORTMAPr_SIZE
typedef BCM53262_A0_ISP_SEL_PORTMAPr_t ISP_SEL_PORTMAPr_t;
#define ISP_SEL_PORTMAPr_CLR BCM53262_A0_ISP_SEL_PORTMAPr_CLR
#define ISP_SEL_PORTMAPr_SET BCM53262_A0_ISP_SEL_PORTMAPr_SET
#define ISP_SEL_PORTMAPr_GET BCM53262_A0_ISP_SEL_PORTMAPr_GET
#define ISP_SEL_PORTMAPr_RESERVED_0Rf_GET BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_0Rf_GET
#define ISP_SEL_PORTMAPr_RESERVED_0Rf_SET BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_0Rf_SET
#define ISP_SEL_PORTMAPr_ISP_PORT_PBMPf_GET BCM53262_A0_ISP_SEL_PORTMAPr_ISP_PORT_PBMPf_GET
#define ISP_SEL_PORTMAPr_ISP_PORT_PBMPf_SET BCM53262_A0_ISP_SEL_PORTMAPr_ISP_PORT_PBMPf_SET
#define ISP_SEL_PORTMAPr_RESERVED_1Rf_GET BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_1Rf_GET
#define ISP_SEL_PORTMAPr_RESERVED_1Rf_SET BCM53262_A0_ISP_SEL_PORTMAPr_RESERVED_1Rf_SET
#define READ_ISP_SEL_PORTMAPr BCM53262_A0_READ_ISP_SEL_PORTMAPr
#define WRITE_ISP_SEL_PORTMAPr BCM53262_A0_WRITE_ISP_SEL_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ISP_SEL_PORTMAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ISP_VID
 * BLOCKS:   SYS
 * DESC:     Global CFP Control 1 Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_VLAN_DELIMITER The Delimiter of ISP Tagged frame. The Delimiter of .1Q tagged frame is 8100.
 */
#define BCM53262_A0_ISP_VIDr 0x00002110

#define BCM53262_A0_ISP_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ISP_VID.
 */
typedef union BCM53262_A0_ISP_VIDr_s {
	uint32_t v[1];
	uint32_t isp_vid[1];
	uint32_t _isp_vid;
} BCM53262_A0_ISP_VIDr_t;

#define BCM53262_A0_ISP_VIDr_CLR(r) (r).isp_vid[0] = 0
#define BCM53262_A0_ISP_VIDr_SET(r,d) (r).isp_vid[0] = d
#define BCM53262_A0_ISP_VIDr_GET(r) (r).isp_vid[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ISP_VIDr_ISP_VLAN_DELIMITERf_GET(r) (((r).isp_vid[0]) & 0xffff)
#define BCM53262_A0_ISP_VIDr_ISP_VLAN_DELIMITERf_SET(r,f) (r).isp_vid[0]=(((r).isp_vid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ISP_VID.
 */
#define BCM53262_A0_READ_ISP_VIDr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ISP_VIDr,(r._isp_vid),2)
#define BCM53262_A0_WRITE_ISP_VIDr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ISP_VIDr,&(r._isp_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_VIDr BCM53262_A0_ISP_VIDr
#define ISP_VIDr_SIZE BCM53262_A0_ISP_VIDr_SIZE
typedef BCM53262_A0_ISP_VIDr_t ISP_VIDr_t;
#define ISP_VIDr_CLR BCM53262_A0_ISP_VIDr_CLR
#define ISP_VIDr_SET BCM53262_A0_ISP_VIDr_SET
#define ISP_VIDr_GET BCM53262_A0_ISP_VIDr_GET
#define ISP_VIDr_ISP_VLAN_DELIMITERf_GET BCM53262_A0_ISP_VIDr_ISP_VLAN_DELIMITERf_GET
#define ISP_VIDr_ISP_VLAN_DELIMITERf_SET BCM53262_A0_ISP_VIDr_ISP_VLAN_DELIMITERf_SET
#define READ_ISP_VIDr BCM53262_A0_READ_ISP_VIDr
#define WRITE_ISP_VIDr BCM53262_A0_WRITE_ISP_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ISP_VIDr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  L2_ARL
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     64
 * FIELDS:
 *     MACADDR_47_12    SA in last 36 bits
 *     PORTID_R         Rx Port Number 
 *     RESERVED1_R      QPriority
 *     AGE              Age status
 *     VID_R            VLAN ID
 *     CONTROL          ARL control :2'b00 : Normal ARL function.2'b01 : Drop if MAC_DA match.(Please also set the "Static" bit)2'b01 : Drop if MAC_SA match.(Please also set the "Static" bit)2'b11 : Forward the destination port specified by ARL, Also send a copy to CPU.
 *     STATIC           Static status
 *     VALID_R          Valid status
 */
#define BCM53262_A0_L2_ARLm 0x52010554

#define BCM53262_A0_L2_ARLm_MIN 0
#define BCM53262_A0_L2_ARLm_MAX 8191
#define BCM53262_A0_L2_ARLm_CMAX(u) 8191
#define BCM53262_A0_L2_ARLm_SIZE 8

/*
 * This structure should be used to declare and program L2_ARL.
 */
typedef union BCM53262_A0_L2_ARLm_s {
	uint32_t v[2];
	uint32_t l2_arl[2];
	uint32_t _l2_arl;
} BCM53262_A0_L2_ARLm_t;

#define BCM53262_A0_L2_ARLm_CLR(r) CDK_MEMSET(&((r)._l2_arl), 0, sizeof(BCM53262_A0_L2_ARLm_t))
#define BCM53262_A0_L2_ARLm_SET(r,i,d) (r).l2_arl[i] = d
#define BCM53262_A0_L2_ARLm_GET(r,i) (r).l2_arl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_L2_ARLm_MACADDR_47_12f_GET(r,a) cdk_field_get((r).l2_arl,0,35,a)
#define BCM53262_A0_L2_ARLm_MACADDR_47_12f_SET(r,a) cdk_field_set((r).l2_arl,0,35,a)
#define BCM53262_A0_L2_ARLm_PORTID_Rf_GET(r) ((((r).l2_arl[1]) >> 4) & 0x3f)
#define BCM53262_A0_L2_ARLm_PORTID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53262_A0_L2_ARLm_RESERVED1_Rf_GET(r) ((((r).l2_arl[1]) >> 10) & 0x1f)
#define BCM53262_A0_L2_ARLm_RESERVED1_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM53262_A0_L2_ARLm_AGEf_GET(r) ((((r).l2_arl[1]) >> 15) & 0x1)
#define BCM53262_A0_L2_ARLm_AGEf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53262_A0_L2_ARLm_VID_Rf_GET(r) ((((r).l2_arl[1]) >> 16) & 0xfff)
#define BCM53262_A0_L2_ARLm_VID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53262_A0_L2_ARLm_CONTROLf_GET(r) ((((r).l2_arl[1]) >> 28) & 0x3)
#define BCM53262_A0_L2_ARLm_CONTROLf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_L2_ARLm_STATICf_GET(r) ((((r).l2_arl[1]) >> 30) & 0x1)
#define BCM53262_A0_L2_ARLm_STATICf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_L2_ARLm_VALID_Rf_GET(r) ((((r).l2_arl[1]) >> 31) & 0x1)
#define BCM53262_A0_L2_ARLm_VALID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access L2_ARL.
 */
#define BCM53262_A0_READ_L2_ARLm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_L2_ARLm,i,(m),8)
#define BCM53262_A0_WRITE_L2_ARLm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_L2_ARLm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ARLm BCM53262_A0_L2_ARLm
#define L2_ARLm_MIN BCM53262_A0_L2_ARLm_MIN
#define L2_ARLm_MAX BCM53262_A0_L2_ARLm_MAX
#define L2_ARLm_CMAX(u) BCM53262_A0_L2_ARLm_CMAX(u)
#define L2_ARLm_SIZE BCM53262_A0_L2_ARLm_SIZE
typedef BCM53262_A0_L2_ARLm_t L2_ARLm_t;
#define L2_ARLm_CLR BCM53262_A0_L2_ARLm_CLR
#define L2_ARLm_SET BCM53262_A0_L2_ARLm_SET
#define L2_ARLm_GET BCM53262_A0_L2_ARLm_GET
#define L2_ARLm_MACADDR_47_12f_GET BCM53262_A0_L2_ARLm_MACADDR_47_12f_GET
#define L2_ARLm_MACADDR_47_12f_SET BCM53262_A0_L2_ARLm_MACADDR_47_12f_SET
#define L2_ARLm_PORTID_Rf_GET BCM53262_A0_L2_ARLm_PORTID_Rf_GET
#define L2_ARLm_PORTID_Rf_SET BCM53262_A0_L2_ARLm_PORTID_Rf_SET
#define L2_ARLm_RESERVED1_Rf_GET BCM53262_A0_L2_ARLm_RESERVED1_Rf_GET
#define L2_ARLm_RESERVED1_Rf_SET BCM53262_A0_L2_ARLm_RESERVED1_Rf_SET
#define L2_ARLm_AGEf_GET BCM53262_A0_L2_ARLm_AGEf_GET
#define L2_ARLm_AGEf_SET BCM53262_A0_L2_ARLm_AGEf_SET
#define L2_ARLm_VID_Rf_GET BCM53262_A0_L2_ARLm_VID_Rf_GET
#define L2_ARLm_VID_Rf_SET BCM53262_A0_L2_ARLm_VID_Rf_SET
#define L2_ARLm_CONTROLf_GET BCM53262_A0_L2_ARLm_CONTROLf_GET
#define L2_ARLm_CONTROLf_SET BCM53262_A0_L2_ARLm_CONTROLf_SET
#define L2_ARLm_STATICf_GET BCM53262_A0_L2_ARLm_STATICf_GET
#define L2_ARLm_STATICf_SET BCM53262_A0_L2_ARLm_STATICf_SET
#define L2_ARLm_VALID_Rf_GET BCM53262_A0_L2_ARLm_VALID_Rf_GET
#define L2_ARLm_VALID_Rf_SET BCM53262_A0_L2_ARLm_VALID_Rf_SET
#define READ_L2_ARLm BCM53262_A0_READ_L2_ARLm
#define WRITE_L2_ARLm BCM53262_A0_WRITE_L2_ARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_L2_ARLm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  L4PORT_RANGE_CHECKER
 * BLOCKS:   SYS
 * DESC:     L4 Port Range Checker Register
 * SIZE:     32
 * FIELDS:
 *     SMALL            Small Value.Large >= xxxx >= SmallNote : also refer RCC in CFP Global Control Register
 *     LARGE            Large Value.Large >= xxxx >= SmallNote : also refer RCC in CFP Global Control RegisterL4PORT_RANGE_CHECKER0 refers to RCC0.L4PORT_RANGE_CHECKER1 refers to RCC1.L4PORT_RANGE_CHECKER2 refers to RCC2.L4PORT_RANGE_CHECKER3 refers to RCC3.
 */
#define BCM53262_A0_L4PORT_RANGE_CHECKERr 0x00002140

#define BCM53262_A0_L4PORT_RANGE_CHECKERr_SIZE 4

/*
 * This structure should be used to declare and program L4PORT_RANGE_CHECKER.
 */
typedef union BCM53262_A0_L4PORT_RANGE_CHECKERr_s {
	uint32_t v[1];
	uint32_t l4port_range_checker[1];
	uint32_t _l4port_range_checker;
} BCM53262_A0_L4PORT_RANGE_CHECKERr_t;

#define BCM53262_A0_L4PORT_RANGE_CHECKERr_CLR(r) (r).l4port_range_checker[0] = 0
#define BCM53262_A0_L4PORT_RANGE_CHECKERr_SET(r,d) (r).l4port_range_checker[0] = d
#define BCM53262_A0_L4PORT_RANGE_CHECKERr_GET(r) (r).l4port_range_checker[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_L4PORT_RANGE_CHECKERr_SMALLf_GET(r) (((r).l4port_range_checker[0]) & 0xffff)
#define BCM53262_A0_L4PORT_RANGE_CHECKERr_SMALLf_SET(r,f) (r).l4port_range_checker[0]=(((r).l4port_range_checker[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53262_A0_L4PORT_RANGE_CHECKERr_LARGEf_GET(r) ((((r).l4port_range_checker[0]) >> 16) & 0xffff)
#define BCM53262_A0_L4PORT_RANGE_CHECKERr_LARGEf_SET(r,f) (r).l4port_range_checker[0]=(((r).l4port_range_checker[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access L4PORT_RANGE_CHECKER.
 */
#define BCM53262_A0_READ_L4PORT_RANGE_CHECKERr(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_L4PORT_RANGE_CHECKERr+(4*(i)),(r._l4port_range_checker),4)
#define BCM53262_A0_WRITE_L4PORT_RANGE_CHECKERr(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_L4PORT_RANGE_CHECKERr+(4*(i)),&(r._l4port_range_checker),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L4PORT_RANGE_CHECKERr BCM53262_A0_L4PORT_RANGE_CHECKERr
#define L4PORT_RANGE_CHECKERr_SIZE BCM53262_A0_L4PORT_RANGE_CHECKERr_SIZE
typedef BCM53262_A0_L4PORT_RANGE_CHECKERr_t L4PORT_RANGE_CHECKERr_t;
#define L4PORT_RANGE_CHECKERr_CLR BCM53262_A0_L4PORT_RANGE_CHECKERr_CLR
#define L4PORT_RANGE_CHECKERr_SET BCM53262_A0_L4PORT_RANGE_CHECKERr_SET
#define L4PORT_RANGE_CHECKERr_GET BCM53262_A0_L4PORT_RANGE_CHECKERr_GET
#define L4PORT_RANGE_CHECKERr_SMALLf_GET BCM53262_A0_L4PORT_RANGE_CHECKERr_SMALLf_GET
#define L4PORT_RANGE_CHECKERr_SMALLf_SET BCM53262_A0_L4PORT_RANGE_CHECKERr_SMALLf_SET
#define L4PORT_RANGE_CHECKERr_LARGEf_GET BCM53262_A0_L4PORT_RANGE_CHECKERr_LARGEf_GET
#define L4PORT_RANGE_CHECKERr_LARGEf_SET BCM53262_A0_L4PORT_RANGE_CHECKERr_LARGEf_SET
#define READ_L4PORT_RANGE_CHECKERr BCM53262_A0_READ_L4PORT_RANGE_CHECKERr
#define WRITE_L4PORT_RANGE_CHECKERr BCM53262_A0_WRITE_L4PORT_RANGE_CHECKERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_L4PORT_RANGE_CHECKERr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LED_CONTROL
 * BLOCKS:   SYS
 * DESC:     LED ReFlash control register
 * SIZE:     16
 * FIELDS:
 *     LED_RFS_STOP     LED reflsh control register.reflsh time = (N+1)*10ns000 : no reflsh;001 : 20ms/25Hz;010 : 30ms/16Hz;011 : 40ms/12Hz;100 : 50ms/10Hz;101 : 60ms/8Hz;110 : 70ms/7Hz;111 : 80ms/6Hz.
 *     LED_NORM_CD_EN   
 *     LED_POST_CD_EN   
 *     LED_PSCAN_EN     
 *     LED_POST_EXEC    
 *     LED_EN           1 : forwarding process enable.0 : turn off forwarding process. Assertion for dumb switchdefault value base on strap pin.
 *     EN_LOW_PORT_START Enable LED data output order from low port to high port.
 *     EN_LNKACT_RATE   Enable LNK/ACT blinking rate for different link speed. 3Hz for 10M, 6Hz for 100M, 12Hz for 1G.
 *     EN_FUNCMAP_REORDER Enable another LED function map 0/1 order.15:reserved14:reserved13:1G/ACT12:10/100M/ACT11:100M/ACT10:10M/ACT9:SPD10M8:LNK/ACT7:DPX/COL6:LNK5:ACT4:DPX3:COL2:SPD100M1:SPD1G0:reserved
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_LED_CONTROLr 0x0000005a

#define BCM53262_A0_LED_CONTROLr_SIZE 2

/*
 * This structure should be used to declare and program LED_CONTROL.
 */
typedef union BCM53262_A0_LED_CONTROLr_s {
	uint32_t v[1];
	uint32_t led_control[1];
	uint32_t _led_control;
} BCM53262_A0_LED_CONTROLr_t;

#define BCM53262_A0_LED_CONTROLr_CLR(r) (r).led_control[0] = 0
#define BCM53262_A0_LED_CONTROLr_SET(r,d) (r).led_control[0] = d
#define BCM53262_A0_LED_CONTROLr_GET(r) (r).led_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LED_CONTROLr_LED_RFS_STOPf_GET(r) (((r).led_control[0]) & 0x7)
#define BCM53262_A0_LED_CONTROLr_LED_RFS_STOPf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53262_A0_LED_CONTROLr_LED_NORM_CD_ENf_GET(r) ((((r).led_control[0]) >> 3) & 0x1)
#define BCM53262_A0_LED_CONTROLr_LED_NORM_CD_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_LED_CONTROLr_LED_POST_CD_ENf_GET(r) ((((r).led_control[0]) >> 4) & 0x1)
#define BCM53262_A0_LED_CONTROLr_LED_POST_CD_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_LED_CONTROLr_LED_PSCAN_ENf_GET(r) ((((r).led_control[0]) >> 5) & 0x1)
#define BCM53262_A0_LED_CONTROLr_LED_PSCAN_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_LED_CONTROLr_LED_POST_EXECf_GET(r) ((((r).led_control[0]) >> 6) & 0x1)
#define BCM53262_A0_LED_CONTROLr_LED_POST_EXECf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_LED_CONTROLr_LED_ENf_GET(r) ((((r).led_control[0]) >> 7) & 0x1)
#define BCM53262_A0_LED_CONTROLr_LED_ENf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_GET(r) ((((r).led_control[0]) >> 8) & 0x1)
#define BCM53262_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_LED_CONTROLr_EN_LNKACT_RATEf_GET(r) ((((r).led_control[0]) >> 9) & 0x1)
#define BCM53262_A0_LED_CONTROLr_EN_LNKACT_RATEf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_GET(r) ((((r).led_control[0]) >> 10) & 0x1)
#define BCM53262_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_LED_CONTROLr_RESERVED_Rf_GET(r) ((((r).led_control[0]) >> 11) & 0x1f)
#define BCM53262_A0_LED_CONTROLr_RESERVED_Rf_SET(r,f) (r).led_control[0]=(((r).led_control[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access LED_CONTROL.
 */
#define BCM53262_A0_READ_LED_CONTROLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LED_CONTROLr,(r._led_control),2)
#define BCM53262_A0_WRITE_LED_CONTROLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LED_CONTROLr,&(r._led_control),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_CONTROLr BCM53262_A0_LED_CONTROLr
#define LED_CONTROLr_SIZE BCM53262_A0_LED_CONTROLr_SIZE
typedef BCM53262_A0_LED_CONTROLr_t LED_CONTROLr_t;
#define LED_CONTROLr_CLR BCM53262_A0_LED_CONTROLr_CLR
#define LED_CONTROLr_SET BCM53262_A0_LED_CONTROLr_SET
#define LED_CONTROLr_GET BCM53262_A0_LED_CONTROLr_GET
#define LED_CONTROLr_LED_RFS_STOPf_GET BCM53262_A0_LED_CONTROLr_LED_RFS_STOPf_GET
#define LED_CONTROLr_LED_RFS_STOPf_SET BCM53262_A0_LED_CONTROLr_LED_RFS_STOPf_SET
#define LED_CONTROLr_LED_NORM_CD_ENf_GET BCM53262_A0_LED_CONTROLr_LED_NORM_CD_ENf_GET
#define LED_CONTROLr_LED_NORM_CD_ENf_SET BCM53262_A0_LED_CONTROLr_LED_NORM_CD_ENf_SET
#define LED_CONTROLr_LED_POST_CD_ENf_GET BCM53262_A0_LED_CONTROLr_LED_POST_CD_ENf_GET
#define LED_CONTROLr_LED_POST_CD_ENf_SET BCM53262_A0_LED_CONTROLr_LED_POST_CD_ENf_SET
#define LED_CONTROLr_LED_PSCAN_ENf_GET BCM53262_A0_LED_CONTROLr_LED_PSCAN_ENf_GET
#define LED_CONTROLr_LED_PSCAN_ENf_SET BCM53262_A0_LED_CONTROLr_LED_PSCAN_ENf_SET
#define LED_CONTROLr_LED_POST_EXECf_GET BCM53262_A0_LED_CONTROLr_LED_POST_EXECf_GET
#define LED_CONTROLr_LED_POST_EXECf_SET BCM53262_A0_LED_CONTROLr_LED_POST_EXECf_SET
#define LED_CONTROLr_LED_ENf_GET BCM53262_A0_LED_CONTROLr_LED_ENf_GET
#define LED_CONTROLr_LED_ENf_SET BCM53262_A0_LED_CONTROLr_LED_ENf_SET
#define LED_CONTROLr_EN_LOW_PORT_STARTf_GET BCM53262_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_GET
#define LED_CONTROLr_EN_LOW_PORT_STARTf_SET BCM53262_A0_LED_CONTROLr_EN_LOW_PORT_STARTf_SET
#define LED_CONTROLr_EN_LNKACT_RATEf_GET BCM53262_A0_LED_CONTROLr_EN_LNKACT_RATEf_GET
#define LED_CONTROLr_EN_LNKACT_RATEf_SET BCM53262_A0_LED_CONTROLr_EN_LNKACT_RATEf_SET
#define LED_CONTROLr_EN_FUNCMAP_REORDERf_GET BCM53262_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_GET
#define LED_CONTROLr_EN_FUNCMAP_REORDERf_SET BCM53262_A0_LED_CONTROLr_EN_FUNCMAP_REORDERf_SET
#define LED_CONTROLr_RESERVED_Rf_GET BCM53262_A0_LED_CONTROLr_RESERVED_Rf_GET
#define LED_CONTROLr_RESERVED_Rf_SET BCM53262_A0_LED_CONTROLr_RESERVED_Rf_SET
#define READ_LED_CONTROLr BCM53262_A0_READ_LED_CONTROLr
#define WRITE_LED_CONTROLr BCM53262_A0_WRITE_LED_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LED_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LED_EN_MAP
 * BLOCKS:   SYS
 * DESC:     LED Enable Map register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     LED_EN_MAP       Per port enable function bit,default value base strap pin.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_LED_EN_MAPr 0x00000068

#define BCM53262_A0_LED_EN_MAPr_SIZE 8

/*
 * This structure should be used to declare and program LED_EN_MAP.
 */
typedef union BCM53262_A0_LED_EN_MAPr_s {
	uint32_t v[2];
	uint32_t led_en_map[2];
	uint32_t _led_en_map;
} BCM53262_A0_LED_EN_MAPr_t;

#define BCM53262_A0_LED_EN_MAPr_CLR(r) CDK_MEMSET(&((r)._led_en_map), 0, sizeof(BCM53262_A0_LED_EN_MAPr_t))
#define BCM53262_A0_LED_EN_MAPr_SET(r,i,d) (r).led_en_map[i] = d
#define BCM53262_A0_LED_EN_MAPr_GET(r,i) (r).led_en_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LED_EN_MAPr_RESERVED_0Rf_GET(r) (((r).led_en_map[0]) & 0xffffff)
#define BCM53262_A0_LED_EN_MAPr_RESERVED_0Rf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_LED_EN_MAPr_LED_EN_MAPf_GET(r) cdk_field32_get((r).led_en_map,24,52)
#define BCM53262_A0_LED_EN_MAPr_LED_EN_MAPf_SET(r,f) cdk_field32_set((r).led_en_map,24,52,f)
#define BCM53262_A0_LED_EN_MAPr_RESERVED_1Rf_GET(r) ((((r).led_en_map[1]) >> 21) & 0x7ff)
#define BCM53262_A0_LED_EN_MAPr_RESERVED_1Rf_SET(r,f) (r).led_en_map[1]=(((r).led_en_map[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access LED_EN_MAP.
 */
#define BCM53262_A0_READ_LED_EN_MAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LED_EN_MAPr,(r._led_en_map),8)
#define BCM53262_A0_WRITE_LED_EN_MAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LED_EN_MAPr,&(r._led_en_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_EN_MAPr BCM53262_A0_LED_EN_MAPr
#define LED_EN_MAPr_SIZE BCM53262_A0_LED_EN_MAPr_SIZE
typedef BCM53262_A0_LED_EN_MAPr_t LED_EN_MAPr_t;
#define LED_EN_MAPr_CLR BCM53262_A0_LED_EN_MAPr_CLR
#define LED_EN_MAPr_SET BCM53262_A0_LED_EN_MAPr_SET
#define LED_EN_MAPr_GET BCM53262_A0_LED_EN_MAPr_GET
#define LED_EN_MAPr_RESERVED_0Rf_GET BCM53262_A0_LED_EN_MAPr_RESERVED_0Rf_GET
#define LED_EN_MAPr_RESERVED_0Rf_SET BCM53262_A0_LED_EN_MAPr_RESERVED_0Rf_SET
#define LED_EN_MAPr_LED_EN_MAPf_GET BCM53262_A0_LED_EN_MAPr_LED_EN_MAPf_GET
#define LED_EN_MAPr_LED_EN_MAPf_SET BCM53262_A0_LED_EN_MAPr_LED_EN_MAPf_SET
#define LED_EN_MAPr_RESERVED_1Rf_GET BCM53262_A0_LED_EN_MAPr_RESERVED_1Rf_GET
#define LED_EN_MAPr_RESERVED_1Rf_SET BCM53262_A0_LED_EN_MAPr_RESERVED_1Rf_SET
#define READ_LED_EN_MAPr BCM53262_A0_READ_LED_EN_MAPr
#define WRITE_LED_EN_MAPr BCM53262_A0_WRITE_LED_EN_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LED_EN_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LED_FUNC0_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        15: RESV14: RESV13: 1G/ACT12: 10/100M/ACT11: 100M/ACT10: 10M/ACT9: SPD1G8: SPD100M7: SPD10M6: DPX/COL5: LNK/ACT4: COL3: ACT2: DPX1: LNK0: RESVdefault : ledmode=00 : 16'h0120;          ledmode=01 : 16'h0C40;          ledmode=10 : 16'h0124;          ledmode=11 : 16'h0C04;
 */
#define BCM53262_A0_LED_FUNC0_CTLr 0x0000005c

#define BCM53262_A0_LED_FUNC0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_CTL.
 */
typedef union BCM53262_A0_LED_FUNC0_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_ctl[1];
	uint32_t _led_func0_ctl;
} BCM53262_A0_LED_FUNC0_CTLr_t;

#define BCM53262_A0_LED_FUNC0_CTLr_CLR(r) (r).led_func0_ctl[0] = 0
#define BCM53262_A0_LED_FUNC0_CTLr_SET(r,d) (r).led_func0_ctl[0] = d
#define BCM53262_A0_LED_FUNC0_CTLr_GET(r) (r).led_func0_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET(r) (((r).led_func0_ctl[0]) & 0xffff)
#define BCM53262_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC0_CTL.
 */
#define BCM53262_A0_READ_LED_FUNC0_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LED_FUNC0_CTLr,(r._led_func0_ctl),2)
#define BCM53262_A0_WRITE_LED_FUNC0_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LED_FUNC0_CTLr,&(r._led_func0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_CTLr BCM53262_A0_LED_FUNC0_CTLr
#define LED_FUNC0_CTLr_SIZE BCM53262_A0_LED_FUNC0_CTLr_SIZE
typedef BCM53262_A0_LED_FUNC0_CTLr_t LED_FUNC0_CTLr_t;
#define LED_FUNC0_CTLr_CLR BCM53262_A0_LED_FUNC0_CTLr_CLR
#define LED_FUNC0_CTLr_SET BCM53262_A0_LED_FUNC0_CTLr_SET
#define LED_FUNC0_CTLr_GET BCM53262_A0_LED_FUNC0_CTLr_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_GET BCM53262_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_SET BCM53262_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC0_CTLr BCM53262_A0_READ_LED_FUNC0_CTLr
#define WRITE_LED_FUNC0_CTLr BCM53262_A0_WRITE_LED_FUNC0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LED_FUNC0_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LED_FUNC1_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC1        15: RESV14: RESV13: 1G/ACT12: 10/100M/ACT11: 100M/ACT10: 10M/ACT9: SPD1G8: SPD100M7: SPD10M6: DPX/COL5: LNK/ACT4: COL3: ACT2: DPX1: LNK0: RESVdefault : ledmode=00 : 16'h0320;          ledmode=01 : 16'h3040;          ledmode=10 : 16'h0324;          ledmode=11 : 16'h2C04;
 */
#define BCM53262_A0_LED_FUNC1_CTLr 0x0000005e

#define BCM53262_A0_LED_FUNC1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_CTL.
 */
typedef union BCM53262_A0_LED_FUNC1_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_ctl[1];
	uint32_t _led_func1_ctl;
} BCM53262_A0_LED_FUNC1_CTLr_t;

#define BCM53262_A0_LED_FUNC1_CTLr_CLR(r) (r).led_func1_ctl[0] = 0
#define BCM53262_A0_LED_FUNC1_CTLr_SET(r,d) (r).led_func1_ctl[0] = d
#define BCM53262_A0_LED_FUNC1_CTLr_GET(r) (r).led_func1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET(r) (((r).led_func1_ctl[0]) & 0xffff)
#define BCM53262_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC1_CTL.
 */
#define BCM53262_A0_READ_LED_FUNC1_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LED_FUNC1_CTLr,(r._led_func1_ctl),2)
#define BCM53262_A0_WRITE_LED_FUNC1_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LED_FUNC1_CTLr,&(r._led_func1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_CTLr BCM53262_A0_LED_FUNC1_CTLr
#define LED_FUNC1_CTLr_SIZE BCM53262_A0_LED_FUNC1_CTLr_SIZE
typedef BCM53262_A0_LED_FUNC1_CTLr_t LED_FUNC1_CTLr_t;
#define LED_FUNC1_CTLr_CLR BCM53262_A0_LED_FUNC1_CTLr_CLR
#define LED_FUNC1_CTLr_SET BCM53262_A0_LED_FUNC1_CTLr_SET
#define LED_FUNC1_CTLr_GET BCM53262_A0_LED_FUNC1_CTLr_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_GET BCM53262_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_SET BCM53262_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET
#define READ_LED_FUNC1_CTLr BCM53262_A0_READ_LED_FUNC1_CTLr
#define WRITE_LED_FUNC1_CTLr BCM53262_A0_WRITE_LED_FUNC1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LED_FUNC1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LED_FUNC_MAP
 * BLOCKS:   SYS
 * DESC:     LED Function Map register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     LED_FUNC_MAP     Per port select function bit.1: select function 1,0: select function 0.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_LED_FUNC_MAPr 0x00000060

#define BCM53262_A0_LED_FUNC_MAPr_SIZE 8

/*
 * This structure should be used to declare and program LED_FUNC_MAP.
 */
typedef union BCM53262_A0_LED_FUNC_MAPr_s {
	uint32_t v[2];
	uint32_t led_func_map[2];
	uint32_t _led_func_map;
} BCM53262_A0_LED_FUNC_MAPr_t;

#define BCM53262_A0_LED_FUNC_MAPr_CLR(r) CDK_MEMSET(&((r)._led_func_map), 0, sizeof(BCM53262_A0_LED_FUNC_MAPr_t))
#define BCM53262_A0_LED_FUNC_MAPr_SET(r,i,d) (r).led_func_map[i] = d
#define BCM53262_A0_LED_FUNC_MAPr_GET(r,i) (r).led_func_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LED_FUNC_MAPr_RESERVED_0Rf_GET(r) (((r).led_func_map[0]) & 0xffffff)
#define BCM53262_A0_LED_FUNC_MAPr_RESERVED_0Rf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET(r) cdk_field32_get((r).led_func_map,24,52)
#define BCM53262_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET(r,f) cdk_field32_set((r).led_func_map,24,52,f)
#define BCM53262_A0_LED_FUNC_MAPr_RESERVED_1Rf_GET(r) ((((r).led_func_map[1]) >> 21) & 0x7ff)
#define BCM53262_A0_LED_FUNC_MAPr_RESERVED_1Rf_SET(r,f) (r).led_func_map[1]=(((r).led_func_map[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access LED_FUNC_MAP.
 */
#define BCM53262_A0_READ_LED_FUNC_MAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LED_FUNC_MAPr,(r._led_func_map),8)
#define BCM53262_A0_WRITE_LED_FUNC_MAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LED_FUNC_MAPr,&(r._led_func_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC_MAPr BCM53262_A0_LED_FUNC_MAPr
#define LED_FUNC_MAPr_SIZE BCM53262_A0_LED_FUNC_MAPr_SIZE
typedef BCM53262_A0_LED_FUNC_MAPr_t LED_FUNC_MAPr_t;
#define LED_FUNC_MAPr_CLR BCM53262_A0_LED_FUNC_MAPr_CLR
#define LED_FUNC_MAPr_SET BCM53262_A0_LED_FUNC_MAPr_SET
#define LED_FUNC_MAPr_GET BCM53262_A0_LED_FUNC_MAPr_GET
#define LED_FUNC_MAPr_RESERVED_0Rf_GET BCM53262_A0_LED_FUNC_MAPr_RESERVED_0Rf_GET
#define LED_FUNC_MAPr_RESERVED_0Rf_SET BCM53262_A0_LED_FUNC_MAPr_RESERVED_0Rf_SET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_GET BCM53262_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_SET BCM53262_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET
#define LED_FUNC_MAPr_RESERVED_1Rf_GET BCM53262_A0_LED_FUNC_MAPr_RESERVED_1Rf_GET
#define LED_FUNC_MAPr_RESERVED_1Rf_SET BCM53262_A0_LED_FUNC_MAPr_RESERVED_1Rf_SET
#define READ_LED_FUNC_MAPr BCM53262_A0_READ_LED_FUNC_MAPr
#define WRITE_LED_FUNC_MAPr BCM53262_A0_WRITE_LED_FUNC_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LED_FUNC_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LED_MODE_MAP_0
 * BLOCKS:   SYS
 * DESC:     LED Mode map 0 register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     LED_MODE_MAP     Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_LED_MODE_MAP_0r 0x00000070

#define BCM53262_A0_LED_MODE_MAP_0r_SIZE 8

/*
 * This structure should be used to declare and program LED_MODE_MAP_0.
 */
typedef union BCM53262_A0_LED_MODE_MAP_0r_s {
	uint32_t v[2];
	uint32_t led_mode_map_0[2];
	uint32_t _led_mode_map_0;
} BCM53262_A0_LED_MODE_MAP_0r_t;

#define BCM53262_A0_LED_MODE_MAP_0r_CLR(r) CDK_MEMSET(&((r)._led_mode_map_0), 0, sizeof(BCM53262_A0_LED_MODE_MAP_0r_t))
#define BCM53262_A0_LED_MODE_MAP_0r_SET(r,i,d) (r).led_mode_map_0[i] = d
#define BCM53262_A0_LED_MODE_MAP_0r_GET(r,i) (r).led_mode_map_0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LED_MODE_MAP_0r_RESERVED_0Rf_GET(r) (((r).led_mode_map_0[0]) & 0xffffff)
#define BCM53262_A0_LED_MODE_MAP_0r_RESERVED_0Rf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET(r) cdk_field32_get((r).led_mode_map_0,24,52)
#define BCM53262_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET(r,f) cdk_field32_set((r).led_mode_map_0,24,52,f)
#define BCM53262_A0_LED_MODE_MAP_0r_RESERVED_1Rf_GET(r) ((((r).led_mode_map_0[1]) >> 21) & 0x7ff)
#define BCM53262_A0_LED_MODE_MAP_0r_RESERVED_1Rf_SET(r,f) (r).led_mode_map_0[1]=(((r).led_mode_map_0[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access LED_MODE_MAP_0.
 */
#define BCM53262_A0_READ_LED_MODE_MAP_0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_LED_MODE_MAP_0r,(r._led_mode_map_0),8)
#define BCM53262_A0_WRITE_LED_MODE_MAP_0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_LED_MODE_MAP_0r,&(r._led_mode_map_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_0r BCM53262_A0_LED_MODE_MAP_0r
#define LED_MODE_MAP_0r_SIZE BCM53262_A0_LED_MODE_MAP_0r_SIZE
typedef BCM53262_A0_LED_MODE_MAP_0r_t LED_MODE_MAP_0r_t;
#define LED_MODE_MAP_0r_CLR BCM53262_A0_LED_MODE_MAP_0r_CLR
#define LED_MODE_MAP_0r_SET BCM53262_A0_LED_MODE_MAP_0r_SET
#define LED_MODE_MAP_0r_GET BCM53262_A0_LED_MODE_MAP_0r_GET
#define LED_MODE_MAP_0r_RESERVED_0Rf_GET BCM53262_A0_LED_MODE_MAP_0r_RESERVED_0Rf_GET
#define LED_MODE_MAP_0r_RESERVED_0Rf_SET BCM53262_A0_LED_MODE_MAP_0r_RESERVED_0Rf_SET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_GET BCM53262_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_SET BCM53262_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_0r_RESERVED_1Rf_GET BCM53262_A0_LED_MODE_MAP_0r_RESERVED_1Rf_GET
#define LED_MODE_MAP_0r_RESERVED_1Rf_SET BCM53262_A0_LED_MODE_MAP_0r_RESERVED_1Rf_SET
#define READ_LED_MODE_MAP_0r BCM53262_A0_READ_LED_MODE_MAP_0r
#define WRITE_LED_MODE_MAP_0r BCM53262_A0_WRITE_LED_MODE_MAP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LED_MODE_MAP_0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LED_MODE_MAP_1
 * BLOCKS:   SYS
 * DESC:     LED Mode map 1 register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     LED_MODE_MAP     Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_LED_MODE_MAP_1r 0x00000078

#define BCM53262_A0_LED_MODE_MAP_1r_SIZE 8

/*
 * This structure should be used to declare and program LED_MODE_MAP_1.
 */
typedef union BCM53262_A0_LED_MODE_MAP_1r_s {
	uint32_t v[2];
	uint32_t led_mode_map_1[2];
	uint32_t _led_mode_map_1;
} BCM53262_A0_LED_MODE_MAP_1r_t;

#define BCM53262_A0_LED_MODE_MAP_1r_CLR(r) CDK_MEMSET(&((r)._led_mode_map_1), 0, sizeof(BCM53262_A0_LED_MODE_MAP_1r_t))
#define BCM53262_A0_LED_MODE_MAP_1r_SET(r,i,d) (r).led_mode_map_1[i] = d
#define BCM53262_A0_LED_MODE_MAP_1r_GET(r,i) (r).led_mode_map_1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LED_MODE_MAP_1r_RESERVED_0Rf_GET(r) (((r).led_mode_map_1[0]) & 0xffffff)
#define BCM53262_A0_LED_MODE_MAP_1r_RESERVED_0Rf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET(r) cdk_field32_get((r).led_mode_map_1,24,52)
#define BCM53262_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET(r,f) cdk_field32_set((r).led_mode_map_1,24,52,f)
#define BCM53262_A0_LED_MODE_MAP_1r_RESERVED_1Rf_GET(r) ((((r).led_mode_map_1[1]) >> 21) & 0x7ff)
#define BCM53262_A0_LED_MODE_MAP_1r_RESERVED_1Rf_SET(r,f) (r).led_mode_map_1[1]=(((r).led_mode_map_1[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access LED_MODE_MAP_1.
 */
#define BCM53262_A0_READ_LED_MODE_MAP_1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_LED_MODE_MAP_1r,(r._led_mode_map_1),8)
#define BCM53262_A0_WRITE_LED_MODE_MAP_1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_LED_MODE_MAP_1r,&(r._led_mode_map_1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_1r BCM53262_A0_LED_MODE_MAP_1r
#define LED_MODE_MAP_1r_SIZE BCM53262_A0_LED_MODE_MAP_1r_SIZE
typedef BCM53262_A0_LED_MODE_MAP_1r_t LED_MODE_MAP_1r_t;
#define LED_MODE_MAP_1r_CLR BCM53262_A0_LED_MODE_MAP_1r_CLR
#define LED_MODE_MAP_1r_SET BCM53262_A0_LED_MODE_MAP_1r_SET
#define LED_MODE_MAP_1r_GET BCM53262_A0_LED_MODE_MAP_1r_GET
#define LED_MODE_MAP_1r_RESERVED_0Rf_GET BCM53262_A0_LED_MODE_MAP_1r_RESERVED_0Rf_GET
#define LED_MODE_MAP_1r_RESERVED_0Rf_SET BCM53262_A0_LED_MODE_MAP_1r_RESERVED_0Rf_SET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_GET BCM53262_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_SET BCM53262_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_1r_RESERVED_1Rf_GET BCM53262_A0_LED_MODE_MAP_1r_RESERVED_1Rf_GET
#define LED_MODE_MAP_1r_RESERVED_1Rf_SET BCM53262_A0_LED_MODE_MAP_1r_RESERVED_1Rf_SET
#define READ_LED_MODE_MAP_1r BCM53262_A0_READ_LED_MODE_MAP_1r
#define WRITE_LED_MODE_MAP_1r BCM53262_A0_WRITE_LED_MODE_MAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LED_MODE_MAP_1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LNKSTS
 * BLOCKS:   SYS
 * DESC:     LinkStatus Summary Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     LNK_STS          Link Status.53bit field indicating the Link Status for each 10/ 100BASE-T port, IMP port, giga g0 ~ g3 (bits 0-47 = 10/ 100BASE-T ports, bit 48 = IMP Port, bit49 = giga g0, bit50= giga g1, bit51 = giga g2, bit52= giga g3 ).0 = Link Fail1 = Link PassNote that link status for the IMP port can only be reported for an external transceiver by:(a) using the LINK# pin to pass the transceiver's state to the BCM5348M:(b) using the CPU to read the link status via the MDC/ MDIO interface and write this back to the IMP Port Status Override register.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_LNKSTSr 0x00000210

#define BCM53262_A0_LNKSTSr_SIZE 8

/*
 * This structure should be used to declare and program LNKSTS.
 */
typedef union BCM53262_A0_LNKSTSr_s {
	uint32_t v[2];
	uint32_t lnksts[2];
	uint32_t _lnksts;
} BCM53262_A0_LNKSTSr_t;

#define BCM53262_A0_LNKSTSr_CLR(r) CDK_MEMSET(&((r)._lnksts), 0, sizeof(BCM53262_A0_LNKSTSr_t))
#define BCM53262_A0_LNKSTSr_SET(r,i,d) (r).lnksts[i] = d
#define BCM53262_A0_LNKSTSr_GET(r,i) (r).lnksts[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LNKSTSr_RESERVED_0Rf_GET(r) (((r).lnksts[0]) & 0xffffff)
#define BCM53262_A0_LNKSTSr_RESERVED_0Rf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_LNKSTSr_LNK_STSf_GET(r) cdk_field32_get((r).lnksts,24,52)
#define BCM53262_A0_LNKSTSr_LNK_STSf_SET(r,f) cdk_field32_set((r).lnksts,24,52,f)
#define BCM53262_A0_LNKSTSr_RESERVED_1Rf_GET(r) ((((r).lnksts[1]) >> 21) & 0x7ff)
#define BCM53262_A0_LNKSTSr_RESERVED_1Rf_SET(r,f) (r).lnksts[1]=(((r).lnksts[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access LNKSTS.
 */
#define BCM53262_A0_READ_LNKSTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LNKSTSr,(r._lnksts),8)
#define BCM53262_A0_WRITE_LNKSTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LNKSTSr,&(r._lnksts),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSr BCM53262_A0_LNKSTSr
#define LNKSTSr_SIZE BCM53262_A0_LNKSTSr_SIZE
typedef BCM53262_A0_LNKSTSr_t LNKSTSr_t;
#define LNKSTSr_CLR BCM53262_A0_LNKSTSr_CLR
#define LNKSTSr_SET BCM53262_A0_LNKSTSr_SET
#define LNKSTSr_GET BCM53262_A0_LNKSTSr_GET
#define LNKSTSr_RESERVED_0Rf_GET BCM53262_A0_LNKSTSr_RESERVED_0Rf_GET
#define LNKSTSr_RESERVED_0Rf_SET BCM53262_A0_LNKSTSr_RESERVED_0Rf_SET
#define LNKSTSr_LNK_STSf_GET BCM53262_A0_LNKSTSr_LNK_STSf_GET
#define LNKSTSr_LNK_STSf_SET BCM53262_A0_LNKSTSr_LNK_STSf_SET
#define LNKSTSr_RESERVED_1Rf_GET BCM53262_A0_LNKSTSr_RESERVED_1Rf_GET
#define LNKSTSr_RESERVED_1Rf_SET BCM53262_A0_LNKSTSr_RESERVED_1Rf_SET
#define READ_LNKSTSr BCM53262_A0_READ_LNKSTSr
#define WRITE_LNKSTSr BCM53262_A0_WRITE_LNKSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LNKSTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LNKSTSCHG
 * BLOCKS:   SYS
 * DESC:     Link Status Change Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     LNK_STS_CHG      Link Status Change.53 bit field indicating that the Link Status for an individual 10/100BASE-T port , IMP port, giga g0~g3 had changed since the last read operation (bits 0-47 = 10/100BASE- T ports, bit 48 = IMP Port, bit49 = giga g0, bit50 = giga g1, bit51 = giga g2, bit52 = giga g3). Upon change of link status, a bit remains set until cleared by a read operation.0 = Link Status Constant1 = Link Status ChangeNote that link status change for the IMP port can only be reported for an external transceiver by:(a) using the LINK# pin to pass the transceiver's state to the BCM5348M:(b) using the CPU to read the link status via the MDC/ MDIO interface and write this back to the IMP Port Status Override register.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_LNKSTSCHGr 0x00000218

#define BCM53262_A0_LNKSTSCHGr_SIZE 8

/*
 * This structure should be used to declare and program LNKSTSCHG.
 */
typedef union BCM53262_A0_LNKSTSCHGr_s {
	uint32_t v[2];
	uint32_t lnkstschg[2];
	uint32_t _lnkstschg;
} BCM53262_A0_LNKSTSCHGr_t;

#define BCM53262_A0_LNKSTSCHGr_CLR(r) CDK_MEMSET(&((r)._lnkstschg), 0, sizeof(BCM53262_A0_LNKSTSCHGr_t))
#define BCM53262_A0_LNKSTSCHGr_SET(r,i,d) (r).lnkstschg[i] = d
#define BCM53262_A0_LNKSTSCHGr_GET(r,i) (r).lnkstschg[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LNKSTSCHGr_RESERVED_0Rf_GET(r) (((r).lnkstschg[0]) & 0xffffff)
#define BCM53262_A0_LNKSTSCHGr_RESERVED_0Rf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_LNKSTSCHGr_LNK_STS_CHGf_GET(r) cdk_field32_get((r).lnkstschg,24,52)
#define BCM53262_A0_LNKSTSCHGr_LNK_STS_CHGf_SET(r,f) cdk_field32_set((r).lnkstschg,24,52,f)
#define BCM53262_A0_LNKSTSCHGr_RESERVED_1Rf_GET(r) ((((r).lnkstschg[1]) >> 21) & 0x7ff)
#define BCM53262_A0_LNKSTSCHGr_RESERVED_1Rf_SET(r,f) (r).lnkstschg[1]=(((r).lnkstschg[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access LNKSTSCHG.
 */
#define BCM53262_A0_READ_LNKSTSCHGr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LNKSTSCHGr,(r._lnkstschg),8)
#define BCM53262_A0_WRITE_LNKSTSCHGr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LNKSTSCHGr,&(r._lnkstschg),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSCHGr BCM53262_A0_LNKSTSCHGr
#define LNKSTSCHGr_SIZE BCM53262_A0_LNKSTSCHGr_SIZE
typedef BCM53262_A0_LNKSTSCHGr_t LNKSTSCHGr_t;
#define LNKSTSCHGr_CLR BCM53262_A0_LNKSTSCHGr_CLR
#define LNKSTSCHGr_SET BCM53262_A0_LNKSTSCHGr_SET
#define LNKSTSCHGr_GET BCM53262_A0_LNKSTSCHGr_GET
#define LNKSTSCHGr_RESERVED_0Rf_GET BCM53262_A0_LNKSTSCHGr_RESERVED_0Rf_GET
#define LNKSTSCHGr_RESERVED_0Rf_SET BCM53262_A0_LNKSTSCHGr_RESERVED_0Rf_SET
#define LNKSTSCHGr_LNK_STS_CHGf_GET BCM53262_A0_LNKSTSCHGr_LNK_STS_CHGf_GET
#define LNKSTSCHGr_LNK_STS_CHGf_SET BCM53262_A0_LNKSTSCHGr_LNK_STS_CHGf_SET
#define LNKSTSCHGr_RESERVED_1Rf_GET BCM53262_A0_LNKSTSCHGr_RESERVED_1Rf_GET
#define LNKSTSCHGr_RESERVED_1Rf_SET BCM53262_A0_LNKSTSCHGr_RESERVED_1Rf_SET
#define READ_LNKSTSCHGr BCM53262_A0_READ_LNKSTSCHGr
#define WRITE_LNKSTSCHGr BCM53262_A0_WRITE_LNKSTSCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LNKSTSCHGr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LPNXP
 * BLOCKS:   EPIC0
 * DESC:     Link Partner next Page Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_LPNXPr 0x0000a010

#define BCM53262_A0_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program LPNXP.
 */
typedef union BCM53262_A0_LPNXPr_s {
	uint32_t v[1];
	uint32_t lpnxp[1];
	uint32_t _lpnxp;
} BCM53262_A0_LPNXPr_t;

#define BCM53262_A0_LPNXPr_CLR(r) (r).lpnxp[0] = 0
#define BCM53262_A0_LPNXPr_SET(r,d) (r).lpnxp[0] = d
#define BCM53262_A0_LPNXPr_GET(r) (r).lpnxp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LPNXPr_RESERVED_Rf_GET(r) (((r).lpnxp[0]) & 0xffff)
#define BCM53262_A0_LPNXPr_RESERVED_Rf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LPNXP.
 */
#define BCM53262_A0_READ_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_LPNXPr,(r._lpnxp),2)
#define BCM53262_A0_WRITE_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_LPNXPr,&(r._lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPNXPr BCM53262_A0_LPNXPr
#define LPNXPr_SIZE BCM53262_A0_LPNXPr_SIZE
typedef BCM53262_A0_LPNXPr_t LPNXPr_t;
#define LPNXPr_CLR BCM53262_A0_LPNXPr_CLR
#define LPNXPr_SET BCM53262_A0_LPNXPr_SET
#define LPNXPr_GET BCM53262_A0_LPNXPr_GET
#define LPNXPr_RESERVED_Rf_GET BCM53262_A0_LPNXPr_RESERVED_Rf_GET
#define LPNXPr_RESERVED_Rf_SET BCM53262_A0_LPNXPr_RESERVED_Rf_SET
#define READ_LPNXPr BCM53262_A0_READ_LPNXPr
#define WRITE_LPNXPr BCM53262_A0_WRITE_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LPNXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LP_STA_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port Link Partners Link Status Register
 * SIZE:     16
 * FIELDS:
 *     MR_LP_ADV_ABILITY Link partner's link code word.1. When SGMII Mode:if mac_mode = 0, refer to tx_config_reg[15:0] from MAC to PHY in SGMII Specificationif mac_mode = 1, refer to tx_config_reg[15:0]from PHY to MAC in SGMII Specification2. When Fiber modeData is from link partner
 */
#define BCM53262_A0_LP_STA_GPr 0x00190d58

#define BCM53262_A0_LP_STA_GPr_SIZE 2

/*
 * This structure should be used to declare and program LP_STA_GP.
 */
typedef union BCM53262_A0_LP_STA_GPr_s {
	uint32_t v[1];
	uint32_t lp_sta_gp[1];
	uint32_t _lp_sta_gp;
} BCM53262_A0_LP_STA_GPr_t;

#define BCM53262_A0_LP_STA_GPr_CLR(r) (r).lp_sta_gp[0] = 0
#define BCM53262_A0_LP_STA_GPr_SET(r,d) (r).lp_sta_gp[0] = d
#define BCM53262_A0_LP_STA_GPr_GET(r) (r).lp_sta_gp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LP_STA_GPr_MR_LP_ADV_ABILITYf_GET(r) (((r).lp_sta_gp[0]) & 0xffff)
#define BCM53262_A0_LP_STA_GPr_MR_LP_ADV_ABILITYf_SET(r,f) (r).lp_sta_gp[0]=(((r).lp_sta_gp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_STA_GP.
 */
#define BCM53262_A0_READ_LP_STA_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_LP_STA_GPr,(r._lp_sta_gp),2)
#define BCM53262_A0_WRITE_LP_STA_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_LP_STA_GPr,&(r._lp_sta_gp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LP_STA_GPr BCM53262_A0_LP_STA_GPr
#define LP_STA_GPr_SIZE BCM53262_A0_LP_STA_GPr_SIZE
typedef BCM53262_A0_LP_STA_GPr_t LP_STA_GPr_t;
#define LP_STA_GPr_CLR BCM53262_A0_LP_STA_GPr_CLR
#define LP_STA_GPr_SET BCM53262_A0_LP_STA_GPr_SET
#define LP_STA_GPr_GET BCM53262_A0_LP_STA_GPr_GET
#define LP_STA_GPr_MR_LP_ADV_ABILITYf_GET BCM53262_A0_LP_STA_GPr_MR_LP_ADV_ABILITYf_GET
#define LP_STA_GPr_MR_LP_ADV_ABILITYf_SET BCM53262_A0_LP_STA_GPr_MR_LP_ADV_ABILITYf_SET
#define READ_LP_STA_GPr BCM53262_A0_READ_LP_STA_GPr
#define WRITE_LP_STA_GPr BCM53262_A0_WRITE_LP_STA_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LP_STA_GPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  LRN_CNT_CTL
 * BLOCKS:   SYS
 * DESC:     Learning Counter Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_NUM_R       Port number.
 *     RESERVED_R       Reserved
 *     ACC_CTL          Access control00 : No operation.01 : Increase by 1 in corresponding port.10 : Decrease by 1 in corresponding port.11 : Reset to 0 in corresponding port
 *     START_DONE       Start/Done command.  Write 1'b1 to initial software learning counter control.It will be reset when finished.
 */
#define BCM53262_A0_LRN_CNT_CTLr 0x00004118

#define BCM53262_A0_LRN_CNT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LRN_CNT_CTL.
 */
typedef union BCM53262_A0_LRN_CNT_CTLr_s {
	uint32_t v[1];
	uint32_t lrn_cnt_ctl[1];
	uint32_t _lrn_cnt_ctl;
} BCM53262_A0_LRN_CNT_CTLr_t;

#define BCM53262_A0_LRN_CNT_CTLr_CLR(r) (r).lrn_cnt_ctl[0] = 0
#define BCM53262_A0_LRN_CNT_CTLr_SET(r,d) (r).lrn_cnt_ctl[0] = d
#define BCM53262_A0_LRN_CNT_CTLr_GET(r) (r).lrn_cnt_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_LRN_CNT_CTLr_PORT_NUM_Rf_GET(r) (((r).lrn_cnt_ctl[0]) & 0x3f)
#define BCM53262_A0_LRN_CNT_CTLr_PORT_NUM_Rf_SET(r,f) (r).lrn_cnt_ctl[0]=(((r).lrn_cnt_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_LRN_CNT_CTLr_RESERVED_Rf_GET(r) ((((r).lrn_cnt_ctl[0]) >> 6) & 0x7f)
#define BCM53262_A0_LRN_CNT_CTLr_RESERVED_Rf_SET(r,f) (r).lrn_cnt_ctl[0]=(((r).lrn_cnt_ctl[0] & ~((uint32_t)0x7f << 6)) | ((((uint32_t)f) & 0x7f) << 6))
#define BCM53262_A0_LRN_CNT_CTLr_ACC_CTLf_GET(r) ((((r).lrn_cnt_ctl[0]) >> 13) & 0x3)
#define BCM53262_A0_LRN_CNT_CTLr_ACC_CTLf_SET(r,f) (r).lrn_cnt_ctl[0]=(((r).lrn_cnt_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53262_A0_LRN_CNT_CTLr_START_DONEf_GET(r) ((((r).lrn_cnt_ctl[0]) >> 15) & 0x1)
#define BCM53262_A0_LRN_CNT_CTLr_START_DONEf_SET(r,f) (r).lrn_cnt_ctl[0]=(((r).lrn_cnt_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access LRN_CNT_CTL.
 */
#define BCM53262_A0_READ_LRN_CNT_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_LRN_CNT_CTLr,(r._lrn_cnt_ctl),2)
#define BCM53262_A0_WRITE_LRN_CNT_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_LRN_CNT_CTLr,&(r._lrn_cnt_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LRN_CNT_CTLr BCM53262_A0_LRN_CNT_CTLr
#define LRN_CNT_CTLr_SIZE BCM53262_A0_LRN_CNT_CTLr_SIZE
typedef BCM53262_A0_LRN_CNT_CTLr_t LRN_CNT_CTLr_t;
#define LRN_CNT_CTLr_CLR BCM53262_A0_LRN_CNT_CTLr_CLR
#define LRN_CNT_CTLr_SET BCM53262_A0_LRN_CNT_CTLr_SET
#define LRN_CNT_CTLr_GET BCM53262_A0_LRN_CNT_CTLr_GET
#define LRN_CNT_CTLr_PORT_NUM_Rf_GET BCM53262_A0_LRN_CNT_CTLr_PORT_NUM_Rf_GET
#define LRN_CNT_CTLr_PORT_NUM_Rf_SET BCM53262_A0_LRN_CNT_CTLr_PORT_NUM_Rf_SET
#define LRN_CNT_CTLr_RESERVED_Rf_GET BCM53262_A0_LRN_CNT_CTLr_RESERVED_Rf_GET
#define LRN_CNT_CTLr_RESERVED_Rf_SET BCM53262_A0_LRN_CNT_CTLr_RESERVED_Rf_SET
#define LRN_CNT_CTLr_ACC_CTLf_GET BCM53262_A0_LRN_CNT_CTLr_ACC_CTLf_GET
#define LRN_CNT_CTLr_ACC_CTLf_SET BCM53262_A0_LRN_CNT_CTLr_ACC_CTLf_SET
#define LRN_CNT_CTLr_START_DONEf_GET BCM53262_A0_LRN_CNT_CTLr_START_DONEf_GET
#define LRN_CNT_CTLr_START_DONEf_SET BCM53262_A0_LRN_CNT_CTLr_START_DONEf_SET
#define READ_LRN_CNT_CTLr BCM53262_A0_READ_LRN_CNT_CTLr
#define WRITE_LRN_CNT_CTLr BCM53262_A0_WRITE_LRN_CNT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_LRN_CNT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  MAC2VLAN
 * BLOCKS:   SYS
 * DESC:     Statistic RAM
 * SIZE:     64
 * FIELDS:
 *     MACADDR          MAC addr
 *     VID_R            Vlan id
 *     PRI_R            Prioritye
 *     VALID_R          Valid bit
 */
#define BCM53262_A0_MAC2VLANm 0x40050538

#define BCM53262_A0_MAC2VLANm_MIN 0
#define BCM53262_A0_MAC2VLANm_MAX 511
#define BCM53262_A0_MAC2VLANm_CMAX(u) 511
#define BCM53262_A0_MAC2VLANm_SIZE 8

/*
 * This structure should be used to declare and program MAC2VLAN.
 */
typedef union BCM53262_A0_MAC2VLANm_s {
	uint32_t v[2];
	uint32_t mac2vlan[2];
	uint32_t _mac2vlan;
} BCM53262_A0_MAC2VLANm_t;

#define BCM53262_A0_MAC2VLANm_CLR(r) CDK_MEMSET(&((r)._mac2vlan), 0, sizeof(BCM53262_A0_MAC2VLANm_t))
#define BCM53262_A0_MAC2VLANm_SET(r,i,d) (r).mac2vlan[i] = d
#define BCM53262_A0_MAC2VLANm_GET(r,i) (r).mac2vlan[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MAC2VLANm_MACADDRf_GET(r,a) cdk_field_get((r).mac2vlan,0,47,a)
#define BCM53262_A0_MAC2VLANm_MACADDRf_SET(r,a) cdk_field_set((r).mac2vlan,0,47,a)
#define BCM53262_A0_MAC2VLANm_VID_Rf_GET(r) ((((r).mac2vlan[1]) >> 16) & 0xfff)
#define BCM53262_A0_MAC2VLANm_VID_Rf_SET(r,f) (r).mac2vlan[1]=(((r).mac2vlan[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53262_A0_MAC2VLANm_PRI_Rf_GET(r) ((((r).mac2vlan[1]) >> 28) & 0x7)
#define BCM53262_A0_MAC2VLANm_PRI_Rf_SET(r,f) (r).mac2vlan[1]=(((r).mac2vlan[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53262_A0_MAC2VLANm_VALID_Rf_GET(r) ((((r).mac2vlan[1]) >> 31) & 0x1)
#define BCM53262_A0_MAC2VLANm_VALID_Rf_SET(r,f) (r).mac2vlan[1]=(((r).mac2vlan[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MAC2VLAN.
 */
#define BCM53262_A0_READ_MAC2VLANm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_MAC2VLANm,i,(m),8)
#define BCM53262_A0_WRITE_MAC2VLANm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_MAC2VLANm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC2VLANm BCM53262_A0_MAC2VLANm
#define MAC2VLANm_MIN BCM53262_A0_MAC2VLANm_MIN
#define MAC2VLANm_MAX BCM53262_A0_MAC2VLANm_MAX
#define MAC2VLANm_CMAX(u) BCM53262_A0_MAC2VLANm_CMAX(u)
#define MAC2VLANm_SIZE BCM53262_A0_MAC2VLANm_SIZE
typedef BCM53262_A0_MAC2VLANm_t MAC2VLANm_t;
#define MAC2VLANm_CLR BCM53262_A0_MAC2VLANm_CLR
#define MAC2VLANm_SET BCM53262_A0_MAC2VLANm_SET
#define MAC2VLANm_GET BCM53262_A0_MAC2VLANm_GET
#define MAC2VLANm_MACADDRf_GET BCM53262_A0_MAC2VLANm_MACADDRf_GET
#define MAC2VLANm_MACADDRf_SET BCM53262_A0_MAC2VLANm_MACADDRf_SET
#define MAC2VLANm_VID_Rf_GET BCM53262_A0_MAC2VLANm_VID_Rf_GET
#define MAC2VLANm_VID_Rf_SET BCM53262_A0_MAC2VLANm_VID_Rf_SET
#define MAC2VLANm_PRI_Rf_GET BCM53262_A0_MAC2VLANm_PRI_Rf_GET
#define MAC2VLANm_PRI_Rf_SET BCM53262_A0_MAC2VLANm_PRI_Rf_SET
#define MAC2VLANm_VALID_Rf_GET BCM53262_A0_MAC2VLANm_VALID_Rf_GET
#define MAC2VLANm_VALID_Rf_SET BCM53262_A0_MAC2VLANm_VALID_Rf_SET
#define READ_MAC2VLANm BCM53262_A0_READ_MAC2VLANm
#define WRITE_MAC2VLANm BCM53262_A0_WRITE_MAC2VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MAC2VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MAC2VLAN_CTL
 * BLOCKS:   SYS
 * DESC:     MAC2VLAN Control Registers
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     MAC2VLAN_CTL     MAC2VLAN Control Registers.When set to 1, enable MAC2VLAN table lookup.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_MAC2VLAN_CTLr 0x000034a8

#define BCM53262_A0_MAC2VLAN_CTLr_SIZE 8

/*
 * This structure should be used to declare and program MAC2VLAN_CTL.
 */
typedef union BCM53262_A0_MAC2VLAN_CTLr_s {
	uint32_t v[2];
	uint32_t mac2vlan_ctl[2];
	uint32_t _mac2vlan_ctl;
} BCM53262_A0_MAC2VLAN_CTLr_t;

#define BCM53262_A0_MAC2VLAN_CTLr_CLR(r) CDK_MEMSET(&((r)._mac2vlan_ctl), 0, sizeof(BCM53262_A0_MAC2VLAN_CTLr_t))
#define BCM53262_A0_MAC2VLAN_CTLr_SET(r,i,d) (r).mac2vlan_ctl[i] = d
#define BCM53262_A0_MAC2VLAN_CTLr_GET(r,i) (r).mac2vlan_ctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MAC2VLAN_CTLr_RESERVED_0Rf_GET(r) (((r).mac2vlan_ctl[0]) & 0xffffff)
#define BCM53262_A0_MAC2VLAN_CTLr_RESERVED_0Rf_SET(r,f) (r).mac2vlan_ctl[0]=(((r).mac2vlan_ctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_MAC2VLAN_CTLr_MAC2VLAN_CTLf_GET(r) cdk_field32_get((r).mac2vlan_ctl,24,52)
#define BCM53262_A0_MAC2VLAN_CTLr_MAC2VLAN_CTLf_SET(r,f) cdk_field32_set((r).mac2vlan_ctl,24,52,f)
#define BCM53262_A0_MAC2VLAN_CTLr_RESERVED_1Rf_GET(r) ((((r).mac2vlan_ctl[1]) >> 21) & 0x7ff)
#define BCM53262_A0_MAC2VLAN_CTLr_RESERVED_1Rf_SET(r,f) (r).mac2vlan_ctl[1]=(((r).mac2vlan_ctl[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access MAC2VLAN_CTL.
 */
#define BCM53262_A0_READ_MAC2VLAN_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MAC2VLAN_CTLr,(r._mac2vlan_ctl),8)
#define BCM53262_A0_WRITE_MAC2VLAN_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MAC2VLAN_CTLr,&(r._mac2vlan_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC2VLAN_CTLr BCM53262_A0_MAC2VLAN_CTLr
#define MAC2VLAN_CTLr_SIZE BCM53262_A0_MAC2VLAN_CTLr_SIZE
typedef BCM53262_A0_MAC2VLAN_CTLr_t MAC2VLAN_CTLr_t;
#define MAC2VLAN_CTLr_CLR BCM53262_A0_MAC2VLAN_CTLr_CLR
#define MAC2VLAN_CTLr_SET BCM53262_A0_MAC2VLAN_CTLr_SET
#define MAC2VLAN_CTLr_GET BCM53262_A0_MAC2VLAN_CTLr_GET
#define MAC2VLAN_CTLr_RESERVED_0Rf_GET BCM53262_A0_MAC2VLAN_CTLr_RESERVED_0Rf_GET
#define MAC2VLAN_CTLr_RESERVED_0Rf_SET BCM53262_A0_MAC2VLAN_CTLr_RESERVED_0Rf_SET
#define MAC2VLAN_CTLr_MAC2VLAN_CTLf_GET BCM53262_A0_MAC2VLAN_CTLr_MAC2VLAN_CTLf_GET
#define MAC2VLAN_CTLr_MAC2VLAN_CTLf_SET BCM53262_A0_MAC2VLAN_CTLr_MAC2VLAN_CTLf_SET
#define MAC2VLAN_CTLr_RESERVED_1Rf_GET BCM53262_A0_MAC2VLAN_CTLr_RESERVED_1Rf_GET
#define MAC2VLAN_CTLr_RESERVED_1Rf_SET BCM53262_A0_MAC2VLAN_CTLr_RESERVED_1Rf_SET
#define READ_MAC2VLAN_CTLr BCM53262_A0_READ_MAC2VLAN_CTLr
#define WRITE_MAC2VLAN_CTLr BCM53262_A0_WRITE_MAC2VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MAC2VLAN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  MARL_PBMP
 * BLOCKS:   SYS
 * DESC:     MARL PortBitmap Table
 * SIZE:     192
 * FIELDS:
 *     RESERVED0_R      Reserved
 *     PBMP_R           Even Mcast pbmp entry
 *     RESERVED1_R      Reserved
 */
#define BCM53262_A0_MARL_PBMPm 0x40020538

#define BCM53262_A0_MARL_PBMPm_MIN 0
#define BCM53262_A0_MARL_PBMPm_MAX 4095
#define BCM53262_A0_MARL_PBMPm_CMAX(u) 4095
#define BCM53262_A0_MARL_PBMPm_SIZE 24

/*
 * This structure should be used to declare and program MARL_PBMP.
 */
typedef union BCM53262_A0_MARL_PBMPm_s {
	uint32_t v[6];
	uint32_t marl_pbmp[6];
	uint32_t _marl_pbmp;
} BCM53262_A0_MARL_PBMPm_t;

#define BCM53262_A0_MARL_PBMPm_CLR(r) CDK_MEMSET(&((r)._marl_pbmp), 0, sizeof(BCM53262_A0_MARL_PBMPm_t))
#define BCM53262_A0_MARL_PBMPm_SET(r,i,d) (r).marl_pbmp[i] = d
#define BCM53262_A0_MARL_PBMPm_GET(r,i) (r).marl_pbmp[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MARL_PBMPm_RESERVED0_Rf_GET(r) (((r).marl_pbmp[0]) & 0xffffff)
#define BCM53262_A0_MARL_PBMPm_RESERVED0_Rf_SET(r,f) (r).marl_pbmp[0]=(((r).marl_pbmp[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_MARL_PBMPm_PBMP_Rf_GET(r) cdk_field32_get((r).marl_pbmp,24,52)
#define BCM53262_A0_MARL_PBMPm_PBMP_Rf_SET(r,f) cdk_field32_set((r).marl_pbmp,24,52,f)
#define BCM53262_A0_MARL_PBMPm_RESERVED1_Rf_GET(r,a) cdk_field_get((r).marl_pbmp,53,191,a)
#define BCM53262_A0_MARL_PBMPm_RESERVED1_Rf_SET(r,a) cdk_field_set((r).marl_pbmp,53,191,a)

/*
 * These macros can be used to access MARL_PBMP.
 */
#define BCM53262_A0_READ_MARL_PBMPm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_MARL_PBMPm,i,(m),24)
#define BCM53262_A0_WRITE_MARL_PBMPm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_MARL_PBMPm,i,&(m),24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARL_PBMPm BCM53262_A0_MARL_PBMPm
#define MARL_PBMPm_MIN BCM53262_A0_MARL_PBMPm_MIN
#define MARL_PBMPm_MAX BCM53262_A0_MARL_PBMPm_MAX
#define MARL_PBMPm_CMAX(u) BCM53262_A0_MARL_PBMPm_CMAX(u)
#define MARL_PBMPm_SIZE BCM53262_A0_MARL_PBMPm_SIZE
typedef BCM53262_A0_MARL_PBMPm_t MARL_PBMPm_t;
#define MARL_PBMPm_CLR BCM53262_A0_MARL_PBMPm_CLR
#define MARL_PBMPm_SET BCM53262_A0_MARL_PBMPm_SET
#define MARL_PBMPm_GET BCM53262_A0_MARL_PBMPm_GET
#define MARL_PBMPm_RESERVED0_Rf_GET BCM53262_A0_MARL_PBMPm_RESERVED0_Rf_GET
#define MARL_PBMPm_RESERVED0_Rf_SET BCM53262_A0_MARL_PBMPm_RESERVED0_Rf_SET
#define MARL_PBMPm_PBMP_Rf_GET BCM53262_A0_MARL_PBMPm_PBMP_Rf_GET
#define MARL_PBMPm_PBMP_Rf_SET BCM53262_A0_MARL_PBMPm_PBMP_Rf_SET
#define MARL_PBMPm_RESERVED1_Rf_GET BCM53262_A0_MARL_PBMPm_RESERVED1_Rf_GET
#define MARL_PBMPm_RESERVED1_Rf_SET BCM53262_A0_MARL_PBMPm_RESERVED1_Rf_SET
#define READ_MARL_PBMPm BCM53262_A0_READ_MARL_PBMPm
#define WRITE_MARL_PBMPm BCM53262_A0_WRITE_MARL_PBMPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MARL_PBMPm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MDIO_BASE_ADDR
 * BLOCKS:   SYS
 * DESC:     SERDES MDIO Base Address Registrer
 * SIZE:     8
 * FIELDS:
 *     BASE_ADDR        SerDes MDIO SCAN Base ADDRESS.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_MDIO_BASE_ADDRr 0x000000b0

#define BCM53262_A0_MDIO_BASE_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_BASE_ADDR.
 */
typedef union BCM53262_A0_MDIO_BASE_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_base_addr[1];
	uint32_t _mdio_base_addr;
} BCM53262_A0_MDIO_BASE_ADDRr_t;

#define BCM53262_A0_MDIO_BASE_ADDRr_CLR(r) (r).mdio_base_addr[0] = 0
#define BCM53262_A0_MDIO_BASE_ADDRr_SET(r,d) (r).mdio_base_addr[0] = d
#define BCM53262_A0_MDIO_BASE_ADDRr_GET(r) (r).mdio_base_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MDIO_BASE_ADDRr_BASE_ADDRf_GET(r) (((r).mdio_base_addr[0]) & 0x1f)
#define BCM53262_A0_MDIO_BASE_ADDRr_BASE_ADDRf_SET(r,f) (r).mdio_base_addr[0]=(((r).mdio_base_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_MDIO_BASE_ADDRr_RESERVED_Rf_GET(r) ((((r).mdio_base_addr[0]) >> 5) & 0x7)
#define BCM53262_A0_MDIO_BASE_ADDRr_RESERVED_Rf_SET(r,f) (r).mdio_base_addr[0]=(((r).mdio_base_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_BASE_ADDR.
 */
#define BCM53262_A0_READ_MDIO_BASE_ADDRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MDIO_BASE_ADDRr,(r._mdio_base_addr),1)
#define BCM53262_A0_WRITE_MDIO_BASE_ADDRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MDIO_BASE_ADDRr,&(r._mdio_base_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BASE_ADDRr BCM53262_A0_MDIO_BASE_ADDRr
#define MDIO_BASE_ADDRr_SIZE BCM53262_A0_MDIO_BASE_ADDRr_SIZE
typedef BCM53262_A0_MDIO_BASE_ADDRr_t MDIO_BASE_ADDRr_t;
#define MDIO_BASE_ADDRr_CLR BCM53262_A0_MDIO_BASE_ADDRr_CLR
#define MDIO_BASE_ADDRr_SET BCM53262_A0_MDIO_BASE_ADDRr_SET
#define MDIO_BASE_ADDRr_GET BCM53262_A0_MDIO_BASE_ADDRr_GET
#define MDIO_BASE_ADDRr_BASE_ADDRf_GET BCM53262_A0_MDIO_BASE_ADDRr_BASE_ADDRf_GET
#define MDIO_BASE_ADDRr_BASE_ADDRf_SET BCM53262_A0_MDIO_BASE_ADDRr_BASE_ADDRf_SET
#define MDIO_BASE_ADDRr_RESERVED_Rf_GET BCM53262_A0_MDIO_BASE_ADDRr_RESERVED_Rf_GET
#define MDIO_BASE_ADDRr_RESERVED_Rf_SET BCM53262_A0_MDIO_BASE_ADDRr_RESERVED_Rf_SET
#define READ_MDIO_BASE_ADDRr BCM53262_A0_READ_MDIO_BASE_ADDRr
#define WRITE_MDIO_BASE_ADDRr BCM53262_A0_WRITE_MDIO_BASE_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MDIO_BASE_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MIBDIGA_PAGE
 * BLOCKS:   SYS
 * DESC:     MIBDIGA Registers
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_MIBDIGA_PAGEr 0x00000b00

#define BCM53262_A0_MIBDIGA_PAGEr_SIZE 2

/*
 * This structure should be used to declare and program MIBDIGA_PAGE.
 */
typedef union BCM53262_A0_MIBDIGA_PAGEr_s {
	uint32_t v[1];
	uint32_t mibdiga_page[1];
	uint32_t _mibdiga_page;
} BCM53262_A0_MIBDIGA_PAGEr_t;

#define BCM53262_A0_MIBDIGA_PAGEr_CLR(r) (r).mibdiga_page[0] = 0
#define BCM53262_A0_MIBDIGA_PAGEr_SET(r,d) (r).mibdiga_page[0] = d
#define BCM53262_A0_MIBDIGA_PAGEr_GET(r) (r).mibdiga_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MIBDIGA_PAGEr_RESERVED_Rf_GET(r) (((r).mibdiga_page[0]) & 0xffff)
#define BCM53262_A0_MIBDIGA_PAGEr_RESERVED_Rf_SET(r,f) (r).mibdiga_page[0]=(((r).mibdiga_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MIBDIGA_PAGE.
 */
#define BCM53262_A0_READ_MIBDIGA_PAGEr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MIBDIGA_PAGEr,(r._mibdiga_page),2)
#define BCM53262_A0_WRITE_MIBDIGA_PAGEr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MIBDIGA_PAGEr,&(r._mibdiga_page),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIBDIGA_PAGEr BCM53262_A0_MIBDIGA_PAGEr
#define MIBDIGA_PAGEr_SIZE BCM53262_A0_MIBDIGA_PAGEr_SIZE
typedef BCM53262_A0_MIBDIGA_PAGEr_t MIBDIGA_PAGEr_t;
#define MIBDIGA_PAGEr_CLR BCM53262_A0_MIBDIGA_PAGEr_CLR
#define MIBDIGA_PAGEr_SET BCM53262_A0_MIBDIGA_PAGEr_SET
#define MIBDIGA_PAGEr_GET BCM53262_A0_MIBDIGA_PAGEr_GET
#define MIBDIGA_PAGEr_RESERVED_Rf_GET BCM53262_A0_MIBDIGA_PAGEr_RESERVED_Rf_GET
#define MIBDIGA_PAGEr_RESERVED_Rf_SET BCM53262_A0_MIBDIGA_PAGEr_RESERVED_Rf_SET
#define READ_MIBDIGA_PAGEr BCM53262_A0_READ_MIBDIGA_PAGEr
#define WRITE_MIBDIGA_PAGEr BCM53262_A0_WRITE_MIBDIGA_PAGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MIBDIGA_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MIBKILLOVR
 * BLOCKS:   SYS
 * DESC:     MIB Kill Control Register
 * SIZE:     8
 * FIELDS:
 *     MEM_DAT_VID      When set this register to 3ch, all MIB counters will be disable.Note : Not to release this register to customers
 */
#define BCM53262_A0_MIBKILLOVRr 0x000008a0

#define BCM53262_A0_MIBKILLOVRr_SIZE 1

/*
 * This structure should be used to declare and program MIBKILLOVR.
 */
typedef union BCM53262_A0_MIBKILLOVRr_s {
	uint32_t v[1];
	uint32_t mibkillovr[1];
	uint32_t _mibkillovr;
} BCM53262_A0_MIBKILLOVRr_t;

#define BCM53262_A0_MIBKILLOVRr_CLR(r) (r).mibkillovr[0] = 0
#define BCM53262_A0_MIBKILLOVRr_SET(r,d) (r).mibkillovr[0] = d
#define BCM53262_A0_MIBKILLOVRr_GET(r) (r).mibkillovr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MIBKILLOVRr_MEM_DAT_VIDf_GET(r) (((r).mibkillovr[0]) & 0xff)
#define BCM53262_A0_MIBKILLOVRr_MEM_DAT_VIDf_SET(r,f) (r).mibkillovr[0]=(((r).mibkillovr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MIBKILLOVR.
 */
#define BCM53262_A0_READ_MIBKILLOVRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MIBKILLOVRr,(r._mibkillovr),1)
#define BCM53262_A0_WRITE_MIBKILLOVRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MIBKILLOVRr,&(r._mibkillovr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIBKILLOVRr BCM53262_A0_MIBKILLOVRr
#define MIBKILLOVRr_SIZE BCM53262_A0_MIBKILLOVRr_SIZE
typedef BCM53262_A0_MIBKILLOVRr_t MIBKILLOVRr_t;
#define MIBKILLOVRr_CLR BCM53262_A0_MIBKILLOVRr_CLR
#define MIBKILLOVRr_SET BCM53262_A0_MIBKILLOVRr_SET
#define MIBKILLOVRr_GET BCM53262_A0_MIBKILLOVRr_GET
#define MIBKILLOVRr_MEM_DAT_VIDf_GET BCM53262_A0_MIBKILLOVRr_MEM_DAT_VIDf_GET
#define MIBKILLOVRr_MEM_DAT_VIDf_SET BCM53262_A0_MIBKILLOVRr_MEM_DAT_VIDf_SET
#define READ_MIBKILLOVRr BCM53262_A0_READ_MIBKILLOVRr
#define WRITE_MIBKILLOVRr BCM53262_A0_WRITE_MIBKILLOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MIBKILLOVRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MIB_SNAPSHOT_CTL
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Control Register
 * SIZE:     8
 * FIELDS:
 *     SNAPSHOT_PORT    Port munber for MIB snapshot function.
 *     SNAPSHOT_MIRROR  1'b1 : enable read address to port MIB, but from MIB snapshot memory.1'b0 : enable to read from port MIB memory.
 *     SNAPSHOT_STDONE  Write 1'b1 to initiate MIB snapshot access clear to 1'b0 when MIB snapshot access is done.
 */
#define BCM53262_A0_MIB_SNAPSHOT_CTLr 0x00000350

#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MIB_SNAPSHOT_CTL.
 */
typedef union BCM53262_A0_MIB_SNAPSHOT_CTLr_s {
	uint32_t v[1];
	uint32_t mib_snapshot_ctl[1];
	uint32_t _mib_snapshot_ctl;
} BCM53262_A0_MIB_SNAPSHOT_CTLr_t;

#define BCM53262_A0_MIB_SNAPSHOT_CTLr_CLR(r) (r).mib_snapshot_ctl[0] = 0
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SET(r,d) (r).mib_snapshot_ctl[0] = d
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_GET(r) (r).mib_snapshot_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET(r) (((r).mib_snapshot_ctl[0]) & 0x3f)
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 6) & 0x1)
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 7) & 0x1)
#define BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIB_SNAPSHOT_CTL.
 */
#define BCM53262_A0_READ_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MIB_SNAPSHOT_CTLr,(r._mib_snapshot_ctl),1)
#define BCM53262_A0_WRITE_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MIB_SNAPSHOT_CTLr,&(r._mib_snapshot_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_SNAPSHOT_CTLr BCM53262_A0_MIB_SNAPSHOT_CTLr
#define MIB_SNAPSHOT_CTLr_SIZE BCM53262_A0_MIB_SNAPSHOT_CTLr_SIZE
typedef BCM53262_A0_MIB_SNAPSHOT_CTLr_t MIB_SNAPSHOT_CTLr_t;
#define MIB_SNAPSHOT_CTLr_CLR BCM53262_A0_MIB_SNAPSHOT_CTLr_CLR
#define MIB_SNAPSHOT_CTLr_SET BCM53262_A0_MIB_SNAPSHOT_CTLr_SET
#define MIB_SNAPSHOT_CTLr_GET BCM53262_A0_MIB_SNAPSHOT_CTLr_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET BCM53262_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET
#define READ_MIB_SNAPSHOT_CTLr BCM53262_A0_READ_MIB_SNAPSHOT_CTLr
#define WRITE_MIB_SNAPSHOT_CTLr BCM53262_A0_WRITE_MIB_SNAPSHOT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MIB_SNAPSHOT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MIICTL
 * BLOCKS:   EPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Ignore when read.
 *     DUPLEX_MOD       1'b1: Full Duplex.1'b0: Half Duplex.
 *     RE_AN            1'b1: Restart Auto-Negotiation process.1'b0: Normal operation.
 *     ISOLATE          1'b1: Electrically isolate PHY from MII 0.1'b0: Normal operation.
 *     PWR_DOWN         1'b0:Normal operation.
 *     AN_EN            1'b1: Auto-Negotiation Enable.1'b0: Auto-Negotiation disable.
 *     F_SPD_SEL        1'b1: 100 Mbps1'b0: 10 Mbps.
 *     LOOPBACK         1'b1: Loopback mode.1'b0: Normal operation.
 *     RESET_R          1'b1: PHY reset.1'b0: Normal operation.
 */
#define BCM53262_A0_MIICTLr 0x0000a000

#define BCM53262_A0_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program MIICTL.
 */
typedef union BCM53262_A0_MIICTLr_s {
	uint32_t v[1];
	uint32_t miictl[1];
	uint32_t _miictl;
} BCM53262_A0_MIICTLr_t;

#define BCM53262_A0_MIICTLr_CLR(r) (r).miictl[0] = 0
#define BCM53262_A0_MIICTLr_SET(r,d) (r).miictl[0] = d
#define BCM53262_A0_MIICTLr_GET(r) (r).miictl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MIICTLr_RESERVED_Rf_GET(r) (((r).miictl[0]) & 0xff)
#define BCM53262_A0_MIICTLr_RESERVED_Rf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_MIICTLr_DUPLEX_MODf_GET(r) ((((r).miictl[0]) >> 8) & 0x1)
#define BCM53262_A0_MIICTLr_DUPLEX_MODf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_MIICTLr_RE_ANf_GET(r) ((((r).miictl[0]) >> 9) & 0x1)
#define BCM53262_A0_MIICTLr_RE_ANf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_MIICTLr_ISOLATEf_GET(r) ((((r).miictl[0]) >> 10) & 0x1)
#define BCM53262_A0_MIICTLr_ISOLATEf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_MIICTLr_PWR_DOWNf_GET(r) ((((r).miictl[0]) >> 11) & 0x1)
#define BCM53262_A0_MIICTLr_PWR_DOWNf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_MIICTLr_AN_ENf_GET(r) ((((r).miictl[0]) >> 12) & 0x1)
#define BCM53262_A0_MIICTLr_AN_ENf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_MIICTLr_F_SPD_SELf_GET(r) ((((r).miictl[0]) >> 13) & 0x1)
#define BCM53262_A0_MIICTLr_F_SPD_SELf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_MIICTLr_LOOPBACKf_GET(r) ((((r).miictl[0]) >> 14) & 0x1)
#define BCM53262_A0_MIICTLr_LOOPBACKf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_MIICTLr_RESET_Rf_GET(r) ((((r).miictl[0]) >> 15) & 0x1)
#define BCM53262_A0_MIICTLr_RESET_Rf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIICTL.
 */
#define BCM53262_A0_READ_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_MIICTLr,(r._miictl),2)
#define BCM53262_A0_WRITE_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_MIICTLr,&(r._miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIICTLr BCM53262_A0_MIICTLr
#define MIICTLr_SIZE BCM53262_A0_MIICTLr_SIZE
typedef BCM53262_A0_MIICTLr_t MIICTLr_t;
#define MIICTLr_CLR BCM53262_A0_MIICTLr_CLR
#define MIICTLr_SET BCM53262_A0_MIICTLr_SET
#define MIICTLr_GET BCM53262_A0_MIICTLr_GET
#define MIICTLr_RESERVED_Rf_GET BCM53262_A0_MIICTLr_RESERVED_Rf_GET
#define MIICTLr_RESERVED_Rf_SET BCM53262_A0_MIICTLr_RESERVED_Rf_SET
#define MIICTLr_DUPLEX_MODf_GET BCM53262_A0_MIICTLr_DUPLEX_MODf_GET
#define MIICTLr_DUPLEX_MODf_SET BCM53262_A0_MIICTLr_DUPLEX_MODf_SET
#define MIICTLr_RE_ANf_GET BCM53262_A0_MIICTLr_RE_ANf_GET
#define MIICTLr_RE_ANf_SET BCM53262_A0_MIICTLr_RE_ANf_SET
#define MIICTLr_ISOLATEf_GET BCM53262_A0_MIICTLr_ISOLATEf_GET
#define MIICTLr_ISOLATEf_SET BCM53262_A0_MIICTLr_ISOLATEf_SET
#define MIICTLr_PWR_DOWNf_GET BCM53262_A0_MIICTLr_PWR_DOWNf_GET
#define MIICTLr_PWR_DOWNf_SET BCM53262_A0_MIICTLr_PWR_DOWNf_SET
#define MIICTLr_AN_ENf_GET BCM53262_A0_MIICTLr_AN_ENf_GET
#define MIICTLr_AN_ENf_SET BCM53262_A0_MIICTLr_AN_ENf_SET
#define MIICTLr_F_SPD_SELf_GET BCM53262_A0_MIICTLr_F_SPD_SELf_GET
#define MIICTLr_F_SPD_SELf_SET BCM53262_A0_MIICTLr_F_SPD_SELf_SET
#define MIICTLr_LOOPBACKf_GET BCM53262_A0_MIICTLr_LOOPBACKf_GET
#define MIICTLr_LOOPBACKf_SET BCM53262_A0_MIICTLr_LOOPBACKf_SET
#define MIICTLr_RESET_Rf_GET BCM53262_A0_MIICTLr_RESET_Rf_GET
#define MIICTLr_RESET_Rf_SET BCM53262_A0_MIICTLr_RESET_Rf_SET
#define READ_MIICTLr BCM53262_A0_READ_MIICTLr
#define WRITE_MIICTLr BCM53262_A0_WRITE_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MIICTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MIISTS
 * BLOCKS:   EPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          
 *     JABBER_DET       
 *     LINK_STA         
 *     AUTO_NEGO_CAP    
 *     REMOTE_FAULT_R   
 *     AUTO_NEGO_COMP   
 *     MF_PRE_SUP       
 *     RESERVED_R       Reserved
 *     B10T_CAP         
 *     B10T_FDX_CAP     
 *     B100TX_CAP       
 *     B100TX_FDX_CAP   
 *     B100T4_CAP       
 */
#define BCM53262_A0_MIISTSr 0x0000a002

#define BCM53262_A0_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program MIISTS.
 */
typedef union BCM53262_A0_MIISTSr_s {
	uint32_t v[1];
	uint32_t miists[1];
	uint32_t _miists;
} BCM53262_A0_MIISTSr_t;

#define BCM53262_A0_MIISTSr_CLR(r) (r).miists[0] = 0
#define BCM53262_A0_MIISTSr_SET(r,d) (r).miists[0] = d
#define BCM53262_A0_MIISTSr_GET(r) (r).miists[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MIISTSr_EXT_CAPf_GET(r) (((r).miists[0]) & 0x1)
#define BCM53262_A0_MIISTSr_EXT_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_MIISTSr_JABBER_DETf_GET(r) ((((r).miists[0]) >> 1) & 0x1)
#define BCM53262_A0_MIISTSr_JABBER_DETf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_MIISTSr_LINK_STAf_GET(r) ((((r).miists[0]) >> 2) & 0x1)
#define BCM53262_A0_MIISTSr_LINK_STAf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).miists[0]) >> 3) & 0x1)
#define BCM53262_A0_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_MIISTSr_REMOTE_FAULT_Rf_GET(r) ((((r).miists[0]) >> 4) & 0x1)
#define BCM53262_A0_MIISTSr_REMOTE_FAULT_Rf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).miists[0]) >> 5) & 0x1)
#define BCM53262_A0_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).miists[0]) >> 6) & 0x1)
#define BCM53262_A0_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_MIISTSr_RESERVED_Rf_GET(r) ((((r).miists[0]) >> 7) & 0xf)
#define BCM53262_A0_MIISTSr_RESERVED_Rf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53262_A0_MIISTSr_B10T_CAPf_GET(r) ((((r).miists[0]) >> 11) & 0x1)
#define BCM53262_A0_MIISTSr_B10T_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).miists[0]) >> 12) & 0x1)
#define BCM53262_A0_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_MIISTSr_B100TX_CAPf_GET(r) ((((r).miists[0]) >> 13) & 0x1)
#define BCM53262_A0_MIISTSr_B100TX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).miists[0]) >> 14) & 0x1)
#define BCM53262_A0_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_MIISTSr_B100T4_CAPf_GET(r) ((((r).miists[0]) >> 15) & 0x1)
#define BCM53262_A0_MIISTSr_B100T4_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIISTS.
 */
#define BCM53262_A0_READ_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_MIISTSr,(r._miists),2)
#define BCM53262_A0_WRITE_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_MIISTSr,&(r._miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIISTSr BCM53262_A0_MIISTSr
#define MIISTSr_SIZE BCM53262_A0_MIISTSr_SIZE
typedef BCM53262_A0_MIISTSr_t MIISTSr_t;
#define MIISTSr_CLR BCM53262_A0_MIISTSr_CLR
#define MIISTSr_SET BCM53262_A0_MIISTSr_SET
#define MIISTSr_GET BCM53262_A0_MIISTSr_GET
#define MIISTSr_EXT_CAPf_GET BCM53262_A0_MIISTSr_EXT_CAPf_GET
#define MIISTSr_EXT_CAPf_SET BCM53262_A0_MIISTSr_EXT_CAPf_SET
#define MIISTSr_JABBER_DETf_GET BCM53262_A0_MIISTSr_JABBER_DETf_GET
#define MIISTSr_JABBER_DETf_SET BCM53262_A0_MIISTSr_JABBER_DETf_SET
#define MIISTSr_LINK_STAf_GET BCM53262_A0_MIISTSr_LINK_STAf_GET
#define MIISTSr_LINK_STAf_SET BCM53262_A0_MIISTSr_LINK_STAf_SET
#define MIISTSr_AUTO_NEGO_CAPf_GET BCM53262_A0_MIISTSr_AUTO_NEGO_CAPf_GET
#define MIISTSr_AUTO_NEGO_CAPf_SET BCM53262_A0_MIISTSr_AUTO_NEGO_CAPf_SET
#define MIISTSr_REMOTE_FAULT_Rf_GET BCM53262_A0_MIISTSr_REMOTE_FAULT_Rf_GET
#define MIISTSr_REMOTE_FAULT_Rf_SET BCM53262_A0_MIISTSr_REMOTE_FAULT_Rf_SET
#define MIISTSr_AUTO_NEGO_COMPf_GET BCM53262_A0_MIISTSr_AUTO_NEGO_COMPf_GET
#define MIISTSr_AUTO_NEGO_COMPf_SET BCM53262_A0_MIISTSr_AUTO_NEGO_COMPf_SET
#define MIISTSr_MF_PRE_SUPf_GET BCM53262_A0_MIISTSr_MF_PRE_SUPf_GET
#define MIISTSr_MF_PRE_SUPf_SET BCM53262_A0_MIISTSr_MF_PRE_SUPf_SET
#define MIISTSr_RESERVED_Rf_GET BCM53262_A0_MIISTSr_RESERVED_Rf_GET
#define MIISTSr_RESERVED_Rf_SET BCM53262_A0_MIISTSr_RESERVED_Rf_SET
#define MIISTSr_B10T_CAPf_GET BCM53262_A0_MIISTSr_B10T_CAPf_GET
#define MIISTSr_B10T_CAPf_SET BCM53262_A0_MIISTSr_B10T_CAPf_SET
#define MIISTSr_B10T_FDX_CAPf_GET BCM53262_A0_MIISTSr_B10T_FDX_CAPf_GET
#define MIISTSr_B10T_FDX_CAPf_SET BCM53262_A0_MIISTSr_B10T_FDX_CAPf_SET
#define MIISTSr_B100TX_CAPf_GET BCM53262_A0_MIISTSr_B100TX_CAPf_GET
#define MIISTSr_B100TX_CAPf_SET BCM53262_A0_MIISTSr_B100TX_CAPf_SET
#define MIISTSr_B100TX_FDX_CAPf_GET BCM53262_A0_MIISTSr_B100TX_FDX_CAPf_GET
#define MIISTSr_B100TX_FDX_CAPf_SET BCM53262_A0_MIISTSr_B100TX_FDX_CAPf_SET
#define MIISTSr_B100T4_CAPf_GET BCM53262_A0_MIISTSr_B100T4_CAPf_GET
#define MIISTSr_B100T4_CAPf_SET BCM53262_A0_MIISTSr_B100T4_CAPf_SET
#define READ_MIISTSr BCM53262_A0_READ_MIISTSr
#define WRITE_MIISTSr BCM53262_A0_WRITE_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MIISTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MIRCAPCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Capture Control Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     SMIR_CAP_PORT    Mirror Capture Port.Bit mask which identifies the single unique port which is designated as the port to which all ingress and/or egress traffic is mirrored on this chip/system.Bits 0-47 = 10/100BASE-T PortsBit 48 = MII/IMPBit 49 = Giga port g0Bit 50 = Giga port g1Bit 51 = Giga port g2Bit 52 = Giga port g3
 *     MIRCAPCTL_RSRV0  Reserved
 *     BLK_NOT_MIR      When enable, all traffic to MIR_CAP_PORT will be blocked except mirror traffic.
 *     MIR_EN           Global enable/disable for all mirroring on this chip.When reset, mirroring is disabled.When set, mirroring is enabled according to the ingress and egress control rules, to the port designated by the MIR_CAP_PORT.
 */
#define BCM53262_A0_MIRCAPCTLr 0x00000310

#define BCM53262_A0_MIRCAPCTLr_SIZE 8

/*
 * This structure should be used to declare and program MIRCAPCTL.
 */
typedef union BCM53262_A0_MIRCAPCTLr_s {
	uint32_t v[2];
	uint32_t mircapctl[2];
	uint32_t _mircapctl;
} BCM53262_A0_MIRCAPCTLr_t;

#define BCM53262_A0_MIRCAPCTLr_CLR(r) CDK_MEMSET(&((r)._mircapctl), 0, sizeof(BCM53262_A0_MIRCAPCTLr_t))
#define BCM53262_A0_MIRCAPCTLr_SET(r,i,d) (r).mircapctl[i] = d
#define BCM53262_A0_MIRCAPCTLr_GET(r,i) (r).mircapctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MIRCAPCTLr_RESERVED_Rf_GET(r) (((r).mircapctl[0]) & 0xffffff)
#define BCM53262_A0_MIRCAPCTLr_RESERVED_Rf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET(r) cdk_field32_get((r).mircapctl,24,52)
#define BCM53262_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET(r,f) cdk_field32_set((r).mircapctl,24,52,f)
#define BCM53262_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_GET(r) ((((r).mircapctl[1]) >> 21) & 0x1ff)
#define BCM53262_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_SET(r,f) (r).mircapctl[1]=(((r).mircapctl[1] & ~((uint32_t)0x1ff << 21)) | ((((uint32_t)f) & 0x1ff) << 21))
#define BCM53262_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET(r) ((((r).mircapctl[1]) >> 30) & 0x1)
#define BCM53262_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET(r,f) (r).mircapctl[1]=(((r).mircapctl[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_MIRCAPCTLr_MIR_ENf_GET(r) ((((r).mircapctl[1]) >> 31) & 0x1)
#define BCM53262_A0_MIRCAPCTLr_MIR_ENf_SET(r,f) (r).mircapctl[1]=(((r).mircapctl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MIRCAPCTL.
 */
#define BCM53262_A0_READ_MIRCAPCTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MIRCAPCTLr,(r._mircapctl),8)
#define BCM53262_A0_WRITE_MIRCAPCTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MIRCAPCTLr,&(r._mircapctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRCAPCTLr BCM53262_A0_MIRCAPCTLr
#define MIRCAPCTLr_SIZE BCM53262_A0_MIRCAPCTLr_SIZE
typedef BCM53262_A0_MIRCAPCTLr_t MIRCAPCTLr_t;
#define MIRCAPCTLr_CLR BCM53262_A0_MIRCAPCTLr_CLR
#define MIRCAPCTLr_SET BCM53262_A0_MIRCAPCTLr_SET
#define MIRCAPCTLr_GET BCM53262_A0_MIRCAPCTLr_GET
#define MIRCAPCTLr_RESERVED_Rf_GET BCM53262_A0_MIRCAPCTLr_RESERVED_Rf_GET
#define MIRCAPCTLr_RESERVED_Rf_SET BCM53262_A0_MIRCAPCTLr_RESERVED_Rf_SET
#define MIRCAPCTLr_SMIR_CAP_PORTf_GET BCM53262_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_SET BCM53262_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET
#define MIRCAPCTLr_MIRCAPCTL_RSRV0f_GET BCM53262_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_GET
#define MIRCAPCTLr_MIRCAPCTL_RSRV0f_SET BCM53262_A0_MIRCAPCTLr_MIRCAPCTL_RSRV0f_SET
#define MIRCAPCTLr_BLK_NOT_MIRf_GET BCM53262_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET
#define MIRCAPCTLr_BLK_NOT_MIRf_SET BCM53262_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET
#define MIRCAPCTLr_MIR_ENf_GET BCM53262_A0_MIRCAPCTLr_MIR_ENf_GET
#define MIRCAPCTLr_MIR_ENf_SET BCM53262_A0_MIRCAPCTLr_MIR_ENf_SET
#define READ_MIRCAPCTLr BCM53262_A0_READ_MIRCAPCTLr
#define WRITE_MIRCAPCTLr BCM53262_A0_WRITE_MIRCAPCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MIRCAPCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MLF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Multicast LookupFail Forward Map Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     MLF_FWD_MAP      Set the assigned Protected port to '1'. For example, if port 24 is assigned as Protected port, set to '29'h0000_0001'#Note : Management port could not be configured as protected port.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_MLF_DROP_MAPr 0x00000038

#define BCM53262_A0_MLF_DROP_MAPr_SIZE 8

/*
 * This structure should be used to declare and program MLF_DROP_MAP.
 */
typedef union BCM53262_A0_MLF_DROP_MAPr_s {
	uint32_t v[2];
	uint32_t mlf_drop_map[2];
	uint32_t _mlf_drop_map;
} BCM53262_A0_MLF_DROP_MAPr_t;

#define BCM53262_A0_MLF_DROP_MAPr_CLR(r) CDK_MEMSET(&((r)._mlf_drop_map), 0, sizeof(BCM53262_A0_MLF_DROP_MAPr_t))
#define BCM53262_A0_MLF_DROP_MAPr_SET(r,i,d) (r).mlf_drop_map[i] = d
#define BCM53262_A0_MLF_DROP_MAPr_GET(r,i) (r).mlf_drop_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MLF_DROP_MAPr_RESERVED_0Rf_GET(r) (((r).mlf_drop_map[0]) & 0xffffff)
#define BCM53262_A0_MLF_DROP_MAPr_RESERVED_0Rf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_MLF_DROP_MAPr_MLF_FWD_MAPf_GET(r) cdk_field32_get((r).mlf_drop_map,24,52)
#define BCM53262_A0_MLF_DROP_MAPr_MLF_FWD_MAPf_SET(r,f) cdk_field32_set((r).mlf_drop_map,24,52,f)
#define BCM53262_A0_MLF_DROP_MAPr_RESERVED_1Rf_GET(r) ((((r).mlf_drop_map[1]) >> 21) & 0x7ff)
#define BCM53262_A0_MLF_DROP_MAPr_RESERVED_1Rf_SET(r,f) (r).mlf_drop_map[1]=(((r).mlf_drop_map[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access MLF_DROP_MAP.
 */
#define BCM53262_A0_READ_MLF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MLF_DROP_MAPr,(r._mlf_drop_map),8)
#define BCM53262_A0_WRITE_MLF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MLF_DROP_MAPr,&(r._mlf_drop_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_DROP_MAPr BCM53262_A0_MLF_DROP_MAPr
#define MLF_DROP_MAPr_SIZE BCM53262_A0_MLF_DROP_MAPr_SIZE
typedef BCM53262_A0_MLF_DROP_MAPr_t MLF_DROP_MAPr_t;
#define MLF_DROP_MAPr_CLR BCM53262_A0_MLF_DROP_MAPr_CLR
#define MLF_DROP_MAPr_SET BCM53262_A0_MLF_DROP_MAPr_SET
#define MLF_DROP_MAPr_GET BCM53262_A0_MLF_DROP_MAPr_GET
#define MLF_DROP_MAPr_RESERVED_0Rf_GET BCM53262_A0_MLF_DROP_MAPr_RESERVED_0Rf_GET
#define MLF_DROP_MAPr_RESERVED_0Rf_SET BCM53262_A0_MLF_DROP_MAPr_RESERVED_0Rf_SET
#define MLF_DROP_MAPr_MLF_FWD_MAPf_GET BCM53262_A0_MLF_DROP_MAPr_MLF_FWD_MAPf_GET
#define MLF_DROP_MAPr_MLF_FWD_MAPf_SET BCM53262_A0_MLF_DROP_MAPr_MLF_FWD_MAPf_SET
#define MLF_DROP_MAPr_RESERVED_1Rf_GET BCM53262_A0_MLF_DROP_MAPr_RESERVED_1Rf_GET
#define MLF_DROP_MAPr_RESERVED_1Rf_SET BCM53262_A0_MLF_DROP_MAPr_RESERVED_1Rf_SET
#define READ_MLF_DROP_MAPr BCM53262_A0_READ_MLF_DROP_MAPr
#define WRITE_MLF_DROP_MAPr BCM53262_A0_WRITE_MLF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MLF_DROP_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MLF_IPMC_FWD_MAP
 * BLOCKS:   SYS
 * DESC:     IPMC Lookup Failed Forwarding Map Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     MLF_IPMC_FWD_MAP IPMC Lookup Failed Forwarding Map.Bit 47~24 : for port 47~ port 24,Bit 48   : for IMP port,Bit 52~49: for goga3 ~ giga0
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_MLF_IPMC_FWD_MAPr 0x00000028

#define BCM53262_A0_MLF_IPMC_FWD_MAPr_SIZE 8

/*
 * This structure should be used to declare and program MLF_IPMC_FWD_MAP.
 */
typedef union BCM53262_A0_MLF_IPMC_FWD_MAPr_s {
	uint32_t v[2];
	uint32_t mlf_ipmc_fwd_map[2];
	uint32_t _mlf_ipmc_fwd_map;
} BCM53262_A0_MLF_IPMC_FWD_MAPr_t;

#define BCM53262_A0_MLF_IPMC_FWD_MAPr_CLR(r) CDK_MEMSET(&((r)._mlf_ipmc_fwd_map), 0, sizeof(BCM53262_A0_MLF_IPMC_FWD_MAPr_t))
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_SET(r,i,d) (r).mlf_ipmc_fwd_map[i] = d
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_GET(r,i) (r).mlf_ipmc_fwd_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_0Rf_GET(r) (((r).mlf_ipmc_fwd_map[0]) & 0xffffff)
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_0Rf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET(r) cdk_field32_get((r).mlf_ipmc_fwd_map,24,52)
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET(r,f) cdk_field32_set((r).mlf_ipmc_fwd_map,24,52,f)
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_1Rf_GET(r) ((((r).mlf_ipmc_fwd_map[1]) >> 21) & 0x7ff)
#define BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_1Rf_SET(r,f) (r).mlf_ipmc_fwd_map[1]=(((r).mlf_ipmc_fwd_map[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access MLF_IPMC_FWD_MAP.
 */
#define BCM53262_A0_READ_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MLF_IPMC_FWD_MAPr,(r._mlf_ipmc_fwd_map),8)
#define BCM53262_A0_WRITE_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MLF_IPMC_FWD_MAPr,&(r._mlf_ipmc_fwd_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_IPMC_FWD_MAPr BCM53262_A0_MLF_IPMC_FWD_MAPr
#define MLF_IPMC_FWD_MAPr_SIZE BCM53262_A0_MLF_IPMC_FWD_MAPr_SIZE
typedef BCM53262_A0_MLF_IPMC_FWD_MAPr_t MLF_IPMC_FWD_MAPr_t;
#define MLF_IPMC_FWD_MAPr_CLR BCM53262_A0_MLF_IPMC_FWD_MAPr_CLR
#define MLF_IPMC_FWD_MAPr_SET BCM53262_A0_MLF_IPMC_FWD_MAPr_SET
#define MLF_IPMC_FWD_MAPr_GET BCM53262_A0_MLF_IPMC_FWD_MAPr_GET
#define MLF_IPMC_FWD_MAPr_RESERVED_0Rf_GET BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_0Rf_GET
#define MLF_IPMC_FWD_MAPr_RESERVED_0Rf_SET BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_0Rf_SET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET BCM53262_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET BCM53262_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET
#define MLF_IPMC_FWD_MAPr_RESERVED_1Rf_GET BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_1Rf_GET
#define MLF_IPMC_FWD_MAPr_RESERVED_1Rf_SET BCM53262_A0_MLF_IPMC_FWD_MAPr_RESERVED_1Rf_SET
#define READ_MLF_IPMC_FWD_MAPr BCM53262_A0_READ_MLF_IPMC_FWD_MAPr
#define WRITE_MLF_IPMC_FWD_MAPr BCM53262_A0_WRITE_MLF_IPMC_FWD_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MLF_IPMC_FWD_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MNGPID
 * BLOCKS:   SYS
 * DESC:     Management Port ID Register
 * SIZE:     8
 * FIELDS:
 *     PORT_ID          Port ID where Management Port is located. This must be programmed consistent with the Frame Management Port in the Global Management Configuration register. Only IMP (Port 48, 6'h30) are legal values.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_MNGPIDr 0x00000302

#define BCM53262_A0_MNGPIDr_SIZE 1

/*
 * This structure should be used to declare and program MNGPID.
 */
typedef union BCM53262_A0_MNGPIDr_s {
	uint32_t v[1];
	uint32_t mngpid[1];
	uint32_t _mngpid;
} BCM53262_A0_MNGPIDr_t;

#define BCM53262_A0_MNGPIDr_CLR(r) (r).mngpid[0] = 0
#define BCM53262_A0_MNGPIDr_SET(r,d) (r).mngpid[0] = d
#define BCM53262_A0_MNGPIDr_GET(r) (r).mngpid[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MNGPIDr_PORT_IDf_GET(r) (((r).mngpid[0]) & 0x3f)
#define BCM53262_A0_MNGPIDr_PORT_IDf_SET(r,f) (r).mngpid[0]=(((r).mngpid[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_MNGPIDr_RESERVED_Rf_GET(r) ((((r).mngpid[0]) >> 6) & 0x3)
#define BCM53262_A0_MNGPIDr_RESERVED_Rf_SET(r,f) (r).mngpid[0]=(((r).mngpid[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MNGPID.
 */
#define BCM53262_A0_READ_MNGPIDr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MNGPIDr,(r._mngpid),1)
#define BCM53262_A0_WRITE_MNGPIDr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MNGPIDr,&(r._mngpid),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MNGPIDr BCM53262_A0_MNGPIDr
#define MNGPIDr_SIZE BCM53262_A0_MNGPIDr_SIZE
typedef BCM53262_A0_MNGPIDr_t MNGPIDr_t;
#define MNGPIDr_CLR BCM53262_A0_MNGPIDr_CLR
#define MNGPIDr_SET BCM53262_A0_MNGPIDr_SET
#define MNGPIDr_GET BCM53262_A0_MNGPIDr_GET
#define MNGPIDr_PORT_IDf_GET BCM53262_A0_MNGPIDr_PORT_IDf_GET
#define MNGPIDr_PORT_IDf_SET BCM53262_A0_MNGPIDr_PORT_IDf_SET
#define MNGPIDr_RESERVED_Rf_GET BCM53262_A0_MNGPIDr_RESERVED_Rf_GET
#define MNGPIDr_RESERVED_Rf_SET BCM53262_A0_MNGPIDr_RESERVED_Rf_SET
#define READ_MNGPIDr BCM53262_A0_READ_MNGPIDr
#define WRITE_MNGPIDr BCM53262_A0_WRITE_MNGPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MNGPIDr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MR_STA
 * BLOCKS:   SYS
 * DESC:     MR Status Register
 * SIZE:     8
 * FIELDS:
 *     PR_ERR           Priority resolution error used for local device remote fault.
 *     RESERVED_R       Reserved
 *     MR_EMOVE_FAULT   
 *     MR_PAGE_RX       
 */
#define BCM53262_A0_MR_STAr 0x00000d07

#define BCM53262_A0_MR_STAr_SIZE 1

/*
 * This structure should be used to declare and program MR_STA.
 */
typedef union BCM53262_A0_MR_STAr_s {
	uint32_t v[1];
	uint32_t mr_sta[1];
	uint32_t _mr_sta;
} BCM53262_A0_MR_STAr_t;

#define BCM53262_A0_MR_STAr_CLR(r) (r).mr_sta[0] = 0
#define BCM53262_A0_MR_STAr_SET(r,d) (r).mr_sta[0] = d
#define BCM53262_A0_MR_STAr_GET(r) (r).mr_sta[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MR_STAr_PR_ERRf_GET(r) (((r).mr_sta[0]) & 0x3)
#define BCM53262_A0_MR_STAr_PR_ERRf_SET(r,f) (r).mr_sta[0]=(((r).mr_sta[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_MR_STAr_RESERVED_Rf_GET(r) ((((r).mr_sta[0]) >> 2) & 0x3)
#define BCM53262_A0_MR_STAr_RESERVED_Rf_SET(r,f) (r).mr_sta[0]=(((r).mr_sta[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_MR_STAr_MR_EMOVE_FAULTf_GET(r) ((((r).mr_sta[0]) >> 4) & 0x3)
#define BCM53262_A0_MR_STAr_MR_EMOVE_FAULTf_SET(r,f) (r).mr_sta[0]=(((r).mr_sta[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_MR_STAr_MR_PAGE_RXf_GET(r) ((((r).mr_sta[0]) >> 6) & 0x3)
#define BCM53262_A0_MR_STAr_MR_PAGE_RXf_SET(r,f) (r).mr_sta[0]=(((r).mr_sta[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MR_STA.
 */
#define BCM53262_A0_READ_MR_STAr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MR_STAr,(r._mr_sta),1)
#define BCM53262_A0_WRITE_MR_STAr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MR_STAr,&(r._mr_sta),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MR_STAr BCM53262_A0_MR_STAr
#define MR_STAr_SIZE BCM53262_A0_MR_STAr_SIZE
typedef BCM53262_A0_MR_STAr_t MR_STAr_t;
#define MR_STAr_CLR BCM53262_A0_MR_STAr_CLR
#define MR_STAr_SET BCM53262_A0_MR_STAr_SET
#define MR_STAr_GET BCM53262_A0_MR_STAr_GET
#define MR_STAr_PR_ERRf_GET BCM53262_A0_MR_STAr_PR_ERRf_GET
#define MR_STAr_PR_ERRf_SET BCM53262_A0_MR_STAr_PR_ERRf_SET
#define MR_STAr_RESERVED_Rf_GET BCM53262_A0_MR_STAr_RESERVED_Rf_GET
#define MR_STAr_RESERVED_Rf_SET BCM53262_A0_MR_STAr_RESERVED_Rf_SET
#define MR_STAr_MR_EMOVE_FAULTf_GET BCM53262_A0_MR_STAr_MR_EMOVE_FAULTf_GET
#define MR_STAr_MR_EMOVE_FAULTf_SET BCM53262_A0_MR_STAr_MR_EMOVE_FAULTf_SET
#define MR_STAr_MR_PAGE_RXf_GET BCM53262_A0_MR_STAr_MR_PAGE_RXf_GET
#define MR_STAr_MR_PAGE_RXf_SET BCM53262_A0_MR_STAr_MR_PAGE_RXf_SET
#define READ_MR_STAr BCM53262_A0_READ_MR_STAr
#define WRITE_MR_STAr BCM53262_A0_WRITE_MR_STAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MR_STAr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  MSPT_TAB
 * BLOCKS:   SYS
 * DESC:     Multiple Spanning Tree Table
 * SIZE:     192
 * FIELDS:
 *     RESERVED1_R      Reserved
 *     MSP_TREE_PORT0   Port 0 SPT status
 *     MSP_TREE_PORT1   Port 1 SPT status
 *     MSP_TREE_PORT2   Port 2 SPT status
 *     MSP_TREE_PORT3   Port 3 SPT status
 *     MSP_TREE_PORT4   Port 4 SPT status
 *     MSP_TREE_PORT5   Port 5 SPT status
 *     MSP_TREE_PORT6   Port 6 SPT status
 *     MSP_TREE_PORT7   Port 7 SPT status
 *     MSP_TREE_PORT8   Port 8 SPT status
 *     MSP_TREE_PORT9   Port 9 SPT status
 *     MSP_TREE_PORT10  Port 10 SPT status
 *     MSP_TREE_PORT11  Port 11 SPT status
 *     MSP_TREE_PORT12  Port 12 SPT status
 *     MSP_TREE_PORT13  Port 13 SPT status
 *     MSP_TREE_PORT14  Port 14 SPT status
 *     MSP_TREE_PORT15  Port 15 SPT status
 *     RESERVED2_R      Reserved
 *     MSP_TREE_PORT16  Port 16 SPT status
 *     MSP_TREE_PORT17  Port 17 SPT status
 *     MSP_TREE_PORT18  Port 18 SPT status
 *     MSP_TREE_PORT19  Port 19 SPT status
 *     MSP_TREE_PORT20  Port 20 SPT status
 *     MSP_TREE_PORT21  Port 21 SPT status
 *     MSP_TREE_PORT22  Port 22 SPT status
 *     MSP_TREE_PORT23  Port 23 SPT status
 *     MSP_TREE_PORT24  Port 24 SPT status
 *     MSP_TREE_PORT25  Port 25 SPT status
 *     MSP_TREE_PORT26  Port 26 SPT status
 *     MSP_TREE_PORT27  Port 27 SPT status
 *     MSP_TREE_PORT28  Port 28 SPT status
 *     RESERVED3_R      Reserved
 */
#define BCM53262_A0_MSPT_TABm 0x40030538

#define BCM53262_A0_MSPT_TABm_MIN 0
#define BCM53262_A0_MSPT_TABm_MAX 255
#define BCM53262_A0_MSPT_TABm_CMAX(u) 255
#define BCM53262_A0_MSPT_TABm_SIZE 24

/*
 * This structure should be used to declare and program MSPT_TAB.
 */
typedef union BCM53262_A0_MSPT_TABm_s {
	uint32_t v[6];
	uint32_t mspt_tab[6];
	uint32_t _mspt_tab;
} BCM53262_A0_MSPT_TABm_t;

#define BCM53262_A0_MSPT_TABm_CLR(r) CDK_MEMSET(&((r)._mspt_tab), 0, sizeof(BCM53262_A0_MSPT_TABm_t))
#define BCM53262_A0_MSPT_TABm_SET(r,i,d) (r).mspt_tab[i] = d
#define BCM53262_A0_MSPT_TABm_GET(r,i) (r).mspt_tab[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MSPT_TABm_RESERVED1_Rf_GET(r,a) cdk_field_get((r).mspt_tab,0,75,a)
#define BCM53262_A0_MSPT_TABm_RESERVED1_Rf_SET(r,a) cdk_field_set((r).mspt_tab,0,75,a)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT0f_GET(r) ((((r).mspt_tab[2]) >> 12) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT0f_SET(r,f) (r).mspt_tab[2]=(((r).mspt_tab[2] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT1f_GET(r) ((((r).mspt_tab[2]) >> 15) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT1f_SET(r,f) (r).mspt_tab[2]=(((r).mspt_tab[2] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT2f_GET(r) ((((r).mspt_tab[2]) >> 18) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT2f_SET(r,f) (r).mspt_tab[2]=(((r).mspt_tab[2] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT3f_GET(r) ((((r).mspt_tab[2]) >> 21) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT3f_SET(r,f) (r).mspt_tab[2]=(((r).mspt_tab[2] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT4f_GET(r) ((((r).mspt_tab[2]) >> 24) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT4f_SET(r,f) (r).mspt_tab[2]=(((r).mspt_tab[2] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT5f_GET(r) ((((r).mspt_tab[2]) >> 27) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT5f_SET(r,f) (r).mspt_tab[2]=(((r).mspt_tab[2] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT6f_GET(r) cdk_field32_get((r).mspt_tab,94,96)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT6f_SET(r,f) cdk_field32_set((r).mspt_tab,94,96,f)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT7f_GET(r) ((((r).mspt_tab[3]) >> 1) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT7f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT8f_GET(r) ((((r).mspt_tab[3]) >> 4) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT8f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT9f_GET(r) ((((r).mspt_tab[3]) >> 7) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT9f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT10f_GET(r) ((((r).mspt_tab[3]) >> 10) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT10f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT11f_GET(r) ((((r).mspt_tab[3]) >> 13) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT11f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT12f_GET(r) ((((r).mspt_tab[3]) >> 16) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT12f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT13f_GET(r) ((((r).mspt_tab[3]) >> 19) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT13f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT14f_GET(r) ((((r).mspt_tab[3]) >> 22) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT14f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT15f_GET(r) ((((r).mspt_tab[3]) >> 25) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT15f_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM53262_A0_MSPT_TABm_RESERVED2_Rf_GET(r) ((((r).mspt_tab[3]) >> 28) & 0xf)
#define BCM53262_A0_MSPT_TABm_RESERVED2_Rf_SET(r,f) (r).mspt_tab[3]=(((r).mspt_tab[3] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT16f_GET(r) (((r).mspt_tab[4]) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT16f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT17f_GET(r) ((((r).mspt_tab[4]) >> 3) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT17f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT18f_GET(r) ((((r).mspt_tab[4]) >> 6) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT18f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT19f_GET(r) ((((r).mspt_tab[4]) >> 9) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT19f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT20f_GET(r) ((((r).mspt_tab[4]) >> 12) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT20f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT21f_GET(r) ((((r).mspt_tab[4]) >> 15) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT21f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT22f_GET(r) ((((r).mspt_tab[4]) >> 18) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT22f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT23f_GET(r) ((((r).mspt_tab[4]) >> 21) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT23f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT24f_GET(r) ((((r).mspt_tab[4]) >> 24) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT24f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT25f_GET(r) ((((r).mspt_tab[4]) >> 27) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT25f_SET(r,f) (r).mspt_tab[4]=(((r).mspt_tab[4] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT26f_GET(r) cdk_field32_get((r).mspt_tab,158,160)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT26f_SET(r,f) cdk_field32_set((r).mspt_tab,158,160,f)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT27f_GET(r) ((((r).mspt_tab[5]) >> 1) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT27f_SET(r,f) (r).mspt_tab[5]=(((r).mspt_tab[5] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT28f_GET(r) ((((r).mspt_tab[5]) >> 4) & 0x7)
#define BCM53262_A0_MSPT_TABm_MSP_TREE_PORT28f_SET(r,f) (r).mspt_tab[5]=(((r).mspt_tab[5] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53262_A0_MSPT_TABm_RESERVED3_Rf_GET(r) ((((r).mspt_tab[5]) >> 7) & 0x1ffffff)
#define BCM53262_A0_MSPT_TABm_RESERVED3_Rf_SET(r,f) (r).mspt_tab[5]=(((r).mspt_tab[5] & ~((uint32_t)0x1ffffff << 7)) | ((((uint32_t)f) & 0x1ffffff) << 7))

/*
 * These macros can be used to access MSPT_TAB.
 */
#define BCM53262_A0_READ_MSPT_TABm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_MSPT_TABm,i,(m),24)
#define BCM53262_A0_WRITE_MSPT_TABm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_MSPT_TABm,i,&(m),24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MSPT_TABm BCM53262_A0_MSPT_TABm
#define MSPT_TABm_MIN BCM53262_A0_MSPT_TABm_MIN
#define MSPT_TABm_MAX BCM53262_A0_MSPT_TABm_MAX
#define MSPT_TABm_CMAX(u) BCM53262_A0_MSPT_TABm_CMAX(u)
#define MSPT_TABm_SIZE BCM53262_A0_MSPT_TABm_SIZE
typedef BCM53262_A0_MSPT_TABm_t MSPT_TABm_t;
#define MSPT_TABm_CLR BCM53262_A0_MSPT_TABm_CLR
#define MSPT_TABm_SET BCM53262_A0_MSPT_TABm_SET
#define MSPT_TABm_GET BCM53262_A0_MSPT_TABm_GET
#define MSPT_TABm_RESERVED1_Rf_GET BCM53262_A0_MSPT_TABm_RESERVED1_Rf_GET
#define MSPT_TABm_RESERVED1_Rf_SET BCM53262_A0_MSPT_TABm_RESERVED1_Rf_SET
#define MSPT_TABm_MSP_TREE_PORT0f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT0f_GET
#define MSPT_TABm_MSP_TREE_PORT0f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT0f_SET
#define MSPT_TABm_MSP_TREE_PORT1f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT1f_GET
#define MSPT_TABm_MSP_TREE_PORT1f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT1f_SET
#define MSPT_TABm_MSP_TREE_PORT2f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT2f_GET
#define MSPT_TABm_MSP_TREE_PORT2f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT2f_SET
#define MSPT_TABm_MSP_TREE_PORT3f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT3f_GET
#define MSPT_TABm_MSP_TREE_PORT3f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT3f_SET
#define MSPT_TABm_MSP_TREE_PORT4f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT4f_GET
#define MSPT_TABm_MSP_TREE_PORT4f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT4f_SET
#define MSPT_TABm_MSP_TREE_PORT5f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT5f_GET
#define MSPT_TABm_MSP_TREE_PORT5f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT5f_SET
#define MSPT_TABm_MSP_TREE_PORT6f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT6f_GET
#define MSPT_TABm_MSP_TREE_PORT6f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT6f_SET
#define MSPT_TABm_MSP_TREE_PORT7f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT7f_GET
#define MSPT_TABm_MSP_TREE_PORT7f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT7f_SET
#define MSPT_TABm_MSP_TREE_PORT8f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT8f_GET
#define MSPT_TABm_MSP_TREE_PORT8f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT8f_SET
#define MSPT_TABm_MSP_TREE_PORT9f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT9f_GET
#define MSPT_TABm_MSP_TREE_PORT9f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT9f_SET
#define MSPT_TABm_MSP_TREE_PORT10f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT10f_GET
#define MSPT_TABm_MSP_TREE_PORT10f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT10f_SET
#define MSPT_TABm_MSP_TREE_PORT11f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT11f_GET
#define MSPT_TABm_MSP_TREE_PORT11f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT11f_SET
#define MSPT_TABm_MSP_TREE_PORT12f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT12f_GET
#define MSPT_TABm_MSP_TREE_PORT12f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT12f_SET
#define MSPT_TABm_MSP_TREE_PORT13f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT13f_GET
#define MSPT_TABm_MSP_TREE_PORT13f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT13f_SET
#define MSPT_TABm_MSP_TREE_PORT14f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT14f_GET
#define MSPT_TABm_MSP_TREE_PORT14f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT14f_SET
#define MSPT_TABm_MSP_TREE_PORT15f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT15f_GET
#define MSPT_TABm_MSP_TREE_PORT15f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT15f_SET
#define MSPT_TABm_RESERVED2_Rf_GET BCM53262_A0_MSPT_TABm_RESERVED2_Rf_GET
#define MSPT_TABm_RESERVED2_Rf_SET BCM53262_A0_MSPT_TABm_RESERVED2_Rf_SET
#define MSPT_TABm_MSP_TREE_PORT16f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT16f_GET
#define MSPT_TABm_MSP_TREE_PORT16f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT16f_SET
#define MSPT_TABm_MSP_TREE_PORT17f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT17f_GET
#define MSPT_TABm_MSP_TREE_PORT17f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT17f_SET
#define MSPT_TABm_MSP_TREE_PORT18f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT18f_GET
#define MSPT_TABm_MSP_TREE_PORT18f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT18f_SET
#define MSPT_TABm_MSP_TREE_PORT19f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT19f_GET
#define MSPT_TABm_MSP_TREE_PORT19f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT19f_SET
#define MSPT_TABm_MSP_TREE_PORT20f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT20f_GET
#define MSPT_TABm_MSP_TREE_PORT20f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT20f_SET
#define MSPT_TABm_MSP_TREE_PORT21f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT21f_GET
#define MSPT_TABm_MSP_TREE_PORT21f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT21f_SET
#define MSPT_TABm_MSP_TREE_PORT22f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT22f_GET
#define MSPT_TABm_MSP_TREE_PORT22f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT22f_SET
#define MSPT_TABm_MSP_TREE_PORT23f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT23f_GET
#define MSPT_TABm_MSP_TREE_PORT23f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT23f_SET
#define MSPT_TABm_MSP_TREE_PORT24f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT24f_GET
#define MSPT_TABm_MSP_TREE_PORT24f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT24f_SET
#define MSPT_TABm_MSP_TREE_PORT25f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT25f_GET
#define MSPT_TABm_MSP_TREE_PORT25f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT25f_SET
#define MSPT_TABm_MSP_TREE_PORT26f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT26f_GET
#define MSPT_TABm_MSP_TREE_PORT26f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT26f_SET
#define MSPT_TABm_MSP_TREE_PORT27f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT27f_GET
#define MSPT_TABm_MSP_TREE_PORT27f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT27f_SET
#define MSPT_TABm_MSP_TREE_PORT28f_GET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT28f_GET
#define MSPT_TABm_MSP_TREE_PORT28f_SET BCM53262_A0_MSPT_TABm_MSP_TREE_PORT28f_SET
#define MSPT_TABm_RESERVED3_Rf_GET BCM53262_A0_MSPT_TABm_RESERVED3_Rf_GET
#define MSPT_TABm_RESERVED3_Rf_SET BCM53262_A0_MSPT_TABm_RESERVED3_Rf_SET
#define READ_MSPT_TABm BCM53262_A0_READ_MSPT_TABm
#define WRITE_MSPT_TABm BCM53262_A0_WRITE_MSPT_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MSPT_TABm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  MST_CON
 * BLOCKS:   SYS
 * DESC:     MST Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_802_1S        1 : Support 802.1s (Multiple Spanning Tree); spanning tree status will be fetched from MST_table.0 : Only one spanning tree supported. (Original mode)
 *     AGE_MODE_PRT     Aging Mode Control, per-port, following per-port setting.
 *     AGE_MODE_VLAN    Ageing Mode Control, per-VLAN, following AGE_EN_VID[11:0] setting
 *     AGE_MODE_SPT     Aging Mode Control, per-spanning tree, following MST setting.
 *     EN_AGE_STATIC    When set to 1, static entry will be ageing out.
 *     EN_UPD_STATIC    1'b1: The age bit in static entry will be update.1'b0: The age bit in static entry will NOT be update. (default)
 *     RESERVED_R       Reserved
 *     FAST_AGE_STDN    Write as 1 to initiate the fast ageing process following AGE_MODE setting.When fast ageing process is done, this bit will be clear to 0.
 */
#define BCM53262_A0_MST_CONr 0x00004500

#define BCM53262_A0_MST_CONr_SIZE 1

/*
 * This structure should be used to declare and program MST_CON.
 */
typedef union BCM53262_A0_MST_CONr_s {
	uint32_t v[1];
	uint32_t mst_con[1];
	uint32_t _mst_con;
} BCM53262_A0_MST_CONr_t;

#define BCM53262_A0_MST_CONr_CLR(r) (r).mst_con[0] = 0
#define BCM53262_A0_MST_CONr_SET(r,d) (r).mst_con[0] = d
#define BCM53262_A0_MST_CONr_GET(r) (r).mst_con[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_MST_CONr_EN_802_1Sf_GET(r) (((r).mst_con[0]) & 0x1)
#define BCM53262_A0_MST_CONr_EN_802_1Sf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_MST_CONr_AGE_MODE_PRTf_GET(r) ((((r).mst_con[0]) >> 1) & 0x1)
#define BCM53262_A0_MST_CONr_AGE_MODE_PRTf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_MST_CONr_AGE_MODE_VLANf_GET(r) ((((r).mst_con[0]) >> 2) & 0x1)
#define BCM53262_A0_MST_CONr_AGE_MODE_VLANf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_MST_CONr_AGE_MODE_SPTf_GET(r) ((((r).mst_con[0]) >> 3) & 0x1)
#define BCM53262_A0_MST_CONr_AGE_MODE_SPTf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_MST_CONr_EN_AGE_STATICf_GET(r) ((((r).mst_con[0]) >> 4) & 0x1)
#define BCM53262_A0_MST_CONr_EN_AGE_STATICf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_MST_CONr_EN_UPD_STATICf_GET(r) ((((r).mst_con[0]) >> 5) & 0x1)
#define BCM53262_A0_MST_CONr_EN_UPD_STATICf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_MST_CONr_RESERVED_Rf_GET(r) ((((r).mst_con[0]) >> 6) & 0x1)
#define BCM53262_A0_MST_CONr_RESERVED_Rf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_MST_CONr_FAST_AGE_STDNf_GET(r) ((((r).mst_con[0]) >> 7) & 0x1)
#define BCM53262_A0_MST_CONr_FAST_AGE_STDNf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MST_CON.
 */
#define BCM53262_A0_READ_MST_CONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_MST_CONr,(r._mst_con),1)
#define BCM53262_A0_WRITE_MST_CONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_MST_CONr,&(r._mst_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_CONr BCM53262_A0_MST_CONr
#define MST_CONr_SIZE BCM53262_A0_MST_CONr_SIZE
typedef BCM53262_A0_MST_CONr_t MST_CONr_t;
#define MST_CONr_CLR BCM53262_A0_MST_CONr_CLR
#define MST_CONr_SET BCM53262_A0_MST_CONr_SET
#define MST_CONr_GET BCM53262_A0_MST_CONr_GET
#define MST_CONr_EN_802_1Sf_GET BCM53262_A0_MST_CONr_EN_802_1Sf_GET
#define MST_CONr_EN_802_1Sf_SET BCM53262_A0_MST_CONr_EN_802_1Sf_SET
#define MST_CONr_AGE_MODE_PRTf_GET BCM53262_A0_MST_CONr_AGE_MODE_PRTf_GET
#define MST_CONr_AGE_MODE_PRTf_SET BCM53262_A0_MST_CONr_AGE_MODE_PRTf_SET
#define MST_CONr_AGE_MODE_VLANf_GET BCM53262_A0_MST_CONr_AGE_MODE_VLANf_GET
#define MST_CONr_AGE_MODE_VLANf_SET BCM53262_A0_MST_CONr_AGE_MODE_VLANf_SET
#define MST_CONr_AGE_MODE_SPTf_GET BCM53262_A0_MST_CONr_AGE_MODE_SPTf_GET
#define MST_CONr_AGE_MODE_SPTf_SET BCM53262_A0_MST_CONr_AGE_MODE_SPTf_SET
#define MST_CONr_EN_AGE_STATICf_GET BCM53262_A0_MST_CONr_EN_AGE_STATICf_GET
#define MST_CONr_EN_AGE_STATICf_SET BCM53262_A0_MST_CONr_EN_AGE_STATICf_SET
#define MST_CONr_EN_UPD_STATICf_GET BCM53262_A0_MST_CONr_EN_UPD_STATICf_GET
#define MST_CONr_EN_UPD_STATICf_SET BCM53262_A0_MST_CONr_EN_UPD_STATICf_SET
#define MST_CONr_RESERVED_Rf_GET BCM53262_A0_MST_CONr_RESERVED_Rf_GET
#define MST_CONr_RESERVED_Rf_SET BCM53262_A0_MST_CONr_RESERVED_Rf_SET
#define MST_CONr_FAST_AGE_STDNf_GET BCM53262_A0_MST_CONr_FAST_AGE_STDNf_GET
#define MST_CONr_FAST_AGE_STDNf_SET BCM53262_A0_MST_CONr_FAST_AGE_STDNf_SET
#define READ_MST_CONr BCM53262_A0_READ_MST_CONr
#define WRITE_MST_CONr BCM53262_A0_WRITE_MST_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_MST_CONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  NEW_CONTROL
 * BLOCKS:   SYS
 * DESC:     NEW Control Register
 * SIZE:     8
 * FIELDS:
 *     DIS_ECC_CHK      Disable ecc check.
 *     MAX_RX_LIMIT     Only valid for 53242/53262 B0.Maximum length limit to receive a packet.2'b00, 2048-bytes for all packet(default).2'b01, 1536-bytes for all packet.2'b10, 1518-byte(Untag)/1552-byte(Single Tag)/1526-byte(Double Tag)2'b11, 2000-byte for all packet.
 *     BC_FM_EN         1'b1: Broadcast packet will only be forwarded to BCAST_FWD_MAP[52:24].1'b0: Broadcast packet will be flooded. (Default)
 *     CLK25            1'b1: Enable 25MHz clock output.1'b0: Disable 25MHz clock output.
 *     ULF_FM_EN        Unicast Lookup Fail Forward Map EnableWhen set to '1', any imcoming packets with unicast DA not in ARL follow Unicast LookupFail Forward Map Register.
 *     MLF_FM_EN        00 : All of multicast lookup failed packets will be flooded.01 : All of multicast lookup failed packets will be forwarded to MLF_FWD_MAP[52:24].10 : IPMC lookup failed packets will be forwarded to IPMC_LF_FWD_MAP[52:24] (NEW);     the other multicast lookup failed packets will be forwarded to MLF_FWD_MAP[52:24].11 : Reserved.
 */
#define BCM53262_A0_NEW_CONTROLr 0x00000003

#define BCM53262_A0_NEW_CONTROLr_SIZE 1

/*
 * This structure should be used to declare and program NEW_CONTROL.
 */
typedef union BCM53262_A0_NEW_CONTROLr_s {
	uint32_t v[1];
	uint32_t new_control[1];
	uint32_t _new_control;
} BCM53262_A0_NEW_CONTROLr_t;

#define BCM53262_A0_NEW_CONTROLr_CLR(r) (r).new_control[0] = 0
#define BCM53262_A0_NEW_CONTROLr_SET(r,d) (r).new_control[0] = d
#define BCM53262_A0_NEW_CONTROLr_GET(r) (r).new_control[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_NEW_CONTROLr_DIS_ECC_CHKf_GET(r) (((r).new_control[0]) & 0x1)
#define BCM53262_A0_NEW_CONTROLr_DIS_ECC_CHKf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_NEW_CONTROLr_MAX_RX_LIMITf_GET(r) ((((r).new_control[0]) >> 1) & 0x3)
#define BCM53262_A0_NEW_CONTROLr_MAX_RX_LIMITf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53262_A0_NEW_CONTROLr_BC_FM_ENf_GET(r) ((((r).new_control[0]) >> 3) & 0x1)
#define BCM53262_A0_NEW_CONTROLr_BC_FM_ENf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_NEW_CONTROLr_CLK25f_GET(r) ((((r).new_control[0]) >> 4) & 0x1)
#define BCM53262_A0_NEW_CONTROLr_CLK25f_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_NEW_CONTROLr_ULF_FM_ENf_GET(r) ((((r).new_control[0]) >> 5) & 0x1)
#define BCM53262_A0_NEW_CONTROLr_ULF_FM_ENf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_NEW_CONTROLr_MLF_FM_ENf_GET(r) ((((r).new_control[0]) >> 6) & 0x3)
#define BCM53262_A0_NEW_CONTROLr_MLF_FM_ENf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access NEW_CONTROL.
 */
#define BCM53262_A0_READ_NEW_CONTROLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_NEW_CONTROLr,(r._new_control),1)
#define BCM53262_A0_WRITE_NEW_CONTROLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_NEW_CONTROLr,&(r._new_control),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_CONTROLr BCM53262_A0_NEW_CONTROLr
#define NEW_CONTROLr_SIZE BCM53262_A0_NEW_CONTROLr_SIZE
typedef BCM53262_A0_NEW_CONTROLr_t NEW_CONTROLr_t;
#define NEW_CONTROLr_CLR BCM53262_A0_NEW_CONTROLr_CLR
#define NEW_CONTROLr_SET BCM53262_A0_NEW_CONTROLr_SET
#define NEW_CONTROLr_GET BCM53262_A0_NEW_CONTROLr_GET
#define NEW_CONTROLr_DIS_ECC_CHKf_GET BCM53262_A0_NEW_CONTROLr_DIS_ECC_CHKf_GET
#define NEW_CONTROLr_DIS_ECC_CHKf_SET BCM53262_A0_NEW_CONTROLr_DIS_ECC_CHKf_SET
#define NEW_CONTROLr_MAX_RX_LIMITf_GET BCM53262_A0_NEW_CONTROLr_MAX_RX_LIMITf_GET
#define NEW_CONTROLr_MAX_RX_LIMITf_SET BCM53262_A0_NEW_CONTROLr_MAX_RX_LIMITf_SET
#define NEW_CONTROLr_BC_FM_ENf_GET BCM53262_A0_NEW_CONTROLr_BC_FM_ENf_GET
#define NEW_CONTROLr_BC_FM_ENf_SET BCM53262_A0_NEW_CONTROLr_BC_FM_ENf_SET
#define NEW_CONTROLr_CLK25f_GET BCM53262_A0_NEW_CONTROLr_CLK25f_GET
#define NEW_CONTROLr_CLK25f_SET BCM53262_A0_NEW_CONTROLr_CLK25f_SET
#define NEW_CONTROLr_ULF_FM_ENf_GET BCM53262_A0_NEW_CONTROLr_ULF_FM_ENf_GET
#define NEW_CONTROLr_ULF_FM_ENf_SET BCM53262_A0_NEW_CONTROLr_ULF_FM_ENf_SET
#define NEW_CONTROLr_MLF_FM_ENf_GET BCM53262_A0_NEW_CONTROLr_MLF_FM_ENf_GET
#define NEW_CONTROLr_MLF_FM_ENf_SET BCM53262_A0_NEW_CONTROLr_MLF_FM_ENf_SET
#define READ_NEW_CONTROLr BCM53262_A0_READ_NEW_CONTROLr
#define WRITE_NEW_CONTROLr BCM53262_A0_WRITE_NEW_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_NEW_CONTROLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  OTHER_CHECKER
 * BLOCKS:   SYS
 * DESC:     Other Checker Register
 * SIZE:     16
 * FIELDS:
 *     BIG_ICMP         BIG_ICMP.
 *     TCP_HEAD_LEN     TCP Header Length.
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_OTHER_CHECKERr 0x00002150

#define BCM53262_A0_OTHER_CHECKERr_SIZE 2

/*
 * This structure should be used to declare and program OTHER_CHECKER.
 */
typedef union BCM53262_A0_OTHER_CHECKERr_s {
	uint32_t v[1];
	uint32_t other_checker[1];
	uint32_t _other_checker;
} BCM53262_A0_OTHER_CHECKERr_t;

#define BCM53262_A0_OTHER_CHECKERr_CLR(r) (r).other_checker[0] = 0
#define BCM53262_A0_OTHER_CHECKERr_SET(r,d) (r).other_checker[0] = d
#define BCM53262_A0_OTHER_CHECKERr_GET(r) (r).other_checker[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_OTHER_CHECKERr_BIG_ICMPf_GET(r) (((r).other_checker[0]) & 0x3ff)
#define BCM53262_A0_OTHER_CHECKERr_BIG_ICMPf_SET(r,f) (r).other_checker[0]=(((r).other_checker[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53262_A0_OTHER_CHECKERr_TCP_HEAD_LENf_GET(r) ((((r).other_checker[0]) >> 10) & 0xf)
#define BCM53262_A0_OTHER_CHECKERr_TCP_HEAD_LENf_SET(r,f) (r).other_checker[0]=(((r).other_checker[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM53262_A0_OTHER_CHECKERr_RESERVED_Rf_GET(r) ((((r).other_checker[0]) >> 14) & 0x3)
#define BCM53262_A0_OTHER_CHECKERr_RESERVED_Rf_SET(r,f) (r).other_checker[0]=(((r).other_checker[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access OTHER_CHECKER.
 */
#define BCM53262_A0_READ_OTHER_CHECKERr(u,r) cdk_robo_reg_read(u,BCM53262_A0_OTHER_CHECKERr,(r._other_checker),2)
#define BCM53262_A0_WRITE_OTHER_CHECKERr(u,r) cdk_robo_reg_write(u,BCM53262_A0_OTHER_CHECKERr,&(r._other_checker),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTHER_CHECKERr BCM53262_A0_OTHER_CHECKERr
#define OTHER_CHECKERr_SIZE BCM53262_A0_OTHER_CHECKERr_SIZE
typedef BCM53262_A0_OTHER_CHECKERr_t OTHER_CHECKERr_t;
#define OTHER_CHECKERr_CLR BCM53262_A0_OTHER_CHECKERr_CLR
#define OTHER_CHECKERr_SET BCM53262_A0_OTHER_CHECKERr_SET
#define OTHER_CHECKERr_GET BCM53262_A0_OTHER_CHECKERr_GET
#define OTHER_CHECKERr_BIG_ICMPf_GET BCM53262_A0_OTHER_CHECKERr_BIG_ICMPf_GET
#define OTHER_CHECKERr_BIG_ICMPf_SET BCM53262_A0_OTHER_CHECKERr_BIG_ICMPf_SET
#define OTHER_CHECKERr_TCP_HEAD_LENf_GET BCM53262_A0_OTHER_CHECKERr_TCP_HEAD_LENf_GET
#define OTHER_CHECKERr_TCP_HEAD_LENf_SET BCM53262_A0_OTHER_CHECKERr_TCP_HEAD_LENf_SET
#define OTHER_CHECKERr_RESERVED_Rf_GET BCM53262_A0_OTHER_CHECKERr_RESERVED_Rf_GET
#define OTHER_CHECKERr_RESERVED_Rf_SET BCM53262_A0_OTHER_CHECKERr_RESERVED_Rf_SET
#define READ_OTHER_CHECKERr BCM53262_A0_READ_OTHER_CHECKERr
#define WRITE_OTHER_CHECKERr BCM53262_A0_WRITE_OTHER_CHECKERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_OTHER_CHECKERr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  OTHER_TABLE_DATA0
 * BLOCKS:   SYS
 * DESC:     Other Table Data 0 Register
 * SIZE:     64
 * FIELDS:
 *     TABLE_DATA0      when VLAN Table access,TABLE_DATA0[63:53] Reserved.TABLE_DATA0[52:24] VLAN Table forwarding map.TABLE_DATA0[23:0]  Reserved.When Multicast Table access,TABLE_DATA0[63:53] Reserved.TABLE_DATA0[52:24] Multicast forwarding vector.TABLE_DATA0[23:0]  Reserved.When Multiple Spanning Tree Table access,TABLE_DATA0[63:0] Reserved.When VLAN2VLAN Table access,TABLE_DATA0[63:14] Reserved.TABLE_DATA0[13:12] 00: Reserved. 01: Mapping Mode. 10: Transparent Mode. 11:Reserved.TABLE_DATA0[11:0]  New VID.When MAC2VLAN Table access,TABLE_DATA0[63]    Valid_0.TABLE_DATA0[62:60] PRI_0, Priority for MAC-base.(SA)TABLE_DATA0[59:48] VID_0.TABLE_DATA0[47:0]  MAC_0, MAC address.When PROTOCOL2VLAN Table access,TABLE_DATA0[63:32] Reserved.TABLE_DATA0[31]    Valid.TABLE_DATA0[30:28] PRI, Priority for Protocol-base.TABLE_DATA0[27:16] VID.TABLE_DATA0[15:0]  Ether Type.When FLOW2VLAN Table access,TABLE_DATA0[63:12] Reserved.TABLE_DATA0[11:0]  VID.
 */
#define BCM53262_A0_OTHER_TABLE_DATA0r 0x00000538

#define BCM53262_A0_OTHER_TABLE_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program OTHER_TABLE_DATA0.
 */
typedef union BCM53262_A0_OTHER_TABLE_DATA0r_s {
	uint32_t v[2];
	uint32_t other_table_data0[2];
	uint32_t _other_table_data0;
} BCM53262_A0_OTHER_TABLE_DATA0r_t;

#define BCM53262_A0_OTHER_TABLE_DATA0r_CLR(r) CDK_MEMSET(&((r)._other_table_data0), 0, sizeof(BCM53262_A0_OTHER_TABLE_DATA0r_t))
#define BCM53262_A0_OTHER_TABLE_DATA0r_SET(r,i,d) (r).other_table_data0[i] = d
#define BCM53262_A0_OTHER_TABLE_DATA0r_GET(r,i) (r).other_table_data0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_OTHER_TABLE_DATA0r_TABLE_DATA0f_GET(r,a) cdk_field_get((r).other_table_data0,0,63,a)
#define BCM53262_A0_OTHER_TABLE_DATA0r_TABLE_DATA0f_SET(r,a) cdk_field_set((r).other_table_data0,0,63,a)

/*
 * These macros can be used to access OTHER_TABLE_DATA0.
 */
#define BCM53262_A0_READ_OTHER_TABLE_DATA0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_OTHER_TABLE_DATA0r,(r._other_table_data0),8)
#define BCM53262_A0_WRITE_OTHER_TABLE_DATA0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_OTHER_TABLE_DATA0r,&(r._other_table_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTHER_TABLE_DATA0r BCM53262_A0_OTHER_TABLE_DATA0r
#define OTHER_TABLE_DATA0r_SIZE BCM53262_A0_OTHER_TABLE_DATA0r_SIZE
typedef BCM53262_A0_OTHER_TABLE_DATA0r_t OTHER_TABLE_DATA0r_t;
#define OTHER_TABLE_DATA0r_CLR BCM53262_A0_OTHER_TABLE_DATA0r_CLR
#define OTHER_TABLE_DATA0r_SET BCM53262_A0_OTHER_TABLE_DATA0r_SET
#define OTHER_TABLE_DATA0r_GET BCM53262_A0_OTHER_TABLE_DATA0r_GET
#define OTHER_TABLE_DATA0r_TABLE_DATA0f_GET BCM53262_A0_OTHER_TABLE_DATA0r_TABLE_DATA0f_GET
#define OTHER_TABLE_DATA0r_TABLE_DATA0f_SET BCM53262_A0_OTHER_TABLE_DATA0r_TABLE_DATA0f_SET
#define READ_OTHER_TABLE_DATA0r BCM53262_A0_READ_OTHER_TABLE_DATA0r
#define WRITE_OTHER_TABLE_DATA0r BCM53262_A0_WRITE_OTHER_TABLE_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_OTHER_TABLE_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  OTHER_TABLE_DATA1
 * BLOCKS:   SYS
 * DESC:     Other Table Data 1 Register
 * SIZE:     64
 * FIELDS:
 *     TABLE_DATA1      when VLAN Table access,TABLE_DATA1[63:53] Reserved.TABLE_DATA1[52:24] VLAN Table un-tagging map.TABLE_DATA1[23:0]  Reserved.When Multicast Table access,TABLE_DATA1[63:0] Reserved.When Multiple Spanning Tree Table access,TABLE_DATA1[63:60] Reserved.TABLE_DATA1[59:57] Multiple spanning tree state for port 39.TABLE_DATA1[56:54] Multiple spanning tree state for port 38........TABLE_DATA1[14:12] Multiple spanning tree state for port 24.3'b000 = No spanning3'b001 = Disable state3'b010 = Blocking state3'b011 = Listening state3'b100 = Learning state3'b101 = Forawrding state3'b110 - 111 = ReservedTABLE_DATA1[11:0] Reserved.When VLAN2VLAN Table access,TABLE_DATA1[63:0] Reserved.When MAC2VLAN Table access,TABLE_DATA1[63]    Valid_1.TABLE_DATA1[62:60] PRI_1, Priority for MAC-base.(SA)TABLE_DATA1[59:48] VID_1.TABLE_DATA1[47:0]  MAC_1, MAC address.When PROTOCOL2VLAN Table access,TABLE_DATA1[63:0] Reserved.When FLOW2VLAN Table access,TABLE_DATA1[63:0] Reserved.
 */
#define BCM53262_A0_OTHER_TABLE_DATA1r 0x00000540

#define BCM53262_A0_OTHER_TABLE_DATA1r_SIZE 8

/*
 * This structure should be used to declare and program OTHER_TABLE_DATA1.
 */
typedef union BCM53262_A0_OTHER_TABLE_DATA1r_s {
	uint32_t v[2];
	uint32_t other_table_data1[2];
	uint32_t _other_table_data1;
} BCM53262_A0_OTHER_TABLE_DATA1r_t;

#define BCM53262_A0_OTHER_TABLE_DATA1r_CLR(r) CDK_MEMSET(&((r)._other_table_data1), 0, sizeof(BCM53262_A0_OTHER_TABLE_DATA1r_t))
#define BCM53262_A0_OTHER_TABLE_DATA1r_SET(r,i,d) (r).other_table_data1[i] = d
#define BCM53262_A0_OTHER_TABLE_DATA1r_GET(r,i) (r).other_table_data1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_OTHER_TABLE_DATA1r_TABLE_DATA1f_GET(r,a) cdk_field_get((r).other_table_data1,0,63,a)
#define BCM53262_A0_OTHER_TABLE_DATA1r_TABLE_DATA1f_SET(r,a) cdk_field_set((r).other_table_data1,0,63,a)

/*
 * These macros can be used to access OTHER_TABLE_DATA1.
 */
#define BCM53262_A0_READ_OTHER_TABLE_DATA1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_OTHER_TABLE_DATA1r,(r._other_table_data1),8)
#define BCM53262_A0_WRITE_OTHER_TABLE_DATA1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_OTHER_TABLE_DATA1r,&(r._other_table_data1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTHER_TABLE_DATA1r BCM53262_A0_OTHER_TABLE_DATA1r
#define OTHER_TABLE_DATA1r_SIZE BCM53262_A0_OTHER_TABLE_DATA1r_SIZE
typedef BCM53262_A0_OTHER_TABLE_DATA1r_t OTHER_TABLE_DATA1r_t;
#define OTHER_TABLE_DATA1r_CLR BCM53262_A0_OTHER_TABLE_DATA1r_CLR
#define OTHER_TABLE_DATA1r_SET BCM53262_A0_OTHER_TABLE_DATA1r_SET
#define OTHER_TABLE_DATA1r_GET BCM53262_A0_OTHER_TABLE_DATA1r_GET
#define OTHER_TABLE_DATA1r_TABLE_DATA1f_GET BCM53262_A0_OTHER_TABLE_DATA1r_TABLE_DATA1f_GET
#define OTHER_TABLE_DATA1r_TABLE_DATA1f_SET BCM53262_A0_OTHER_TABLE_DATA1r_TABLE_DATA1f_SET
#define READ_OTHER_TABLE_DATA1r BCM53262_A0_READ_OTHER_TABLE_DATA1r
#define WRITE_OTHER_TABLE_DATA1r BCM53262_A0_WRITE_OTHER_TABLE_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_OTHER_TABLE_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  OTHER_TABLE_DATA2
 * BLOCKS:   SYS
 * DESC:     Other Table Data 2 Register
 * SIZE:     64
 * FIELDS:
 *     TABLE_DATA2      when VLAN Table access,TABLE_DATA2[63:9] Reserved.TABLE_DATA2[8]    Disable learning process for VLAN.TABLE_DATA2[7:0]  VLAN Table spaning ID.When Multicast Table access,TABLE_DATA2[63:0] Reserved.When Multiple Spanning Tree Table access,TABLE_DATA2[63:39] Reserved.TABLE_DATA2[38:36] Multiple spanning tree state for port 52(G3).TABLE_DATA2[35:33] Multiple spanning tree state for port 51(G2)........TABLE_DATA2[2:0]   Multiple spanning tree state for port 40.3'b000 = No spanning3'b001 = Disable state3'b010 = Blocking state3'b011 = Listening state3'b100 = Learning state3'b101 = Forawrding state3'b110 - 111 = ReservedWhen VLAN2VLAN Table access,TABLE_DATA2[63:0] Reserved.When MAC2VLAN Table access,TABLE_DATA2[63:0] Reserved.When PROTOCOL2VLAN Table access,TABLE_DATA2[63:0] Reserved.When FLOW2VLAN Table access,TABLE_DATA2[63:0] Reserved.
 *     RESERVED_R       
 */
#define BCM53262_A0_OTHER_TABLE_DATA2r 0x00000548

#define BCM53262_A0_OTHER_TABLE_DATA2r_SIZE 8

/*
 * This structure should be used to declare and program OTHER_TABLE_DATA2.
 */
typedef union BCM53262_A0_OTHER_TABLE_DATA2r_s {
	uint32_t v[2];
	uint32_t other_table_data2[2];
	uint32_t _other_table_data2;
} BCM53262_A0_OTHER_TABLE_DATA2r_t;

#define BCM53262_A0_OTHER_TABLE_DATA2r_CLR(r) CDK_MEMSET(&((r)._other_table_data2), 0, sizeof(BCM53262_A0_OTHER_TABLE_DATA2r_t))
#define BCM53262_A0_OTHER_TABLE_DATA2r_SET(r,i,d) (r).other_table_data2[i] = d
#define BCM53262_A0_OTHER_TABLE_DATA2r_GET(r,i) (r).other_table_data2[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_OTHER_TABLE_DATA2r_TABLE_DATA2f_GET(r,a) cdk_field_get((r).other_table_data2,0,38,a)
#define BCM53262_A0_OTHER_TABLE_DATA2r_TABLE_DATA2f_SET(r,a) cdk_field_set((r).other_table_data2,0,38,a)
#define BCM53262_A0_OTHER_TABLE_DATA2r_RESERVED_Rf_GET(r) ((((r).other_table_data2[1]) >> 7) & 0x1ffffff)
#define BCM53262_A0_OTHER_TABLE_DATA2r_RESERVED_Rf_SET(r,f) (r).other_table_data2[1]=(((r).other_table_data2[1] & ~((uint32_t)0x1ffffff << 7)) | ((((uint32_t)f) & 0x1ffffff) << 7))

/*
 * These macros can be used to access OTHER_TABLE_DATA2.
 */
#define BCM53262_A0_READ_OTHER_TABLE_DATA2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_OTHER_TABLE_DATA2r,(r._other_table_data2),8)
#define BCM53262_A0_WRITE_OTHER_TABLE_DATA2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_OTHER_TABLE_DATA2r,&(r._other_table_data2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTHER_TABLE_DATA2r BCM53262_A0_OTHER_TABLE_DATA2r
#define OTHER_TABLE_DATA2r_SIZE BCM53262_A0_OTHER_TABLE_DATA2r_SIZE
typedef BCM53262_A0_OTHER_TABLE_DATA2r_t OTHER_TABLE_DATA2r_t;
#define OTHER_TABLE_DATA2r_CLR BCM53262_A0_OTHER_TABLE_DATA2r_CLR
#define OTHER_TABLE_DATA2r_SET BCM53262_A0_OTHER_TABLE_DATA2r_SET
#define OTHER_TABLE_DATA2r_GET BCM53262_A0_OTHER_TABLE_DATA2r_GET
#define OTHER_TABLE_DATA2r_TABLE_DATA2f_GET BCM53262_A0_OTHER_TABLE_DATA2r_TABLE_DATA2f_GET
#define OTHER_TABLE_DATA2r_TABLE_DATA2f_SET BCM53262_A0_OTHER_TABLE_DATA2r_TABLE_DATA2f_SET
#define OTHER_TABLE_DATA2r_RESERVED_Rf_GET BCM53262_A0_OTHER_TABLE_DATA2r_RESERVED_Rf_GET
#define OTHER_TABLE_DATA2r_RESERVED_Rf_SET BCM53262_A0_OTHER_TABLE_DATA2r_RESERVED_Rf_SET
#define READ_OTHER_TABLE_DATA2r BCM53262_A0_READ_OTHER_TABLE_DATA2r
#define WRITE_OTHER_TABLE_DATA2r BCM53262_A0_WRITE_OTHER_TABLE_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_OTHER_TABLE_DATA2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  OTHER_TABLE_INDEX
 * BLOCKS:   SYS
 * DESC:     Other Table Index Register
 * SIZE:     16
 * FIELDS:
 *     TABLE_INDEX      Page 05h; Offset 00h; bit[3:1] = 3'b001: VLAN Table Access.Page 05h; Offset 00h; bit[3:1] = 3'b010: Multicast Table Access.Page 05h; Offset 00h; bit[3:1] = 3'b011: Multiple Spanning Tree Table Access.Page 05h; Offset 00h; bit[3:1] = 3'b100: VLAN2VLAN Table Access.Page 05h; Offset 00h; bit[3:1] = 3'b101: MAC2VLAN Table Access.Page 05h; Offset 00h; bit[3:1] = 3'b110: PROTOCOL2VLAN Table Access.Page 05h; Offset 00h; bit[3:1] = 3'b111: FLOW2VLAN Table Access.When VLAN Table access, TABLE_INDEX [11:0] for VLAN Table Index.When Multicast Table access, TABLE_INDEX [11:0] for Multicast Table Index.When Multiple Spanning Tree Table access, TABLE_INDEX [7:0] for ultiple Spanning Tree Table Index.When VLAN2VLAN Table access, TABLE_INDEX [11:0] for VLAN2VLAN Table Index.When MAC2VLAN Table access, Reserved. (Note: Write MAC Address Index Register)When PROTOCOL2VLAN Table access, TABLE_INDEX [3:0] for PROTOCOL2VLAN Table Index.When FLOW2VLAN Table access, TABLE_INDEX [8:0] for FLOW2VLAN Table Index. 000-00F: for PORT24, 010-01F: for PORT25,....., 1C0-1CF: for PORT52.
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_OTHER_TABLE_INDEXr 0x00000530

#define BCM53262_A0_OTHER_TABLE_INDEXr_SIZE 2

/*
 * This structure should be used to declare and program OTHER_TABLE_INDEX.
 */
typedef union BCM53262_A0_OTHER_TABLE_INDEXr_s {
	uint32_t v[1];
	uint32_t other_table_index[1];
	uint32_t _other_table_index;
} BCM53262_A0_OTHER_TABLE_INDEXr_t;

#define BCM53262_A0_OTHER_TABLE_INDEXr_CLR(r) (r).other_table_index[0] = 0
#define BCM53262_A0_OTHER_TABLE_INDEXr_SET(r,d) (r).other_table_index[0] = d
#define BCM53262_A0_OTHER_TABLE_INDEXr_GET(r) (r).other_table_index[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_OTHER_TABLE_INDEXr_TABLE_INDEXf_GET(r) (((r).other_table_index[0]) & 0xfff)
#define BCM53262_A0_OTHER_TABLE_INDEXr_TABLE_INDEXf_SET(r,f) (r).other_table_index[0]=(((r).other_table_index[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_OTHER_TABLE_INDEXr_RESERVED_Rf_GET(r) ((((r).other_table_index[0]) >> 12) & 0xf)
#define BCM53262_A0_OTHER_TABLE_INDEXr_RESERVED_Rf_SET(r,f) (r).other_table_index[0]=(((r).other_table_index[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access OTHER_TABLE_INDEX.
 */
#define BCM53262_A0_READ_OTHER_TABLE_INDEXr(u,r) cdk_robo_reg_read(u,BCM53262_A0_OTHER_TABLE_INDEXr,(r._other_table_index),2)
#define BCM53262_A0_WRITE_OTHER_TABLE_INDEXr(u,r) cdk_robo_reg_write(u,BCM53262_A0_OTHER_TABLE_INDEXr,&(r._other_table_index),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTHER_TABLE_INDEXr BCM53262_A0_OTHER_TABLE_INDEXr
#define OTHER_TABLE_INDEXr_SIZE BCM53262_A0_OTHER_TABLE_INDEXr_SIZE
typedef BCM53262_A0_OTHER_TABLE_INDEXr_t OTHER_TABLE_INDEXr_t;
#define OTHER_TABLE_INDEXr_CLR BCM53262_A0_OTHER_TABLE_INDEXr_CLR
#define OTHER_TABLE_INDEXr_SET BCM53262_A0_OTHER_TABLE_INDEXr_SET
#define OTHER_TABLE_INDEXr_GET BCM53262_A0_OTHER_TABLE_INDEXr_GET
#define OTHER_TABLE_INDEXr_TABLE_INDEXf_GET BCM53262_A0_OTHER_TABLE_INDEXr_TABLE_INDEXf_GET
#define OTHER_TABLE_INDEXr_TABLE_INDEXf_SET BCM53262_A0_OTHER_TABLE_INDEXr_TABLE_INDEXf_SET
#define OTHER_TABLE_INDEXr_RESERVED_Rf_GET BCM53262_A0_OTHER_TABLE_INDEXr_RESERVED_Rf_GET
#define OTHER_TABLE_INDEXr_RESERVED_Rf_SET BCM53262_A0_OTHER_TABLE_INDEXr_RESERVED_Rf_SET
#define READ_OTHER_TABLE_INDEXr BCM53262_A0_READ_OTHER_TABLE_INDEXr
#define WRITE_OTHER_TABLE_INDEXr BCM53262_A0_WRITE_OTHER_TABLE_INDEXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_OTHER_TABLE_INDEXr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PAUSESTS
 * BLOCKS:   SYS
 * DESC:     Pause Status Summary Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     PAUSE_STS        PAUSE State.48bit field indicating the PAUSE state for each 10/100 BASE-T port  (bits 0-47 = 10/100 BASE-T ports).0 = Not pause enabled1 = Pause enabled
 *     PAUSE_STS_IMP    PAUSE State for Giga Port IMP.Bit1 : for TXBit0 : for RX
 *     PAUSE_STS_G0     PAUSE State for Giga Port g0.Bit1 : for TXBit0 : for RX
 *     PAUSE_STS_G1     PAUSE State for Giga Port g1.Bit1 : for RXBit0 : for TX
 *     PAUSE_STS_G2     PAUSE State for Giga Port g2.Bit1 : for TXBit0 : for RX
 *     PAUSE_STS_G3     PAUSE State for Giga Port g3.Bit1 : for TXBit0 : for RX
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_PAUSESTSr 0x00000230

#define BCM53262_A0_PAUSESTSr_SIZE 8

/*
 * This structure should be used to declare and program PAUSESTS.
 */
typedef union BCM53262_A0_PAUSESTSr_s {
	uint32_t v[2];
	uint32_t pausests[2];
	uint32_t _pausests;
} BCM53262_A0_PAUSESTSr_t;

#define BCM53262_A0_PAUSESTSr_CLR(r) CDK_MEMSET(&((r)._pausests), 0, sizeof(BCM53262_A0_PAUSESTSr_t))
#define BCM53262_A0_PAUSESTSr_SET(r,i,d) (r).pausests[i] = d
#define BCM53262_A0_PAUSESTSr_GET(r,i) (r).pausests[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PAUSESTSr_RESERVED_0Rf_GET(r) (((r).pausests[0]) & 0xffffff)
#define BCM53262_A0_PAUSESTSr_RESERVED_0Rf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_PAUSESTSr_PAUSE_STSf_GET(r) cdk_field32_get((r).pausests,24,47)
#define BCM53262_A0_PAUSESTSr_PAUSE_STSf_SET(r,f) cdk_field32_set((r).pausests,24,47,f)
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_IMPf_GET(r) ((((r).pausests[1]) >> 16) & 0x3)
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_IMPf_SET(r,f) (r).pausests[1]=(((r).pausests[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G0f_GET(r) ((((r).pausests[1]) >> 18) & 0x3)
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G0f_SET(r,f) (r).pausests[1]=(((r).pausests[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G1f_GET(r) ((((r).pausests[1]) >> 20) & 0x3)
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G1f_SET(r,f) (r).pausests[1]=(((r).pausests[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G2f_GET(r) ((((r).pausests[1]) >> 22) & 0x3)
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G2f_SET(r,f) (r).pausests[1]=(((r).pausests[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G3f_GET(r) ((((r).pausests[1]) >> 24) & 0x3)
#define BCM53262_A0_PAUSESTSr_PAUSE_STS_G3f_SET(r,f) (r).pausests[1]=(((r).pausests[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53262_A0_PAUSESTSr_RESERVED_1Rf_GET(r) ((((r).pausests[1]) >> 26) & 0x3f)
#define BCM53262_A0_PAUSESTSr_RESERVED_1Rf_SET(r,f) (r).pausests[1]=(((r).pausests[1] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access PAUSESTS.
 */
#define BCM53262_A0_READ_PAUSESTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PAUSESTSr,(r._pausests),8)
#define BCM53262_A0_WRITE_PAUSESTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PAUSESTSr,&(r._pausests),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSESTSr BCM53262_A0_PAUSESTSr
#define PAUSESTSr_SIZE BCM53262_A0_PAUSESTSr_SIZE
typedef BCM53262_A0_PAUSESTSr_t PAUSESTSr_t;
#define PAUSESTSr_CLR BCM53262_A0_PAUSESTSr_CLR
#define PAUSESTSr_SET BCM53262_A0_PAUSESTSr_SET
#define PAUSESTSr_GET BCM53262_A0_PAUSESTSr_GET
#define PAUSESTSr_RESERVED_0Rf_GET BCM53262_A0_PAUSESTSr_RESERVED_0Rf_GET
#define PAUSESTSr_RESERVED_0Rf_SET BCM53262_A0_PAUSESTSr_RESERVED_0Rf_SET
#define PAUSESTSr_PAUSE_STSf_GET BCM53262_A0_PAUSESTSr_PAUSE_STSf_GET
#define PAUSESTSr_PAUSE_STSf_SET BCM53262_A0_PAUSESTSr_PAUSE_STSf_SET
#define PAUSESTSr_PAUSE_STS_IMPf_GET BCM53262_A0_PAUSESTSr_PAUSE_STS_IMPf_GET
#define PAUSESTSr_PAUSE_STS_IMPf_SET BCM53262_A0_PAUSESTSr_PAUSE_STS_IMPf_SET
#define PAUSESTSr_PAUSE_STS_G0f_GET BCM53262_A0_PAUSESTSr_PAUSE_STS_G0f_GET
#define PAUSESTSr_PAUSE_STS_G0f_SET BCM53262_A0_PAUSESTSr_PAUSE_STS_G0f_SET
#define PAUSESTSr_PAUSE_STS_G1f_GET BCM53262_A0_PAUSESTSr_PAUSE_STS_G1f_GET
#define PAUSESTSr_PAUSE_STS_G1f_SET BCM53262_A0_PAUSESTSr_PAUSE_STS_G1f_SET
#define PAUSESTSr_PAUSE_STS_G2f_GET BCM53262_A0_PAUSESTSr_PAUSE_STS_G2f_GET
#define PAUSESTSr_PAUSE_STS_G2f_SET BCM53262_A0_PAUSESTSr_PAUSE_STS_G2f_SET
#define PAUSESTSr_PAUSE_STS_G3f_GET BCM53262_A0_PAUSESTSr_PAUSE_STS_G3f_GET
#define PAUSESTSr_PAUSE_STS_G3f_SET BCM53262_A0_PAUSESTSr_PAUSE_STS_G3f_SET
#define PAUSESTSr_RESERVED_1Rf_GET BCM53262_A0_PAUSESTSr_RESERVED_1Rf_GET
#define PAUSESTSr_RESERVED_1Rf_SET BCM53262_A0_PAUSESTSr_RESERVED_1Rf_SET
#define READ_PAUSESTSr BCM53262_A0_READ_PAUSESTSr
#define WRITE_PAUSESTSr BCM53262_A0_WRITE_PAUSESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PAUSESTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PHYIDH
 * BLOCKS:   EPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         
 */
#define BCM53262_A0_PHYIDHr 0x0000a004

#define BCM53262_A0_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDH.
 */
typedef union BCM53262_A0_PHYIDHr_s {
	uint32_t v[1];
	uint32_t phyidh[1];
	uint32_t _phyidh;
} BCM53262_A0_PHYIDHr_t;

#define BCM53262_A0_PHYIDHr_CLR(r) (r).phyidh[0] = 0
#define BCM53262_A0_PHYIDHr_SET(r,d) (r).phyidh[0] = d
#define BCM53262_A0_PHYIDHr_GET(r) (r).phyidh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PHYIDHr_MII_ADDRf_GET(r) (((r).phyidh[0]) & 0xffff)
#define BCM53262_A0_PHYIDHr_MII_ADDRf_SET(r,f) (r).phyidh[0]=(((r).phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDH.
 */
#define BCM53262_A0_READ_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PHYIDHr,(r._phyidh),2)
#define BCM53262_A0_WRITE_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PHYIDHr,&(r._phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDHr BCM53262_A0_PHYIDHr
#define PHYIDHr_SIZE BCM53262_A0_PHYIDHr_SIZE
typedef BCM53262_A0_PHYIDHr_t PHYIDHr_t;
#define PHYIDHr_CLR BCM53262_A0_PHYIDHr_CLR
#define PHYIDHr_SET BCM53262_A0_PHYIDHr_SET
#define PHYIDHr_GET BCM53262_A0_PHYIDHr_GET
#define PHYIDHr_MII_ADDRf_GET BCM53262_A0_PHYIDHr_MII_ADDRf_GET
#define PHYIDHr_MII_ADDRf_SET BCM53262_A0_PHYIDHr_MII_ADDRf_SET
#define READ_PHYIDHr BCM53262_A0_READ_PHYIDHr
#define WRITE_PHYIDHr BCM53262_A0_WRITE_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PHYIDHr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PHYIDL
 * BLOCKS:   EPIC0
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Default ValueBCM53242: 0xbf10BCM53262: 0xbf20
 */
#define BCM53262_A0_PHYIDLr 0x0000a006

#define BCM53262_A0_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDL.
 */
typedef union BCM53262_A0_PHYIDLr_s {
	uint32_t v[1];
	uint32_t phyidl[1];
	uint32_t _phyidl;
} BCM53262_A0_PHYIDLr_t;

#define BCM53262_A0_PHYIDLr_CLR(r) (r).phyidl[0] = 0
#define BCM53262_A0_PHYIDLr_SET(r,d) (r).phyidl[0] = d
#define BCM53262_A0_PHYIDLr_GET(r) (r).phyidl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PHYIDLr_MII_ADDRf_GET(r) (((r).phyidl[0]) & 0xffff)
#define BCM53262_A0_PHYIDLr_MII_ADDRf_SET(r,f) (r).phyidl[0]=(((r).phyidl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDL.
 */
#define BCM53262_A0_READ_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PHYIDLr,(r._phyidl),2)
#define BCM53262_A0_WRITE_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PHYIDLr,&(r._phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDLr BCM53262_A0_PHYIDLr
#define PHYIDLr_SIZE BCM53262_A0_PHYIDLr_SIZE
typedef BCM53262_A0_PHYIDLr_t PHYIDLr_t;
#define PHYIDLr_CLR BCM53262_A0_PHYIDLr_CLR
#define PHYIDLr_SET BCM53262_A0_PHYIDLr_SET
#define PHYIDLr_GET BCM53262_A0_PHYIDLr_GET
#define PHYIDLr_MII_ADDRf_GET BCM53262_A0_PHYIDLr_MII_ADDRf_GET
#define PHYIDLr_MII_ADDRf_SET BCM53262_A0_PHYIDLr_MII_ADDRf_SET
#define READ_PHYIDLr BCM53262_A0_READ_PHYIDLr
#define WRITE_PHYIDLr BCM53262_A0_WRITE_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PHYIDLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PHYINFO_PHYIDH
 * BLOCKS:   SYS
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         
 */
#define BCM53262_A0_PHYINFO_PHYIDHr 0x00001004

#define BCM53262_A0_PHYINFO_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program PHYINFO_PHYIDH.
 */
typedef union BCM53262_A0_PHYINFO_PHYIDHr_s {
	uint32_t v[1];
	uint32_t phyinfo_phyidh[1];
	uint32_t _phyinfo_phyidh;
} BCM53262_A0_PHYINFO_PHYIDHr_t;

#define BCM53262_A0_PHYINFO_PHYIDHr_CLR(r) (r).phyinfo_phyidh[0] = 0
#define BCM53262_A0_PHYINFO_PHYIDHr_SET(r,d) (r).phyinfo_phyidh[0] = d
#define BCM53262_A0_PHYINFO_PHYIDHr_GET(r) (r).phyinfo_phyidh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PHYINFO_PHYIDHr_MII_ADDRf_GET(r) (((r).phyinfo_phyidh[0]) & 0xffff)
#define BCM53262_A0_PHYINFO_PHYIDHr_MII_ADDRf_SET(r,f) (r).phyinfo_phyidh[0]=(((r).phyinfo_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYINFO_PHYIDH.
 */
#define BCM53262_A0_READ_PHYINFO_PHYIDHr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PHYINFO_PHYIDHr,(r._phyinfo_phyidh),2)
#define BCM53262_A0_WRITE_PHYINFO_PHYIDHr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PHYINFO_PHYIDHr,&(r._phyinfo_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYINFO_PHYIDHr BCM53262_A0_PHYINFO_PHYIDHr
#define PHYINFO_PHYIDHr_SIZE BCM53262_A0_PHYINFO_PHYIDHr_SIZE
typedef BCM53262_A0_PHYINFO_PHYIDHr_t PHYINFO_PHYIDHr_t;
#define PHYINFO_PHYIDHr_CLR BCM53262_A0_PHYINFO_PHYIDHr_CLR
#define PHYINFO_PHYIDHr_SET BCM53262_A0_PHYINFO_PHYIDHr_SET
#define PHYINFO_PHYIDHr_GET BCM53262_A0_PHYINFO_PHYIDHr_GET
#define PHYINFO_PHYIDHr_MII_ADDRf_GET BCM53262_A0_PHYINFO_PHYIDHr_MII_ADDRf_GET
#define PHYINFO_PHYIDHr_MII_ADDRf_SET BCM53262_A0_PHYINFO_PHYIDHr_MII_ADDRf_SET
#define READ_PHYINFO_PHYIDHr BCM53262_A0_READ_PHYINFO_PHYIDHr
#define WRITE_PHYINFO_PHYIDHr BCM53262_A0_WRITE_PHYINFO_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PHYINFO_PHYIDHr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PHYINFO_PHYIDL
 * BLOCKS:   SYS
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Default ValueBCM53242: 0xbf10BCM53262: 0xbf20
 */
#define BCM53262_A0_PHYINFO_PHYIDLr 0x00001006

#define BCM53262_A0_PHYINFO_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program PHYINFO_PHYIDL.
 */
typedef union BCM53262_A0_PHYINFO_PHYIDLr_s {
	uint32_t v[1];
	uint32_t phyinfo_phyidl[1];
	uint32_t _phyinfo_phyidl;
} BCM53262_A0_PHYINFO_PHYIDLr_t;

#define BCM53262_A0_PHYINFO_PHYIDLr_CLR(r) (r).phyinfo_phyidl[0] = 0
#define BCM53262_A0_PHYINFO_PHYIDLr_SET(r,d) (r).phyinfo_phyidl[0] = d
#define BCM53262_A0_PHYINFO_PHYIDLr_GET(r) (r).phyinfo_phyidl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PHYINFO_PHYIDLr_MII_ADDRf_GET(r) (((r).phyinfo_phyidl[0]) & 0xffff)
#define BCM53262_A0_PHYINFO_PHYIDLr_MII_ADDRf_SET(r,f) (r).phyinfo_phyidl[0]=(((r).phyinfo_phyidl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYINFO_PHYIDL.
 */
#define BCM53262_A0_READ_PHYINFO_PHYIDLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PHYINFO_PHYIDLr,(r._phyinfo_phyidl),2)
#define BCM53262_A0_WRITE_PHYINFO_PHYIDLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PHYINFO_PHYIDLr,&(r._phyinfo_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYINFO_PHYIDLr BCM53262_A0_PHYINFO_PHYIDLr
#define PHYINFO_PHYIDLr_SIZE BCM53262_A0_PHYINFO_PHYIDLr_SIZE
typedef BCM53262_A0_PHYINFO_PHYIDLr_t PHYINFO_PHYIDLr_t;
#define PHYINFO_PHYIDLr_CLR BCM53262_A0_PHYINFO_PHYIDLr_CLR
#define PHYINFO_PHYIDLr_SET BCM53262_A0_PHYINFO_PHYIDLr_SET
#define PHYINFO_PHYIDLr_GET BCM53262_A0_PHYINFO_PHYIDLr_GET
#define PHYINFO_PHYIDLr_MII_ADDRf_GET BCM53262_A0_PHYINFO_PHYIDLr_MII_ADDRf_GET
#define PHYINFO_PHYIDLr_MII_ADDRf_SET BCM53262_A0_PHYINFO_PHYIDLr_MII_ADDRf_SET
#define READ_PHYINFO_PHYIDLr BCM53262_A0_READ_PHYINFO_PHYIDLr
#define WRITE_PHYINFO_PHYIDLr BCM53262_A0_WRITE_PHYINFO_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PHYINFO_PHYIDLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PHYSCAN_CTL
 * BLOCKS:   SYS
 * DESC:     PHY Scan Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_INIT_CFG      Enable initial configure.
 *     EN_PHY_SCAN      Enable PHY Scan.
 *     RESERVED_R       Reserved
 *     PHY_START_ADDR   1'b0: PHY 0 address is 5'h00;1'b1: PHY 0 address is 5'h01,
 */
#define BCM53262_A0_PHYSCAN_CTLr 0x00000002

#define BCM53262_A0_PHYSCAN_CTLr_SIZE 1

/*
 * This structure should be used to declare and program PHYSCAN_CTL.
 */
typedef union BCM53262_A0_PHYSCAN_CTLr_s {
	uint32_t v[1];
	uint32_t physcan_ctl[1];
	uint32_t _physcan_ctl;
} BCM53262_A0_PHYSCAN_CTLr_t;

#define BCM53262_A0_PHYSCAN_CTLr_CLR(r) (r).physcan_ctl[0] = 0
#define BCM53262_A0_PHYSCAN_CTLr_SET(r,d) (r).physcan_ctl[0] = d
#define BCM53262_A0_PHYSCAN_CTLr_GET(r) (r).physcan_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PHYSCAN_CTLr_EN_INIT_CFGf_GET(r) (((r).physcan_ctl[0]) & 0x1)
#define BCM53262_A0_PHYSCAN_CTLr_EN_INIT_CFGf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_PHYSCAN_CTLr_EN_PHY_SCANf_GET(r) ((((r).physcan_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_PHYSCAN_CTLr_EN_PHY_SCANf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_PHYSCAN_CTLr_RESERVED_Rf_GET(r) ((((r).physcan_ctl[0]) >> 2) & 0x1f)
#define BCM53262_A0_PHYSCAN_CTLr_RESERVED_Rf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53262_A0_PHYSCAN_CTLr_PHY_START_ADDRf_GET(r) ((((r).physcan_ctl[0]) >> 7) & 0x1)
#define BCM53262_A0_PHYSCAN_CTLr_PHY_START_ADDRf_SET(r,f) (r).physcan_ctl[0]=(((r).physcan_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PHYSCAN_CTL.
 */
#define BCM53262_A0_READ_PHYSCAN_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PHYSCAN_CTLr,(r._physcan_ctl),1)
#define BCM53262_A0_WRITE_PHYSCAN_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PHYSCAN_CTLr,&(r._physcan_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYSCAN_CTLr BCM53262_A0_PHYSCAN_CTLr
#define PHYSCAN_CTLr_SIZE BCM53262_A0_PHYSCAN_CTLr_SIZE
typedef BCM53262_A0_PHYSCAN_CTLr_t PHYSCAN_CTLr_t;
#define PHYSCAN_CTLr_CLR BCM53262_A0_PHYSCAN_CTLr_CLR
#define PHYSCAN_CTLr_SET BCM53262_A0_PHYSCAN_CTLr_SET
#define PHYSCAN_CTLr_GET BCM53262_A0_PHYSCAN_CTLr_GET
#define PHYSCAN_CTLr_EN_INIT_CFGf_GET BCM53262_A0_PHYSCAN_CTLr_EN_INIT_CFGf_GET
#define PHYSCAN_CTLr_EN_INIT_CFGf_SET BCM53262_A0_PHYSCAN_CTLr_EN_INIT_CFGf_SET
#define PHYSCAN_CTLr_EN_PHY_SCANf_GET BCM53262_A0_PHYSCAN_CTLr_EN_PHY_SCANf_GET
#define PHYSCAN_CTLr_EN_PHY_SCANf_SET BCM53262_A0_PHYSCAN_CTLr_EN_PHY_SCANf_SET
#define PHYSCAN_CTLr_RESERVED_Rf_GET BCM53262_A0_PHYSCAN_CTLr_RESERVED_Rf_GET
#define PHYSCAN_CTLr_RESERVED_Rf_SET BCM53262_A0_PHYSCAN_CTLr_RESERVED_Rf_SET
#define PHYSCAN_CTLr_PHY_START_ADDRf_GET BCM53262_A0_PHYSCAN_CTLr_PHY_START_ADDRf_GET
#define PHYSCAN_CTLr_PHY_START_ADDRf_SET BCM53262_A0_PHYSCAN_CTLr_PHY_START_ADDRf_SET
#define READ_PHYSCAN_CTLr BCM53262_A0_READ_PHYSCAN_CTLr
#define WRITE_PHYSCAN_CTLr BCM53262_A0_WRITE_PHYSCAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PHYSCAN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PORTVEC1
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 1 Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     PORT_VCTR        Multiport Vector 1A bit mask corresponding to the physical ports on the chip. A frame with a DA matching the content of the Multiport Address 1 register will be forwarded to each port with a bit set in the Multiport Vector 1 bit map.Bits 0-47: 10/100BASE-T PortsBit 48: IMP PortsBit 49: Giga Port g0Bit 50: Giga port g1Bit 51: Giga Port g2Bit 52: Giga port g3
 *     PORTVEC_RSRV0    Reserved
 */
#define BCM53262_A0_PORTVEC1r 0x00000418

#define BCM53262_A0_PORTVEC1r_SIZE 8

/*
 * This structure should be used to declare and program PORTVEC1.
 */
typedef union BCM53262_A0_PORTVEC1r_s {
	uint32_t v[2];
	uint32_t portvec1[2];
	uint32_t _portvec1;
} BCM53262_A0_PORTVEC1r_t;

#define BCM53262_A0_PORTVEC1r_CLR(r) CDK_MEMSET(&((r)._portvec1), 0, sizeof(BCM53262_A0_PORTVEC1r_t))
#define BCM53262_A0_PORTVEC1r_SET(r,i,d) (r).portvec1[i] = d
#define BCM53262_A0_PORTVEC1r_GET(r,i) (r).portvec1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PORTVEC1r_RESERVED_Rf_GET(r) (((r).portvec1[0]) & 0xffffff)
#define BCM53262_A0_PORTVEC1r_RESERVED_Rf_SET(r,f) (r).portvec1[0]=(((r).portvec1[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_PORTVEC1r_PORT_VCTRf_GET(r) cdk_field32_get((r).portvec1,24,52)
#define BCM53262_A0_PORTVEC1r_PORT_VCTRf_SET(r,f) cdk_field32_set((r).portvec1,24,52,f)
#define BCM53262_A0_PORTVEC1r_PORTVEC_RSRV0f_GET(r) ((((r).portvec1[1]) >> 21) & 0x7ff)
#define BCM53262_A0_PORTVEC1r_PORTVEC_RSRV0f_SET(r,f) (r).portvec1[1]=(((r).portvec1[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORTVEC1.
 */
#define BCM53262_A0_READ_PORTVEC1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_PORTVEC1r,(r._portvec1),8)
#define BCM53262_A0_WRITE_PORTVEC1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_PORTVEC1r,&(r._portvec1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORTVEC1r BCM53262_A0_PORTVEC1r
#define PORTVEC1r_SIZE BCM53262_A0_PORTVEC1r_SIZE
typedef BCM53262_A0_PORTVEC1r_t PORTVEC1r_t;
#define PORTVEC1r_CLR BCM53262_A0_PORTVEC1r_CLR
#define PORTVEC1r_SET BCM53262_A0_PORTVEC1r_SET
#define PORTVEC1r_GET BCM53262_A0_PORTVEC1r_GET
#define PORTVEC1r_RESERVED_Rf_GET BCM53262_A0_PORTVEC1r_RESERVED_Rf_GET
#define PORTVEC1r_RESERVED_Rf_SET BCM53262_A0_PORTVEC1r_RESERVED_Rf_SET
#define PORTVEC1r_PORT_VCTRf_GET BCM53262_A0_PORTVEC1r_PORT_VCTRf_GET
#define PORTVEC1r_PORT_VCTRf_SET BCM53262_A0_PORTVEC1r_PORT_VCTRf_SET
#define PORTVEC1r_PORTVEC_RSRV0f_GET BCM53262_A0_PORTVEC1r_PORTVEC_RSRV0f_GET
#define PORTVEC1r_PORTVEC_RSRV0f_SET BCM53262_A0_PORTVEC1r_PORTVEC_RSRV0f_SET
#define READ_PORTVEC1r BCM53262_A0_READ_PORTVEC1r
#define WRITE_PORTVEC1r BCM53262_A0_WRITE_PORTVEC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PORTVEC1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PORTVEC2
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 2 Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     PORT_VCTR        Multiport Vector 2A bit mask corresponding to the physical ports on the chip. A frame with a DA matching the content of the Multiport Address 2 register will be forwarded to each port with a bit set in the Multiport Vector 2 bit map.Bits 0-47: 10/100BASE-T PortsBit 48: MII PortBit 49: Giga port g0Bit 50: Giga Port g1Bit 51: Giga port g2Bit 52: Giga Port g3
 *     PORTVEC_RSRV0    Reserved
 */
#define BCM53262_A0_PORTVEC2r 0x00000428

#define BCM53262_A0_PORTVEC2r_SIZE 8

/*
 * This structure should be used to declare and program PORTVEC2.
 */
typedef union BCM53262_A0_PORTVEC2r_s {
	uint32_t v[2];
	uint32_t portvec2[2];
	uint32_t _portvec2;
} BCM53262_A0_PORTVEC2r_t;

#define BCM53262_A0_PORTVEC2r_CLR(r) CDK_MEMSET(&((r)._portvec2), 0, sizeof(BCM53262_A0_PORTVEC2r_t))
#define BCM53262_A0_PORTVEC2r_SET(r,i,d) (r).portvec2[i] = d
#define BCM53262_A0_PORTVEC2r_GET(r,i) (r).portvec2[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PORTVEC2r_RESERVED_Rf_GET(r) (((r).portvec2[0]) & 0xffffff)
#define BCM53262_A0_PORTVEC2r_RESERVED_Rf_SET(r,f) (r).portvec2[0]=(((r).portvec2[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_PORTVEC2r_PORT_VCTRf_GET(r) cdk_field32_get((r).portvec2,24,52)
#define BCM53262_A0_PORTVEC2r_PORT_VCTRf_SET(r,f) cdk_field32_set((r).portvec2,24,52,f)
#define BCM53262_A0_PORTVEC2r_PORTVEC_RSRV0f_GET(r) ((((r).portvec2[1]) >> 21) & 0x7ff)
#define BCM53262_A0_PORTVEC2r_PORTVEC_RSRV0f_SET(r,f) (r).portvec2[1]=(((r).portvec2[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORTVEC2.
 */
#define BCM53262_A0_READ_PORTVEC2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_PORTVEC2r,(r._portvec2),8)
#define BCM53262_A0_WRITE_PORTVEC2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_PORTVEC2r,&(r._portvec2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORTVEC2r BCM53262_A0_PORTVEC2r
#define PORTVEC2r_SIZE BCM53262_A0_PORTVEC2r_SIZE
typedef BCM53262_A0_PORTVEC2r_t PORTVEC2r_t;
#define PORTVEC2r_CLR BCM53262_A0_PORTVEC2r_CLR
#define PORTVEC2r_SET BCM53262_A0_PORTVEC2r_SET
#define PORTVEC2r_GET BCM53262_A0_PORTVEC2r_GET
#define PORTVEC2r_RESERVED_Rf_GET BCM53262_A0_PORTVEC2r_RESERVED_Rf_GET
#define PORTVEC2r_RESERVED_Rf_SET BCM53262_A0_PORTVEC2r_RESERVED_Rf_SET
#define PORTVEC2r_PORT_VCTRf_GET BCM53262_A0_PORTVEC2r_PORT_VCTRf_GET
#define PORTVEC2r_PORT_VCTRf_SET BCM53262_A0_PORTVEC2r_PORT_VCTRf_SET
#define PORTVEC2r_PORTVEC_RSRV0f_GET BCM53262_A0_PORTVEC2r_PORTVEC_RSRV0f_GET
#define PORTVEC2r_PORTVEC_RSRV0f_SET BCM53262_A0_PORTVEC2r_PORTVEC_RSRV0f_SET
#define READ_PORTVEC2r BCM53262_A0_READ_PORTVEC2r
#define WRITE_PORTVEC2r BCM53262_A0_WRITE_PORTVEC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PORTVEC2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PORT_EAP_DA
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     PortX Unicast EAP DA Registers
 * SIZE:     48
 * FIELDS:
 *     EAP_UNI_DA       EAP frame Unicast DA register.Address 20h-25h : Port 24.Address 26h-2Bh : Port 25.......Address C8h-CDh : Port 52.
 */
#define BCM53262_A0_PORT_EAP_DAr 0x00004020

#define BCM53262_A0_PORT_EAP_DAr_SIZE 6

/*
 * This structure should be used to declare and program PORT_EAP_DA.
 */
typedef union BCM53262_A0_PORT_EAP_DAr_s {
	uint32_t v[2];
	uint32_t port_eap_da[2];
	uint32_t _port_eap_da;
} BCM53262_A0_PORT_EAP_DAr_t;

#define BCM53262_A0_PORT_EAP_DAr_CLR(r) CDK_MEMSET(&((r)._port_eap_da), 0, sizeof(BCM53262_A0_PORT_EAP_DAr_t))
#define BCM53262_A0_PORT_EAP_DAr_SET(r,i,d) (r).port_eap_da[i] = d
#define BCM53262_A0_PORT_EAP_DAr_GET(r,i) (r).port_eap_da[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PORT_EAP_DAr_EAP_UNI_DAf_GET(r,a) cdk_field_get((r).port_eap_da,0,47,a)
#define BCM53262_A0_PORT_EAP_DAr_EAP_UNI_DAf_SET(r,a) cdk_field_set((r).port_eap_da,0,47,a)

/*
 * These macros can be used to access PORT_EAP_DA.
 */
#define BCM53262_A0_READ_PORT_EAP_DAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PORT_EAP_DAr,(r._port_eap_da),6)
#define BCM53262_A0_WRITE_PORT_EAP_DAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PORT_EAP_DAr,&(r._port_eap_da),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EAP_DAr BCM53262_A0_PORT_EAP_DAr
#define PORT_EAP_DAr_SIZE BCM53262_A0_PORT_EAP_DAr_SIZE
typedef BCM53262_A0_PORT_EAP_DAr_t PORT_EAP_DAr_t;
#define PORT_EAP_DAr_CLR BCM53262_A0_PORT_EAP_DAr_CLR
#define PORT_EAP_DAr_SET BCM53262_A0_PORT_EAP_DAr_SET
#define PORT_EAP_DAr_GET BCM53262_A0_PORT_EAP_DAr_GET
#define PORT_EAP_DAr_EAP_UNI_DAf_GET BCM53262_A0_PORT_EAP_DAr_EAP_UNI_DAf_GET
#define PORT_EAP_DAr_EAP_UNI_DAf_SET BCM53262_A0_PORT_EAP_DAr_EAP_UNI_DAf_SET
#define READ_PORT_EAP_DAr BCM53262_A0_READ_PORT_EAP_DAr
#define WRITE_PORT_EAP_DAr BCM53262_A0_WRITE_PORT_EAP_DAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PORT_EAP_DAr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PORT_EGCTL
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     PORT 52 ~24 VLAN Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     PORT_EGRESS_EN   Port Egress Enable.
 *     PORT_EGCTL_RSRV1 Reserved
 */
#define BCM53262_A0_PORT_EGCTLr 0x00003300

#define BCM53262_A0_PORT_EGCTLr_SIZE 8

/*
 * This structure should be used to declare and program PORT_EGCTL.
 */
typedef union BCM53262_A0_PORT_EGCTLr_s {
	uint32_t v[2];
	uint32_t port_egctl[2];
	uint32_t _port_egctl;
} BCM53262_A0_PORT_EGCTLr_t;

#define BCM53262_A0_PORT_EGCTLr_CLR(r) CDK_MEMSET(&((r)._port_egctl), 0, sizeof(BCM53262_A0_PORT_EGCTLr_t))
#define BCM53262_A0_PORT_EGCTLr_SET(r,i,d) (r).port_egctl[i] = d
#define BCM53262_A0_PORT_EGCTLr_GET(r,i) (r).port_egctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PORT_EGCTLr_RESERVED_Rf_GET(r) (((r).port_egctl[0]) & 0xffffff)
#define BCM53262_A0_PORT_EGCTLr_RESERVED_Rf_SET(r,f) (r).port_egctl[0]=(((r).port_egctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_PORT_EGCTLr_PORT_EGRESS_ENf_GET(r) cdk_field32_get((r).port_egctl,24,52)
#define BCM53262_A0_PORT_EGCTLr_PORT_EGRESS_ENf_SET(r,f) cdk_field32_set((r).port_egctl,24,52,f)
#define BCM53262_A0_PORT_EGCTLr_PORT_EGCTL_RSRV1f_GET(r) ((((r).port_egctl[1]) >> 21) & 0x7ff)
#define BCM53262_A0_PORT_EGCTLr_PORT_EGCTL_RSRV1f_SET(r,f) (r).port_egctl[1]=(((r).port_egctl[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORT_EGCTL.
 */
#define BCM53262_A0_READ_PORT_EGCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PORT_EGCTLr,(r._port_egctl),8)
#define BCM53262_A0_WRITE_PORT_EGCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PORT_EGCTLr,&(r._port_egctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EGCTLr BCM53262_A0_PORT_EGCTLr
#define PORT_EGCTLr_SIZE BCM53262_A0_PORT_EGCTLr_SIZE
typedef BCM53262_A0_PORT_EGCTLr_t PORT_EGCTLr_t;
#define PORT_EGCTLr_CLR BCM53262_A0_PORT_EGCTLr_CLR
#define PORT_EGCTLr_SET BCM53262_A0_PORT_EGCTLr_SET
#define PORT_EGCTLr_GET BCM53262_A0_PORT_EGCTLr_GET
#define PORT_EGCTLr_RESERVED_Rf_GET BCM53262_A0_PORT_EGCTLr_RESERVED_Rf_GET
#define PORT_EGCTLr_RESERVED_Rf_SET BCM53262_A0_PORT_EGCTLr_RESERVED_Rf_SET
#define PORT_EGCTLr_PORT_EGRESS_ENf_GET BCM53262_A0_PORT_EGCTLr_PORT_EGRESS_ENf_GET
#define PORT_EGCTLr_PORT_EGRESS_ENf_SET BCM53262_A0_PORT_EGCTLr_PORT_EGRESS_ENf_SET
#define PORT_EGCTLr_PORT_EGCTL_RSRV1f_GET BCM53262_A0_PORT_EGCTLr_PORT_EGCTL_RSRV1f_GET
#define PORT_EGCTLr_PORT_EGCTL_RSRV1f_SET BCM53262_A0_PORT_EGCTLr_PORT_EGCTL_RSRV1f_SET
#define READ_PORT_EGCTLr BCM53262_A0_READ_PORT_EGCTLr
#define WRITE_PORT_EGCTLr BCM53262_A0_WRITE_PORT_EGCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PORT_EGCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PORT_MAX_LEARN
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     PortX Dynamic Learning Threshold Registers
 * SIZE:     16
 * FIELDS:
 *     DYN_MAX_MAC_NO   Dynamic Mode Maximum MAC Address Number for each port.{DYN_MAX_MAC_NO[12:0]} to indicated how many dynamic MAC address entries could be learned in system.Address 20h-21h : Port 24.Address 22h-23h : Port 25.......Address 58h-59h : Port 52.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_PORT_MAX_LEARNr 0x00004120

#define BCM53262_A0_PORT_MAX_LEARNr_SIZE 2

/*
 * This structure should be used to declare and program PORT_MAX_LEARN.
 */
typedef union BCM53262_A0_PORT_MAX_LEARNr_s {
	uint32_t v[1];
	uint32_t port_max_learn[1];
	uint32_t _port_max_learn;
} BCM53262_A0_PORT_MAX_LEARNr_t;

#define BCM53262_A0_PORT_MAX_LEARNr_CLR(r) (r).port_max_learn[0] = 0
#define BCM53262_A0_PORT_MAX_LEARNr_SET(r,d) (r).port_max_learn[0] = d
#define BCM53262_A0_PORT_MAX_LEARNr_GET(r) (r).port_max_learn[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PORT_MAX_LEARNr_DYN_MAX_MAC_NOf_GET(r) (((r).port_max_learn[0]) & 0x1fff)
#define BCM53262_A0_PORT_MAX_LEARNr_DYN_MAX_MAC_NOf_SET(r,f) (r).port_max_learn[0]=(((r).port_max_learn[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53262_A0_PORT_MAX_LEARNr_RESERVED_Rf_GET(r) ((((r).port_max_learn[0]) >> 13) & 0x7)
#define BCM53262_A0_PORT_MAX_LEARNr_RESERVED_Rf_SET(r,f) (r).port_max_learn[0]=(((r).port_max_learn[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PORT_MAX_LEARN.
 */
#define BCM53262_A0_READ_PORT_MAX_LEARNr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PORT_MAX_LEARNr,(r._port_max_learn),2)
#define BCM53262_A0_WRITE_PORT_MAX_LEARNr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PORT_MAX_LEARNr,&(r._port_max_learn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_MAX_LEARNr BCM53262_A0_PORT_MAX_LEARNr
#define PORT_MAX_LEARNr_SIZE BCM53262_A0_PORT_MAX_LEARNr_SIZE
typedef BCM53262_A0_PORT_MAX_LEARNr_t PORT_MAX_LEARNr_t;
#define PORT_MAX_LEARNr_CLR BCM53262_A0_PORT_MAX_LEARNr_CLR
#define PORT_MAX_LEARNr_SET BCM53262_A0_PORT_MAX_LEARNr_SET
#define PORT_MAX_LEARNr_GET BCM53262_A0_PORT_MAX_LEARNr_GET
#define PORT_MAX_LEARNr_DYN_MAX_MAC_NOf_GET BCM53262_A0_PORT_MAX_LEARNr_DYN_MAX_MAC_NOf_GET
#define PORT_MAX_LEARNr_DYN_MAX_MAC_NOf_SET BCM53262_A0_PORT_MAX_LEARNr_DYN_MAX_MAC_NOf_SET
#define PORT_MAX_LEARNr_RESERVED_Rf_GET BCM53262_A0_PORT_MAX_LEARNr_RESERVED_Rf_GET
#define PORT_MAX_LEARNr_RESERVED_Rf_SET BCM53262_A0_PORT_MAX_LEARNr_RESERVED_Rf_SET
#define READ_PORT_MAX_LEARNr BCM53262_A0_READ_PORT_MAX_LEARNr
#define WRITE_PORT_MAX_LEARNr BCM53262_A0_WRITE_PORT_MAX_LEARNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PORT_MAX_LEARNr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PORT_SA_CNT
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     PortX Current SA Learning Registers
 * SIZE:     16
 * FIELDS:
 *     CUR_SA_CNT       Port Current SA Count for up to 8K Dynamic Mode.Address 60h-61h : Port 24.Address 62h-63h : Port 25.......Address 98h-99h : Port 52.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_PORT_SA_CNTr 0x00004160

#define BCM53262_A0_PORT_SA_CNTr_SIZE 2

/*
 * This structure should be used to declare and program PORT_SA_CNT.
 */
typedef union BCM53262_A0_PORT_SA_CNTr_s {
	uint32_t v[1];
	uint32_t port_sa_cnt[1];
	uint32_t _port_sa_cnt;
} BCM53262_A0_PORT_SA_CNTr_t;

#define BCM53262_A0_PORT_SA_CNTr_CLR(r) (r).port_sa_cnt[0] = 0
#define BCM53262_A0_PORT_SA_CNTr_SET(r,d) (r).port_sa_cnt[0] = d
#define BCM53262_A0_PORT_SA_CNTr_GET(r) (r).port_sa_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PORT_SA_CNTr_CUR_SA_CNTf_GET(r) (((r).port_sa_cnt[0]) & 0x1fff)
#define BCM53262_A0_PORT_SA_CNTr_CUR_SA_CNTf_SET(r,f) (r).port_sa_cnt[0]=(((r).port_sa_cnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53262_A0_PORT_SA_CNTr_RESERVED_Rf_GET(r) ((((r).port_sa_cnt[0]) >> 13) & 0x7)
#define BCM53262_A0_PORT_SA_CNTr_RESERVED_Rf_SET(r,f) (r).port_sa_cnt[0]=(((r).port_sa_cnt[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access PORT_SA_CNT.
 */
#define BCM53262_A0_READ_PORT_SA_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PORT_SA_CNTr,(r._port_sa_cnt),2)
#define BCM53262_A0_WRITE_PORT_SA_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PORT_SA_CNTr,&(r._port_sa_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SA_CNTr BCM53262_A0_PORT_SA_CNTr
#define PORT_SA_CNTr_SIZE BCM53262_A0_PORT_SA_CNTr_SIZE
typedef BCM53262_A0_PORT_SA_CNTr_t PORT_SA_CNTr_t;
#define PORT_SA_CNTr_CLR BCM53262_A0_PORT_SA_CNTr_CLR
#define PORT_SA_CNTr_SET BCM53262_A0_PORT_SA_CNTr_SET
#define PORT_SA_CNTr_GET BCM53262_A0_PORT_SA_CNTr_GET
#define PORT_SA_CNTr_CUR_SA_CNTf_GET BCM53262_A0_PORT_SA_CNTr_CUR_SA_CNTf_GET
#define PORT_SA_CNTr_CUR_SA_CNTf_SET BCM53262_A0_PORT_SA_CNTr_CUR_SA_CNTf_SET
#define PORT_SA_CNTr_RESERVED_Rf_GET BCM53262_A0_PORT_SA_CNTr_RESERVED_Rf_GET
#define PORT_SA_CNTr_RESERVED_Rf_SET BCM53262_A0_PORT_SA_CNTr_RESERVED_Rf_SET
#define READ_PORT_SA_CNTr BCM53262_A0_READ_PORT_SA_CNTr
#define WRITE_PORT_SA_CNTr BCM53262_A0_WRITE_PORT_SA_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PORT_SA_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PORT_SEC_CON
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     PortX Security Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     EAP_MODE         Extend mode or basic mode00 : Basic mode (default).  SA will not be checked.01 : EAP Extended mode for unknown SA handling.  For all non-EAP frame and non-EAP special frame only, check SA and port number.  If unknown SA, drop or trap it, and this unknown SA is not learned in ARL.10 : EAP Extended mode for SA limited learning handling.  For all non-EAP frame and non-EAP special frame only, check its SA learning number.  If it exceeds the upper programmed number, drop or trap it, and this violated SA is not learned in ARL.11 : Reserved.
 *     EAP_PORT_BLK     Set local port to block mode.  (Do not need this bit for management port)00 : Local port is not blocked. (default)01 : Local port is blocked in ingress side.  Only 802.1x packet and special frame will be received.  And do not learn SA of incoming packet.10 : Local port is blocked in both ingress and egress side.  Only 802.1x packet and special frame will be received.  And do not learn SA of incoming packet.11 : Reserved
 *     EAP_EN_USER_DA   Enable EAP frame with user-MAC (unicast or multicast)  DA. This is to change the definition of "special frame" definition under EAP _PORT_BLK condition.0 : Do not support user DA EAP frame. (default)1 : Support user DA EAP frame.
 *     DIS_LEARN        0 : Learning enable. (default)1 : Learning disable
 *     SA_VIO_OPT       This control bit is used when set EAP_MODE = 2'b01 or 2'b10 and incoming packet with SA violation (not in ARL table or exceeding learning limitation)0 : Drop. (default)1 : Trap to IMP.
 *     ROAMING_OPT      Address 00h : Port 24.Address 01h : Port 25.......Address 1Ch : Port 52.This control bit is used when set EAP_MODE = 2'b10.0 : Not support address roaming. (default)1 : Support address roaming.
 */
#define BCM53262_A0_PORT_SEC_CONr 0x00004000

#define BCM53262_A0_PORT_SEC_CONr_SIZE 1

/*
 * This structure should be used to declare and program PORT_SEC_CON.
 */
typedef union BCM53262_A0_PORT_SEC_CONr_s {
	uint32_t v[1];
	uint32_t port_sec_con[1];
	uint32_t _port_sec_con;
} BCM53262_A0_PORT_SEC_CONr_t;

#define BCM53262_A0_PORT_SEC_CONr_CLR(r) (r).port_sec_con[0] = 0
#define BCM53262_A0_PORT_SEC_CONr_SET(r,d) (r).port_sec_con[0] = d
#define BCM53262_A0_PORT_SEC_CONr_GET(r) (r).port_sec_con[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PORT_SEC_CONr_EAP_MODEf_GET(r) (((r).port_sec_con[0]) & 0x3)
#define BCM53262_A0_PORT_SEC_CONr_EAP_MODEf_SET(r,f) (r).port_sec_con[0]=(((r).port_sec_con[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_PORT_SEC_CONr_EAP_PORT_BLKf_GET(r) ((((r).port_sec_con[0]) >> 2) & 0x3)
#define BCM53262_A0_PORT_SEC_CONr_EAP_PORT_BLKf_SET(r,f) (r).port_sec_con[0]=(((r).port_sec_con[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_PORT_SEC_CONr_EAP_EN_USER_DAf_GET(r) ((((r).port_sec_con[0]) >> 4) & 0x1)
#define BCM53262_A0_PORT_SEC_CONr_EAP_EN_USER_DAf_SET(r,f) (r).port_sec_con[0]=(((r).port_sec_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_PORT_SEC_CONr_DIS_LEARNf_GET(r) ((((r).port_sec_con[0]) >> 5) & 0x1)
#define BCM53262_A0_PORT_SEC_CONr_DIS_LEARNf_SET(r,f) (r).port_sec_con[0]=(((r).port_sec_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_PORT_SEC_CONr_SA_VIO_OPTf_GET(r) ((((r).port_sec_con[0]) >> 6) & 0x1)
#define BCM53262_A0_PORT_SEC_CONr_SA_VIO_OPTf_SET(r,f) (r).port_sec_con[0]=(((r).port_sec_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_PORT_SEC_CONr_ROAMING_OPTf_GET(r) ((((r).port_sec_con[0]) >> 7) & 0x1)
#define BCM53262_A0_PORT_SEC_CONr_ROAMING_OPTf_SET(r,f) (r).port_sec_con[0]=(((r).port_sec_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PORT_SEC_CON.
 */
#define BCM53262_A0_READ_PORT_SEC_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PORT_SEC_CONr,(r._port_sec_con),1)
#define BCM53262_A0_WRITE_PORT_SEC_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PORT_SEC_CONr,&(r._port_sec_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SEC_CONr BCM53262_A0_PORT_SEC_CONr
#define PORT_SEC_CONr_SIZE BCM53262_A0_PORT_SEC_CONr_SIZE
typedef BCM53262_A0_PORT_SEC_CONr_t PORT_SEC_CONr_t;
#define PORT_SEC_CONr_CLR BCM53262_A0_PORT_SEC_CONr_CLR
#define PORT_SEC_CONr_SET BCM53262_A0_PORT_SEC_CONr_SET
#define PORT_SEC_CONr_GET BCM53262_A0_PORT_SEC_CONr_GET
#define PORT_SEC_CONr_EAP_MODEf_GET BCM53262_A0_PORT_SEC_CONr_EAP_MODEf_GET
#define PORT_SEC_CONr_EAP_MODEf_SET BCM53262_A0_PORT_SEC_CONr_EAP_MODEf_SET
#define PORT_SEC_CONr_EAP_PORT_BLKf_GET BCM53262_A0_PORT_SEC_CONr_EAP_PORT_BLKf_GET
#define PORT_SEC_CONr_EAP_PORT_BLKf_SET BCM53262_A0_PORT_SEC_CONr_EAP_PORT_BLKf_SET
#define PORT_SEC_CONr_EAP_EN_USER_DAf_GET BCM53262_A0_PORT_SEC_CONr_EAP_EN_USER_DAf_GET
#define PORT_SEC_CONr_EAP_EN_USER_DAf_SET BCM53262_A0_PORT_SEC_CONr_EAP_EN_USER_DAf_SET
#define PORT_SEC_CONr_DIS_LEARNf_GET BCM53262_A0_PORT_SEC_CONr_DIS_LEARNf_GET
#define PORT_SEC_CONr_DIS_LEARNf_SET BCM53262_A0_PORT_SEC_CONr_DIS_LEARNf_SET
#define PORT_SEC_CONr_SA_VIO_OPTf_GET BCM53262_A0_PORT_SEC_CONr_SA_VIO_OPTf_GET
#define PORT_SEC_CONr_SA_VIO_OPTf_SET BCM53262_A0_PORT_SEC_CONr_SA_VIO_OPTf_SET
#define PORT_SEC_CONr_ROAMING_OPTf_GET BCM53262_A0_PORT_SEC_CONr_ROAMING_OPTf_GET
#define PORT_SEC_CONr_ROAMING_OPTf_SET BCM53262_A0_PORT_SEC_CONr_ROAMING_OPTf_SET
#define READ_PORT_SEC_CONr BCM53262_A0_READ_PORT_SEC_CONr
#define WRITE_PORT_SEC_CONr BCM53262_A0_WRITE_PORT_SEC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PORT_SEC_CONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PRBS_CTL
 * BLOCKS:   SYS
 * DESC:     PRBS Control Register
 * SIZE:     8
 * FIELDS:
 *     PRBS_ERR_CLR     Clear PRBS error  counter value .Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).This bit is a write and clear bit.
 *     PRBS_EN          Enable PRBS generator, when this bit is enabled,fiber_mode and en10b need to be asserted together because it generates the non-ethernet packet.Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 *     PRBS_ORDER       00: x(n)= 1 + x(6) + x(7)01: x(n)= 1 + x(14) + x(15)10: x(n)= 1 + x(14) + x(15)11: x(n)= 1 + x(28) + x(31)bit 3:2 for port 50 (Giga 1)bit 1:0 for port 49 (Giga 0)
 */
#define BCM53262_A0_PRBS_CTLr 0x00000d02

#define BCM53262_A0_PRBS_CTLr_SIZE 1

/*
 * This structure should be used to declare and program PRBS_CTL.
 */
typedef union BCM53262_A0_PRBS_CTLr_s {
	uint32_t v[1];
	uint32_t prbs_ctl[1];
	uint32_t _prbs_ctl;
} BCM53262_A0_PRBS_CTLr_t;

#define BCM53262_A0_PRBS_CTLr_CLR(r) (r).prbs_ctl[0] = 0
#define BCM53262_A0_PRBS_CTLr_SET(r,d) (r).prbs_ctl[0] = d
#define BCM53262_A0_PRBS_CTLr_GET(r) (r).prbs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PRBS_CTLr_PRBS_ERR_CLRf_GET(r) (((r).prbs_ctl[0]) & 0x3)
#define BCM53262_A0_PRBS_CTLr_PRBS_ERR_CLRf_SET(r,f) (r).prbs_ctl[0]=(((r).prbs_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_PRBS_CTLr_PRBS_ENf_GET(r) ((((r).prbs_ctl[0]) >> 2) & 0x3)
#define BCM53262_A0_PRBS_CTLr_PRBS_ENf_SET(r,f) (r).prbs_ctl[0]=(((r).prbs_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_PRBS_CTLr_PRBS_ORDERf_GET(r) ((((r).prbs_ctl[0]) >> 4) & 0xf)
#define BCM53262_A0_PRBS_CTLr_PRBS_ORDERf_SET(r,f) (r).prbs_ctl[0]=(((r).prbs_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PRBS_CTL.
 */
#define BCM53262_A0_READ_PRBS_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PRBS_CTLr,(r._prbs_ctl),1)
#define BCM53262_A0_WRITE_PRBS_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PRBS_CTLr,&(r._prbs_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRBS_CTLr BCM53262_A0_PRBS_CTLr
#define PRBS_CTLr_SIZE BCM53262_A0_PRBS_CTLr_SIZE
typedef BCM53262_A0_PRBS_CTLr_t PRBS_CTLr_t;
#define PRBS_CTLr_CLR BCM53262_A0_PRBS_CTLr_CLR
#define PRBS_CTLr_SET BCM53262_A0_PRBS_CTLr_SET
#define PRBS_CTLr_GET BCM53262_A0_PRBS_CTLr_GET
#define PRBS_CTLr_PRBS_ERR_CLRf_GET BCM53262_A0_PRBS_CTLr_PRBS_ERR_CLRf_GET
#define PRBS_CTLr_PRBS_ERR_CLRf_SET BCM53262_A0_PRBS_CTLr_PRBS_ERR_CLRf_SET
#define PRBS_CTLr_PRBS_ENf_GET BCM53262_A0_PRBS_CTLr_PRBS_ENf_GET
#define PRBS_CTLr_PRBS_ENf_SET BCM53262_A0_PRBS_CTLr_PRBS_ENf_SET
#define PRBS_CTLr_PRBS_ORDERf_GET BCM53262_A0_PRBS_CTLr_PRBS_ORDERf_GET
#define PRBS_CTLr_PRBS_ORDERf_SET BCM53262_A0_PRBS_CTLr_PRBS_ORDERf_SET
#define READ_PRBS_CTLr BCM53262_A0_READ_PRBS_CTLr
#define WRITE_PRBS_CTLr BCM53262_A0_WRITE_PRBS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PRBS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PRBS_STA
 * BLOCKS:   SYS
 * DESC:     PRBS Status Register
 * SIZE:     32
 * FIELDS:
 *     SW_STKY          PRBS Lost lock sticky bit.Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 *     PRBS_LOCK        PRBS monitor is locked.Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 *     PRBS_ERR_P49     Port 49 PRBS error counter.
 *     PRBS_ERR_P50     Port 50 PRBS error counter.
 */
#define BCM53262_A0_PRBS_STAr 0x00000d03

#define BCM53262_A0_PRBS_STAr_SIZE 4

/*
 * This structure should be used to declare and program PRBS_STA.
 */
typedef union BCM53262_A0_PRBS_STAr_s {
	uint32_t v[1];
	uint32_t prbs_sta[1];
	uint32_t _prbs_sta;
} BCM53262_A0_PRBS_STAr_t;

#define BCM53262_A0_PRBS_STAr_CLR(r) (r).prbs_sta[0] = 0
#define BCM53262_A0_PRBS_STAr_SET(r,d) (r).prbs_sta[0] = d
#define BCM53262_A0_PRBS_STAr_GET(r) (r).prbs_sta[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PRBS_STAr_SW_STKYf_GET(r) (((r).prbs_sta[0]) & 0x3)
#define BCM53262_A0_PRBS_STAr_SW_STKYf_SET(r,f) (r).prbs_sta[0]=(((r).prbs_sta[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_PRBS_STAr_PRBS_LOCKf_GET(r) ((((r).prbs_sta[0]) >> 2) & 0x3)
#define BCM53262_A0_PRBS_STAr_PRBS_LOCKf_SET(r,f) (r).prbs_sta[0]=(((r).prbs_sta[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_PRBS_STAr_PRBS_ERR_P49f_GET(r) ((((r).prbs_sta[0]) >> 4) & 0x3fff)
#define BCM53262_A0_PRBS_STAr_PRBS_ERR_P49f_SET(r,f) (r).prbs_sta[0]=(((r).prbs_sta[0] & ~((uint32_t)0x3fff << 4)) | ((((uint32_t)f) & 0x3fff) << 4))
#define BCM53262_A0_PRBS_STAr_PRBS_ERR_P50f_GET(r) ((((r).prbs_sta[0]) >> 18) & 0x3fff)
#define BCM53262_A0_PRBS_STAr_PRBS_ERR_P50f_SET(r,f) (r).prbs_sta[0]=(((r).prbs_sta[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PRBS_STA.
 */
#define BCM53262_A0_READ_PRBS_STAr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PRBS_STAr,(r._prbs_sta),4)
#define BCM53262_A0_WRITE_PRBS_STAr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PRBS_STAr,&(r._prbs_sta),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRBS_STAr BCM53262_A0_PRBS_STAr
#define PRBS_STAr_SIZE BCM53262_A0_PRBS_STAr_SIZE
typedef BCM53262_A0_PRBS_STAr_t PRBS_STAr_t;
#define PRBS_STAr_CLR BCM53262_A0_PRBS_STAr_CLR
#define PRBS_STAr_SET BCM53262_A0_PRBS_STAr_SET
#define PRBS_STAr_GET BCM53262_A0_PRBS_STAr_GET
#define PRBS_STAr_SW_STKYf_GET BCM53262_A0_PRBS_STAr_SW_STKYf_GET
#define PRBS_STAr_SW_STKYf_SET BCM53262_A0_PRBS_STAr_SW_STKYf_SET
#define PRBS_STAr_PRBS_LOCKf_GET BCM53262_A0_PRBS_STAr_PRBS_LOCKf_GET
#define PRBS_STAr_PRBS_LOCKf_SET BCM53262_A0_PRBS_STAr_PRBS_LOCKf_SET
#define PRBS_STAr_PRBS_ERR_P49f_GET BCM53262_A0_PRBS_STAr_PRBS_ERR_P49f_GET
#define PRBS_STAr_PRBS_ERR_P49f_SET BCM53262_A0_PRBS_STAr_PRBS_ERR_P49f_SET
#define PRBS_STAr_PRBS_ERR_P50f_GET BCM53262_A0_PRBS_STAr_PRBS_ERR_P50f_GET
#define PRBS_STAr_PRBS_ERR_P50f_SET BCM53262_A0_PRBS_STAr_PRBS_ERR_P50f_SET
#define READ_PRBS_STAr BCM53262_A0_READ_PRBS_STAr
#define WRITE_PRBS_STAr BCM53262_A0_WRITE_PRBS_STAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PRBS_STAr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PROTECTED_SEL
 * BLOCKS:   SYS
 * DESC:     Protected Port Select Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     PROTECTED_PORT_SELECT Protected port select map.
 *     PROTECTED_RESERVED Reserved
 */
#define BCM53262_A0_PROTECTED_SELr 0x00000040

#define BCM53262_A0_PROTECTED_SELr_SIZE 8

/*
 * This structure should be used to declare and program PROTECTED_SEL.
 */
typedef union BCM53262_A0_PROTECTED_SELr_s {
	uint32_t v[2];
	uint32_t protected_sel[2];
	uint32_t _protected_sel;
} BCM53262_A0_PROTECTED_SELr_t;

#define BCM53262_A0_PROTECTED_SELr_CLR(r) CDK_MEMSET(&((r)._protected_sel), 0, sizeof(BCM53262_A0_PROTECTED_SELr_t))
#define BCM53262_A0_PROTECTED_SELr_SET(r,i,d) (r).protected_sel[i] = d
#define BCM53262_A0_PROTECTED_SELr_GET(r,i) (r).protected_sel[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PROTECTED_SELr_RESERVED_Rf_GET(r) (((r).protected_sel[0]) & 0xffffff)
#define BCM53262_A0_PROTECTED_SELr_RESERVED_Rf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_PROTECTED_SELr_PROTECTED_PORT_SELECTf_GET(r) cdk_field32_get((r).protected_sel,24,52)
#define BCM53262_A0_PROTECTED_SELr_PROTECTED_PORT_SELECTf_SET(r,f) cdk_field32_set((r).protected_sel,24,52,f)
#define BCM53262_A0_PROTECTED_SELr_PROTECTED_RESERVEDf_GET(r) ((((r).protected_sel[1]) >> 21) & 0x7ff)
#define BCM53262_A0_PROTECTED_SELr_PROTECTED_RESERVEDf_SET(r,f) (r).protected_sel[1]=(((r).protected_sel[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PROTECTED_SEL.
 */
#define BCM53262_A0_READ_PROTECTED_SELr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PROTECTED_SELr,(r._protected_sel),8)
#define BCM53262_A0_WRITE_PROTECTED_SELr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PROTECTED_SELr,&(r._protected_sel),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTECTED_SELr BCM53262_A0_PROTECTED_SELr
#define PROTECTED_SELr_SIZE BCM53262_A0_PROTECTED_SELr_SIZE
typedef BCM53262_A0_PROTECTED_SELr_t PROTECTED_SELr_t;
#define PROTECTED_SELr_CLR BCM53262_A0_PROTECTED_SELr_CLR
#define PROTECTED_SELr_SET BCM53262_A0_PROTECTED_SELr_SET
#define PROTECTED_SELr_GET BCM53262_A0_PROTECTED_SELr_GET
#define PROTECTED_SELr_RESERVED_Rf_GET BCM53262_A0_PROTECTED_SELr_RESERVED_Rf_GET
#define PROTECTED_SELr_RESERVED_Rf_SET BCM53262_A0_PROTECTED_SELr_RESERVED_Rf_SET
#define PROTECTED_SELr_PROTECTED_PORT_SELECTf_GET BCM53262_A0_PROTECTED_SELr_PROTECTED_PORT_SELECTf_GET
#define PROTECTED_SELr_PROTECTED_PORT_SELECTf_SET BCM53262_A0_PROTECTED_SELr_PROTECTED_PORT_SELECTf_SET
#define PROTECTED_SELr_PROTECTED_RESERVEDf_GET BCM53262_A0_PROTECTED_SELr_PROTECTED_RESERVEDf_GET
#define PROTECTED_SELr_PROTECTED_RESERVEDf_SET BCM53262_A0_PROTECTED_SELr_PROTECTED_RESERVEDf_SET
#define READ_PROTECTED_SELr BCM53262_A0_READ_PROTECTED_SELr
#define WRITE_PROTECTED_SELr BCM53262_A0_WRITE_PROTECTED_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PROTECTED_SELr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  PROTOCOL2VLAN
 * BLOCKS:   SYS
 * DESC:     Statistic RAM
 * SIZE:     32
 * FIELDS:
 *     ETHER_TYPE       Ether type
 *     VID_R            Vlan id
 *     PRI_R            Prioritye
 *     VALID_R          Valid bit
 */
#define BCM53262_A0_PROTOCOL2VLANm 0x40060538

#define BCM53262_A0_PROTOCOL2VLANm_MIN 0
#define BCM53262_A0_PROTOCOL2VLANm_MAX 15
#define BCM53262_A0_PROTOCOL2VLANm_CMAX(u) 15
#define BCM53262_A0_PROTOCOL2VLANm_SIZE 4

/*
 * This structure should be used to declare and program PROTOCOL2VLAN.
 */
typedef union BCM53262_A0_PROTOCOL2VLANm_s {
	uint32_t v[1];
	uint32_t protocol2vlan[1];
	uint32_t _protocol2vlan;
} BCM53262_A0_PROTOCOL2VLANm_t;

#define BCM53262_A0_PROTOCOL2VLANm_CLR(r) (r).protocol2vlan[0] = 0
#define BCM53262_A0_PROTOCOL2VLANm_SET(r,d) (r).protocol2vlan[0] = d
#define BCM53262_A0_PROTOCOL2VLANm_GET(r) (r).protocol2vlan[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PROTOCOL2VLANm_ETHER_TYPEf_GET(r) (((r).protocol2vlan[0]) & 0xffff)
#define BCM53262_A0_PROTOCOL2VLANm_ETHER_TYPEf_SET(r,f) (r).protocol2vlan[0]=(((r).protocol2vlan[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53262_A0_PROTOCOL2VLANm_VID_Rf_GET(r) ((((r).protocol2vlan[0]) >> 16) & 0xfff)
#define BCM53262_A0_PROTOCOL2VLANm_VID_Rf_SET(r,f) (r).protocol2vlan[0]=(((r).protocol2vlan[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53262_A0_PROTOCOL2VLANm_PRI_Rf_GET(r) ((((r).protocol2vlan[0]) >> 28) & 0x7)
#define BCM53262_A0_PROTOCOL2VLANm_PRI_Rf_SET(r,f) (r).protocol2vlan[0]=(((r).protocol2vlan[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53262_A0_PROTOCOL2VLANm_VALID_Rf_GET(r) ((((r).protocol2vlan[0]) >> 31) & 0x1)
#define BCM53262_A0_PROTOCOL2VLANm_VALID_Rf_SET(r,f) (r).protocol2vlan[0]=(((r).protocol2vlan[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PROTOCOL2VLAN.
 */
#define BCM53262_A0_READ_PROTOCOL2VLANm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_PROTOCOL2VLANm,i,(m),4)
#define BCM53262_A0_WRITE_PROTOCOL2VLANm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_PROTOCOL2VLANm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTOCOL2VLANm BCM53262_A0_PROTOCOL2VLANm
#define PROTOCOL2VLANm_MIN BCM53262_A0_PROTOCOL2VLANm_MIN
#define PROTOCOL2VLANm_MAX BCM53262_A0_PROTOCOL2VLANm_MAX
#define PROTOCOL2VLANm_CMAX(u) BCM53262_A0_PROTOCOL2VLANm_CMAX(u)
#define PROTOCOL2VLANm_SIZE BCM53262_A0_PROTOCOL2VLANm_SIZE
typedef BCM53262_A0_PROTOCOL2VLANm_t PROTOCOL2VLANm_t;
#define PROTOCOL2VLANm_CLR BCM53262_A0_PROTOCOL2VLANm_CLR
#define PROTOCOL2VLANm_SET BCM53262_A0_PROTOCOL2VLANm_SET
#define PROTOCOL2VLANm_GET BCM53262_A0_PROTOCOL2VLANm_GET
#define PROTOCOL2VLANm_ETHER_TYPEf_GET BCM53262_A0_PROTOCOL2VLANm_ETHER_TYPEf_GET
#define PROTOCOL2VLANm_ETHER_TYPEf_SET BCM53262_A0_PROTOCOL2VLANm_ETHER_TYPEf_SET
#define PROTOCOL2VLANm_VID_Rf_GET BCM53262_A0_PROTOCOL2VLANm_VID_Rf_GET
#define PROTOCOL2VLANm_VID_Rf_SET BCM53262_A0_PROTOCOL2VLANm_VID_Rf_SET
#define PROTOCOL2VLANm_PRI_Rf_GET BCM53262_A0_PROTOCOL2VLANm_PRI_Rf_GET
#define PROTOCOL2VLANm_PRI_Rf_SET BCM53262_A0_PROTOCOL2VLANm_PRI_Rf_SET
#define PROTOCOL2VLANm_VALID_Rf_GET BCM53262_A0_PROTOCOL2VLANm_VALID_Rf_GET
#define PROTOCOL2VLANm_VALID_Rf_SET BCM53262_A0_PROTOCOL2VLANm_VALID_Rf_SET
#define READ_PROTOCOL2VLANm BCM53262_A0_READ_PROTOCOL2VLANm
#define WRITE_PROTOCOL2VLANm BCM53262_A0_WRITE_PROTOCOL2VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PROTOCOL2VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PROTOCOL2VLAN_CTL
 * BLOCKS:   SYS
 * DESC:     PROTOCOL2VLAN Control Registers
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     PROTOCOL2VLAN_CTL PROTOCOL2VLAN Control Registers.When set to 1, enable PROTOCOL2VLAN table lookup.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_PROTOCOL2VLAN_CTLr 0x000034b0

#define BCM53262_A0_PROTOCOL2VLAN_CTLr_SIZE 8

/*
 * This structure should be used to declare and program PROTOCOL2VLAN_CTL.
 */
typedef union BCM53262_A0_PROTOCOL2VLAN_CTLr_s {
	uint32_t v[2];
	uint32_t protocol2vlan_ctl[2];
	uint32_t _protocol2vlan_ctl;
} BCM53262_A0_PROTOCOL2VLAN_CTLr_t;

#define BCM53262_A0_PROTOCOL2VLAN_CTLr_CLR(r) CDK_MEMSET(&((r)._protocol2vlan_ctl), 0, sizeof(BCM53262_A0_PROTOCOL2VLAN_CTLr_t))
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_SET(r,i,d) (r).protocol2vlan_ctl[i] = d
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_GET(r,i) (r).protocol2vlan_ctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_0Rf_GET(r) (((r).protocol2vlan_ctl[0]) & 0xffffff)
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_0Rf_SET(r,f) (r).protocol2vlan_ctl[0]=(((r).protocol2vlan_ctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_PROTOCOL2VLAN_CTLf_GET(r) cdk_field32_get((r).protocol2vlan_ctl,24,52)
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_PROTOCOL2VLAN_CTLf_SET(r,f) cdk_field32_set((r).protocol2vlan_ctl,24,52,f)
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_1Rf_GET(r) ((((r).protocol2vlan_ctl[1]) >> 21) & 0x7ff)
#define BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_1Rf_SET(r,f) (r).protocol2vlan_ctl[1]=(((r).protocol2vlan_ctl[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PROTOCOL2VLAN_CTL.
 */
#define BCM53262_A0_READ_PROTOCOL2VLAN_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PROTOCOL2VLAN_CTLr,(r._protocol2vlan_ctl),8)
#define BCM53262_A0_WRITE_PROTOCOL2VLAN_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PROTOCOL2VLAN_CTLr,&(r._protocol2vlan_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTOCOL2VLAN_CTLr BCM53262_A0_PROTOCOL2VLAN_CTLr
#define PROTOCOL2VLAN_CTLr_SIZE BCM53262_A0_PROTOCOL2VLAN_CTLr_SIZE
typedef BCM53262_A0_PROTOCOL2VLAN_CTLr_t PROTOCOL2VLAN_CTLr_t;
#define PROTOCOL2VLAN_CTLr_CLR BCM53262_A0_PROTOCOL2VLAN_CTLr_CLR
#define PROTOCOL2VLAN_CTLr_SET BCM53262_A0_PROTOCOL2VLAN_CTLr_SET
#define PROTOCOL2VLAN_CTLr_GET BCM53262_A0_PROTOCOL2VLAN_CTLr_GET
#define PROTOCOL2VLAN_CTLr_RESERVED_0Rf_GET BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_0Rf_GET
#define PROTOCOL2VLAN_CTLr_RESERVED_0Rf_SET BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_0Rf_SET
#define PROTOCOL2VLAN_CTLr_PROTOCOL2VLAN_CTLf_GET BCM53262_A0_PROTOCOL2VLAN_CTLr_PROTOCOL2VLAN_CTLf_GET
#define PROTOCOL2VLAN_CTLr_PROTOCOL2VLAN_CTLf_SET BCM53262_A0_PROTOCOL2VLAN_CTLr_PROTOCOL2VLAN_CTLf_SET
#define PROTOCOL2VLAN_CTLr_RESERVED_1Rf_GET BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_1Rf_GET
#define PROTOCOL2VLAN_CTLr_RESERVED_1Rf_SET BCM53262_A0_PROTOCOL2VLAN_CTLr_RESERVED_1Rf_SET
#define READ_PROTOCOL2VLAN_CTLr BCM53262_A0_READ_PROTOCOL2VLAN_CTLr
#define WRITE_PROTOCOL2VLAN_CTLr BCM53262_A0_WRITE_PROTOCOL2VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PROTOCOL2VLAN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  PWR_DOWN_MODE
 * BLOCKS:   SYS
 * DESC:     Power Down Mode Register
 * SIZE:     32
 * FIELDS:
 *     PORTX_PWR_DOWN   Individual port power down register.Disables all clocking to an individual PHY port.0: PHY is enabled.1: PHY is disabled.bit23~bit0 for port47 ~ port24,bit24 for IMP port,bit28~bit25 for giga port3 ~ giga port0 .
 *     PWR_DOWN_RESERVED Reserved
 */
#define BCM53262_A0_PWR_DOWN_MODEr 0x00000005

#define BCM53262_A0_PWR_DOWN_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PWR_DOWN_MODE.
 */
typedef union BCM53262_A0_PWR_DOWN_MODEr_s {
	uint32_t v[1];
	uint32_t pwr_down_mode[1];
	uint32_t _pwr_down_mode;
} BCM53262_A0_PWR_DOWN_MODEr_t;

#define BCM53262_A0_PWR_DOWN_MODEr_CLR(r) (r).pwr_down_mode[0] = 0
#define BCM53262_A0_PWR_DOWN_MODEr_SET(r,d) (r).pwr_down_mode[0] = d
#define BCM53262_A0_PWR_DOWN_MODEr_GET(r) (r).pwr_down_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_GET(r) (((r).pwr_down_mode[0]) & 0x1fffffff)
#define BCM53262_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_SET(r,f) (r).pwr_down_mode[0]=(((r).pwr_down_mode[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53262_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVEDf_GET(r) ((((r).pwr_down_mode[0]) >> 29) & 0x7)
#define BCM53262_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVEDf_SET(r,f) (r).pwr_down_mode[0]=(((r).pwr_down_mode[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access PWR_DOWN_MODE.
 */
#define BCM53262_A0_READ_PWR_DOWN_MODEr(u,r) cdk_robo_reg_read(u,BCM53262_A0_PWR_DOWN_MODEr,(r._pwr_down_mode),4)
#define BCM53262_A0_WRITE_PWR_DOWN_MODEr(u,r) cdk_robo_reg_write(u,BCM53262_A0_PWR_DOWN_MODEr,&(r._pwr_down_mode),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PWR_DOWN_MODEr BCM53262_A0_PWR_DOWN_MODEr
#define PWR_DOWN_MODEr_SIZE BCM53262_A0_PWR_DOWN_MODEr_SIZE
typedef BCM53262_A0_PWR_DOWN_MODEr_t PWR_DOWN_MODEr_t;
#define PWR_DOWN_MODEr_CLR BCM53262_A0_PWR_DOWN_MODEr_CLR
#define PWR_DOWN_MODEr_SET BCM53262_A0_PWR_DOWN_MODEr_SET
#define PWR_DOWN_MODEr_GET BCM53262_A0_PWR_DOWN_MODEr_GET
#define PWR_DOWN_MODEr_PORTX_PWR_DOWNf_GET BCM53262_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_GET
#define PWR_DOWN_MODEr_PORTX_PWR_DOWNf_SET BCM53262_A0_PWR_DOWN_MODEr_PORTX_PWR_DOWNf_SET
#define PWR_DOWN_MODEr_PWR_DOWN_RESERVEDf_GET BCM53262_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVEDf_GET
#define PWR_DOWN_MODEr_PWR_DOWN_RESERVEDf_SET BCM53262_A0_PWR_DOWN_MODEr_PWR_DOWN_RESERVEDf_SET
#define READ_PWR_DOWN_MODEr BCM53262_A0_READ_PWR_DOWN_MODEr
#define WRITE_PWR_DOWN_MODEr BCM53262_A0_WRITE_PWR_DOWN_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PWR_DOWN_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  Pkts1024toMaxOctets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx 1024 to Max Bytes Octets Counter
 * SIZE:     32
 */
#define BCM53262_A0_PKTS1024TOMAXOCTETSr 0x0000688c

#define BCM53262_A0_PKTS1024TOMAXOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxOctets.
 */
typedef union BCM53262_A0_PKTS1024TOMAXOCTETSr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxoctets[1];
	uint32_t _pkts1024tomaxoctets;
} BCM53262_A0_PKTS1024TOMAXOCTETSr_t;

#define BCM53262_A0_PKTS1024TOMAXOCTETSr_CLR(r) (r).pkts1024tomaxoctets[0] = 0
#define BCM53262_A0_PKTS1024TOMAXOCTETSr_SET(r,d) (r).pkts1024tomaxoctets[0] = d
#define BCM53262_A0_PKTS1024TOMAXOCTETSr_GET(r) (r).pkts1024tomaxoctets[0]


/*
 * These macros can be used to access Pkts1024toMaxOctets.
 */
#define BCM53262_A0_READ_PKTS1024TOMAXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PKTS1024TOMAXOCTETSr,(r._pkts1024tomaxoctets),4)
#define BCM53262_A0_WRITE_PKTS1024TOMAXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PKTS1024TOMAXOCTETSr,&(r._pkts1024tomaxoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXOCTETSr BCM53262_A0_PKTS1024TOMAXOCTETSr
#define PKTS1024TOMAXOCTETSr_SIZE BCM53262_A0_PKTS1024TOMAXOCTETSr_SIZE
typedef BCM53262_A0_PKTS1024TOMAXOCTETSr_t PKTS1024TOMAXOCTETSr_t;
#define PKTS1024TOMAXOCTETSr_CLR BCM53262_A0_PKTS1024TOMAXOCTETSr_CLR
#define PKTS1024TOMAXOCTETSr_SET BCM53262_A0_PKTS1024TOMAXOCTETSr_SET
#define PKTS1024TOMAXOCTETSr_GET BCM53262_A0_PKTS1024TOMAXOCTETSr_GET
#define READ_PKTS1024TOMAXOCTETSr BCM53262_A0_READ_PKTS1024TOMAXOCTETSr
#define WRITE_PKTS1024TOMAXOCTETSr BCM53262_A0_WRITE_PKTS1024TOMAXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PKTS1024TOMAXOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  Pkts128to255Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 */
#define BCM53262_A0_PKTS128TO255OCTETSr 0x00006880

#define BCM53262_A0_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets.
 */
typedef union BCM53262_A0_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets[1];
	uint32_t _pkts128to255octets;
} BCM53262_A0_PKTS128TO255OCTETSr_t;

#define BCM53262_A0_PKTS128TO255OCTETSr_CLR(r) (r).pkts128to255octets[0] = 0
#define BCM53262_A0_PKTS128TO255OCTETSr_SET(r,d) (r).pkts128to255octets[0] = d
#define BCM53262_A0_PKTS128TO255OCTETSr_GET(r) (r).pkts128to255octets[0]


/*
 * These macros can be used to access Pkts128to255Octets.
 */
#define BCM53262_A0_READ_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PKTS128TO255OCTETSr,(r._pkts128to255octets),4)
#define BCM53262_A0_WRITE_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PKTS128TO255OCTETSr,&(r._pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETSr BCM53262_A0_PKTS128TO255OCTETSr
#define PKTS128TO255OCTETSr_SIZE BCM53262_A0_PKTS128TO255OCTETSr_SIZE
typedef BCM53262_A0_PKTS128TO255OCTETSr_t PKTS128TO255OCTETSr_t;
#define PKTS128TO255OCTETSr_CLR BCM53262_A0_PKTS128TO255OCTETSr_CLR
#define PKTS128TO255OCTETSr_SET BCM53262_A0_PKTS128TO255OCTETSr_SET
#define PKTS128TO255OCTETSr_GET BCM53262_A0_PKTS128TO255OCTETSr_GET
#define READ_PKTS128TO255OCTETSr BCM53262_A0_READ_PKTS128TO255OCTETSr
#define WRITE_PKTS128TO255OCTETSr BCM53262_A0_WRITE_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PKTS128TO255OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  Pkts256to511Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 */
#define BCM53262_A0_PKTS256TO511OCTETSr 0x00006884

#define BCM53262_A0_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets.
 */
typedef union BCM53262_A0_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets[1];
	uint32_t _pkts256to511octets;
} BCM53262_A0_PKTS256TO511OCTETSr_t;

#define BCM53262_A0_PKTS256TO511OCTETSr_CLR(r) (r).pkts256to511octets[0] = 0
#define BCM53262_A0_PKTS256TO511OCTETSr_SET(r,d) (r).pkts256to511octets[0] = d
#define BCM53262_A0_PKTS256TO511OCTETSr_GET(r) (r).pkts256to511octets[0]


/*
 * These macros can be used to access Pkts256to511Octets.
 */
#define BCM53262_A0_READ_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PKTS256TO511OCTETSr,(r._pkts256to511octets),4)
#define BCM53262_A0_WRITE_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PKTS256TO511OCTETSr,&(r._pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETSr BCM53262_A0_PKTS256TO511OCTETSr
#define PKTS256TO511OCTETSr_SIZE BCM53262_A0_PKTS256TO511OCTETSr_SIZE
typedef BCM53262_A0_PKTS256TO511OCTETSr_t PKTS256TO511OCTETSr_t;
#define PKTS256TO511OCTETSr_CLR BCM53262_A0_PKTS256TO511OCTETSr_CLR
#define PKTS256TO511OCTETSr_SET BCM53262_A0_PKTS256TO511OCTETSr_SET
#define PKTS256TO511OCTETSr_GET BCM53262_A0_PKTS256TO511OCTETSr_GET
#define READ_PKTS256TO511OCTETSr BCM53262_A0_READ_PKTS256TO511OCTETSr
#define WRITE_PKTS256TO511OCTETSr BCM53262_A0_WRITE_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PKTS256TO511OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  Pkts512to1023Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 */
#define BCM53262_A0_PKTS512TO1023OCTETSr 0x00006888

#define BCM53262_A0_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets.
 */
typedef union BCM53262_A0_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets[1];
	uint32_t _pkts512to1023octets;
} BCM53262_A0_PKTS512TO1023OCTETSr_t;

#define BCM53262_A0_PKTS512TO1023OCTETSr_CLR(r) (r).pkts512to1023octets[0] = 0
#define BCM53262_A0_PKTS512TO1023OCTETSr_SET(r,d) (r).pkts512to1023octets[0] = d
#define BCM53262_A0_PKTS512TO1023OCTETSr_GET(r) (r).pkts512to1023octets[0]


/*
 * These macros can be used to access Pkts512to1023Octets.
 */
#define BCM53262_A0_READ_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PKTS512TO1023OCTETSr,(r._pkts512to1023octets),4)
#define BCM53262_A0_WRITE_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PKTS512TO1023OCTETSr,&(r._pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETSr BCM53262_A0_PKTS512TO1023OCTETSr
#define PKTS512TO1023OCTETSr_SIZE BCM53262_A0_PKTS512TO1023OCTETSr_SIZE
typedef BCM53262_A0_PKTS512TO1023OCTETSr_t PKTS512TO1023OCTETSr_t;
#define PKTS512TO1023OCTETSr_CLR BCM53262_A0_PKTS512TO1023OCTETSr_CLR
#define PKTS512TO1023OCTETSr_SET BCM53262_A0_PKTS512TO1023OCTETSr_SET
#define PKTS512TO1023OCTETSr_GET BCM53262_A0_PKTS512TO1023OCTETSr_GET
#define READ_PKTS512TO1023OCTETSr BCM53262_A0_READ_PKTS512TO1023OCTETSr
#define WRITE_PKTS512TO1023OCTETSr BCM53262_A0_WRITE_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PKTS512TO1023OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  Pkts64Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 */
#define BCM53262_A0_PKTS64OCTETSr 0x00006878

#define BCM53262_A0_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets.
 */
typedef union BCM53262_A0_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts64octets[1];
	uint32_t _pkts64octets;
} BCM53262_A0_PKTS64OCTETSr_t;

#define BCM53262_A0_PKTS64OCTETSr_CLR(r) (r).pkts64octets[0] = 0
#define BCM53262_A0_PKTS64OCTETSr_SET(r,d) (r).pkts64octets[0] = d
#define BCM53262_A0_PKTS64OCTETSr_GET(r) (r).pkts64octets[0]


/*
 * These macros can be used to access Pkts64Octets.
 */
#define BCM53262_A0_READ_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PKTS64OCTETSr,(r._pkts64octets),4)
#define BCM53262_A0_WRITE_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PKTS64OCTETSr,&(r._pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETSr BCM53262_A0_PKTS64OCTETSr
#define PKTS64OCTETSr_SIZE BCM53262_A0_PKTS64OCTETSr_SIZE
typedef BCM53262_A0_PKTS64OCTETSr_t PKTS64OCTETSr_t;
#define PKTS64OCTETSr_CLR BCM53262_A0_PKTS64OCTETSr_CLR
#define PKTS64OCTETSr_SET BCM53262_A0_PKTS64OCTETSr_SET
#define PKTS64OCTETSr_GET BCM53262_A0_PKTS64OCTETSr_GET
#define READ_PKTS64OCTETSr BCM53262_A0_READ_PKTS64OCTETSr
#define WRITE_PKTS64OCTETSr BCM53262_A0_WRITE_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PKTS64OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  Pkts65to127Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 */
#define BCM53262_A0_PKTS65TO127OCTETSr 0x0000687c

#define BCM53262_A0_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets.
 */
typedef union BCM53262_A0_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets[1];
	uint32_t _pkts65to127octets;
} BCM53262_A0_PKTS65TO127OCTETSr_t;

#define BCM53262_A0_PKTS65TO127OCTETSr_CLR(r) (r).pkts65to127octets[0] = 0
#define BCM53262_A0_PKTS65TO127OCTETSr_SET(r,d) (r).pkts65to127octets[0] = d
#define BCM53262_A0_PKTS65TO127OCTETSr_GET(r) (r).pkts65to127octets[0]


/*
 * These macros can be used to access Pkts65to127Octets.
 */
#define BCM53262_A0_READ_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_PKTS65TO127OCTETSr,(r._pkts65to127octets),4)
#define BCM53262_A0_WRITE_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_PKTS65TO127OCTETSr,&(r._pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETSr BCM53262_A0_PKTS65TO127OCTETSr
#define PKTS65TO127OCTETSr_SIZE BCM53262_A0_PKTS65TO127OCTETSr_SIZE
typedef BCM53262_A0_PKTS65TO127OCTETSr_t PKTS65TO127OCTETSr_t;
#define PKTS65TO127OCTETSr_CLR BCM53262_A0_PKTS65TO127OCTETSr_CLR
#define PKTS65TO127OCTETSr_SET BCM53262_A0_PKTS65TO127OCTETSr_SET
#define PKTS65TO127OCTETSr_GET BCM53262_A0_PKTS65TO127OCTETSr_GET
#define READ_PKTS65TO127OCTETSr BCM53262_A0_READ_PKTS65TO127OCTETSr
#define WRITE_PKTS65TO127OCTETSr BCM53262_A0_WRITE_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_PKTS65TO127OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_1P_EN
 * BLOCKS:   SYS
 * DESC:     QoS 802.1P Enable Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     QOS_1P_EN        802.1p QoS enable bit for per-port.Bits 24-47: 10/100BASE-T PortsBit 48: MII Port.Bit 49: Giga Port g0.Bit 50: Giga Port g1.Bit 51: Giga Port g2.Bit 52: Giga Port g3.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_QOS_1P_ENr 0x00003018

#define BCM53262_A0_QOS_1P_ENr_SIZE 8

/*
 * This structure should be used to declare and program QOS_1P_EN.
 */
typedef union BCM53262_A0_QOS_1P_ENr_s {
	uint32_t v[2];
	uint32_t qos_1p_en[2];
	uint32_t _qos_1p_en;
} BCM53262_A0_QOS_1P_ENr_t;

#define BCM53262_A0_QOS_1P_ENr_CLR(r) CDK_MEMSET(&((r)._qos_1p_en), 0, sizeof(BCM53262_A0_QOS_1P_ENr_t))
#define BCM53262_A0_QOS_1P_ENr_SET(r,i,d) (r).qos_1p_en[i] = d
#define BCM53262_A0_QOS_1P_ENr_GET(r,i) (r).qos_1p_en[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_1P_ENr_RESERVED_0Rf_GET(r) (((r).qos_1p_en[0]) & 0xffffff)
#define BCM53262_A0_QOS_1P_ENr_RESERVED_0Rf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_QOS_1P_ENr_QOS_1P_ENf_GET(r) cdk_field32_get((r).qos_1p_en,24,52)
#define BCM53262_A0_QOS_1P_ENr_QOS_1P_ENf_SET(r,f) cdk_field32_set((r).qos_1p_en,24,52,f)
#define BCM53262_A0_QOS_1P_ENr_RESERVED_1Rf_GET(r) ((((r).qos_1p_en[1]) >> 21) & 0x7ff)
#define BCM53262_A0_QOS_1P_ENr_RESERVED_1Rf_SET(r,f) (r).qos_1p_en[1]=(((r).qos_1p_en[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access QOS_1P_EN.
 */
#define BCM53262_A0_READ_QOS_1P_ENr(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_1P_ENr,(r._qos_1p_en),8)
#define BCM53262_A0_WRITE_QOS_1P_ENr(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_1P_ENr,&(r._qos_1p_en),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_1P_ENr BCM53262_A0_QOS_1P_ENr
#define QOS_1P_ENr_SIZE BCM53262_A0_QOS_1P_ENr_SIZE
typedef BCM53262_A0_QOS_1P_ENr_t QOS_1P_ENr_t;
#define QOS_1P_ENr_CLR BCM53262_A0_QOS_1P_ENr_CLR
#define QOS_1P_ENr_SET BCM53262_A0_QOS_1P_ENr_SET
#define QOS_1P_ENr_GET BCM53262_A0_QOS_1P_ENr_GET
#define QOS_1P_ENr_RESERVED_0Rf_GET BCM53262_A0_QOS_1P_ENr_RESERVED_0Rf_GET
#define QOS_1P_ENr_RESERVED_0Rf_SET BCM53262_A0_QOS_1P_ENr_RESERVED_0Rf_SET
#define QOS_1P_ENr_QOS_1P_ENf_GET BCM53262_A0_QOS_1P_ENr_QOS_1P_ENf_GET
#define QOS_1P_ENr_QOS_1P_ENf_SET BCM53262_A0_QOS_1P_ENr_QOS_1P_ENf_SET
#define QOS_1P_ENr_RESERVED_1Rf_GET BCM53262_A0_QOS_1P_ENr_RESERVED_1Rf_GET
#define QOS_1P_ENr_RESERVED_1Rf_SET BCM53262_A0_QOS_1P_ENr_RESERVED_1Rf_SET
#define READ_QOS_1P_ENr BCM53262_A0_READ_QOS_1P_ENr
#define WRITE_QOS_1P_ENr BCM53262_A0_WRITE_QOS_1P_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_1P_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_CTL
 * BLOCKS:   SYS
 * DESC:     QoS Control Register
 * SIZE:     64
 * FIELDS:
 *     SCHEDULE_SELECT  Strict Priority.00 : 4WRP (default)01 : 1SP-3WRP10 : 2SP-2WRP11 : 4SP
 *     RESERVED_0R      Reserved
 *     QOS_EN           11 = When CPU Control Enable (bit 63) is asserted, this bit enables 4 queues QoS functionality.10 = Reserved.01 = Reserved.00 = When CPU Control Enable (bit 63) is asserted, "00" disables QoS functionality.
 *     DIS_ACAST_QOSREG 1 = Disable Automatically set QoS registers.
 *     RESERVED_1R      Reserved
 *     CPU_CTRL_EN      1 = Register values control the port-based priority settings.This includes:- QOS_EN strap is overridden by QOS_Enable setting (bit 59-58 of this register).- High priority ports are selected by this register (bits 52-0).- Flow control enable/disable is controlled on a per- port basis in the QoS Pause Enable Register (offset 13h-14h).
 */
#define BCM53262_A0_QOS_CTLr 0x00003010

#define BCM53262_A0_QOS_CTLr_SIZE 8

/*
 * This structure should be used to declare and program QOS_CTL.
 */
typedef union BCM53262_A0_QOS_CTLr_s {
	uint32_t v[2];
	uint32_t qos_ctl[2];
	uint32_t _qos_ctl;
} BCM53262_A0_QOS_CTLr_t;

#define BCM53262_A0_QOS_CTLr_CLR(r) CDK_MEMSET(&((r)._qos_ctl), 0, sizeof(BCM53262_A0_QOS_CTLr_t))
#define BCM53262_A0_QOS_CTLr_SET(r,i,d) (r).qos_ctl[i] = d
#define BCM53262_A0_QOS_CTLr_GET(r,i) (r).qos_ctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_CTLr_SCHEDULE_SELECTf_GET(r) (((r).qos_ctl[0]) & 0x3)
#define BCM53262_A0_QOS_CTLr_SCHEDULE_SELECTf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_QOS_CTLr_RESERVED_0Rf_GET(r,a) cdk_field_get((r).qos_ctl,2,57,a)
#define BCM53262_A0_QOS_CTLr_RESERVED_0Rf_SET(r,a) cdk_field_set((r).qos_ctl,2,57,a)
#define BCM53262_A0_QOS_CTLr_QOS_ENf_GET(r) ((((r).qos_ctl[1]) >> 26) & 0x3)
#define BCM53262_A0_QOS_CTLr_QOS_ENf_SET(r,f) (r).qos_ctl[1]=(((r).qos_ctl[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53262_A0_QOS_CTLr_DIS_ACAST_QOSREGf_GET(r) ((((r).qos_ctl[1]) >> 28) & 0x1)
#define BCM53262_A0_QOS_CTLr_DIS_ACAST_QOSREGf_SET(r,f) (r).qos_ctl[1]=(((r).qos_ctl[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53262_A0_QOS_CTLr_RESERVED_1Rf_GET(r) ((((r).qos_ctl[1]) >> 29) & 0x3)
#define BCM53262_A0_QOS_CTLr_RESERVED_1Rf_SET(r,f) (r).qos_ctl[1]=(((r).qos_ctl[1] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53262_A0_QOS_CTLr_CPU_CTRL_ENf_GET(r) ((((r).qos_ctl[1]) >> 31) & 0x1)
#define BCM53262_A0_QOS_CTLr_CPU_CTRL_ENf_SET(r,f) (r).qos_ctl[1]=(((r).qos_ctl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access QOS_CTL.
 */
#define BCM53262_A0_READ_QOS_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_CTLr,(r._qos_ctl),8)
#define BCM53262_A0_WRITE_QOS_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_CTLr,&(r._qos_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_CTLr BCM53262_A0_QOS_CTLr
#define QOS_CTLr_SIZE BCM53262_A0_QOS_CTLr_SIZE
typedef BCM53262_A0_QOS_CTLr_t QOS_CTLr_t;
#define QOS_CTLr_CLR BCM53262_A0_QOS_CTLr_CLR
#define QOS_CTLr_SET BCM53262_A0_QOS_CTLr_SET
#define QOS_CTLr_GET BCM53262_A0_QOS_CTLr_GET
#define QOS_CTLr_SCHEDULE_SELECTf_GET BCM53262_A0_QOS_CTLr_SCHEDULE_SELECTf_GET
#define QOS_CTLr_SCHEDULE_SELECTf_SET BCM53262_A0_QOS_CTLr_SCHEDULE_SELECTf_SET
#define QOS_CTLr_RESERVED_0Rf_GET BCM53262_A0_QOS_CTLr_RESERVED_0Rf_GET
#define QOS_CTLr_RESERVED_0Rf_SET BCM53262_A0_QOS_CTLr_RESERVED_0Rf_SET
#define QOS_CTLr_QOS_ENf_GET BCM53262_A0_QOS_CTLr_QOS_ENf_GET
#define QOS_CTLr_QOS_ENf_SET BCM53262_A0_QOS_CTLr_QOS_ENf_SET
#define QOS_CTLr_DIS_ACAST_QOSREGf_GET BCM53262_A0_QOS_CTLr_DIS_ACAST_QOSREGf_GET
#define QOS_CTLr_DIS_ACAST_QOSREGf_SET BCM53262_A0_QOS_CTLr_DIS_ACAST_QOSREGf_SET
#define QOS_CTLr_RESERVED_1Rf_GET BCM53262_A0_QOS_CTLr_RESERVED_1Rf_GET
#define QOS_CTLr_RESERVED_1Rf_SET BCM53262_A0_QOS_CTLr_RESERVED_1Rf_SET
#define QOS_CTLr_CPU_CTRL_ENf_GET BCM53262_A0_QOS_CTLr_CPU_CTRL_ENf_GET
#define QOS_CTLr_CPU_CTRL_ENf_SET BCM53262_A0_QOS_CTLr_CPU_CTRL_ENf_SET
#define READ_QOS_CTLr BCM53262_A0_READ_QOS_CTLr
#define WRITE_QOS_CTLr BCM53262_A0_WRITE_QOS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_DIFF_DSCP1
 * BLOCKS:   SYS
 * DESC:     DiffServ DSCP Priority Register 1
 * SIZE:     64
 * FIELDS:
 *     PRI_DSCP_000000  To assign priority queue of differentiated service  000000 classes.
 *     PRI_DSCP_000001  To assign priority queue of differentiated service  000001 classes.
 *     PRI_DSCP_000010  To assign priority queue of differentiated service  000010 classes.
 *     PRI_DSCP_000011  To assign priority queue of differentiated service  000011 classes.
 *     PRI_DSCP_000100  To assign priority queue of differentiated service  000100 classes.
 *     PRI_DSCP_000101  To assign priority queue of differentiated service  000101 classes.
 *     PRI_DSCP_000110  To assign priority queue of differentiated service  000110 classes.
 *     PRI_DSCP_000111  To assign priority queue of differentiated service  000111 classes.
 *     PRI_DSCP_001000  To assign priority queue of differentiated service  001000 classes.
 *     PRI_DSCP_001001  To assign priority queue of differentiated service  001001 classes.
 *     PRI_DSCP_001010  To assign priority queue of differentiated service  001010 classes.
 *     PRI_DSCP_001011  To assign priority queue of differentiated service  001011 classes.
 *     PRI_DSCP_001100  To assign priority queue of differentiated service  001100 classes.
 *     PRI_DSCP_001101  To assign priority queue of differentiated service  001101 classes.
 *     PRI_DSCP_001110  To assign priority queue of differentiated service  001110 classes.
 *     PRI_DSCP_001111  To assign priority queue of differentiated service  001111 classes.
 *     PRI_DSCP_010000  To assign priority queue of differentiated service  010000 classes.
 *     PRI_DSCP_010001  To assign priority queue of differentiated service  010001 classes.
 *     PRI_DSCP_010010  To assign priority queue of differentiated service  010010 classes.
 *     PRI_DSCP_010011  To assign priority queue of differentiated service  010011 classes.
 *     PRI_DSCP_010100  To assign priority queue of differentiated service  010100 classes.
 *     PRI_DSCP_010101  To assign priority queue of differentiated service  010101 classes.
 *     PRI_DSCP_010110  To assign priority queue of differentiated service  010110 classes.
 *     PRI_DSCP_010111  To assign priority queue of differentiated service  010111 classes.
 *     PRI_DSCP_011000  To assign priority queue of differentiated service  011000 classes.
 *     PRI_DSCP_011001  To assign priority queue of differentiated service  011001 classes.
 *     PRI_DSCP_011010  To assign priority queue of differentiated service  011010 classes.
 *     PRI_DSCP_011011  To assign priority queue of differentiated service  011011 classes.
 *     PRI_DSCP_011100  To assign priority queue of differentiated service  011100 classes.
 *     PRI_DSCP_011101  To assign priority queue of differentiated service  011101 classes.
 *     PRI_DSCP_011110  To assign priority queue of differentiated service  011110 classes.
 *     PRI_DSCP_011111  To assign priority queue of differentiated service  011111 classes.
 */
#define BCM53262_A0_QOS_DIFF_DSCP1r 0x00003040

#define BCM53262_A0_QOS_DIFF_DSCP1r_SIZE 8

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP1.
 */
typedef union BCM53262_A0_QOS_DIFF_DSCP1r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp1[2];
	uint32_t _qos_diff_dscp1;
} BCM53262_A0_QOS_DIFF_DSCP1r_t;

#define BCM53262_A0_QOS_DIFF_DSCP1r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp1), 0, sizeof(BCM53262_A0_QOS_DIFF_DSCP1r_t))
#define BCM53262_A0_QOS_DIFF_DSCP1r_SET(r,i,d) (r).qos_diff_dscp1[i] = d
#define BCM53262_A0_QOS_DIFF_DSCP1r_GET(r,i) (r).qos_diff_dscp1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000000f_GET(r) (((r).qos_diff_dscp1[0]) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 2) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000010f_GET(r) ((((r).qos_diff_dscp1[0]) >> 4) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000010f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000011f_GET(r) ((((r).qos_diff_dscp1[0]) >> 6) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000011f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000100f_GET(r) ((((r).qos_diff_dscp1[0]) >> 8) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000100f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000101f_GET(r) ((((r).qos_diff_dscp1[0]) >> 10) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000101f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000110f_GET(r) ((((r).qos_diff_dscp1[0]) >> 12) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000110f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000111f_GET(r) ((((r).qos_diff_dscp1[0]) >> 14) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000111f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001000f_GET(r) ((((r).qos_diff_dscp1[0]) >> 16) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 18) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001010f_GET(r) ((((r).qos_diff_dscp1[0]) >> 20) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001010f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001011f_GET(r) ((((r).qos_diff_dscp1[0]) >> 22) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001011f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001100f_GET(r) ((((r).qos_diff_dscp1[0]) >> 24) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001100f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001101f_GET(r) ((((r).qos_diff_dscp1[0]) >> 26) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001101f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001110f_GET(r) ((((r).qos_diff_dscp1[0]) >> 28) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001110f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001111f_GET(r) ((((r).qos_diff_dscp1[0]) >> 30) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001111f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET(r) (((r).qos_diff_dscp1[1]) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET(r) ((((r).qos_diff_dscp1[1]) >> 2) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET(r) ((((r).qos_diff_dscp1[1]) >> 4) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET(r) ((((r).qos_diff_dscp1[1]) >> 6) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET(r) ((((r).qos_diff_dscp1[1]) >> 8) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET(r) ((((r).qos_diff_dscp1[1]) >> 10) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET(r) ((((r).qos_diff_dscp1[1]) >> 12) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET(r) ((((r).qos_diff_dscp1[1]) >> 14) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET(r) ((((r).qos_diff_dscp1[1]) >> 16) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET(r) ((((r).qos_diff_dscp1[1]) >> 18) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET(r) ((((r).qos_diff_dscp1[1]) >> 20) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET(r) ((((r).qos_diff_dscp1[1]) >> 22) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET(r) ((((r).qos_diff_dscp1[1]) >> 24) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET(r) ((((r).qos_diff_dscp1[1]) >> 26) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET(r) ((((r).qos_diff_dscp1[1]) >> 28) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET(r) ((((r).qos_diff_dscp1[1]) >> 30) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access QOS_DIFF_DSCP1.
 */
#define BCM53262_A0_READ_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_DIFF_DSCP1r,(r._qos_diff_dscp1),8)
#define BCM53262_A0_WRITE_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_DIFF_DSCP1r,&(r._qos_diff_dscp1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP1r BCM53262_A0_QOS_DIFF_DSCP1r
#define QOS_DIFF_DSCP1r_SIZE BCM53262_A0_QOS_DIFF_DSCP1r_SIZE
typedef BCM53262_A0_QOS_DIFF_DSCP1r_t QOS_DIFF_DSCP1r_t;
#define QOS_DIFF_DSCP1r_CLR BCM53262_A0_QOS_DIFF_DSCP1r_CLR
#define QOS_DIFF_DSCP1r_SET BCM53262_A0_QOS_DIFF_DSCP1r_SET
#define QOS_DIFF_DSCP1r_GET BCM53262_A0_QOS_DIFF_DSCP1r_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000000f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000000f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000001f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000001f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000010f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000010f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000011f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000011f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000100f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000100f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000101f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000101f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000110f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000110f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000111f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_000111f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_000111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001000f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001000f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001001f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001001f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001010f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001010f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001011f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001011f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001100f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001100f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001101f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001101f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001110f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001110f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001111f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_001111f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_001111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET BCM53262_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET
#define READ_QOS_DIFF_DSCP1r BCM53262_A0_READ_QOS_DIFF_DSCP1r
#define WRITE_QOS_DIFF_DSCP1r BCM53262_A0_WRITE_QOS_DIFF_DSCP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_DIFF_DSCP1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_DIFF_DSCP2
 * BLOCKS:   SYS
 * DESC:     DiffServ DSCP Priority Register 2
 * SIZE:     64
 * FIELDS:
 *     PRI_DSCP_100000  To assign priority queue of differentiated service  100000 classes.
 *     PRI_DSCP_100001  To assign priority queue of differentiated service  100001 classes.
 *     PRI_DSCP_100010  To assign priority queue of differentiated service  100010 classes.
 *     PRI_DSCP_100011  To assign priority queue of differentiated service  100011 classes.
 *     PRI_DSCP_100100  To assign priority queue of differentiated service  100100 classes.
 *     PRI_DSCP_100101  To assign priority queue of differentiated service  100101 classes.
 *     PRI_DSCP_100110  To assign priority queue of differentiated service  100110 classes.
 *     PRI_DSCP_100111  To assign priority queue of differentiated service  100111 classes.
 *     PRI_DSCP_101000  To assign priority queue of differentiated service  101000 classes.
 *     PRI_DSCP_101001  To assign priority queue of differentiated service  101001 classes.
 *     PRI_DSCP_101010  To assign priority queue of differentiated service  101010 classes.
 *     PRI_DSCP_101011  To assign priority queue of differentiated service  101011 classes.
 *     PRI_DSCP_101100  To assign priority queue of differentiated service  101100 classes.
 *     PRI_DSCP_101101  To assign priority queue of differentiated service  111111 classes.
 *     PRI_DSCP_101110  To assign priority queue of differentiated service  101110 classes.
 *     PRI_DSCP_101111  To assign priority queue of differentiated service  101111 classes.
 *     PRI_DSCP_110000  To assign priority queue of differentiated service  110000 classes.
 *     PRI_DSCP_110001  To assign priority queue of differentiated service  110001 classes.
 *     PRI_DSCP_110010  To assign priority queue of differentiated service  110010 classes.
 *     PRI_DSCP_110011  To assign priority queue of differentiated service  110011 classes.
 *     PRI_DSCP_110100  To assign priority queue of differentiated service  110100 classes.
 *     PRI_DSCP_110101  To assign priority queue of differentiated service  110101 classes.
 *     PRI_DSCP_110110  To assign priority queue of differentiated service  110110 classes.
 *     PRI_DSCP_110111  To assign priority queue of differentiated service  110111 classes.
 *     PRI_DSCP_111000  To assign priority queue of differentiated service  111000 classes.
 *     PRI_DSCP_111001  To assign priority queue of differentiated service  111001 classes.
 *     PRI_DSCP_111010  To assign priority queue of differentiated service  111010 classes.
 *     PRI_DSCP_111011  To assign priority queue of differentiated service  111011 classes.
 *     PRI_DSCP_111100  To assign priority queue of differentiated service  111100 classes.
 *     PRI_DSCP_111101  To assign priority queue of differentiated service  111101 classes.
 *     PRI_DSCP_111110  To assign priority queue of differentiated service  111110 classes.
 *     PRI_DSCP_111111  To assign priority queue of differentiated service  111111 classes.
 */
#define BCM53262_A0_QOS_DIFF_DSCP2r 0x00003048

#define BCM53262_A0_QOS_DIFF_DSCP2r_SIZE 8

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP2.
 */
typedef union BCM53262_A0_QOS_DIFF_DSCP2r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp2[2];
	uint32_t _qos_diff_dscp2;
} BCM53262_A0_QOS_DIFF_DSCP2r_t;

#define BCM53262_A0_QOS_DIFF_DSCP2r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp2), 0, sizeof(BCM53262_A0_QOS_DIFF_DSCP2r_t))
#define BCM53262_A0_QOS_DIFF_DSCP2r_SET(r,i,d) (r).qos_diff_dscp2[i] = d
#define BCM53262_A0_QOS_DIFF_DSCP2r_GET(r,i) (r).qos_diff_dscp2[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET(r) (((r).qos_diff_dscp2[0]) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 2) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET(r) ((((r).qos_diff_dscp2[0]) >> 4) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET(r) ((((r).qos_diff_dscp2[0]) >> 6) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET(r) ((((r).qos_diff_dscp2[0]) >> 8) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET(r) ((((r).qos_diff_dscp2[0]) >> 10) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET(r) ((((r).qos_diff_dscp2[0]) >> 12) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET(r) ((((r).qos_diff_dscp2[0]) >> 14) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET(r) ((((r).qos_diff_dscp2[0]) >> 16) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 18) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET(r) ((((r).qos_diff_dscp2[0]) >> 20) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET(r) ((((r).qos_diff_dscp2[0]) >> 22) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET(r) ((((r).qos_diff_dscp2[0]) >> 24) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET(r) ((((r).qos_diff_dscp2[0]) >> 26) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET(r) ((((r).qos_diff_dscp2[0]) >> 28) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET(r) ((((r).qos_diff_dscp2[0]) >> 30) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110000f_GET(r) (((r).qos_diff_dscp2[1]) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110000f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110001f_GET(r) ((((r).qos_diff_dscp2[1]) >> 2) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110001f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110010f_GET(r) ((((r).qos_diff_dscp2[1]) >> 4) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110010f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110011f_GET(r) ((((r).qos_diff_dscp2[1]) >> 6) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110011f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110100f_GET(r) ((((r).qos_diff_dscp2[1]) >> 8) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110100f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110101f_GET(r) ((((r).qos_diff_dscp2[1]) >> 10) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110101f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110110f_GET(r) ((((r).qos_diff_dscp2[1]) >> 12) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110110f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110111f_GET(r) ((((r).qos_diff_dscp2[1]) >> 14) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110111f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111000f_GET(r) ((((r).qos_diff_dscp2[1]) >> 16) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111000f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111001f_GET(r) ((((r).qos_diff_dscp2[1]) >> 18) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111001f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111010f_GET(r) ((((r).qos_diff_dscp2[1]) >> 20) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111010f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111011f_GET(r) ((((r).qos_diff_dscp2[1]) >> 22) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111011f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111100f_GET(r) ((((r).qos_diff_dscp2[1]) >> 24) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111100f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111101f_GET(r) ((((r).qos_diff_dscp2[1]) >> 26) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111101f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111110f_GET(r) ((((r).qos_diff_dscp2[1]) >> 28) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111110f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111111f_GET(r) ((((r).qos_diff_dscp2[1]) >> 30) & 0x3)
#define BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111111f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access QOS_DIFF_DSCP2.
 */
#define BCM53262_A0_READ_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_DIFF_DSCP2r,(r._qos_diff_dscp2),8)
#define BCM53262_A0_WRITE_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_DIFF_DSCP2r,&(r._qos_diff_dscp2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP2r BCM53262_A0_QOS_DIFF_DSCP2r
#define QOS_DIFF_DSCP2r_SIZE BCM53262_A0_QOS_DIFF_DSCP2r_SIZE
typedef BCM53262_A0_QOS_DIFF_DSCP2r_t QOS_DIFF_DSCP2r_t;
#define QOS_DIFF_DSCP2r_CLR BCM53262_A0_QOS_DIFF_DSCP2r_CLR
#define QOS_DIFF_DSCP2r_SET BCM53262_A0_QOS_DIFF_DSCP2r_SET
#define QOS_DIFF_DSCP2r_GET BCM53262_A0_QOS_DIFF_DSCP2r_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110000f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110000f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110001f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110001f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110010f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110010f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110011f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110011f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110100f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110100f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110101f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110101f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110110f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110110f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110111f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_110111f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_110111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111000f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111000f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111001f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111001f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111010f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111010f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111011f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111011f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111100f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111100f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111101f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111101f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111110f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111110f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111111f_GET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_111111f_SET BCM53262_A0_QOS_DIFF_DSCP2r_PRI_DSCP_111111f_SET
#define READ_QOS_DIFF_DSCP2r BCM53262_A0_READ_QOS_DIFF_DSCP2r
#define WRITE_QOS_DIFF_DSCP2r BCM53262_A0_WRITE_QOS_DIFF_DSCP2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_DIFF_DSCP2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_PAUSE_EN
 * BLOCKS:   SYS
 * DESC:     QoS Pause Enable Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     LOCAL_PAUSE_EN   Bits 0-23: 10/100BASE-T Ports
 *     MII_PAUSE_EN     When software control of QoS is enabled by asserting the QOS_EN bit of the QoS Control Register:0 = Half-duplex back pressure and full-duplex flow control are disabled. Only dropping of frames is supported on the given port.1 = Individual port supports half-duplex back pressure and full-duplex flow control when QOS_EN bit of the QoS Control register is enabled.
 *     GIGA_PAUSE_EN    Bit 52 : Giga Port g3.Bit 51 : Giga Port g2.Bit 50 : Giga Port g1.Bit 49 : Giga Port g0.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_QOS_PAUSE_ENr 0x00003028

#define BCM53262_A0_QOS_PAUSE_ENr_SIZE 8

/*
 * This structure should be used to declare and program QOS_PAUSE_EN.
 */
typedef union BCM53262_A0_QOS_PAUSE_ENr_s {
	uint32_t v[2];
	uint32_t qos_pause_en[2];
	uint32_t _qos_pause_en;
} BCM53262_A0_QOS_PAUSE_ENr_t;

#define BCM53262_A0_QOS_PAUSE_ENr_CLR(r) CDK_MEMSET(&((r)._qos_pause_en), 0, sizeof(BCM53262_A0_QOS_PAUSE_ENr_t))
#define BCM53262_A0_QOS_PAUSE_ENr_SET(r,i,d) (r).qos_pause_en[i] = d
#define BCM53262_A0_QOS_PAUSE_ENr_GET(r,i) (r).qos_pause_en[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_PAUSE_ENr_RESERVED_0Rf_GET(r) (((r).qos_pause_en[0]) & 0xffffff)
#define BCM53262_A0_QOS_PAUSE_ENr_RESERVED_0Rf_SET(r,f) (r).qos_pause_en[0]=(((r).qos_pause_en[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_QOS_PAUSE_ENr_LOCAL_PAUSE_ENf_GET(r) cdk_field32_get((r).qos_pause_en,24,47)
#define BCM53262_A0_QOS_PAUSE_ENr_LOCAL_PAUSE_ENf_SET(r,f) cdk_field32_set((r).qos_pause_en,24,47,f)
#define BCM53262_A0_QOS_PAUSE_ENr_MII_PAUSE_ENf_GET(r) ((((r).qos_pause_en[1]) >> 16) & 0x1)
#define BCM53262_A0_QOS_PAUSE_ENr_MII_PAUSE_ENf_SET(r,f) (r).qos_pause_en[1]=(((r).qos_pause_en[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53262_A0_QOS_PAUSE_ENr_GIGA_PAUSE_ENf_GET(r) ((((r).qos_pause_en[1]) >> 17) & 0xf)
#define BCM53262_A0_QOS_PAUSE_ENr_GIGA_PAUSE_ENf_SET(r,f) (r).qos_pause_en[1]=(((r).qos_pause_en[1] & ~((uint32_t)0xf << 17)) | ((((uint32_t)f) & 0xf) << 17))
#define BCM53262_A0_QOS_PAUSE_ENr_RESERVED_1Rf_GET(r) ((((r).qos_pause_en[1]) >> 21) & 0x7ff)
#define BCM53262_A0_QOS_PAUSE_ENr_RESERVED_1Rf_SET(r,f) (r).qos_pause_en[1]=(((r).qos_pause_en[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access QOS_PAUSE_EN.
 */
#define BCM53262_A0_READ_QOS_PAUSE_ENr(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_PAUSE_ENr,(r._qos_pause_en),8)
#define BCM53262_A0_WRITE_QOS_PAUSE_ENr(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_PAUSE_ENr,&(r._qos_pause_en),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_PAUSE_ENr BCM53262_A0_QOS_PAUSE_ENr
#define QOS_PAUSE_ENr_SIZE BCM53262_A0_QOS_PAUSE_ENr_SIZE
typedef BCM53262_A0_QOS_PAUSE_ENr_t QOS_PAUSE_ENr_t;
#define QOS_PAUSE_ENr_CLR BCM53262_A0_QOS_PAUSE_ENr_CLR
#define QOS_PAUSE_ENr_SET BCM53262_A0_QOS_PAUSE_ENr_SET
#define QOS_PAUSE_ENr_GET BCM53262_A0_QOS_PAUSE_ENr_GET
#define QOS_PAUSE_ENr_RESERVED_0Rf_GET BCM53262_A0_QOS_PAUSE_ENr_RESERVED_0Rf_GET
#define QOS_PAUSE_ENr_RESERVED_0Rf_SET BCM53262_A0_QOS_PAUSE_ENr_RESERVED_0Rf_SET
#define QOS_PAUSE_ENr_LOCAL_PAUSE_ENf_GET BCM53262_A0_QOS_PAUSE_ENr_LOCAL_PAUSE_ENf_GET
#define QOS_PAUSE_ENr_LOCAL_PAUSE_ENf_SET BCM53262_A0_QOS_PAUSE_ENr_LOCAL_PAUSE_ENf_SET
#define QOS_PAUSE_ENr_MII_PAUSE_ENf_GET BCM53262_A0_QOS_PAUSE_ENr_MII_PAUSE_ENf_GET
#define QOS_PAUSE_ENr_MII_PAUSE_ENf_SET BCM53262_A0_QOS_PAUSE_ENr_MII_PAUSE_ENf_SET
#define QOS_PAUSE_ENr_GIGA_PAUSE_ENf_GET BCM53262_A0_QOS_PAUSE_ENr_GIGA_PAUSE_ENf_GET
#define QOS_PAUSE_ENr_GIGA_PAUSE_ENf_SET BCM53262_A0_QOS_PAUSE_ENr_GIGA_PAUSE_ENf_SET
#define QOS_PAUSE_ENr_RESERVED_1Rf_GET BCM53262_A0_QOS_PAUSE_ENr_RESERVED_1Rf_GET
#define QOS_PAUSE_ENr_RESERVED_1Rf_SET BCM53262_A0_QOS_PAUSE_ENr_RESERVED_1Rf_SET
#define READ_QOS_PAUSE_ENr BCM53262_A0_READ_QOS_PAUSE_ENr
#define WRITE_QOS_PAUSE_ENr BCM53262_A0_WRITE_QOS_PAUSE_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_PAUSE_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_REASON_CODE
 * BLOCKS:   SYS
 * DESC:     QoS Reason Code Register
 * SIZE:     16
 * FIELDS:
 *     PRI_MIRROR       To assign priority queue of Reason Code = MIRROR packets.
 *     PRI_SA_LEARN     To assign priority queue of Reason Code = SA LEARNING packets.
 *     PRI_SWITCH       To assign priority queue of Reason Code = SWITCH packets.
 *     PRI_PROTOCOL_TERM To assign priority queue of Reason Code = PROTOCOL TERMINATION packets.
 *     PRI_PROTOCOL_SNOOP To assign priority queue of Reason Code = PROTOCOL SNOOPING packets.
 *     PRI_EXCEPT       To assign priority queue of Reason Code = EXCEPTION / FLOODING  packets.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_QOS_REASON_CODEr 0x00003058

#define BCM53262_A0_QOS_REASON_CODEr_SIZE 2

/*
 * This structure should be used to declare and program QOS_REASON_CODE.
 */
typedef union BCM53262_A0_QOS_REASON_CODEr_s {
	uint32_t v[1];
	uint32_t qos_reason_code[1];
	uint32_t _qos_reason_code;
} BCM53262_A0_QOS_REASON_CODEr_t;

#define BCM53262_A0_QOS_REASON_CODEr_CLR(r) (r).qos_reason_code[0] = 0
#define BCM53262_A0_QOS_REASON_CODEr_SET(r,d) (r).qos_reason_code[0] = d
#define BCM53262_A0_QOS_REASON_CODEr_GET(r) (r).qos_reason_code[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_REASON_CODEr_PRI_MIRRORf_GET(r) (((r).qos_reason_code[0]) & 0x3)
#define BCM53262_A0_QOS_REASON_CODEr_PRI_MIRRORf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_QOS_REASON_CODEr_PRI_SA_LEARNf_GET(r) ((((r).qos_reason_code[0]) >> 2) & 0x3)
#define BCM53262_A0_QOS_REASON_CODEr_PRI_SA_LEARNf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_QOS_REASON_CODEr_PRI_SWITCHf_GET(r) ((((r).qos_reason_code[0]) >> 4) & 0x3)
#define BCM53262_A0_QOS_REASON_CODEr_PRI_SWITCHf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_TERMf_GET(r) ((((r).qos_reason_code[0]) >> 6) & 0x3)
#define BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_TERMf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_SNOOPf_GET(r) ((((r).qos_reason_code[0]) >> 8) & 0x3)
#define BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_SNOOPf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_QOS_REASON_CODEr_PRI_EXCEPTf_GET(r) ((((r).qos_reason_code[0]) >> 10) & 0x3)
#define BCM53262_A0_QOS_REASON_CODEr_PRI_EXCEPTf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_QOS_REASON_CODEr_RESERVED_Rf_GET(r) ((((r).qos_reason_code[0]) >> 12) & 0xf)
#define BCM53262_A0_QOS_REASON_CODEr_RESERVED_Rf_SET(r,f) (r).qos_reason_code[0]=(((r).qos_reason_code[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access QOS_REASON_CODE.
 */
#define BCM53262_A0_READ_QOS_REASON_CODEr(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_REASON_CODEr,(r._qos_reason_code),2)
#define BCM53262_A0_WRITE_QOS_REASON_CODEr(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_REASON_CODEr,&(r._qos_reason_code),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_REASON_CODEr BCM53262_A0_QOS_REASON_CODEr
#define QOS_REASON_CODEr_SIZE BCM53262_A0_QOS_REASON_CODEr_SIZE
typedef BCM53262_A0_QOS_REASON_CODEr_t QOS_REASON_CODEr_t;
#define QOS_REASON_CODEr_CLR BCM53262_A0_QOS_REASON_CODEr_CLR
#define QOS_REASON_CODEr_SET BCM53262_A0_QOS_REASON_CODEr_SET
#define QOS_REASON_CODEr_GET BCM53262_A0_QOS_REASON_CODEr_GET
#define QOS_REASON_CODEr_PRI_MIRRORf_GET BCM53262_A0_QOS_REASON_CODEr_PRI_MIRRORf_GET
#define QOS_REASON_CODEr_PRI_MIRRORf_SET BCM53262_A0_QOS_REASON_CODEr_PRI_MIRRORf_SET
#define QOS_REASON_CODEr_PRI_SA_LEARNf_GET BCM53262_A0_QOS_REASON_CODEr_PRI_SA_LEARNf_GET
#define QOS_REASON_CODEr_PRI_SA_LEARNf_SET BCM53262_A0_QOS_REASON_CODEr_PRI_SA_LEARNf_SET
#define QOS_REASON_CODEr_PRI_SWITCHf_GET BCM53262_A0_QOS_REASON_CODEr_PRI_SWITCHf_GET
#define QOS_REASON_CODEr_PRI_SWITCHf_SET BCM53262_A0_QOS_REASON_CODEr_PRI_SWITCHf_SET
#define QOS_REASON_CODEr_PRI_PROTOCOL_TERMf_GET BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_TERMf_GET
#define QOS_REASON_CODEr_PRI_PROTOCOL_TERMf_SET BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_TERMf_SET
#define QOS_REASON_CODEr_PRI_PROTOCOL_SNOOPf_GET BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_SNOOPf_GET
#define QOS_REASON_CODEr_PRI_PROTOCOL_SNOOPf_SET BCM53262_A0_QOS_REASON_CODEr_PRI_PROTOCOL_SNOOPf_SET
#define QOS_REASON_CODEr_PRI_EXCEPTf_GET BCM53262_A0_QOS_REASON_CODEr_PRI_EXCEPTf_GET
#define QOS_REASON_CODEr_PRI_EXCEPTf_SET BCM53262_A0_QOS_REASON_CODEr_PRI_EXCEPTf_SET
#define QOS_REASON_CODEr_RESERVED_Rf_GET BCM53262_A0_QOS_REASON_CODEr_RESERVED_Rf_GET
#define QOS_REASON_CODEr_RESERVED_Rf_SET BCM53262_A0_QOS_REASON_CODEr_RESERVED_Rf_SET
#define READ_QOS_REASON_CODEr BCM53262_A0_READ_QOS_REASON_CODEr
#define WRITE_QOS_REASON_CODEr BCM53262_A0_WRITE_QOS_REASON_CODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_REASON_CODEr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_TCI_TH
 * BLOCKS:   SYS
 * DESC:     Priority Threshold Register
 * SIZE:     16
 * FIELDS:
 *     PRITAG_000       priority queue of tag 000.
 *     PRITAG_001       priority queue of tag 001.
 *     PRITAG_010       priority queue of tag 010.
 *     PRITAG_011       priority queue of tag 011.
 *     PRITAG_100       priority queue of tag 100.
 *     PRITAG_101       priority queue of tag 101.
 *     PRITAG_110       priority queue of tag 110.
 *     PRITAG_111       priority queue of tag 111.
 */
#define BCM53262_A0_QOS_TCI_THr 0x00003030

#define BCM53262_A0_QOS_TCI_THr_SIZE 2

/*
 * This structure should be used to declare and program QOS_TCI_TH.
 */
typedef union BCM53262_A0_QOS_TCI_THr_s {
	uint32_t v[1];
	uint32_t qos_tci_th[1];
	uint32_t _qos_tci_th;
} BCM53262_A0_QOS_TCI_THr_t;

#define BCM53262_A0_QOS_TCI_THr_CLR(r) (r).qos_tci_th[0] = 0
#define BCM53262_A0_QOS_TCI_THr_SET(r,d) (r).qos_tci_th[0] = d
#define BCM53262_A0_QOS_TCI_THr_GET(r) (r).qos_tci_th[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_TCI_THr_PRITAG_000f_GET(r) (((r).qos_tci_th[0]) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_000f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_QOS_TCI_THr_PRITAG_001f_GET(r) ((((r).qos_tci_th[0]) >> 2) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_001f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_QOS_TCI_THr_PRITAG_010f_GET(r) ((((r).qos_tci_th[0]) >> 4) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_010f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_QOS_TCI_THr_PRITAG_011f_GET(r) ((((r).qos_tci_th[0]) >> 6) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_011f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_QOS_TCI_THr_PRITAG_100f_GET(r) ((((r).qos_tci_th[0]) >> 8) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_100f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_QOS_TCI_THr_PRITAG_101f_GET(r) ((((r).qos_tci_th[0]) >> 10) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_101f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_QOS_TCI_THr_PRITAG_110f_GET(r) ((((r).qos_tci_th[0]) >> 12) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_110f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_QOS_TCI_THr_PRITAG_111f_GET(r) ((((r).qos_tci_th[0]) >> 14) & 0x3)
#define BCM53262_A0_QOS_TCI_THr_PRITAG_111f_SET(r,f) (r).qos_tci_th[0]=(((r).qos_tci_th[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access QOS_TCI_TH.
 */
#define BCM53262_A0_READ_QOS_TCI_THr(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_TCI_THr,(r._qos_tci_th),2)
#define BCM53262_A0_WRITE_QOS_TCI_THr(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_TCI_THr,&(r._qos_tci_th),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_TCI_THr BCM53262_A0_QOS_TCI_THr
#define QOS_TCI_THr_SIZE BCM53262_A0_QOS_TCI_THr_SIZE
typedef BCM53262_A0_QOS_TCI_THr_t QOS_TCI_THr_t;
#define QOS_TCI_THr_CLR BCM53262_A0_QOS_TCI_THr_CLR
#define QOS_TCI_THr_SET BCM53262_A0_QOS_TCI_THr_SET
#define QOS_TCI_THr_GET BCM53262_A0_QOS_TCI_THr_GET
#define QOS_TCI_THr_PRITAG_000f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_000f_GET
#define QOS_TCI_THr_PRITAG_000f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_000f_SET
#define QOS_TCI_THr_PRITAG_001f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_001f_GET
#define QOS_TCI_THr_PRITAG_001f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_001f_SET
#define QOS_TCI_THr_PRITAG_010f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_010f_GET
#define QOS_TCI_THr_PRITAG_010f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_010f_SET
#define QOS_TCI_THr_PRITAG_011f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_011f_GET
#define QOS_TCI_THr_PRITAG_011f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_011f_SET
#define QOS_TCI_THr_PRITAG_100f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_100f_GET
#define QOS_TCI_THr_PRITAG_100f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_100f_SET
#define QOS_TCI_THr_PRITAG_101f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_101f_GET
#define QOS_TCI_THr_PRITAG_101f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_101f_SET
#define QOS_TCI_THr_PRITAG_110f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_110f_GET
#define QOS_TCI_THr_PRITAG_110f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_110f_SET
#define QOS_TCI_THr_PRITAG_111f_GET BCM53262_A0_QOS_TCI_THr_PRITAG_111f_GET
#define QOS_TCI_THr_PRITAG_111f_SET BCM53262_A0_QOS_TCI_THr_PRITAG_111f_SET
#define READ_QOS_TCI_THr BCM53262_A0_READ_QOS_TCI_THr
#define WRITE_QOS_TCI_THr BCM53262_A0_WRITE_QOS_TCI_THr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_TCI_THr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QOS_TOS_DIF_EN
 * BLOCKS:   SYS
 * DESC:     QoS TOS/DiffServ Enable Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     QOS_TOS_DIFF_EN  TOS/DiffServ QoS enable bit for per-port.Bits 0-47: 10/100BASE-T PortsBit 48: MII Port.Bit 49: Giga Port g0.Bit 50: Giga Port g1.Bit 51: Giga Port g2.Bit 52: Giga Port g3.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_QOS_TOS_DIF_ENr 0x00003020

#define BCM53262_A0_QOS_TOS_DIF_ENr_SIZE 8

/*
 * This structure should be used to declare and program QOS_TOS_DIF_EN.
 */
typedef union BCM53262_A0_QOS_TOS_DIF_ENr_s {
	uint32_t v[2];
	uint32_t qos_tos_dif_en[2];
	uint32_t _qos_tos_dif_en;
} BCM53262_A0_QOS_TOS_DIF_ENr_t;

#define BCM53262_A0_QOS_TOS_DIF_ENr_CLR(r) CDK_MEMSET(&((r)._qos_tos_dif_en), 0, sizeof(BCM53262_A0_QOS_TOS_DIF_ENr_t))
#define BCM53262_A0_QOS_TOS_DIF_ENr_SET(r,i,d) (r).qos_tos_dif_en[i] = d
#define BCM53262_A0_QOS_TOS_DIF_ENr_GET(r,i) (r).qos_tos_dif_en[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_0Rf_GET(r) (((r).qos_tos_dif_en[0]) & 0xffffff)
#define BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_0Rf_SET(r,f) (r).qos_tos_dif_en[0]=(((r).qos_tos_dif_en[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_QOS_TOS_DIF_ENr_QOS_TOS_DIFF_ENf_GET(r) cdk_field32_get((r).qos_tos_dif_en,24,52)
#define BCM53262_A0_QOS_TOS_DIF_ENr_QOS_TOS_DIFF_ENf_SET(r,f) cdk_field32_set((r).qos_tos_dif_en,24,52,f)
#define BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_1Rf_GET(r) ((((r).qos_tos_dif_en[1]) >> 21) & 0x7ff)
#define BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_1Rf_SET(r,f) (r).qos_tos_dif_en[1]=(((r).qos_tos_dif_en[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access QOS_TOS_DIF_EN.
 */
#define BCM53262_A0_READ_QOS_TOS_DIF_ENr(u,r) cdk_robo_reg_read(u,BCM53262_A0_QOS_TOS_DIF_ENr,(r._qos_tos_dif_en),8)
#define BCM53262_A0_WRITE_QOS_TOS_DIF_ENr(u,r) cdk_robo_reg_write(u,BCM53262_A0_QOS_TOS_DIF_ENr,&(r._qos_tos_dif_en),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_TOS_DIF_ENr BCM53262_A0_QOS_TOS_DIF_ENr
#define QOS_TOS_DIF_ENr_SIZE BCM53262_A0_QOS_TOS_DIF_ENr_SIZE
typedef BCM53262_A0_QOS_TOS_DIF_ENr_t QOS_TOS_DIF_ENr_t;
#define QOS_TOS_DIF_ENr_CLR BCM53262_A0_QOS_TOS_DIF_ENr_CLR
#define QOS_TOS_DIF_ENr_SET BCM53262_A0_QOS_TOS_DIF_ENr_SET
#define QOS_TOS_DIF_ENr_GET BCM53262_A0_QOS_TOS_DIF_ENr_GET
#define QOS_TOS_DIF_ENr_RESERVED_0Rf_GET BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_0Rf_GET
#define QOS_TOS_DIF_ENr_RESERVED_0Rf_SET BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_0Rf_SET
#define QOS_TOS_DIF_ENr_QOS_TOS_DIFF_ENf_GET BCM53262_A0_QOS_TOS_DIF_ENr_QOS_TOS_DIFF_ENf_GET
#define QOS_TOS_DIF_ENr_QOS_TOS_DIFF_ENf_SET BCM53262_A0_QOS_TOS_DIF_ENr_QOS_TOS_DIFF_ENf_SET
#define QOS_TOS_DIF_ENr_RESERVED_1Rf_GET BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_1Rf_GET
#define QOS_TOS_DIF_ENr_RESERVED_1Rf_SET BCM53262_A0_QOS_TOS_DIF_ENr_RESERVED_1Rf_SET
#define READ_QOS_TOS_DIF_ENr BCM53262_A0_READ_QOS_TOS_DIF_ENr
#define WRITE_QOS_TOS_DIF_ENr BCM53262_A0_WRITE_QOS_TOS_DIF_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QOS_TOS_DIF_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QUEUE_CONGESTION_STATUS0
 * BLOCKS:   SYS
 * DESC:     Queue Congestion Status Register  0
 * SIZE:     16
 * FIELDS:
 *     QUEUE_CONG_MAP   Diagnosis only: Queue_cong_map[15:0].
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS0r 0x00000a50

#define BCM53262_A0_QUEUE_CONGESTION_STATUS0r_SIZE 2

/*
 * This structure should be used to declare and program QUEUE_CONGESTION_STATUS0.
 */
typedef union BCM53262_A0_QUEUE_CONGESTION_STATUS0r_s {
	uint32_t v[1];
	uint32_t queue_congestion_status0[1];
	uint32_t _queue_congestion_status0;
} BCM53262_A0_QUEUE_CONGESTION_STATUS0r_t;

#define BCM53262_A0_QUEUE_CONGESTION_STATUS0r_CLR(r) (r).queue_congestion_status0[0] = 0
#define BCM53262_A0_QUEUE_CONGESTION_STATUS0r_SET(r,d) (r).queue_congestion_status0[0] = d
#define BCM53262_A0_QUEUE_CONGESTION_STATUS0r_GET(r) (r).queue_congestion_status0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS0r_QUEUE_CONG_MAPf_GET(r) (((r).queue_congestion_status0[0]) & 0xffff)
#define BCM53262_A0_QUEUE_CONGESTION_STATUS0r_QUEUE_CONG_MAPf_SET(r,f) (r).queue_congestion_status0[0]=(((r).queue_congestion_status0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access QUEUE_CONGESTION_STATUS0.
 */
#define BCM53262_A0_READ_QUEUE_CONGESTION_STATUS0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QUEUE_CONGESTION_STATUS0r,(r._queue_congestion_status0),2)
#define BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QUEUE_CONGESTION_STATUS0r,&(r._queue_congestion_status0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE_CONGESTION_STATUS0r BCM53262_A0_QUEUE_CONGESTION_STATUS0r
#define QUEUE_CONGESTION_STATUS0r_SIZE BCM53262_A0_QUEUE_CONGESTION_STATUS0r_SIZE
typedef BCM53262_A0_QUEUE_CONGESTION_STATUS0r_t QUEUE_CONGESTION_STATUS0r_t;
#define QUEUE_CONGESTION_STATUS0r_CLR BCM53262_A0_QUEUE_CONGESTION_STATUS0r_CLR
#define QUEUE_CONGESTION_STATUS0r_SET BCM53262_A0_QUEUE_CONGESTION_STATUS0r_SET
#define QUEUE_CONGESTION_STATUS0r_GET BCM53262_A0_QUEUE_CONGESTION_STATUS0r_GET
#define QUEUE_CONGESTION_STATUS0r_QUEUE_CONG_MAPf_GET BCM53262_A0_QUEUE_CONGESTION_STATUS0r_QUEUE_CONG_MAPf_GET
#define QUEUE_CONGESTION_STATUS0r_QUEUE_CONG_MAPf_SET BCM53262_A0_QUEUE_CONGESTION_STATUS0r_QUEUE_CONG_MAPf_SET
#define READ_QUEUE_CONGESTION_STATUS0r BCM53262_A0_READ_QUEUE_CONGESTION_STATUS0r
#define WRITE_QUEUE_CONGESTION_STATUS0r BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QUEUE_CONGESTION_STATUS0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QUEUE_CONGESTION_STATUS1
 * BLOCKS:   SYS
 * DESC:     Queue Congestion Status Register 1
 * SIZE:     16
 * FIELDS:
 *     QUEUE_CONG_MAP   Diagnosis only: Queue_cong_map[21:16].
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS1r 0x00000a52

#define BCM53262_A0_QUEUE_CONGESTION_STATUS1r_SIZE 2

/*
 * This structure should be used to declare and program QUEUE_CONGESTION_STATUS1.
 */
typedef union BCM53262_A0_QUEUE_CONGESTION_STATUS1r_s {
	uint32_t v[1];
	uint32_t queue_congestion_status1[1];
	uint32_t _queue_congestion_status1;
} BCM53262_A0_QUEUE_CONGESTION_STATUS1r_t;

#define BCM53262_A0_QUEUE_CONGESTION_STATUS1r_CLR(r) (r).queue_congestion_status1[0] = 0
#define BCM53262_A0_QUEUE_CONGESTION_STATUS1r_SET(r,d) (r).queue_congestion_status1[0] = d
#define BCM53262_A0_QUEUE_CONGESTION_STATUS1r_GET(r) (r).queue_congestion_status1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS1r_QUEUE_CONG_MAPf_GET(r) (((r).queue_congestion_status1[0]) & 0xffff)
#define BCM53262_A0_QUEUE_CONGESTION_STATUS1r_QUEUE_CONG_MAPf_SET(r,f) (r).queue_congestion_status1[0]=(((r).queue_congestion_status1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access QUEUE_CONGESTION_STATUS1.
 */
#define BCM53262_A0_READ_QUEUE_CONGESTION_STATUS1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QUEUE_CONGESTION_STATUS1r,(r._queue_congestion_status1),2)
#define BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QUEUE_CONGESTION_STATUS1r,&(r._queue_congestion_status1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE_CONGESTION_STATUS1r BCM53262_A0_QUEUE_CONGESTION_STATUS1r
#define QUEUE_CONGESTION_STATUS1r_SIZE BCM53262_A0_QUEUE_CONGESTION_STATUS1r_SIZE
typedef BCM53262_A0_QUEUE_CONGESTION_STATUS1r_t QUEUE_CONGESTION_STATUS1r_t;
#define QUEUE_CONGESTION_STATUS1r_CLR BCM53262_A0_QUEUE_CONGESTION_STATUS1r_CLR
#define QUEUE_CONGESTION_STATUS1r_SET BCM53262_A0_QUEUE_CONGESTION_STATUS1r_SET
#define QUEUE_CONGESTION_STATUS1r_GET BCM53262_A0_QUEUE_CONGESTION_STATUS1r_GET
#define QUEUE_CONGESTION_STATUS1r_QUEUE_CONG_MAPf_GET BCM53262_A0_QUEUE_CONGESTION_STATUS1r_QUEUE_CONG_MAPf_GET
#define QUEUE_CONGESTION_STATUS1r_QUEUE_CONG_MAPf_SET BCM53262_A0_QUEUE_CONGESTION_STATUS1r_QUEUE_CONG_MAPf_SET
#define READ_QUEUE_CONGESTION_STATUS1r BCM53262_A0_READ_QUEUE_CONGESTION_STATUS1r
#define WRITE_QUEUE_CONGESTION_STATUS1r BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QUEUE_CONGESTION_STATUS1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QUEUE_CONGESTION_STATUS2
 * BLOCKS:   SYS
 * DESC:     Queue Congestion Status Register 2
 * SIZE:     16
 * FIELDS:
 *     QUEUE_CONG_MAP   Diagnosis only: Queue_cong_map[47:32].
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS2r 0x00000a54

#define BCM53262_A0_QUEUE_CONGESTION_STATUS2r_SIZE 2

/*
 * This structure should be used to declare and program QUEUE_CONGESTION_STATUS2.
 */
typedef union BCM53262_A0_QUEUE_CONGESTION_STATUS2r_s {
	uint32_t v[1];
	uint32_t queue_congestion_status2[1];
	uint32_t _queue_congestion_status2;
} BCM53262_A0_QUEUE_CONGESTION_STATUS2r_t;

#define BCM53262_A0_QUEUE_CONGESTION_STATUS2r_CLR(r) (r).queue_congestion_status2[0] = 0
#define BCM53262_A0_QUEUE_CONGESTION_STATUS2r_SET(r,d) (r).queue_congestion_status2[0] = d
#define BCM53262_A0_QUEUE_CONGESTION_STATUS2r_GET(r) (r).queue_congestion_status2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS2r_QUEUE_CONG_MAPf_GET(r) (((r).queue_congestion_status2[0]) & 0xffff)
#define BCM53262_A0_QUEUE_CONGESTION_STATUS2r_QUEUE_CONG_MAPf_SET(r,f) (r).queue_congestion_status2[0]=(((r).queue_congestion_status2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access QUEUE_CONGESTION_STATUS2.
 */
#define BCM53262_A0_READ_QUEUE_CONGESTION_STATUS2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QUEUE_CONGESTION_STATUS2r,(r._queue_congestion_status2),2)
#define BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QUEUE_CONGESTION_STATUS2r,&(r._queue_congestion_status2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE_CONGESTION_STATUS2r BCM53262_A0_QUEUE_CONGESTION_STATUS2r
#define QUEUE_CONGESTION_STATUS2r_SIZE BCM53262_A0_QUEUE_CONGESTION_STATUS2r_SIZE
typedef BCM53262_A0_QUEUE_CONGESTION_STATUS2r_t QUEUE_CONGESTION_STATUS2r_t;
#define QUEUE_CONGESTION_STATUS2r_CLR BCM53262_A0_QUEUE_CONGESTION_STATUS2r_CLR
#define QUEUE_CONGESTION_STATUS2r_SET BCM53262_A0_QUEUE_CONGESTION_STATUS2r_SET
#define QUEUE_CONGESTION_STATUS2r_GET BCM53262_A0_QUEUE_CONGESTION_STATUS2r_GET
#define QUEUE_CONGESTION_STATUS2r_QUEUE_CONG_MAPf_GET BCM53262_A0_QUEUE_CONGESTION_STATUS2r_QUEUE_CONG_MAPf_GET
#define QUEUE_CONGESTION_STATUS2r_QUEUE_CONG_MAPf_SET BCM53262_A0_QUEUE_CONGESTION_STATUS2r_QUEUE_CONG_MAPf_SET
#define READ_QUEUE_CONGESTION_STATUS2r BCM53262_A0_READ_QUEUE_CONGESTION_STATUS2r
#define WRITE_QUEUE_CONGESTION_STATUS2r BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QUEUE_CONGESTION_STATUS2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QUEUE_CONGESTION_STATUS3
 * BLOCKS:   SYS
 * DESC:     Queue Congestion Status Register 3
 * SIZE:     16
 * FIELDS:
 *     QUEUE_CONG_MAP   Diagnosis only: Queue_cong_map[xx:xx].
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS3r 0x00000a56

#define BCM53262_A0_QUEUE_CONGESTION_STATUS3r_SIZE 2

/*
 * This structure should be used to declare and program QUEUE_CONGESTION_STATUS3.
 */
typedef union BCM53262_A0_QUEUE_CONGESTION_STATUS3r_s {
	uint32_t v[1];
	uint32_t queue_congestion_status3[1];
	uint32_t _queue_congestion_status3;
} BCM53262_A0_QUEUE_CONGESTION_STATUS3r_t;

#define BCM53262_A0_QUEUE_CONGESTION_STATUS3r_CLR(r) (r).queue_congestion_status3[0] = 0
#define BCM53262_A0_QUEUE_CONGESTION_STATUS3r_SET(r,d) (r).queue_congestion_status3[0] = d
#define BCM53262_A0_QUEUE_CONGESTION_STATUS3r_GET(r) (r).queue_congestion_status3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS3r_QUEUE_CONG_MAPf_GET(r) (((r).queue_congestion_status3[0]) & 0xffff)
#define BCM53262_A0_QUEUE_CONGESTION_STATUS3r_QUEUE_CONG_MAPf_SET(r,f) (r).queue_congestion_status3[0]=(((r).queue_congestion_status3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access QUEUE_CONGESTION_STATUS3.
 */
#define BCM53262_A0_READ_QUEUE_CONGESTION_STATUS3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QUEUE_CONGESTION_STATUS3r,(r._queue_congestion_status3),2)
#define BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QUEUE_CONGESTION_STATUS3r,&(r._queue_congestion_status3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE_CONGESTION_STATUS3r BCM53262_A0_QUEUE_CONGESTION_STATUS3r
#define QUEUE_CONGESTION_STATUS3r_SIZE BCM53262_A0_QUEUE_CONGESTION_STATUS3r_SIZE
typedef BCM53262_A0_QUEUE_CONGESTION_STATUS3r_t QUEUE_CONGESTION_STATUS3r_t;
#define QUEUE_CONGESTION_STATUS3r_CLR BCM53262_A0_QUEUE_CONGESTION_STATUS3r_CLR
#define QUEUE_CONGESTION_STATUS3r_SET BCM53262_A0_QUEUE_CONGESTION_STATUS3r_SET
#define QUEUE_CONGESTION_STATUS3r_GET BCM53262_A0_QUEUE_CONGESTION_STATUS3r_GET
#define QUEUE_CONGESTION_STATUS3r_QUEUE_CONG_MAPf_GET BCM53262_A0_QUEUE_CONGESTION_STATUS3r_QUEUE_CONG_MAPf_GET
#define QUEUE_CONGESTION_STATUS3r_QUEUE_CONG_MAPf_SET BCM53262_A0_QUEUE_CONGESTION_STATUS3r_QUEUE_CONG_MAPf_SET
#define READ_QUEUE_CONGESTION_STATUS3r BCM53262_A0_READ_QUEUE_CONGESTION_STATUS3r
#define WRITE_QUEUE_CONGESTION_STATUS3r BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QUEUE_CONGESTION_STATUS3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QUEUE_CONGESTION_STATUS4
 * BLOCKS:   SYS
 * DESC:     Queue Congestion Status Register 4
 * SIZE:     16
 * FIELDS:
 *     QUEUE_CONG_MAP   Diagnosis only: Queue_cong_map[xx:xx].
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS4r 0x00000a58

#define BCM53262_A0_QUEUE_CONGESTION_STATUS4r_SIZE 2

/*
 * This structure should be used to declare and program QUEUE_CONGESTION_STATUS4.
 */
typedef union BCM53262_A0_QUEUE_CONGESTION_STATUS4r_s {
	uint32_t v[1];
	uint32_t queue_congestion_status4[1];
	uint32_t _queue_congestion_status4;
} BCM53262_A0_QUEUE_CONGESTION_STATUS4r_t;

#define BCM53262_A0_QUEUE_CONGESTION_STATUS4r_CLR(r) (r).queue_congestion_status4[0] = 0
#define BCM53262_A0_QUEUE_CONGESTION_STATUS4r_SET(r,d) (r).queue_congestion_status4[0] = d
#define BCM53262_A0_QUEUE_CONGESTION_STATUS4r_GET(r) (r).queue_congestion_status4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS4r_QUEUE_CONG_MAPf_GET(r) (((r).queue_congestion_status4[0]) & 0xffff)
#define BCM53262_A0_QUEUE_CONGESTION_STATUS4r_QUEUE_CONG_MAPf_SET(r,f) (r).queue_congestion_status4[0]=(((r).queue_congestion_status4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access QUEUE_CONGESTION_STATUS4.
 */
#define BCM53262_A0_READ_QUEUE_CONGESTION_STATUS4r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QUEUE_CONGESTION_STATUS4r,(r._queue_congestion_status4),2)
#define BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS4r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QUEUE_CONGESTION_STATUS4r,&(r._queue_congestion_status4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE_CONGESTION_STATUS4r BCM53262_A0_QUEUE_CONGESTION_STATUS4r
#define QUEUE_CONGESTION_STATUS4r_SIZE BCM53262_A0_QUEUE_CONGESTION_STATUS4r_SIZE
typedef BCM53262_A0_QUEUE_CONGESTION_STATUS4r_t QUEUE_CONGESTION_STATUS4r_t;
#define QUEUE_CONGESTION_STATUS4r_CLR BCM53262_A0_QUEUE_CONGESTION_STATUS4r_CLR
#define QUEUE_CONGESTION_STATUS4r_SET BCM53262_A0_QUEUE_CONGESTION_STATUS4r_SET
#define QUEUE_CONGESTION_STATUS4r_GET BCM53262_A0_QUEUE_CONGESTION_STATUS4r_GET
#define QUEUE_CONGESTION_STATUS4r_QUEUE_CONG_MAPf_GET BCM53262_A0_QUEUE_CONGESTION_STATUS4r_QUEUE_CONG_MAPf_GET
#define QUEUE_CONGESTION_STATUS4r_QUEUE_CONG_MAPf_SET BCM53262_A0_QUEUE_CONGESTION_STATUS4r_QUEUE_CONG_MAPf_SET
#define READ_QUEUE_CONGESTION_STATUS4r BCM53262_A0_READ_QUEUE_CONGESTION_STATUS4r
#define WRITE_QUEUE_CONGESTION_STATUS4r BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QUEUE_CONGESTION_STATUS4r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  QUEUE_CONGESTION_STATUS5
 * BLOCKS:   SYS
 * DESC:     Queue Congestion Status Register 5
 * SIZE:     16
 * FIELDS:
 *     QUEUE_CONG_MAP   Diagnosis only: Queue_cong_map[xx:xx].
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS5r 0x00000a5c

#define BCM53262_A0_QUEUE_CONGESTION_STATUS5r_SIZE 2

/*
 * This structure should be used to declare and program QUEUE_CONGESTION_STATUS5.
 */
typedef union BCM53262_A0_QUEUE_CONGESTION_STATUS5r_s {
	uint32_t v[1];
	uint32_t queue_congestion_status5[1];
	uint32_t _queue_congestion_status5;
} BCM53262_A0_QUEUE_CONGESTION_STATUS5r_t;

#define BCM53262_A0_QUEUE_CONGESTION_STATUS5r_CLR(r) (r).queue_congestion_status5[0] = 0
#define BCM53262_A0_QUEUE_CONGESTION_STATUS5r_SET(r,d) (r).queue_congestion_status5[0] = d
#define BCM53262_A0_QUEUE_CONGESTION_STATUS5r_GET(r) (r).queue_congestion_status5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_QUEUE_CONGESTION_STATUS5r_QUEUE_CONG_MAPf_GET(r) (((r).queue_congestion_status5[0]) & 0xffff)
#define BCM53262_A0_QUEUE_CONGESTION_STATUS5r_QUEUE_CONG_MAPf_SET(r,f) (r).queue_congestion_status5[0]=(((r).queue_congestion_status5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access QUEUE_CONGESTION_STATUS5.
 */
#define BCM53262_A0_READ_QUEUE_CONGESTION_STATUS5r(u,r) cdk_robo_reg_read(u,BCM53262_A0_QUEUE_CONGESTION_STATUS5r,(r._queue_congestion_status5),2)
#define BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS5r(u,r) cdk_robo_reg_write(u,BCM53262_A0_QUEUE_CONGESTION_STATUS5r,&(r._queue_congestion_status5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QUEUE_CONGESTION_STATUS5r BCM53262_A0_QUEUE_CONGESTION_STATUS5r
#define QUEUE_CONGESTION_STATUS5r_SIZE BCM53262_A0_QUEUE_CONGESTION_STATUS5r_SIZE
typedef BCM53262_A0_QUEUE_CONGESTION_STATUS5r_t QUEUE_CONGESTION_STATUS5r_t;
#define QUEUE_CONGESTION_STATUS5r_CLR BCM53262_A0_QUEUE_CONGESTION_STATUS5r_CLR
#define QUEUE_CONGESTION_STATUS5r_SET BCM53262_A0_QUEUE_CONGESTION_STATUS5r_SET
#define QUEUE_CONGESTION_STATUS5r_GET BCM53262_A0_QUEUE_CONGESTION_STATUS5r_GET
#define QUEUE_CONGESTION_STATUS5r_QUEUE_CONG_MAPf_GET BCM53262_A0_QUEUE_CONGESTION_STATUS5r_QUEUE_CONG_MAPf_GET
#define QUEUE_CONGESTION_STATUS5r_QUEUE_CONG_MAPf_SET BCM53262_A0_QUEUE_CONGESTION_STATUS5r_QUEUE_CONG_MAPf_SET
#define READ_QUEUE_CONGESTION_STATUS5r BCM53262_A0_READ_QUEUE_CONGESTION_STATUS5r
#define WRITE_QUEUE_CONGESTION_STATUS5r BCM53262_A0_WRITE_QUEUE_CONGESTION_STATUS5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_QUEUE_CONGESTION_STATUS5r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RANGE_CHECKER_CTL
 * BLOCKS:   SYS
 * DESC:     Range Checker Control Registers
 * SIZE:     8
 * FIELDS:
 *     RCC0             Range Checker Control 0.0: L4 Source port.1: L4 Destination port.
 *     RCC1             Range Checker Control 1.0: L4 Source port.1: L4 Destination port.
 *     RCC2             Range Checker Control 2.0: L4 Source port.1: L4 Destination port.
 *     RCC3             Range Checker Control 3.0: L4 Source port.1: L4 Destination port.
 *     CHG_VID_FFF_CTL  Flow2Vlan Change VID "FFF" Control.If use FLOWID to change VID and new VID == 'FFF'.0: Not2change1: Change VID = 'FFF'
 *     DSCP_CHKSUM_FFFF_CTL DSCP Checksum Value "FFFF" Control.If new DSCP checksum value == 'FFFF'.0: Not2change1: Change new DSCP checksum == '0000'.
 *     RESERVED_R       Reserved.
 */
#define BCM53262_A0_RANGE_CHECKER_CTLr 0x00002108

#define BCM53262_A0_RANGE_CHECKER_CTLr_SIZE 1

/*
 * This structure should be used to declare and program RANGE_CHECKER_CTL.
 */
typedef union BCM53262_A0_RANGE_CHECKER_CTLr_s {
	uint32_t v[1];
	uint32_t range_checker_ctl[1];
	uint32_t _range_checker_ctl;
} BCM53262_A0_RANGE_CHECKER_CTLr_t;

#define BCM53262_A0_RANGE_CHECKER_CTLr_CLR(r) (r).range_checker_ctl[0] = 0
#define BCM53262_A0_RANGE_CHECKER_CTLr_SET(r,d) (r).range_checker_ctl[0] = d
#define BCM53262_A0_RANGE_CHECKER_CTLr_GET(r) (r).range_checker_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC0f_GET(r) (((r).range_checker_ctl[0]) & 0x1)
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC0f_SET(r,f) (r).range_checker_ctl[0]=(((r).range_checker_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC1f_GET(r) ((((r).range_checker_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC1f_SET(r,f) (r).range_checker_ctl[0]=(((r).range_checker_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC2f_GET(r) ((((r).range_checker_ctl[0]) >> 2) & 0x1)
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC2f_SET(r,f) (r).range_checker_ctl[0]=(((r).range_checker_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC3f_GET(r) ((((r).range_checker_ctl[0]) >> 3) & 0x1)
#define BCM53262_A0_RANGE_CHECKER_CTLr_RCC3f_SET(r,f) (r).range_checker_ctl[0]=(((r).range_checker_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_RANGE_CHECKER_CTLr_CHG_VID_FFF_CTLf_GET(r) ((((r).range_checker_ctl[0]) >> 4) & 0x1)
#define BCM53262_A0_RANGE_CHECKER_CTLr_CHG_VID_FFF_CTLf_SET(r,f) (r).range_checker_ctl[0]=(((r).range_checker_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_RANGE_CHECKER_CTLr_DSCP_CHKSUM_FFFF_CTLf_GET(r) ((((r).range_checker_ctl[0]) >> 5) & 0x1)
#define BCM53262_A0_RANGE_CHECKER_CTLr_DSCP_CHKSUM_FFFF_CTLf_SET(r,f) (r).range_checker_ctl[0]=(((r).range_checker_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_RANGE_CHECKER_CTLr_RESERVED_Rf_GET(r) ((((r).range_checker_ctl[0]) >> 6) & 0x3)
#define BCM53262_A0_RANGE_CHECKER_CTLr_RESERVED_Rf_SET(r,f) (r).range_checker_ctl[0]=(((r).range_checker_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RANGE_CHECKER_CTL.
 */
#define BCM53262_A0_READ_RANGE_CHECKER_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RANGE_CHECKER_CTLr,(r._range_checker_ctl),1)
#define BCM53262_A0_WRITE_RANGE_CHECKER_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RANGE_CHECKER_CTLr,&(r._range_checker_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RANGE_CHECKER_CTLr BCM53262_A0_RANGE_CHECKER_CTLr
#define RANGE_CHECKER_CTLr_SIZE BCM53262_A0_RANGE_CHECKER_CTLr_SIZE
typedef BCM53262_A0_RANGE_CHECKER_CTLr_t RANGE_CHECKER_CTLr_t;
#define RANGE_CHECKER_CTLr_CLR BCM53262_A0_RANGE_CHECKER_CTLr_CLR
#define RANGE_CHECKER_CTLr_SET BCM53262_A0_RANGE_CHECKER_CTLr_SET
#define RANGE_CHECKER_CTLr_GET BCM53262_A0_RANGE_CHECKER_CTLr_GET
#define RANGE_CHECKER_CTLr_RCC0f_GET BCM53262_A0_RANGE_CHECKER_CTLr_RCC0f_GET
#define RANGE_CHECKER_CTLr_RCC0f_SET BCM53262_A0_RANGE_CHECKER_CTLr_RCC0f_SET
#define RANGE_CHECKER_CTLr_RCC1f_GET BCM53262_A0_RANGE_CHECKER_CTLr_RCC1f_GET
#define RANGE_CHECKER_CTLr_RCC1f_SET BCM53262_A0_RANGE_CHECKER_CTLr_RCC1f_SET
#define RANGE_CHECKER_CTLr_RCC2f_GET BCM53262_A0_RANGE_CHECKER_CTLr_RCC2f_GET
#define RANGE_CHECKER_CTLr_RCC2f_SET BCM53262_A0_RANGE_CHECKER_CTLr_RCC2f_SET
#define RANGE_CHECKER_CTLr_RCC3f_GET BCM53262_A0_RANGE_CHECKER_CTLr_RCC3f_GET
#define RANGE_CHECKER_CTLr_RCC3f_SET BCM53262_A0_RANGE_CHECKER_CTLr_RCC3f_SET
#define RANGE_CHECKER_CTLr_CHG_VID_FFF_CTLf_GET BCM53262_A0_RANGE_CHECKER_CTLr_CHG_VID_FFF_CTLf_GET
#define RANGE_CHECKER_CTLr_CHG_VID_FFF_CTLf_SET BCM53262_A0_RANGE_CHECKER_CTLr_CHG_VID_FFF_CTLf_SET
#define RANGE_CHECKER_CTLr_DSCP_CHKSUM_FFFF_CTLf_GET BCM53262_A0_RANGE_CHECKER_CTLr_DSCP_CHKSUM_FFFF_CTLf_GET
#define RANGE_CHECKER_CTLr_DSCP_CHKSUM_FFFF_CTLf_SET BCM53262_A0_RANGE_CHECKER_CTLr_DSCP_CHKSUM_FFFF_CTLf_SET
#define RANGE_CHECKER_CTLr_RESERVED_Rf_GET BCM53262_A0_RANGE_CHECKER_CTLr_RESERVED_Rf_GET
#define RANGE_CHECKER_CTLr_RESERVED_Rf_SET BCM53262_A0_RANGE_CHECKER_CTLr_RESERVED_Rf_SET
#define READ_RANGE_CHECKER_CTLr BCM53262_A0_READ_RANGE_CHECKER_CTLr
#define WRITE_RANGE_CHECKER_CTLr BCM53262_A0_WRITE_RANGE_CHECKER_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RANGE_CHECKER_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RATE_INBAND
 * BLOCKS:   SYS
 * DESC:     CFP REAT In-Band Statistic Registers
 * SIZE:     32
 * FIELDS:
 *     INBAND_CNT       In Band CounterThis field contains the data to read from or write to the in-band counter RAM.
 */
#define BCM53262_A0_RATE_INBANDr 0x00002090

#define BCM53262_A0_RATE_INBANDr_SIZE 4

/*
 * This structure should be used to declare and program RATE_INBAND.
 */
typedef union BCM53262_A0_RATE_INBANDr_s {
	uint32_t v[1];
	uint32_t rate_inband[1];
	uint32_t _rate_inband;
} BCM53262_A0_RATE_INBANDr_t;

#define BCM53262_A0_RATE_INBANDr_CLR(r) (r).rate_inband[0] = 0
#define BCM53262_A0_RATE_INBANDr_SET(r,d) (r).rate_inband[0] = d
#define BCM53262_A0_RATE_INBANDr_GET(r) (r).rate_inband[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RATE_INBANDr_INBAND_CNTf_GET(r) ((r).rate_inband[0])
#define BCM53262_A0_RATE_INBANDr_INBAND_CNTf_SET(r,f) (r).rate_inband[0]=((uint32_t)f)

/*
 * These macros can be used to access RATE_INBAND.
 */
#define BCM53262_A0_READ_RATE_INBANDr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RATE_INBANDr,(r._rate_inband),4)
#define BCM53262_A0_WRITE_RATE_INBANDr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RATE_INBANDr,&(r._rate_inband),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_INBANDr BCM53262_A0_RATE_INBANDr
#define RATE_INBANDr_SIZE BCM53262_A0_RATE_INBANDr_SIZE
typedef BCM53262_A0_RATE_INBANDr_t RATE_INBANDr_t;
#define RATE_INBANDr_CLR BCM53262_A0_RATE_INBANDr_CLR
#define RATE_INBANDr_SET BCM53262_A0_RATE_INBANDr_SET
#define RATE_INBANDr_GET BCM53262_A0_RATE_INBANDr_GET
#define RATE_INBANDr_INBAND_CNTf_GET BCM53262_A0_RATE_INBANDr_INBAND_CNTf_GET
#define RATE_INBANDr_INBAND_CNTf_SET BCM53262_A0_RATE_INBANDr_INBAND_CNTf_SET
#define READ_RATE_INBANDr BCM53262_A0_READ_RATE_INBANDr
#define WRITE_RATE_INBANDr BCM53262_A0_WRITE_RATE_INBANDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RATE_INBANDr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RATE_OUTBAND
 * BLOCKS:   SYS
 * DESC:     CFP REAT OUT-Band Statistic Registers
 * SIZE:     32
 * FIELDS:
 *     OUTBAND_CNT      Out Band Counter.This field contains the data to read from or write to the out-band counter RAM.
 */
#define BCM53262_A0_RATE_OUTBANDr 0x00002094

#define BCM53262_A0_RATE_OUTBANDr_SIZE 4

/*
 * This structure should be used to declare and program RATE_OUTBAND.
 */
typedef union BCM53262_A0_RATE_OUTBANDr_s {
	uint32_t v[1];
	uint32_t rate_outband[1];
	uint32_t _rate_outband;
} BCM53262_A0_RATE_OUTBANDr_t;

#define BCM53262_A0_RATE_OUTBANDr_CLR(r) (r).rate_outband[0] = 0
#define BCM53262_A0_RATE_OUTBANDr_SET(r,d) (r).rate_outband[0] = d
#define BCM53262_A0_RATE_OUTBANDr_GET(r) (r).rate_outband[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RATE_OUTBANDr_OUTBAND_CNTf_GET(r) ((r).rate_outband[0])
#define BCM53262_A0_RATE_OUTBANDr_OUTBAND_CNTf_SET(r,f) (r).rate_outband[0]=((uint32_t)f)

/*
 * These macros can be used to access RATE_OUTBAND.
 */
#define BCM53262_A0_READ_RATE_OUTBANDr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RATE_OUTBANDr,(r._rate_outband),4)
#define BCM53262_A0_WRITE_RATE_OUTBANDr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RATE_OUTBANDr,&(r._rate_outband),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_OUTBANDr BCM53262_A0_RATE_OUTBANDr
#define RATE_OUTBANDr_SIZE BCM53262_A0_RATE_OUTBANDr_SIZE
typedef BCM53262_A0_RATE_OUTBANDr_t RATE_OUTBANDr_t;
#define RATE_OUTBANDr_CLR BCM53262_A0_RATE_OUTBANDr_CLR
#define RATE_OUTBANDr_SET BCM53262_A0_RATE_OUTBANDr_SET
#define RATE_OUTBANDr_GET BCM53262_A0_RATE_OUTBANDr_GET
#define RATE_OUTBANDr_OUTBAND_CNTf_GET BCM53262_A0_RATE_OUTBANDr_OUTBAND_CNTf_GET
#define RATE_OUTBANDr_OUTBAND_CNTf_SET BCM53262_A0_RATE_OUTBANDr_OUTBAND_CNTf_SET
#define READ_RATE_OUTBANDr BCM53262_A0_READ_RATE_OUTBANDr
#define WRITE_RATE_OUTBANDr BCM53262_A0_WRITE_RATE_OUTBANDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RATE_OUTBANDr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RCM_CTL
 * BLOCKS:   SYS
 * DESC:     Rate Control Memory Read/Write Registers
 * SIZE:     8
 * FIELDS:
 *     RCM_RW           Rate Control Memory Read/Write1'b1: Read1'b0: Write
 *     IE_IND           Ingress / Egress Indication.1'b0: Ingress Rate Control Memory access.1'b1: Egress  Rate Control Memory access.
 *     XLEN_EN          Extra Length Calculate Enable (Only used for Ingress Rate Control)1'b1: Eable. (Premble + SFD will be calculated)1'b0: Disable.
 *     RESERVED_R       Reserved
 *     RCM_RW_STRTDN    Start/Done Command.Write as 1 to initiate a read or write command for a rate control memory access...It will be reset to indicate a write operation completed, or a read operation has completed.
 */
#define BCM53262_A0_RCM_CTLr 0x00004300

#define BCM53262_A0_RCM_CTLr_SIZE 1

/*
 * This structure should be used to declare and program RCM_CTL.
 */
typedef union BCM53262_A0_RCM_CTLr_s {
	uint32_t v[1];
	uint32_t rcm_ctl[1];
	uint32_t _rcm_ctl;
} BCM53262_A0_RCM_CTLr_t;

#define BCM53262_A0_RCM_CTLr_CLR(r) (r).rcm_ctl[0] = 0
#define BCM53262_A0_RCM_CTLr_SET(r,d) (r).rcm_ctl[0] = d
#define BCM53262_A0_RCM_CTLr_GET(r) (r).rcm_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RCM_CTLr_RCM_RWf_GET(r) (((r).rcm_ctl[0]) & 0x1)
#define BCM53262_A0_RCM_CTLr_RCM_RWf_SET(r,f) (r).rcm_ctl[0]=(((r).rcm_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_RCM_CTLr_IE_INDf_GET(r) ((((r).rcm_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_RCM_CTLr_IE_INDf_SET(r,f) (r).rcm_ctl[0]=(((r).rcm_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_RCM_CTLr_XLEN_ENf_GET(r) ((((r).rcm_ctl[0]) >> 2) & 0x1)
#define BCM53262_A0_RCM_CTLr_XLEN_ENf_SET(r,f) (r).rcm_ctl[0]=(((r).rcm_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_RCM_CTLr_RESERVED_Rf_GET(r) ((((r).rcm_ctl[0]) >> 3) & 0xf)
#define BCM53262_A0_RCM_CTLr_RESERVED_Rf_SET(r,f) (r).rcm_ctl[0]=(((r).rcm_ctl[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM53262_A0_RCM_CTLr_RCM_RW_STRTDNf_GET(r) ((((r).rcm_ctl[0]) >> 7) & 0x1)
#define BCM53262_A0_RCM_CTLr_RCM_RW_STRTDNf_SET(r,f) (r).rcm_ctl[0]=(((r).rcm_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RCM_CTL.
 */
#define BCM53262_A0_READ_RCM_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RCM_CTLr,(r._rcm_ctl),1)
#define BCM53262_A0_WRITE_RCM_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RCM_CTLr,&(r._rcm_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RCM_CTLr BCM53262_A0_RCM_CTLr
#define RCM_CTLr_SIZE BCM53262_A0_RCM_CTLr_SIZE
typedef BCM53262_A0_RCM_CTLr_t RCM_CTLr_t;
#define RCM_CTLr_CLR BCM53262_A0_RCM_CTLr_CLR
#define RCM_CTLr_SET BCM53262_A0_RCM_CTLr_SET
#define RCM_CTLr_GET BCM53262_A0_RCM_CTLr_GET
#define RCM_CTLr_RCM_RWf_GET BCM53262_A0_RCM_CTLr_RCM_RWf_GET
#define RCM_CTLr_RCM_RWf_SET BCM53262_A0_RCM_CTLr_RCM_RWf_SET
#define RCM_CTLr_IE_INDf_GET BCM53262_A0_RCM_CTLr_IE_INDf_GET
#define RCM_CTLr_IE_INDf_SET BCM53262_A0_RCM_CTLr_IE_INDf_SET
#define RCM_CTLr_XLEN_ENf_GET BCM53262_A0_RCM_CTLr_XLEN_ENf_GET
#define RCM_CTLr_XLEN_ENf_SET BCM53262_A0_RCM_CTLr_XLEN_ENf_SET
#define RCM_CTLr_RESERVED_Rf_GET BCM53262_A0_RCM_CTLr_RESERVED_Rf_GET
#define RCM_CTLr_RESERVED_Rf_SET BCM53262_A0_RCM_CTLr_RESERVED_Rf_SET
#define RCM_CTLr_RCM_RW_STRTDNf_GET BCM53262_A0_RCM_CTLr_RCM_RW_STRTDNf_GET
#define RCM_CTLr_RCM_RW_STRTDNf_SET BCM53262_A0_RCM_CTLr_RCM_RW_STRTDNf_SET
#define READ_RCM_CTLr BCM53262_A0_READ_RCM_CTLr
#define WRITE_RCM_CTLr BCM53262_A0_WRITE_RCM_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RCM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RCM_DATA0
 * BLOCKS:   SYS
 * DESC:     Rate Control Memory Data REGISTER 0
 * SIZE:     32
 * FIELDS:
 *     REF_CNTS         Refresh Count, the desired rate.For Ingress Rate Control: (per-bucket,B0)For Egress  Rate Control: (Total)
 *     REF_UNIT         0 for 62.5Kbps. 1 for 1Mbps.For Ingress Rate Control: (per-bucket,B0)For Egress  Rate Control: (Total)
 *     BUCKET_SIZE      For Ingress Rate Control: Bucket Size, unit 8Kbytes. (per-bucket,B0)For Egress  Rate Control: Bucket Size, unit 8Kbytes. (Total)
 *     IRC_PKT_MASK_B0  For Ingress Rate Control: Packet Mask (per-bucket)    6 : Unknown SA	   5 : Unicast Destination Lookup Fail Frame (DLF)	   4 : Multicast Destination Lookup Fail Frame (MLF)	   3 : Broadcast	   2 : Multicast Reserved Frame (DA=01-80-c2-00-00-00 ~ 2F)	   1 : Multicast Destination Lookup Hit Frame	   0 : Unicast Destination Lookup Hit Frame.For Egress  Rate Control: RESERVED
 *     RESERVED_R       Reserved
 *     IRC_DROP_EN      For Ingress Rate Control: Drop Enable.    1'b0: When over rate, pause it.    1'b1: When over rate, drop it.For Egress  Rate Control: RESERVED
 *     IE_RC_EN         For Ingress Rate Control(Page 43h; offset 00h; bit 1 = 1'b0):    Ingress Rate Control Enable.For Egress  Rate Control(Page 43h; offset 00h; bit 1 = 1'b1):    Egress Rate Control Enable. (Total)
 */
#define BCM53262_A0_RCM_DATA0r 0x00004310

#define BCM53262_A0_RCM_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program RCM_DATA0.
 */
typedef union BCM53262_A0_RCM_DATA0r_s {
	uint32_t v[1];
	uint32_t rcm_data0[1];
	uint32_t _rcm_data0;
} BCM53262_A0_RCM_DATA0r_t;

#define BCM53262_A0_RCM_DATA0r_CLR(r) (r).rcm_data0[0] = 0
#define BCM53262_A0_RCM_DATA0r_SET(r,d) (r).rcm_data0[0] = d
#define BCM53262_A0_RCM_DATA0r_GET(r) (r).rcm_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RCM_DATA0r_REF_CNTSf_GET(r) (((r).rcm_data0[0]) & 0x3fff)
#define BCM53262_A0_RCM_DATA0r_REF_CNTSf_SET(r,f) (r).rcm_data0[0]=(((r).rcm_data0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_RCM_DATA0r_REF_UNITf_GET(r) ((((r).rcm_data0[0]) >> 14) & 0x1)
#define BCM53262_A0_RCM_DATA0r_REF_UNITf_SET(r,f) (r).rcm_data0[0]=(((r).rcm_data0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_RCM_DATA0r_BUCKET_SIZEf_GET(r) ((((r).rcm_data0[0]) >> 15) & 0x7f)
#define BCM53262_A0_RCM_DATA0r_BUCKET_SIZEf_SET(r,f) (r).rcm_data0[0]=(((r).rcm_data0[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_RCM_DATA0r_IRC_PKT_MASK_B0f_GET(r) ((((r).rcm_data0[0]) >> 22) & 0x7f)
#define BCM53262_A0_RCM_DATA0r_IRC_PKT_MASK_B0f_SET(r,f) (r).rcm_data0[0]=(((r).rcm_data0[0] & ~((uint32_t)0x7f << 22)) | ((((uint32_t)f) & 0x7f) << 22))
#define BCM53262_A0_RCM_DATA0r_RESERVED_Rf_GET(r) ((((r).rcm_data0[0]) >> 29) & 0x1)
#define BCM53262_A0_RCM_DATA0r_RESERVED_Rf_SET(r,f) (r).rcm_data0[0]=(((r).rcm_data0[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53262_A0_RCM_DATA0r_IRC_DROP_ENf_GET(r) ((((r).rcm_data0[0]) >> 30) & 0x1)
#define BCM53262_A0_RCM_DATA0r_IRC_DROP_ENf_SET(r,f) (r).rcm_data0[0]=(((r).rcm_data0[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_RCM_DATA0r_IE_RC_ENf_GET(r) ((((r).rcm_data0[0]) >> 31) & 0x1)
#define BCM53262_A0_RCM_DATA0r_IE_RC_ENf_SET(r,f) (r).rcm_data0[0]=(((r).rcm_data0[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access RCM_DATA0.
 */
#define BCM53262_A0_READ_RCM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RCM_DATA0r,(r._rcm_data0),4)
#define BCM53262_A0_WRITE_RCM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RCM_DATA0r,&(r._rcm_data0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RCM_DATA0r BCM53262_A0_RCM_DATA0r
#define RCM_DATA0r_SIZE BCM53262_A0_RCM_DATA0r_SIZE
typedef BCM53262_A0_RCM_DATA0r_t RCM_DATA0r_t;
#define RCM_DATA0r_CLR BCM53262_A0_RCM_DATA0r_CLR
#define RCM_DATA0r_SET BCM53262_A0_RCM_DATA0r_SET
#define RCM_DATA0r_GET BCM53262_A0_RCM_DATA0r_GET
#define RCM_DATA0r_REF_CNTSf_GET BCM53262_A0_RCM_DATA0r_REF_CNTSf_GET
#define RCM_DATA0r_REF_CNTSf_SET BCM53262_A0_RCM_DATA0r_REF_CNTSf_SET
#define RCM_DATA0r_REF_UNITf_GET BCM53262_A0_RCM_DATA0r_REF_UNITf_GET
#define RCM_DATA0r_REF_UNITf_SET BCM53262_A0_RCM_DATA0r_REF_UNITf_SET
#define RCM_DATA0r_BUCKET_SIZEf_GET BCM53262_A0_RCM_DATA0r_BUCKET_SIZEf_GET
#define RCM_DATA0r_BUCKET_SIZEf_SET BCM53262_A0_RCM_DATA0r_BUCKET_SIZEf_SET
#define RCM_DATA0r_IRC_PKT_MASK_B0f_GET BCM53262_A0_RCM_DATA0r_IRC_PKT_MASK_B0f_GET
#define RCM_DATA0r_IRC_PKT_MASK_B0f_SET BCM53262_A0_RCM_DATA0r_IRC_PKT_MASK_B0f_SET
#define RCM_DATA0r_RESERVED_Rf_GET BCM53262_A0_RCM_DATA0r_RESERVED_Rf_GET
#define RCM_DATA0r_RESERVED_Rf_SET BCM53262_A0_RCM_DATA0r_RESERVED_Rf_SET
#define RCM_DATA0r_IRC_DROP_ENf_GET BCM53262_A0_RCM_DATA0r_IRC_DROP_ENf_GET
#define RCM_DATA0r_IRC_DROP_ENf_SET BCM53262_A0_RCM_DATA0r_IRC_DROP_ENf_SET
#define RCM_DATA0r_IE_RC_ENf_GET BCM53262_A0_RCM_DATA0r_IE_RC_ENf_GET
#define RCM_DATA0r_IE_RC_ENf_SET BCM53262_A0_RCM_DATA0r_IE_RC_ENf_SET
#define READ_RCM_DATA0r BCM53262_A0_READ_RCM_DATA0r
#define WRITE_RCM_DATA0r BCM53262_A0_WRITE_RCM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RCM_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RCM_DATA1
 * BLOCKS:   SYS
 * DESC:     Rate Control Memory Data REGISTER 1
 * SIZE:     32
 * FIELDS:
 *     REF_CNTS         Refresh Count, the desired rate.For Ingress Rate Control: (per-bucket,B1)For Egress  Rate Control: (For Q0)
 *     REF_UNIT         0 for 62.5Kbps. 1 for 1Mbps.For Ingress Rate Control: (per-bucket,B1)For Egress  Rate Control: (For Q0)
 *     BUCKET_SIZE      For Ingress Rate Control: Bucket Size, unit 8Kbytes. (per-bucket,B1)For Egress  Rate Control: Bucket Size, unit 8Kbytes. (For Q0)
 *     IRC_PKT_MASK_B1  For Ingress Rate Control: Packet Mask (per-bucket)    6 : Unknown SA	   5 : Unicast Destination Lookup Fail Frame (DLF)	   4 : Multicast Destination Lookup Fail Frame (MLF)	   3 : Broadcast	   2 : Multicast Reserved Frame (DA=01-80-c2-00-00-00 ~ 2F)	   1 : Multicast Destination Lookup Hit Frame	   0 : Unicast Destination Lookup Hit Frame.For Egress  Rate Control: RESERVED
 *     RESERVED_R       Reserved
 *     ERC_Q_EN         For Ingress Rate Control: RESERVED.For Egress  Rate Control: Egress Rate Control Enable. (Per-Q)
 */
#define BCM53262_A0_RCM_DATA1r 0x00004314

#define BCM53262_A0_RCM_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program RCM_DATA1.
 */
typedef union BCM53262_A0_RCM_DATA1r_s {
	uint32_t v[1];
	uint32_t rcm_data1[1];
	uint32_t _rcm_data1;
} BCM53262_A0_RCM_DATA1r_t;

#define BCM53262_A0_RCM_DATA1r_CLR(r) (r).rcm_data1[0] = 0
#define BCM53262_A0_RCM_DATA1r_SET(r,d) (r).rcm_data1[0] = d
#define BCM53262_A0_RCM_DATA1r_GET(r) (r).rcm_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RCM_DATA1r_REF_CNTSf_GET(r) (((r).rcm_data1[0]) & 0x3fff)
#define BCM53262_A0_RCM_DATA1r_REF_CNTSf_SET(r,f) (r).rcm_data1[0]=(((r).rcm_data1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_RCM_DATA1r_REF_UNITf_GET(r) ((((r).rcm_data1[0]) >> 14) & 0x1)
#define BCM53262_A0_RCM_DATA1r_REF_UNITf_SET(r,f) (r).rcm_data1[0]=(((r).rcm_data1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_RCM_DATA1r_BUCKET_SIZEf_GET(r) ((((r).rcm_data1[0]) >> 15) & 0x7f)
#define BCM53262_A0_RCM_DATA1r_BUCKET_SIZEf_SET(r,f) (r).rcm_data1[0]=(((r).rcm_data1[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_RCM_DATA1r_IRC_PKT_MASK_B1f_GET(r) ((((r).rcm_data1[0]) >> 22) & 0x7f)
#define BCM53262_A0_RCM_DATA1r_IRC_PKT_MASK_B1f_SET(r,f) (r).rcm_data1[0]=(((r).rcm_data1[0] & ~((uint32_t)0x7f << 22)) | ((((uint32_t)f) & 0x7f) << 22))
#define BCM53262_A0_RCM_DATA1r_RESERVED_Rf_GET(r) ((((r).rcm_data1[0]) >> 29) & 0x3)
#define BCM53262_A0_RCM_DATA1r_RESERVED_Rf_SET(r,f) (r).rcm_data1[0]=(((r).rcm_data1[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53262_A0_RCM_DATA1r_ERC_Q_ENf_GET(r) ((((r).rcm_data1[0]) >> 31) & 0x1)
#define BCM53262_A0_RCM_DATA1r_ERC_Q_ENf_SET(r,f) (r).rcm_data1[0]=(((r).rcm_data1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access RCM_DATA1.
 */
#define BCM53262_A0_READ_RCM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RCM_DATA1r,(r._rcm_data1),4)
#define BCM53262_A0_WRITE_RCM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RCM_DATA1r,&(r._rcm_data1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RCM_DATA1r BCM53262_A0_RCM_DATA1r
#define RCM_DATA1r_SIZE BCM53262_A0_RCM_DATA1r_SIZE
typedef BCM53262_A0_RCM_DATA1r_t RCM_DATA1r_t;
#define RCM_DATA1r_CLR BCM53262_A0_RCM_DATA1r_CLR
#define RCM_DATA1r_SET BCM53262_A0_RCM_DATA1r_SET
#define RCM_DATA1r_GET BCM53262_A0_RCM_DATA1r_GET
#define RCM_DATA1r_REF_CNTSf_GET BCM53262_A0_RCM_DATA1r_REF_CNTSf_GET
#define RCM_DATA1r_REF_CNTSf_SET BCM53262_A0_RCM_DATA1r_REF_CNTSf_SET
#define RCM_DATA1r_REF_UNITf_GET BCM53262_A0_RCM_DATA1r_REF_UNITf_GET
#define RCM_DATA1r_REF_UNITf_SET BCM53262_A0_RCM_DATA1r_REF_UNITf_SET
#define RCM_DATA1r_BUCKET_SIZEf_GET BCM53262_A0_RCM_DATA1r_BUCKET_SIZEf_GET
#define RCM_DATA1r_BUCKET_SIZEf_SET BCM53262_A0_RCM_DATA1r_BUCKET_SIZEf_SET
#define RCM_DATA1r_IRC_PKT_MASK_B1f_GET BCM53262_A0_RCM_DATA1r_IRC_PKT_MASK_B1f_GET
#define RCM_DATA1r_IRC_PKT_MASK_B1f_SET BCM53262_A0_RCM_DATA1r_IRC_PKT_MASK_B1f_SET
#define RCM_DATA1r_RESERVED_Rf_GET BCM53262_A0_RCM_DATA1r_RESERVED_Rf_GET
#define RCM_DATA1r_RESERVED_Rf_SET BCM53262_A0_RCM_DATA1r_RESERVED_Rf_SET
#define RCM_DATA1r_ERC_Q_ENf_GET BCM53262_A0_RCM_DATA1r_ERC_Q_ENf_GET
#define RCM_DATA1r_ERC_Q_ENf_SET BCM53262_A0_RCM_DATA1r_ERC_Q_ENf_SET
#define READ_RCM_DATA1r BCM53262_A0_READ_RCM_DATA1r
#define WRITE_RCM_DATA1r BCM53262_A0_WRITE_RCM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RCM_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RCM_DATA2
 * BLOCKS:   SYS
 * DESC:     Rate Control Memory Data REGISTER 2
 * SIZE:     32
 * FIELDS:
 *     REF_CNTS         Refresh Count, the desired rate.For Ingress Rate Control: (per-bucket,B2)For Egress  Rate Control: (For Q1)
 *     REF_UNIT         0 for 62.5Kbps. 1 for 1Mbps.For Ingress Rate Control: (per-bucket,B2)For Egress  Rate Control: (For Q1)
 *     BUCKET_SIZE      For Ingress Rate Control: Bucket Size, unit 8Kbytes. (per-bucket,B2)For Egress  Rate Control: Bucket Size, unit 8Kbytes. (For Q1)
 *     IRC_PKT_MASK_B2  For Ingress Rate Control: Packet Mask (per-bucket)    6 : Unknown SA	   5 : Unicast Destination Lookup Fail Frame (DLF)	   4 : Multicast Destination Lookup Fail Frame (MLF)	   3 : Broadcast	   2 : Multicast Reserved Frame (DA=01-80-c2-00-00-00 ~ 2F)	   1 : Multicast Destination Lookup Hit Frame	   0 : Unicast Destination Lookup Hit Frame.For Egress  Rate Control: RESERVED
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_RCM_DATA2r 0x00004318

#define BCM53262_A0_RCM_DATA2r_SIZE 4

/*
 * This structure should be used to declare and program RCM_DATA2.
 */
typedef union BCM53262_A0_RCM_DATA2r_s {
	uint32_t v[1];
	uint32_t rcm_data2[1];
	uint32_t _rcm_data2;
} BCM53262_A0_RCM_DATA2r_t;

#define BCM53262_A0_RCM_DATA2r_CLR(r) (r).rcm_data2[0] = 0
#define BCM53262_A0_RCM_DATA2r_SET(r,d) (r).rcm_data2[0] = d
#define BCM53262_A0_RCM_DATA2r_GET(r) (r).rcm_data2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RCM_DATA2r_REF_CNTSf_GET(r) (((r).rcm_data2[0]) & 0x3fff)
#define BCM53262_A0_RCM_DATA2r_REF_CNTSf_SET(r,f) (r).rcm_data2[0]=(((r).rcm_data2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_RCM_DATA2r_REF_UNITf_GET(r) ((((r).rcm_data2[0]) >> 14) & 0x1)
#define BCM53262_A0_RCM_DATA2r_REF_UNITf_SET(r,f) (r).rcm_data2[0]=(((r).rcm_data2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_RCM_DATA2r_BUCKET_SIZEf_GET(r) ((((r).rcm_data2[0]) >> 15) & 0x7f)
#define BCM53262_A0_RCM_DATA2r_BUCKET_SIZEf_SET(r,f) (r).rcm_data2[0]=(((r).rcm_data2[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_RCM_DATA2r_IRC_PKT_MASK_B2f_GET(r) ((((r).rcm_data2[0]) >> 22) & 0x7f)
#define BCM53262_A0_RCM_DATA2r_IRC_PKT_MASK_B2f_SET(r,f) (r).rcm_data2[0]=(((r).rcm_data2[0] & ~((uint32_t)0x7f << 22)) | ((((uint32_t)f) & 0x7f) << 22))
#define BCM53262_A0_RCM_DATA2r_RESERVED_Rf_GET(r) ((((r).rcm_data2[0]) >> 29) & 0x7)
#define BCM53262_A0_RCM_DATA2r_RESERVED_Rf_SET(r,f) (r).rcm_data2[0]=(((r).rcm_data2[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access RCM_DATA2.
 */
#define BCM53262_A0_READ_RCM_DATA2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RCM_DATA2r,(r._rcm_data2),4)
#define BCM53262_A0_WRITE_RCM_DATA2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RCM_DATA2r,&(r._rcm_data2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RCM_DATA2r BCM53262_A0_RCM_DATA2r
#define RCM_DATA2r_SIZE BCM53262_A0_RCM_DATA2r_SIZE
typedef BCM53262_A0_RCM_DATA2r_t RCM_DATA2r_t;
#define RCM_DATA2r_CLR BCM53262_A0_RCM_DATA2r_CLR
#define RCM_DATA2r_SET BCM53262_A0_RCM_DATA2r_SET
#define RCM_DATA2r_GET BCM53262_A0_RCM_DATA2r_GET
#define RCM_DATA2r_REF_CNTSf_GET BCM53262_A0_RCM_DATA2r_REF_CNTSf_GET
#define RCM_DATA2r_REF_CNTSf_SET BCM53262_A0_RCM_DATA2r_REF_CNTSf_SET
#define RCM_DATA2r_REF_UNITf_GET BCM53262_A0_RCM_DATA2r_REF_UNITf_GET
#define RCM_DATA2r_REF_UNITf_SET BCM53262_A0_RCM_DATA2r_REF_UNITf_SET
#define RCM_DATA2r_BUCKET_SIZEf_GET BCM53262_A0_RCM_DATA2r_BUCKET_SIZEf_GET
#define RCM_DATA2r_BUCKET_SIZEf_SET BCM53262_A0_RCM_DATA2r_BUCKET_SIZEf_SET
#define RCM_DATA2r_IRC_PKT_MASK_B2f_GET BCM53262_A0_RCM_DATA2r_IRC_PKT_MASK_B2f_GET
#define RCM_DATA2r_IRC_PKT_MASK_B2f_SET BCM53262_A0_RCM_DATA2r_IRC_PKT_MASK_B2f_SET
#define RCM_DATA2r_RESERVED_Rf_GET BCM53262_A0_RCM_DATA2r_RESERVED_Rf_GET
#define RCM_DATA2r_RESERVED_Rf_SET BCM53262_A0_RCM_DATA2r_RESERVED_Rf_SET
#define READ_RCM_DATA2r BCM53262_A0_READ_RCM_DATA2r
#define WRITE_RCM_DATA2r BCM53262_A0_WRITE_RCM_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RCM_DATA2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RCM_DATA3
 * BLOCKS:   SYS
 * DESC:     Rate Control Memory Data REGISTER 3
 * SIZE:     32
 * FIELDS:
 *     REF_CNTS         Refresh Count, the desired rate.For Ingress Rate Control: RESERVEDFor Egress  Rate Control: (For Q2)
 *     REF_UNIT         0 for 62.5Kbps. 1 for 1Mbps.For Ingress Rate Control: RESERVEDFor Egress  Rate Control: (For Q2)
 *     BUCKET_SIZE      For Ingress Rate Control: RESERVEDFor Egress  Rate Control: Bucket Size, unit 8Kbytes. (For Q2)
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_RCM_DATA3r 0x0000431c

#define BCM53262_A0_RCM_DATA3r_SIZE 4

/*
 * This structure should be used to declare and program RCM_DATA3.
 */
typedef union BCM53262_A0_RCM_DATA3r_s {
	uint32_t v[1];
	uint32_t rcm_data3[1];
	uint32_t _rcm_data3;
} BCM53262_A0_RCM_DATA3r_t;

#define BCM53262_A0_RCM_DATA3r_CLR(r) (r).rcm_data3[0] = 0
#define BCM53262_A0_RCM_DATA3r_SET(r,d) (r).rcm_data3[0] = d
#define BCM53262_A0_RCM_DATA3r_GET(r) (r).rcm_data3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RCM_DATA3r_REF_CNTSf_GET(r) (((r).rcm_data3[0]) & 0x3fff)
#define BCM53262_A0_RCM_DATA3r_REF_CNTSf_SET(r,f) (r).rcm_data3[0]=(((r).rcm_data3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_RCM_DATA3r_REF_UNITf_GET(r) ((((r).rcm_data3[0]) >> 14) & 0x1)
#define BCM53262_A0_RCM_DATA3r_REF_UNITf_SET(r,f) (r).rcm_data3[0]=(((r).rcm_data3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_RCM_DATA3r_BUCKET_SIZEf_GET(r) ((((r).rcm_data3[0]) >> 15) & 0x7f)
#define BCM53262_A0_RCM_DATA3r_BUCKET_SIZEf_SET(r,f) (r).rcm_data3[0]=(((r).rcm_data3[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_RCM_DATA3r_RESERVED_Rf_GET(r) ((((r).rcm_data3[0]) >> 22) & 0x3ff)
#define BCM53262_A0_RCM_DATA3r_RESERVED_Rf_SET(r,f) (r).rcm_data3[0]=(((r).rcm_data3[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access RCM_DATA3.
 */
#define BCM53262_A0_READ_RCM_DATA3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RCM_DATA3r,(r._rcm_data3),4)
#define BCM53262_A0_WRITE_RCM_DATA3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RCM_DATA3r,&(r._rcm_data3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RCM_DATA3r BCM53262_A0_RCM_DATA3r
#define RCM_DATA3r_SIZE BCM53262_A0_RCM_DATA3r_SIZE
typedef BCM53262_A0_RCM_DATA3r_t RCM_DATA3r_t;
#define RCM_DATA3r_CLR BCM53262_A0_RCM_DATA3r_CLR
#define RCM_DATA3r_SET BCM53262_A0_RCM_DATA3r_SET
#define RCM_DATA3r_GET BCM53262_A0_RCM_DATA3r_GET
#define RCM_DATA3r_REF_CNTSf_GET BCM53262_A0_RCM_DATA3r_REF_CNTSf_GET
#define RCM_DATA3r_REF_CNTSf_SET BCM53262_A0_RCM_DATA3r_REF_CNTSf_SET
#define RCM_DATA3r_REF_UNITf_GET BCM53262_A0_RCM_DATA3r_REF_UNITf_GET
#define RCM_DATA3r_REF_UNITf_SET BCM53262_A0_RCM_DATA3r_REF_UNITf_SET
#define RCM_DATA3r_BUCKET_SIZEf_GET BCM53262_A0_RCM_DATA3r_BUCKET_SIZEf_GET
#define RCM_DATA3r_BUCKET_SIZEf_SET BCM53262_A0_RCM_DATA3r_BUCKET_SIZEf_SET
#define RCM_DATA3r_RESERVED_Rf_GET BCM53262_A0_RCM_DATA3r_RESERVED_Rf_GET
#define RCM_DATA3r_RESERVED_Rf_SET BCM53262_A0_RCM_DATA3r_RESERVED_Rf_SET
#define READ_RCM_DATA3r BCM53262_A0_READ_RCM_DATA3r
#define WRITE_RCM_DATA3r BCM53262_A0_WRITE_RCM_DATA3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RCM_DATA3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RCM_DATA4
 * BLOCKS:   SYS
 * DESC:     Rate Control Memory Data REGISTER 4
 * SIZE:     32
 * FIELDS:
 *     REF_CNTS         Refresh Count, the desired rate.For Ingress Rate Control: RESERVEDFor Egress  Rate Control: (For Q3)
 *     REF_UNIT         0 for 62.5Kbps. 1 for 1Mbps.For Ingress Rate Control: RESERVEDFor Egress  Rate Control: (For Q3)
 *     BUCKET_SIZE      For Ingress Rate Control: RESERVEDFor Egress  Rate Control: Bucket Size, unit 8Kbytes. (For Q3)
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_RCM_DATA4r 0x00004320

#define BCM53262_A0_RCM_DATA4r_SIZE 4

/*
 * This structure should be used to declare and program RCM_DATA4.
 */
typedef union BCM53262_A0_RCM_DATA4r_s {
	uint32_t v[1];
	uint32_t rcm_data4[1];
	uint32_t _rcm_data4;
} BCM53262_A0_RCM_DATA4r_t;

#define BCM53262_A0_RCM_DATA4r_CLR(r) (r).rcm_data4[0] = 0
#define BCM53262_A0_RCM_DATA4r_SET(r,d) (r).rcm_data4[0] = d
#define BCM53262_A0_RCM_DATA4r_GET(r) (r).rcm_data4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RCM_DATA4r_REF_CNTSf_GET(r) (((r).rcm_data4[0]) & 0x3fff)
#define BCM53262_A0_RCM_DATA4r_REF_CNTSf_SET(r,f) (r).rcm_data4[0]=(((r).rcm_data4[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53262_A0_RCM_DATA4r_REF_UNITf_GET(r) ((((r).rcm_data4[0]) >> 14) & 0x1)
#define BCM53262_A0_RCM_DATA4r_REF_UNITf_SET(r,f) (r).rcm_data4[0]=(((r).rcm_data4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_RCM_DATA4r_BUCKET_SIZEf_GET(r) ((((r).rcm_data4[0]) >> 15) & 0x7f)
#define BCM53262_A0_RCM_DATA4r_BUCKET_SIZEf_SET(r,f) (r).rcm_data4[0]=(((r).rcm_data4[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_RCM_DATA4r_RESERVED_Rf_GET(r) ((((r).rcm_data4[0]) >> 22) & 0x3ff)
#define BCM53262_A0_RCM_DATA4r_RESERVED_Rf_SET(r,f) (r).rcm_data4[0]=(((r).rcm_data4[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access RCM_DATA4.
 */
#define BCM53262_A0_READ_RCM_DATA4r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RCM_DATA4r,(r._rcm_data4),4)
#define BCM53262_A0_WRITE_RCM_DATA4r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RCM_DATA4r,&(r._rcm_data4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RCM_DATA4r BCM53262_A0_RCM_DATA4r
#define RCM_DATA4r_SIZE BCM53262_A0_RCM_DATA4r_SIZE
typedef BCM53262_A0_RCM_DATA4r_t RCM_DATA4r_t;
#define RCM_DATA4r_CLR BCM53262_A0_RCM_DATA4r_CLR
#define RCM_DATA4r_SET BCM53262_A0_RCM_DATA4r_SET
#define RCM_DATA4r_GET BCM53262_A0_RCM_DATA4r_GET
#define RCM_DATA4r_REF_CNTSf_GET BCM53262_A0_RCM_DATA4r_REF_CNTSf_GET
#define RCM_DATA4r_REF_CNTSf_SET BCM53262_A0_RCM_DATA4r_REF_CNTSf_SET
#define RCM_DATA4r_REF_UNITf_GET BCM53262_A0_RCM_DATA4r_REF_UNITf_GET
#define RCM_DATA4r_REF_UNITf_SET BCM53262_A0_RCM_DATA4r_REF_UNITf_SET
#define RCM_DATA4r_BUCKET_SIZEf_GET BCM53262_A0_RCM_DATA4r_BUCKET_SIZEf_GET
#define RCM_DATA4r_BUCKET_SIZEf_SET BCM53262_A0_RCM_DATA4r_BUCKET_SIZEf_SET
#define RCM_DATA4r_RESERVED_Rf_GET BCM53262_A0_RCM_DATA4r_RESERVED_Rf_GET
#define RCM_DATA4r_RESERVED_Rf_SET BCM53262_A0_RCM_DATA4r_RESERVED_Rf_SET
#define READ_RCM_DATA4r BCM53262_A0_READ_RCM_DATA4r
#define WRITE_RCM_DATA4r BCM53262_A0_WRITE_RCM_DATA4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RCM_DATA4r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RCM_PORT
 * BLOCKS:   SYS
 * DESC:     Rate Control Memory PORT Registers
 * SIZE:     8
 * FIELDS:
 *     RCM_PORT         Rate Control Memort Port NumberOnly 0x18 (PORT24) - 0x34 (PORT52) are valid
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_RCM_PORTr 0x00004301

#define BCM53262_A0_RCM_PORTr_SIZE 1

/*
 * This structure should be used to declare and program RCM_PORT.
 */
typedef union BCM53262_A0_RCM_PORTr_s {
	uint32_t v[1];
	uint32_t rcm_port[1];
	uint32_t _rcm_port;
} BCM53262_A0_RCM_PORTr_t;

#define BCM53262_A0_RCM_PORTr_CLR(r) (r).rcm_port[0] = 0
#define BCM53262_A0_RCM_PORTr_SET(r,d) (r).rcm_port[0] = d
#define BCM53262_A0_RCM_PORTr_GET(r) (r).rcm_port[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RCM_PORTr_RCM_PORTf_GET(r) (((r).rcm_port[0]) & 0x3f)
#define BCM53262_A0_RCM_PORTr_RCM_PORTf_SET(r,f) (r).rcm_port[0]=(((r).rcm_port[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_RCM_PORTr_RESERVED_Rf_GET(r) ((((r).rcm_port[0]) >> 6) & 0x3)
#define BCM53262_A0_RCM_PORTr_RESERVED_Rf_SET(r,f) (r).rcm_port[0]=(((r).rcm_port[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RCM_PORT.
 */
#define BCM53262_A0_READ_RCM_PORTr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RCM_PORTr,(r._rcm_port),1)
#define BCM53262_A0_WRITE_RCM_PORTr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RCM_PORTr,&(r._rcm_port),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RCM_PORTr BCM53262_A0_RCM_PORTr
#define RCM_PORTr_SIZE BCM53262_A0_RCM_PORTr_SIZE
typedef BCM53262_A0_RCM_PORTr_t RCM_PORTr_t;
#define RCM_PORTr_CLR BCM53262_A0_RCM_PORTr_CLR
#define RCM_PORTr_SET BCM53262_A0_RCM_PORTr_SET
#define RCM_PORTr_GET BCM53262_A0_RCM_PORTr_GET
#define RCM_PORTr_RCM_PORTf_GET BCM53262_A0_RCM_PORTr_RCM_PORTf_GET
#define RCM_PORTr_RCM_PORTf_SET BCM53262_A0_RCM_PORTr_RCM_PORTf_SET
#define RCM_PORTr_RESERVED_Rf_GET BCM53262_A0_RCM_PORTr_RESERVED_Rf_GET
#define RCM_PORTr_RESERVED_Rf_SET BCM53262_A0_RCM_PORTr_RESERVED_Rf_SET
#define READ_RCM_PORTr BCM53262_A0_READ_RCM_PORTr
#define WRITE_RCM_PORTr BCM53262_A0_WRITE_RCM_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RCM_PORTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RGMII_CTL_GP49
 * BLOCKS:   SYS
 * DESC:     Port 49 RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     RGMII_RX2NS_DELAY 
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_RGMII_CTL_GP49r 0x00000102

#define BCM53262_A0_RGMII_CTL_GP49r_SIZE 1

/*
 * This structure should be used to declare and program RGMII_CTL_GP49.
 */
typedef union BCM53262_A0_RGMII_CTL_GP49r_s {
	uint32_t v[1];
	uint32_t rgmii_ctl_gp49[1];
	uint32_t _rgmii_ctl_gp49;
} BCM53262_A0_RGMII_CTL_GP49r_t;

#define BCM53262_A0_RGMII_CTL_GP49r_CLR(r) (r).rgmii_ctl_gp49[0] = 0
#define BCM53262_A0_RGMII_CTL_GP49r_SET(r,d) (r).rgmii_ctl_gp49[0] = d
#define BCM53262_A0_RGMII_CTL_GP49r_GET(r) (r).rgmii_ctl_gp49[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RGMII_CTL_GP49r_RESERVED_0Rf_GET(r) (((r).rgmii_ctl_gp49[0]) & 0x1)
#define BCM53262_A0_RGMII_CTL_GP49r_RESERVED_0Rf_SET(r,f) (r).rgmii_ctl_gp49[0]=(((r).rgmii_ctl_gp49[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_RGMII_CTL_GP49r_RGMII_RX2NS_DELAYf_GET(r) ((((r).rgmii_ctl_gp49[0]) >> 1) & 0x1)
#define BCM53262_A0_RGMII_CTL_GP49r_RGMII_RX2NS_DELAYf_SET(r,f) (r).rgmii_ctl_gp49[0]=(((r).rgmii_ctl_gp49[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_RGMII_CTL_GP49r_RESERVED_1Rf_GET(r) ((((r).rgmii_ctl_gp49[0]) >> 2) & 0x3f)
#define BCM53262_A0_RGMII_CTL_GP49r_RESERVED_1Rf_SET(r,f) (r).rgmii_ctl_gp49[0]=(((r).rgmii_ctl_gp49[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access RGMII_CTL_GP49.
 */
#define BCM53262_A0_READ_RGMII_CTL_GP49r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RGMII_CTL_GP49r,(r._rgmii_ctl_gp49),1)
#define BCM53262_A0_WRITE_RGMII_CTL_GP49r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RGMII_CTL_GP49r,&(r._rgmii_ctl_gp49),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_CTL_GP49r BCM53262_A0_RGMII_CTL_GP49r
#define RGMII_CTL_GP49r_SIZE BCM53262_A0_RGMII_CTL_GP49r_SIZE
typedef BCM53262_A0_RGMII_CTL_GP49r_t RGMII_CTL_GP49r_t;
#define RGMII_CTL_GP49r_CLR BCM53262_A0_RGMII_CTL_GP49r_CLR
#define RGMII_CTL_GP49r_SET BCM53262_A0_RGMII_CTL_GP49r_SET
#define RGMII_CTL_GP49r_GET BCM53262_A0_RGMII_CTL_GP49r_GET
#define RGMII_CTL_GP49r_RESERVED_0Rf_GET BCM53262_A0_RGMII_CTL_GP49r_RESERVED_0Rf_GET
#define RGMII_CTL_GP49r_RESERVED_0Rf_SET BCM53262_A0_RGMII_CTL_GP49r_RESERVED_0Rf_SET
#define RGMII_CTL_GP49r_RGMII_RX2NS_DELAYf_GET BCM53262_A0_RGMII_CTL_GP49r_RGMII_RX2NS_DELAYf_GET
#define RGMII_CTL_GP49r_RGMII_RX2NS_DELAYf_SET BCM53262_A0_RGMII_CTL_GP49r_RGMII_RX2NS_DELAYf_SET
#define RGMII_CTL_GP49r_RESERVED_1Rf_GET BCM53262_A0_RGMII_CTL_GP49r_RESERVED_1Rf_GET
#define RGMII_CTL_GP49r_RESERVED_1Rf_SET BCM53262_A0_RGMII_CTL_GP49r_RESERVED_1Rf_SET
#define READ_RGMII_CTL_GP49r BCM53262_A0_READ_RGMII_CTL_GP49r
#define WRITE_RGMII_CTL_GP49r BCM53262_A0_WRITE_RGMII_CTL_GP49r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RGMII_CTL_GP49r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RGMII_CTL_GP50
 * BLOCKS:   SYS
 * DESC:     Port 50 RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     RGMII_RX2NS_DELAY 
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_RGMII_CTL_GP50r 0x00000103

#define BCM53262_A0_RGMII_CTL_GP50r_SIZE 1

/*
 * This structure should be used to declare and program RGMII_CTL_GP50.
 */
typedef union BCM53262_A0_RGMII_CTL_GP50r_s {
	uint32_t v[1];
	uint32_t rgmii_ctl_gp50[1];
	uint32_t _rgmii_ctl_gp50;
} BCM53262_A0_RGMII_CTL_GP50r_t;

#define BCM53262_A0_RGMII_CTL_GP50r_CLR(r) (r).rgmii_ctl_gp50[0] = 0
#define BCM53262_A0_RGMII_CTL_GP50r_SET(r,d) (r).rgmii_ctl_gp50[0] = d
#define BCM53262_A0_RGMII_CTL_GP50r_GET(r) (r).rgmii_ctl_gp50[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RGMII_CTL_GP50r_RESERVED_0Rf_GET(r) (((r).rgmii_ctl_gp50[0]) & 0x1)
#define BCM53262_A0_RGMII_CTL_GP50r_RESERVED_0Rf_SET(r,f) (r).rgmii_ctl_gp50[0]=(((r).rgmii_ctl_gp50[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_RGMII_CTL_GP50r_RGMII_RX2NS_DELAYf_GET(r) ((((r).rgmii_ctl_gp50[0]) >> 1) & 0x1)
#define BCM53262_A0_RGMII_CTL_GP50r_RGMII_RX2NS_DELAYf_SET(r,f) (r).rgmii_ctl_gp50[0]=(((r).rgmii_ctl_gp50[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_RGMII_CTL_GP50r_RESERVED_1Rf_GET(r) ((((r).rgmii_ctl_gp50[0]) >> 2) & 0x3f)
#define BCM53262_A0_RGMII_CTL_GP50r_RESERVED_1Rf_SET(r,f) (r).rgmii_ctl_gp50[0]=(((r).rgmii_ctl_gp50[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access RGMII_CTL_GP50.
 */
#define BCM53262_A0_READ_RGMII_CTL_GP50r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RGMII_CTL_GP50r,(r._rgmii_ctl_gp50),1)
#define BCM53262_A0_WRITE_RGMII_CTL_GP50r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RGMII_CTL_GP50r,&(r._rgmii_ctl_gp50),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_CTL_GP50r BCM53262_A0_RGMII_CTL_GP50r
#define RGMII_CTL_GP50r_SIZE BCM53262_A0_RGMII_CTL_GP50r_SIZE
typedef BCM53262_A0_RGMII_CTL_GP50r_t RGMII_CTL_GP50r_t;
#define RGMII_CTL_GP50r_CLR BCM53262_A0_RGMII_CTL_GP50r_CLR
#define RGMII_CTL_GP50r_SET BCM53262_A0_RGMII_CTL_GP50r_SET
#define RGMII_CTL_GP50r_GET BCM53262_A0_RGMII_CTL_GP50r_GET
#define RGMII_CTL_GP50r_RESERVED_0Rf_GET BCM53262_A0_RGMII_CTL_GP50r_RESERVED_0Rf_GET
#define RGMII_CTL_GP50r_RESERVED_0Rf_SET BCM53262_A0_RGMII_CTL_GP50r_RESERVED_0Rf_SET
#define RGMII_CTL_GP50r_RGMII_RX2NS_DELAYf_GET BCM53262_A0_RGMII_CTL_GP50r_RGMII_RX2NS_DELAYf_GET
#define RGMII_CTL_GP50r_RGMII_RX2NS_DELAYf_SET BCM53262_A0_RGMII_CTL_GP50r_RGMII_RX2NS_DELAYf_SET
#define RGMII_CTL_GP50r_RESERVED_1Rf_GET BCM53262_A0_RGMII_CTL_GP50r_RESERVED_1Rf_GET
#define RGMII_CTL_GP50r_RESERVED_1Rf_SET BCM53262_A0_RGMII_CTL_GP50r_RESERVED_1Rf_SET
#define READ_RGMII_CTL_GP50r BCM53262_A0_READ_RGMII_CTL_GP50r
#define WRITE_RGMII_CTL_GP50r BCM53262_A0_WRITE_RGMII_CTL_GP50r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RGMII_CTL_GP50r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RGMII_TIME_DLY_GP49
 * BLOCKS:   SYS
 * DESC:     GigaPort 0 RGMII Timing Delay Register
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : clk_rbco = 1'b14'b1101 : clk_rbc1 = 1'b1
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1. CPU over-write Enable, del_value and del_addr will affect the RGMII interface Timing adjustment.
 */
#define BCM53262_A0_RGMII_TIME_DLY_GP49r 0x00000100

#define BCM53262_A0_RGMII_TIME_DLY_GP49r_SIZE 1

/*
 * This structure should be used to declare and program RGMII_TIME_DLY_GP49.
 */
typedef union BCM53262_A0_RGMII_TIME_DLY_GP49r_s {
	uint32_t v[1];
	uint32_t rgmii_time_dly_gp49[1];
	uint32_t _rgmii_time_dly_gp49;
} BCM53262_A0_RGMII_TIME_DLY_GP49r_t;

#define BCM53262_A0_RGMII_TIME_DLY_GP49r_CLR(r) (r).rgmii_time_dly_gp49[0] = 0
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_SET(r,d) (r).rgmii_time_dly_gp49[0] = d
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_GET(r) (r).rgmii_time_dly_gp49[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_ADDRf_GET(r) (((r).rgmii_time_dly_gp49[0]) & 0xf)
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_ADDRf_SET(r,f) (r).rgmii_time_dly_gp49[0]=(((r).rgmii_time_dly_gp49[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_VALUEf_GET(r) ((((r).rgmii_time_dly_gp49[0]) >> 4) & 0x7)
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_VALUEf_SET(r,f) (r).rgmii_time_dly_gp49[0]=(((r).rgmii_time_dly_gp49[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_STRBf_GET(r) ((((r).rgmii_time_dly_gp49[0]) >> 7) & 0x1)
#define BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_STRBf_SET(r,f) (r).rgmii_time_dly_gp49[0]=(((r).rgmii_time_dly_gp49[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RGMII_TIME_DLY_GP49.
 */
#define BCM53262_A0_READ_RGMII_TIME_DLY_GP49r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RGMII_TIME_DLY_GP49r,(r._rgmii_time_dly_gp49),1)
#define BCM53262_A0_WRITE_RGMII_TIME_DLY_GP49r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RGMII_TIME_DLY_GP49r,&(r._rgmii_time_dly_gp49),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_TIME_DLY_GP49r BCM53262_A0_RGMII_TIME_DLY_GP49r
#define RGMII_TIME_DLY_GP49r_SIZE BCM53262_A0_RGMII_TIME_DLY_GP49r_SIZE
typedef BCM53262_A0_RGMII_TIME_DLY_GP49r_t RGMII_TIME_DLY_GP49r_t;
#define RGMII_TIME_DLY_GP49r_CLR BCM53262_A0_RGMII_TIME_DLY_GP49r_CLR
#define RGMII_TIME_DLY_GP49r_SET BCM53262_A0_RGMII_TIME_DLY_GP49r_SET
#define RGMII_TIME_DLY_GP49r_GET BCM53262_A0_RGMII_TIME_DLY_GP49r_GET
#define RGMII_TIME_DLY_GP49r_DEL_ADDRf_GET BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_ADDRf_GET
#define RGMII_TIME_DLY_GP49r_DEL_ADDRf_SET BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_ADDRf_SET
#define RGMII_TIME_DLY_GP49r_DEL_VALUEf_GET BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_VALUEf_GET
#define RGMII_TIME_DLY_GP49r_DEL_VALUEf_SET BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_VALUEf_SET
#define RGMII_TIME_DLY_GP49r_DEL_STRBf_GET BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_STRBf_GET
#define RGMII_TIME_DLY_GP49r_DEL_STRBf_SET BCM53262_A0_RGMII_TIME_DLY_GP49r_DEL_STRBf_SET
#define READ_RGMII_TIME_DLY_GP49r BCM53262_A0_READ_RGMII_TIME_DLY_GP49r
#define WRITE_RGMII_TIME_DLY_GP49r BCM53262_A0_WRITE_RGMII_TIME_DLY_GP49r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RGMII_TIME_DLY_GP49r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RGMII_TIME_DLY_GP50
 * BLOCKS:   SYS
 * DESC:     GigaPort 1 RGMII Timing Delay Register
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : clk_rbco = 1'b14'b1101 : clk_rbc1 = 1'b1
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1. CPU over-write Enable, del_value and del_addr will affect the RGMII interface Timing adjustment.
 */
#define BCM53262_A0_RGMII_TIME_DLY_GP50r 0x00000101

#define BCM53262_A0_RGMII_TIME_DLY_GP50r_SIZE 1

/*
 * This structure should be used to declare and program RGMII_TIME_DLY_GP50.
 */
typedef union BCM53262_A0_RGMII_TIME_DLY_GP50r_s {
	uint32_t v[1];
	uint32_t rgmii_time_dly_gp50[1];
	uint32_t _rgmii_time_dly_gp50;
} BCM53262_A0_RGMII_TIME_DLY_GP50r_t;

#define BCM53262_A0_RGMII_TIME_DLY_GP50r_CLR(r) (r).rgmii_time_dly_gp50[0] = 0
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_SET(r,d) (r).rgmii_time_dly_gp50[0] = d
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_GET(r) (r).rgmii_time_dly_gp50[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_ADDRf_GET(r) (((r).rgmii_time_dly_gp50[0]) & 0xf)
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_ADDRf_SET(r,f) (r).rgmii_time_dly_gp50[0]=(((r).rgmii_time_dly_gp50[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_VALUEf_GET(r) ((((r).rgmii_time_dly_gp50[0]) >> 4) & 0x7)
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_VALUEf_SET(r,f) (r).rgmii_time_dly_gp50[0]=(((r).rgmii_time_dly_gp50[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_STRBf_GET(r) ((((r).rgmii_time_dly_gp50[0]) >> 7) & 0x1)
#define BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_STRBf_SET(r,f) (r).rgmii_time_dly_gp50[0]=(((r).rgmii_time_dly_gp50[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RGMII_TIME_DLY_GP50.
 */
#define BCM53262_A0_READ_RGMII_TIME_DLY_GP50r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RGMII_TIME_DLY_GP50r,(r._rgmii_time_dly_gp50),1)
#define BCM53262_A0_WRITE_RGMII_TIME_DLY_GP50r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RGMII_TIME_DLY_GP50r,&(r._rgmii_time_dly_gp50),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_TIME_DLY_GP50r BCM53262_A0_RGMII_TIME_DLY_GP50r
#define RGMII_TIME_DLY_GP50r_SIZE BCM53262_A0_RGMII_TIME_DLY_GP50r_SIZE
typedef BCM53262_A0_RGMII_TIME_DLY_GP50r_t RGMII_TIME_DLY_GP50r_t;
#define RGMII_TIME_DLY_GP50r_CLR BCM53262_A0_RGMII_TIME_DLY_GP50r_CLR
#define RGMII_TIME_DLY_GP50r_SET BCM53262_A0_RGMII_TIME_DLY_GP50r_SET
#define RGMII_TIME_DLY_GP50r_GET BCM53262_A0_RGMII_TIME_DLY_GP50r_GET
#define RGMII_TIME_DLY_GP50r_DEL_ADDRf_GET BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_ADDRf_GET
#define RGMII_TIME_DLY_GP50r_DEL_ADDRf_SET BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_ADDRf_SET
#define RGMII_TIME_DLY_GP50r_DEL_VALUEf_GET BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_VALUEf_GET
#define RGMII_TIME_DLY_GP50r_DEL_VALUEf_SET BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_VALUEf_SET
#define RGMII_TIME_DLY_GP50r_DEL_STRBf_GET BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_STRBf_GET
#define RGMII_TIME_DLY_GP50r_DEL_STRBf_SET BCM53262_A0_RGMII_TIME_DLY_GP50r_DEL_STRBf_SET
#define READ_RGMII_TIME_DLY_GP50r BCM53262_A0_READ_RGMII_TIME_DLY_GP50r
#define WRITE_RGMII_TIME_DLY_GP50r BCM53262_A0_WRITE_RGMII_TIME_DLY_GP50r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RGMII_TIME_DLY_GP50r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RMONSTEER
 * BLOCKS:   SYS
 * DESC:     RMON MIB Steering Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     OR_RMON_RCV      Override RMON ReceiveForces the RMON packet size "bucket" counters from the normal default of snooping on the receive side of the MAC, to the transmit side. This allows the RMON "bucket" counters to snoop either transmit or receive, allowing full duplex MAC support.0-47: 10/100BASE-T Ports48: IMP Port.49: Giga port g050: Giga port g151: Giga port g252: Giga port g3
 *     MNSTR_RSRV0      Reserved
 */
#define BCM53262_A0_RMONSTEERr 0x00000308

#define BCM53262_A0_RMONSTEERr_SIZE 8

/*
 * This structure should be used to declare and program RMONSTEER.
 */
typedef union BCM53262_A0_RMONSTEERr_s {
	uint32_t v[2];
	uint32_t rmonsteer[2];
	uint32_t _rmonsteer;
} BCM53262_A0_RMONSTEERr_t;

#define BCM53262_A0_RMONSTEERr_CLR(r) CDK_MEMSET(&((r)._rmonsteer), 0, sizeof(BCM53262_A0_RMONSTEERr_t))
#define BCM53262_A0_RMONSTEERr_SET(r,i,d) (r).rmonsteer[i] = d
#define BCM53262_A0_RMONSTEERr_GET(r,i) (r).rmonsteer[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RMONSTEERr_RESERVED_Rf_GET(r) (((r).rmonsteer[0]) & 0xffffff)
#define BCM53262_A0_RMONSTEERr_RESERVED_Rf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_RMONSTEERr_OR_RMON_RCVf_GET(r) cdk_field32_get((r).rmonsteer,24,52)
#define BCM53262_A0_RMONSTEERr_OR_RMON_RCVf_SET(r,f) cdk_field32_set((r).rmonsteer,24,52,f)
#define BCM53262_A0_RMONSTEERr_MNSTR_RSRV0f_GET(r) ((((r).rmonsteer[1]) >> 21) & 0x7ff)
#define BCM53262_A0_RMONSTEERr_MNSTR_RSRV0f_SET(r,f) (r).rmonsteer[1]=(((r).rmonsteer[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access RMONSTEER.
 */
#define BCM53262_A0_READ_RMONSTEERr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RMONSTEERr,(r._rmonsteer),8)
#define BCM53262_A0_WRITE_RMONSTEERr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RMONSTEERr,&(r._rmonsteer),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RMONSTEERr BCM53262_A0_RMONSTEERr
#define RMONSTEERr_SIZE BCM53262_A0_RMONSTEERr_SIZE
typedef BCM53262_A0_RMONSTEERr_t RMONSTEERr_t;
#define RMONSTEERr_CLR BCM53262_A0_RMONSTEERr_CLR
#define RMONSTEERr_SET BCM53262_A0_RMONSTEERr_SET
#define RMONSTEERr_GET BCM53262_A0_RMONSTEERr_GET
#define RMONSTEERr_RESERVED_Rf_GET BCM53262_A0_RMONSTEERr_RESERVED_Rf_GET
#define RMONSTEERr_RESERVED_Rf_SET BCM53262_A0_RMONSTEERr_RESERVED_Rf_SET
#define RMONSTEERr_OR_RMON_RCVf_GET BCM53262_A0_RMONSTEERr_OR_RMON_RCVf_GET
#define RMONSTEERr_OR_RMON_RCVf_SET BCM53262_A0_RMONSTEERr_OR_RMON_RCVf_SET
#define RMONSTEERr_MNSTR_RSRV0f_GET BCM53262_A0_RMONSTEERr_MNSTR_RSRV0f_GET
#define RMONSTEERr_MNSTR_RSRV0f_SET BCM53262_A0_RMONSTEERr_MNSTR_RSRV0f_SET
#define READ_RMONSTEERr BCM53262_A0_READ_RMONSTEERr
#define WRITE_RMONSTEERr BCM53262_A0_WRITE_RMONSTEERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RMONSTEERr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RST_TABLE_MEM
 * BLOCKS:   SYS
 * DESC:     Table Memory Reset Control Register
 * SIZE:     8
 * FIELDS:
 *     RST_MIB_CNT      Reset MIB Counter.Default : 1'b0.Set to 1'b1 to reset all MIB counter to zero.When finished, it will be reset to 1'b0.
 *     RST_ARL          Reset ARL Table.Default : 1'b0.Set to 1'b1 to reset L2 ARL Table to zero.When finished, it will be reset to 1'b0.
 *     RST_VT           Reset VLAN Table.Default : 1'b0.Set to 1'b1 to reset VLAN Table to zero.When finished, it will be reset to 1'b0.
 *     RST_IPMC         Reset L2 Multicast Table.Default : 1'b0.Set to 1'b1 to reset L2 Multicast Table to zero.When finished, it will be reset to 1'b0.
 *     RST_MSPT         Reset Multiple Spanning Tree Table.Default : 1'b0.Set to 1'b1 to reset Multiple Spanning Tree Table to zero.When finished, it will be reset to 1'b0.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_RST_TABLE_MEMr 0x00000301

#define BCM53262_A0_RST_TABLE_MEMr_SIZE 1

/*
 * This structure should be used to declare and program RST_TABLE_MEM.
 */
typedef union BCM53262_A0_RST_TABLE_MEMr_s {
	uint32_t v[1];
	uint32_t rst_table_mem[1];
	uint32_t _rst_table_mem;
} BCM53262_A0_RST_TABLE_MEMr_t;

#define BCM53262_A0_RST_TABLE_MEMr_CLR(r) (r).rst_table_mem[0] = 0
#define BCM53262_A0_RST_TABLE_MEMr_SET(r,d) (r).rst_table_mem[0] = d
#define BCM53262_A0_RST_TABLE_MEMr_GET(r) (r).rst_table_mem[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RST_TABLE_MEMr_RST_MIB_CNTf_GET(r) (((r).rst_table_mem[0]) & 0x1)
#define BCM53262_A0_RST_TABLE_MEMr_RST_MIB_CNTf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_RST_TABLE_MEMr_RST_ARLf_GET(r) ((((r).rst_table_mem[0]) >> 1) & 0x1)
#define BCM53262_A0_RST_TABLE_MEMr_RST_ARLf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_RST_TABLE_MEMr_RST_VTf_GET(r) ((((r).rst_table_mem[0]) >> 2) & 0x1)
#define BCM53262_A0_RST_TABLE_MEMr_RST_VTf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_RST_TABLE_MEMr_RST_IPMCf_GET(r) ((((r).rst_table_mem[0]) >> 3) & 0x1)
#define BCM53262_A0_RST_TABLE_MEMr_RST_IPMCf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_RST_TABLE_MEMr_RST_MSPTf_GET(r) ((((r).rst_table_mem[0]) >> 4) & 0x1)
#define BCM53262_A0_RST_TABLE_MEMr_RST_MSPTf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_RST_TABLE_MEMr_RESERVED_Rf_GET(r) ((((r).rst_table_mem[0]) >> 5) & 0x7)
#define BCM53262_A0_RST_TABLE_MEMr_RESERVED_Rf_SET(r,f) (r).rst_table_mem[0]=(((r).rst_table_mem[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access RST_TABLE_MEM.
 */
#define BCM53262_A0_READ_RST_TABLE_MEMr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RST_TABLE_MEMr,(r._rst_table_mem),1)
#define BCM53262_A0_WRITE_RST_TABLE_MEMr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RST_TABLE_MEMr,&(r._rst_table_mem),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RST_TABLE_MEMr BCM53262_A0_RST_TABLE_MEMr
#define RST_TABLE_MEMr_SIZE BCM53262_A0_RST_TABLE_MEMr_SIZE
typedef BCM53262_A0_RST_TABLE_MEMr_t RST_TABLE_MEMr_t;
#define RST_TABLE_MEMr_CLR BCM53262_A0_RST_TABLE_MEMr_CLR
#define RST_TABLE_MEMr_SET BCM53262_A0_RST_TABLE_MEMr_SET
#define RST_TABLE_MEMr_GET BCM53262_A0_RST_TABLE_MEMr_GET
#define RST_TABLE_MEMr_RST_MIB_CNTf_GET BCM53262_A0_RST_TABLE_MEMr_RST_MIB_CNTf_GET
#define RST_TABLE_MEMr_RST_MIB_CNTf_SET BCM53262_A0_RST_TABLE_MEMr_RST_MIB_CNTf_SET
#define RST_TABLE_MEMr_RST_ARLf_GET BCM53262_A0_RST_TABLE_MEMr_RST_ARLf_GET
#define RST_TABLE_MEMr_RST_ARLf_SET BCM53262_A0_RST_TABLE_MEMr_RST_ARLf_SET
#define RST_TABLE_MEMr_RST_VTf_GET BCM53262_A0_RST_TABLE_MEMr_RST_VTf_GET
#define RST_TABLE_MEMr_RST_VTf_SET BCM53262_A0_RST_TABLE_MEMr_RST_VTf_SET
#define RST_TABLE_MEMr_RST_IPMCf_GET BCM53262_A0_RST_TABLE_MEMr_RST_IPMCf_GET
#define RST_TABLE_MEMr_RST_IPMCf_SET BCM53262_A0_RST_TABLE_MEMr_RST_IPMCf_SET
#define RST_TABLE_MEMr_RST_MSPTf_GET BCM53262_A0_RST_TABLE_MEMr_RST_MSPTf_GET
#define RST_TABLE_MEMr_RST_MSPTf_SET BCM53262_A0_RST_TABLE_MEMr_RST_MSPTf_SET
#define RST_TABLE_MEMr_RESERVED_Rf_GET BCM53262_A0_RST_TABLE_MEMr_RESERVED_Rf_GET
#define RST_TABLE_MEMr_RESERVED_Rf_SET BCM53262_A0_RST_TABLE_MEMr_RESERVED_Rf_SET
#define READ_RST_TABLE_MEMr BCM53262_A0_READ_RST_TABLE_MEMr
#define WRITE_RST_TABLE_MEMr BCM53262_A0_WRITE_RST_TABLE_MEMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RST_TABLE_MEMr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RST_TABLE_MEM1
 * BLOCKS:   SYS
 * DESC:     Reset Table Memory 1 Register
 * SIZE:     8
 * FIELDS:
 *     RST_VLAN2VLAN    Set to 1'b1 to reset vlan-based VLAN table.
 *     RST_MAC2VLAN     Set to 1'b1 to reset mac-based VLAN table.
 *     RST_PROTOCOL2VLAN Set to 1'b1 to reset protocol-based VLAN table.
 *     RST_FLOW2VLAN    Set to 1'b1 to reset flow-based VLAN table.
 *     RST_IRC_MEM      Set to 1'b1 to reset port-based ingress rate control configuration memory.
 *     RST_ERC_MEM      Set to 1'b1 to reset port-based egress rate control configuration memory.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_RST_TABLE_MEM1r 0x00000303

#define BCM53262_A0_RST_TABLE_MEM1r_SIZE 1

/*
 * This structure should be used to declare and program RST_TABLE_MEM1.
 */
typedef union BCM53262_A0_RST_TABLE_MEM1r_s {
	uint32_t v[1];
	uint32_t rst_table_mem1[1];
	uint32_t _rst_table_mem1;
} BCM53262_A0_RST_TABLE_MEM1r_t;

#define BCM53262_A0_RST_TABLE_MEM1r_CLR(r) (r).rst_table_mem1[0] = 0
#define BCM53262_A0_RST_TABLE_MEM1r_SET(r,d) (r).rst_table_mem1[0] = d
#define BCM53262_A0_RST_TABLE_MEM1r_GET(r) (r).rst_table_mem1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RST_TABLE_MEM1r_RST_VLAN2VLANf_GET(r) (((r).rst_table_mem1[0]) & 0x1)
#define BCM53262_A0_RST_TABLE_MEM1r_RST_VLAN2VLANf_SET(r,f) (r).rst_table_mem1[0]=(((r).rst_table_mem1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_RST_TABLE_MEM1r_RST_MAC2VLANf_GET(r) ((((r).rst_table_mem1[0]) >> 1) & 0x1)
#define BCM53262_A0_RST_TABLE_MEM1r_RST_MAC2VLANf_SET(r,f) (r).rst_table_mem1[0]=(((r).rst_table_mem1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_RST_TABLE_MEM1r_RST_PROTOCOL2VLANf_GET(r) ((((r).rst_table_mem1[0]) >> 2) & 0x1)
#define BCM53262_A0_RST_TABLE_MEM1r_RST_PROTOCOL2VLANf_SET(r,f) (r).rst_table_mem1[0]=(((r).rst_table_mem1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_RST_TABLE_MEM1r_RST_FLOW2VLANf_GET(r) ((((r).rst_table_mem1[0]) >> 3) & 0x1)
#define BCM53262_A0_RST_TABLE_MEM1r_RST_FLOW2VLANf_SET(r,f) (r).rst_table_mem1[0]=(((r).rst_table_mem1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_RST_TABLE_MEM1r_RST_IRC_MEMf_GET(r) ((((r).rst_table_mem1[0]) >> 4) & 0x1)
#define BCM53262_A0_RST_TABLE_MEM1r_RST_IRC_MEMf_SET(r,f) (r).rst_table_mem1[0]=(((r).rst_table_mem1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_RST_TABLE_MEM1r_RST_ERC_MEMf_GET(r) ((((r).rst_table_mem1[0]) >> 5) & 0x1)
#define BCM53262_A0_RST_TABLE_MEM1r_RST_ERC_MEMf_SET(r,f) (r).rst_table_mem1[0]=(((r).rst_table_mem1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_RST_TABLE_MEM1r_RESERVED_Rf_GET(r) ((((r).rst_table_mem1[0]) >> 6) & 0x3)
#define BCM53262_A0_RST_TABLE_MEM1r_RESERVED_Rf_SET(r,f) (r).rst_table_mem1[0]=(((r).rst_table_mem1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RST_TABLE_MEM1.
 */
#define BCM53262_A0_READ_RST_TABLE_MEM1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_RST_TABLE_MEM1r,(r._rst_table_mem1),1)
#define BCM53262_A0_WRITE_RST_TABLE_MEM1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_RST_TABLE_MEM1r,&(r._rst_table_mem1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RST_TABLE_MEM1r BCM53262_A0_RST_TABLE_MEM1r
#define RST_TABLE_MEM1r_SIZE BCM53262_A0_RST_TABLE_MEM1r_SIZE
typedef BCM53262_A0_RST_TABLE_MEM1r_t RST_TABLE_MEM1r_t;
#define RST_TABLE_MEM1r_CLR BCM53262_A0_RST_TABLE_MEM1r_CLR
#define RST_TABLE_MEM1r_SET BCM53262_A0_RST_TABLE_MEM1r_SET
#define RST_TABLE_MEM1r_GET BCM53262_A0_RST_TABLE_MEM1r_GET
#define RST_TABLE_MEM1r_RST_VLAN2VLANf_GET BCM53262_A0_RST_TABLE_MEM1r_RST_VLAN2VLANf_GET
#define RST_TABLE_MEM1r_RST_VLAN2VLANf_SET BCM53262_A0_RST_TABLE_MEM1r_RST_VLAN2VLANf_SET
#define RST_TABLE_MEM1r_RST_MAC2VLANf_GET BCM53262_A0_RST_TABLE_MEM1r_RST_MAC2VLANf_GET
#define RST_TABLE_MEM1r_RST_MAC2VLANf_SET BCM53262_A0_RST_TABLE_MEM1r_RST_MAC2VLANf_SET
#define RST_TABLE_MEM1r_RST_PROTOCOL2VLANf_GET BCM53262_A0_RST_TABLE_MEM1r_RST_PROTOCOL2VLANf_GET
#define RST_TABLE_MEM1r_RST_PROTOCOL2VLANf_SET BCM53262_A0_RST_TABLE_MEM1r_RST_PROTOCOL2VLANf_SET
#define RST_TABLE_MEM1r_RST_FLOW2VLANf_GET BCM53262_A0_RST_TABLE_MEM1r_RST_FLOW2VLANf_GET
#define RST_TABLE_MEM1r_RST_FLOW2VLANf_SET BCM53262_A0_RST_TABLE_MEM1r_RST_FLOW2VLANf_SET
#define RST_TABLE_MEM1r_RST_IRC_MEMf_GET BCM53262_A0_RST_TABLE_MEM1r_RST_IRC_MEMf_GET
#define RST_TABLE_MEM1r_RST_IRC_MEMf_SET BCM53262_A0_RST_TABLE_MEM1r_RST_IRC_MEMf_SET
#define RST_TABLE_MEM1r_RST_ERC_MEMf_GET BCM53262_A0_RST_TABLE_MEM1r_RST_ERC_MEMf_GET
#define RST_TABLE_MEM1r_RST_ERC_MEMf_SET BCM53262_A0_RST_TABLE_MEM1r_RST_ERC_MEMf_SET
#define RST_TABLE_MEM1r_RESERVED_Rf_GET BCM53262_A0_RST_TABLE_MEM1r_RESERVED_Rf_GET
#define RST_TABLE_MEM1r_RESERVED_Rf_SET BCM53262_A0_RST_TABLE_MEM1r_RESERVED_Rf_SET
#define READ_RST_TABLE_MEM1r BCM53262_A0_READ_RST_TABLE_MEM1r
#define WRITE_RST_TABLE_MEM1r BCM53262_A0_WRITE_RST_TABLE_MEM1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RST_TABLE_MEM1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RXSymblErr
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXSYMBLERRr 0x000068c4

#define BCM53262_A0_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr.
 */
typedef union BCM53262_A0_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t rxsymblerr[1];
	uint32_t _rxsymblerr;
} BCM53262_A0_RXSYMBLERRr_t;

#define BCM53262_A0_RXSYMBLERRr_CLR(r) (r).rxsymblerr[0] = 0
#define BCM53262_A0_RXSYMBLERRr_SET(r,d) (r).rxsymblerr[0] = d
#define BCM53262_A0_RXSYMBLERRr_GET(r) (r).rxsymblerr[0]


/*
 * These macros can be used to access RXSymblErr.
 */
#define BCM53262_A0_READ_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXSYMBLERRr,(r._rxsymblerr),4)
#define BCM53262_A0_WRITE_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXSYMBLERRr,&(r._rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERRr BCM53262_A0_RXSYMBLERRr
#define RXSYMBLERRr_SIZE BCM53262_A0_RXSYMBLERRr_SIZE
typedef BCM53262_A0_RXSYMBLERRr_t RXSYMBLERRr_t;
#define RXSYMBLERRr_CLR BCM53262_A0_RXSYMBLERRr_CLR
#define RXSYMBLERRr_SET BCM53262_A0_RXSYMBLERRr_SET
#define RXSYMBLERRr_GET BCM53262_A0_RXSYMBLERRr_GET
#define READ_RXSYMBLERRr BCM53262_A0_READ_RXSYMBLERRr
#define WRITE_RXSYMBLERRr BCM53262_A0_WRITE_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXSYMBLERRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for RX Registrer
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     RX_PAUSE_PASS    Ignore RX pause through map.1 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_RX_PAUSE_PASSr 0x00000090

#define BCM53262_A0_RX_PAUSE_PASSr_SIZE 8

/*
 * This structure should be used to declare and program RX_PAUSE_PASS.
 */
typedef union BCM53262_A0_RX_PAUSE_PASSr_s {
	uint32_t v[2];
	uint32_t rx_pause_pass[2];
	uint32_t _rx_pause_pass;
} BCM53262_A0_RX_PAUSE_PASSr_t;

#define BCM53262_A0_RX_PAUSE_PASSr_CLR(r) CDK_MEMSET(&((r)._rx_pause_pass), 0, sizeof(BCM53262_A0_RX_PAUSE_PASSr_t))
#define BCM53262_A0_RX_PAUSE_PASSr_SET(r,i,d) (r).rx_pause_pass[i] = d
#define BCM53262_A0_RX_PAUSE_PASSr_GET(r,i) (r).rx_pause_pass[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_RX_PAUSE_PASSr_RESERVED_0Rf_GET(r) (((r).rx_pause_pass[0]) & 0xffffff)
#define BCM53262_A0_RX_PAUSE_PASSr_RESERVED_0Rf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET(r) cdk_field32_get((r).rx_pause_pass,24,52)
#define BCM53262_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET(r,f) cdk_field32_set((r).rx_pause_pass,24,52,f)
#define BCM53262_A0_RX_PAUSE_PASSr_RESERVED_1Rf_GET(r) ((((r).rx_pause_pass[1]) >> 21) & 0x7ff)
#define BCM53262_A0_RX_PAUSE_PASSr_RESERVED_1Rf_SET(r,f) (r).rx_pause_pass[1]=(((r).rx_pause_pass[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access RX_PAUSE_PASS.
 */
#define BCM53262_A0_READ_RX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_RX_PAUSE_PASSr,(r._rx_pause_pass),8)
#define BCM53262_A0_WRITE_RX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_RX_PAUSE_PASSr,&(r._rx_pause_pass),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PAUSE_PASSr BCM53262_A0_RX_PAUSE_PASSr
#define RX_PAUSE_PASSr_SIZE BCM53262_A0_RX_PAUSE_PASSr_SIZE
typedef BCM53262_A0_RX_PAUSE_PASSr_t RX_PAUSE_PASSr_t;
#define RX_PAUSE_PASSr_CLR BCM53262_A0_RX_PAUSE_PASSr_CLR
#define RX_PAUSE_PASSr_SET BCM53262_A0_RX_PAUSE_PASSr_SET
#define RX_PAUSE_PASSr_GET BCM53262_A0_RX_PAUSE_PASSr_GET
#define RX_PAUSE_PASSr_RESERVED_0Rf_GET BCM53262_A0_RX_PAUSE_PASSr_RESERVED_0Rf_GET
#define RX_PAUSE_PASSr_RESERVED_0Rf_SET BCM53262_A0_RX_PAUSE_PASSr_RESERVED_0Rf_SET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET BCM53262_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET BCM53262_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET
#define RX_PAUSE_PASSr_RESERVED_1Rf_GET BCM53262_A0_RX_PAUSE_PASSr_RESERVED_1Rf_GET
#define RX_PAUSE_PASSr_RESERVED_1Rf_SET BCM53262_A0_RX_PAUSE_PASSr_RESERVED_1Rf_SET
#define READ_RX_PAUSE_PASSr BCM53262_A0_READ_RX_PAUSE_PASSr
#define WRITE_RX_PAUSE_PASSr BCM53262_A0_WRITE_RX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RX_PAUSE_PASSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxAlignmentErrors
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXALIGNMENTERRORSr 0x00006898

#define BCM53262_A0_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors.
 */
typedef union BCM53262_A0_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors[1];
	uint32_t _rxalignmenterrors;
} BCM53262_A0_RXALIGNMENTERRORSr_t;

#define BCM53262_A0_RXALIGNMENTERRORSr_CLR(r) (r).rxalignmenterrors[0] = 0
#define BCM53262_A0_RXALIGNMENTERRORSr_SET(r,d) (r).rxalignmenterrors[0] = d
#define BCM53262_A0_RXALIGNMENTERRORSr_GET(r) (r).rxalignmenterrors[0]


/*
 * These macros can be used to access RxAlignmentErrors.
 */
#define BCM53262_A0_READ_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXALIGNMENTERRORSr,(r._rxalignmenterrors),4)
#define BCM53262_A0_WRITE_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXALIGNMENTERRORSr,&(r._rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORSr BCM53262_A0_RXALIGNMENTERRORSr
#define RXALIGNMENTERRORSr_SIZE BCM53262_A0_RXALIGNMENTERRORSr_SIZE
typedef BCM53262_A0_RXALIGNMENTERRORSr_t RXALIGNMENTERRORSr_t;
#define RXALIGNMENTERRORSr_CLR BCM53262_A0_RXALIGNMENTERRORSr_CLR
#define RXALIGNMENTERRORSr_SET BCM53262_A0_RXALIGNMENTERRORSr_SET
#define RXALIGNMENTERRORSr_GET BCM53262_A0_RXALIGNMENTERRORSr_GET
#define READ_RXALIGNMENTERRORSr BCM53262_A0_READ_RXALIGNMENTERRORSr
#define WRITE_RXALIGNMENTERRORSr BCM53262_A0_WRITE_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXALIGNMENTERRORSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxBroadcastPkt
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXBROADCASTPKTr 0x000068b4

#define BCM53262_A0_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkt.
 */
typedef union BCM53262_A0_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkt[1];
	uint32_t _rxbroadcastpkt;
} BCM53262_A0_RXBROADCASTPKTr_t;

#define BCM53262_A0_RXBROADCASTPKTr_CLR(r) (r).rxbroadcastpkt[0] = 0
#define BCM53262_A0_RXBROADCASTPKTr_SET(r,d) (r).rxbroadcastpkt[0] = d
#define BCM53262_A0_RXBROADCASTPKTr_GET(r) (r).rxbroadcastpkt[0]


/*
 * These macros can be used to access RxBroadcastPkt.
 */
#define BCM53262_A0_READ_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXBROADCASTPKTr,(r._rxbroadcastpkt),4)
#define BCM53262_A0_WRITE_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXBROADCASTPKTr,&(r._rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTr BCM53262_A0_RXBROADCASTPKTr
#define RXBROADCASTPKTr_SIZE BCM53262_A0_RXBROADCASTPKTr_SIZE
typedef BCM53262_A0_RXBROADCASTPKTr_t RXBROADCASTPKTr_t;
#define RXBROADCASTPKTr_CLR BCM53262_A0_RXBROADCASTPKTr_CLR
#define RXBROADCASTPKTr_SET BCM53262_A0_RXBROADCASTPKTr_SET
#define RXBROADCASTPKTr_GET BCM53262_A0_RXBROADCASTPKTr_GET
#define READ_RXBROADCASTPKTr BCM53262_A0_READ_RXBROADCASTPKTr
#define WRITE_RXBROADCASTPKTr BCM53262_A0_WRITE_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXBROADCASTPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxDropPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXDROPPKTSr 0x000068a8

#define BCM53262_A0_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts.
 */
typedef union BCM53262_A0_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t rxdroppkts[1];
	uint32_t _rxdroppkts;
} BCM53262_A0_RXDROPPKTSr_t;

#define BCM53262_A0_RXDROPPKTSr_CLR(r) (r).rxdroppkts[0] = 0
#define BCM53262_A0_RXDROPPKTSr_SET(r,d) (r).rxdroppkts[0] = d
#define BCM53262_A0_RXDROPPKTSr_GET(r) (r).rxdroppkts[0]


/*
 * These macros can be used to access RxDropPkts.
 */
#define BCM53262_A0_READ_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXDROPPKTSr,(r._rxdroppkts),4)
#define BCM53262_A0_WRITE_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXDROPPKTSr,&(r._rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTSr BCM53262_A0_RXDROPPKTSr
#define RXDROPPKTSr_SIZE BCM53262_A0_RXDROPPKTSr_SIZE
typedef BCM53262_A0_RXDROPPKTSr_t RXDROPPKTSr_t;
#define RXDROPPKTSr_CLR BCM53262_A0_RXDROPPKTSr_CLR
#define RXDROPPKTSr_SET BCM53262_A0_RXDROPPKTSr_SET
#define RXDROPPKTSr_GET BCM53262_A0_RXDROPPKTSr_GET
#define READ_RXDROPPKTSr BCM53262_A0_READ_RXDROPPKTSr
#define WRITE_RXDROPPKTSr BCM53262_A0_WRITE_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXDROPPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxExcessSizeDisc
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Excess Size Disc Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXEXCESSSIZEDISCr 0x000068c0

#define BCM53262_A0_RXEXCESSSIZEDISCr_SIZE 4

/*
 * This structure should be used to declare and program RxExcessSizeDisc.
 */
typedef union BCM53262_A0_RXEXCESSSIZEDISCr_s {
	uint32_t v[1];
	uint32_t rxexcesssizedisc[1];
	uint32_t _rxexcesssizedisc;
} BCM53262_A0_RXEXCESSSIZEDISCr_t;

#define BCM53262_A0_RXEXCESSSIZEDISCr_CLR(r) (r).rxexcesssizedisc[0] = 0
#define BCM53262_A0_RXEXCESSSIZEDISCr_SET(r,d) (r).rxexcesssizedisc[0] = d
#define BCM53262_A0_RXEXCESSSIZEDISCr_GET(r) (r).rxexcesssizedisc[0]


/*
 * These macros can be used to access RxExcessSizeDisc.
 */
#define BCM53262_A0_READ_RXEXCESSSIZEDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXEXCESSSIZEDISCr,(r._rxexcesssizedisc),4)
#define BCM53262_A0_WRITE_RXEXCESSSIZEDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXEXCESSSIZEDISCr,&(r._rxexcesssizedisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXEXCESSSIZEDISCr BCM53262_A0_RXEXCESSSIZEDISCr
#define RXEXCESSSIZEDISCr_SIZE BCM53262_A0_RXEXCESSSIZEDISCr_SIZE
typedef BCM53262_A0_RXEXCESSSIZEDISCr_t RXEXCESSSIZEDISCr_t;
#define RXEXCESSSIZEDISCr_CLR BCM53262_A0_RXEXCESSSIZEDISCr_CLR
#define RXEXCESSSIZEDISCr_SET BCM53262_A0_RXEXCESSSIZEDISCr_SET
#define RXEXCESSSIZEDISCr_GET BCM53262_A0_RXEXCESSSIZEDISCr_GET
#define READ_RXEXCESSSIZEDISCr BCM53262_A0_READ_RXEXCESSSIZEDISCr
#define WRITE_RXEXCESSSIZEDISCr BCM53262_A0_WRITE_RXEXCESSSIZEDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXEXCESSSIZEDISCr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxFCSErrors
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXFCSERRORSr 0x0000689c

#define BCM53262_A0_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors.
 */
typedef union BCM53262_A0_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t rxfcserrors[1];
	uint32_t _rxfcserrors;
} BCM53262_A0_RXFCSERRORSr_t;

#define BCM53262_A0_RXFCSERRORSr_CLR(r) (r).rxfcserrors[0] = 0
#define BCM53262_A0_RXFCSERRORSr_SET(r,d) (r).rxfcserrors[0] = d
#define BCM53262_A0_RXFCSERRORSr_GET(r) (r).rxfcserrors[0]


/*
 * These macros can be used to access RxFCSErrors.
 */
#define BCM53262_A0_READ_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXFCSERRORSr,(r._rxfcserrors),4)
#define BCM53262_A0_WRITE_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXFCSERRORSr,&(r._rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORSr BCM53262_A0_RXFCSERRORSr
#define RXFCSERRORSr_SIZE BCM53262_A0_RXFCSERRORSr_SIZE
typedef BCM53262_A0_RXFCSERRORSr_t RXFCSERRORSr_t;
#define RXFCSERRORSr_CLR BCM53262_A0_RXFCSERRORSr_CLR
#define RXFCSERRORSr_SET BCM53262_A0_RXFCSERRORSr_SET
#define RXFCSERRORSr_GET BCM53262_A0_RXFCSERRORSr_GET
#define READ_RXFCSERRORSr BCM53262_A0_READ_RXFCSERRORSr
#define WRITE_RXFCSERRORSr BCM53262_A0_WRITE_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXFCSERRORSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxFragments
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXFRAGMENTSr 0x000068bc

#define BCM53262_A0_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments.
 */
typedef union BCM53262_A0_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t rxfragments[1];
	uint32_t _rxfragments;
} BCM53262_A0_RXFRAGMENTSr_t;

#define BCM53262_A0_RXFRAGMENTSr_CLR(r) (r).rxfragments[0] = 0
#define BCM53262_A0_RXFRAGMENTSr_SET(r,d) (r).rxfragments[0] = d
#define BCM53262_A0_RXFRAGMENTSr_GET(r) (r).rxfragments[0]


/*
 * These macros can be used to access RxFragments.
 */
#define BCM53262_A0_READ_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXFRAGMENTSr,(r._rxfragments),4)
#define BCM53262_A0_WRITE_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXFRAGMENTSr,&(r._rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTSr BCM53262_A0_RXFRAGMENTSr
#define RXFRAGMENTSr_SIZE BCM53262_A0_RXFRAGMENTSr_SIZE
typedef BCM53262_A0_RXFRAGMENTSr_t RXFRAGMENTSr_t;
#define RXFRAGMENTSr_CLR BCM53262_A0_RXFRAGMENTSr_CLR
#define RXFRAGMENTSr_SET BCM53262_A0_RXFRAGMENTSr_SET
#define RXFRAGMENTSr_GET BCM53262_A0_RXFRAGMENTSr_GET
#define READ_RXFRAGMENTSr BCM53262_A0_READ_RXFRAGMENTSr
#define WRITE_RXFRAGMENTSr BCM53262_A0_WRITE_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXFRAGMENTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxFwdDiscPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Forward Discard Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXFWDDISCPKTSr 0x000068c8

#define BCM53262_A0_RXFWDDISCPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFwdDiscPkts.
 */
typedef union BCM53262_A0_RXFWDDISCPKTSr_s {
	uint32_t v[1];
	uint32_t rxfwddiscpkts[1];
	uint32_t _rxfwddiscpkts;
} BCM53262_A0_RXFWDDISCPKTSr_t;

#define BCM53262_A0_RXFWDDISCPKTSr_CLR(r) (r).rxfwddiscpkts[0] = 0
#define BCM53262_A0_RXFWDDISCPKTSr_SET(r,d) (r).rxfwddiscpkts[0] = d
#define BCM53262_A0_RXFWDDISCPKTSr_GET(r) (r).rxfwddiscpkts[0]


/*
 * These macros can be used to access RxFwdDiscPkts.
 */
#define BCM53262_A0_READ_RXFWDDISCPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXFWDDISCPKTSr,(r._rxfwddiscpkts),4)
#define BCM53262_A0_WRITE_RXFWDDISCPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXFWDDISCPKTSr,&(r._rxfwddiscpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFWDDISCPKTSr BCM53262_A0_RXFWDDISCPKTSr
#define RXFWDDISCPKTSr_SIZE BCM53262_A0_RXFWDDISCPKTSr_SIZE
typedef BCM53262_A0_RXFWDDISCPKTSr_t RXFWDDISCPKTSr_t;
#define RXFWDDISCPKTSr_CLR BCM53262_A0_RXFWDDISCPKTSr_CLR
#define RXFWDDISCPKTSr_SET BCM53262_A0_RXFWDDISCPKTSr_SET
#define RXFWDDISCPKTSr_GET BCM53262_A0_RXFWDDISCPKTSr_GET
#define READ_RXFWDDISCPKTSr BCM53262_A0_READ_RXFWDDISCPKTSr
#define WRITE_RXFWDDISCPKTSr BCM53262_A0_WRITE_RXFWDDISCPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXFWDDISCPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxGoodOctets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 */
#define BCM53262_A0_RXGOODOCTETSr 0x000068a0

#define BCM53262_A0_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets.
 */
typedef union BCM53262_A0_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets[2];
	uint32_t _rxgoodoctets;
} BCM53262_A0_RXGOODOCTETSr_t;

#define BCM53262_A0_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets), 0, sizeof(BCM53262_A0_RXGOODOCTETSr_t))
#define BCM53262_A0_RXGOODOCTETSr_SET(r,i,d) (r).rxgoodoctets[i] = d
#define BCM53262_A0_RXGOODOCTETSr_GET(r,i) (r).rxgoodoctets[i]


/*
 * These macros can be used to access RxGoodOctets.
 */
#define BCM53262_A0_READ_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXGOODOCTETSr,(r._rxgoodoctets),8)
#define BCM53262_A0_WRITE_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXGOODOCTETSr,&(r._rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETSr BCM53262_A0_RXGOODOCTETSr
#define RXGOODOCTETSr_SIZE BCM53262_A0_RXGOODOCTETSr_SIZE
typedef BCM53262_A0_RXGOODOCTETSr_t RXGOODOCTETSr_t;
#define RXGOODOCTETSr_CLR BCM53262_A0_RXGOODOCTETSr_CLR
#define RXGOODOCTETSr_SET BCM53262_A0_RXGOODOCTETSr_SET
#define RXGOODOCTETSr_GET BCM53262_A0_RXGOODOCTETSr_GET
#define READ_RXGOODOCTETSr BCM53262_A0_READ_RXGOODOCTETSr
#define WRITE_RXGOODOCTETSr BCM53262_A0_WRITE_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXGOODOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxJabbers
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXJABBERSr 0x00006894

#define BCM53262_A0_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers.
 */
typedef union BCM53262_A0_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t rxjabbers[1];
	uint32_t _rxjabbers;
} BCM53262_A0_RXJABBERSr_t;

#define BCM53262_A0_RXJABBERSr_CLR(r) (r).rxjabbers[0] = 0
#define BCM53262_A0_RXJABBERSr_SET(r,d) (r).rxjabbers[0] = d
#define BCM53262_A0_RXJABBERSr_GET(r) (r).rxjabbers[0]


/*
 * These macros can be used to access RxJabbers.
 */
#define BCM53262_A0_READ_RXJABBERSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXJABBERSr,(r._rxjabbers),4)
#define BCM53262_A0_WRITE_RXJABBERSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXJABBERSr,&(r._rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERSr BCM53262_A0_RXJABBERSr
#define RXJABBERSr_SIZE BCM53262_A0_RXJABBERSr_SIZE
typedef BCM53262_A0_RXJABBERSr_t RXJABBERSr_t;
#define RXJABBERSr_CLR BCM53262_A0_RXJABBERSr_CLR
#define RXJABBERSr_SET BCM53262_A0_RXJABBERSr_SET
#define RXJABBERSr_GET BCM53262_A0_RXJABBERSr_GET
#define READ_RXJABBERSr BCM53262_A0_READ_RXJABBERSr
#define WRITE_RXJABBERSr BCM53262_A0_WRITE_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXJABBERSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxMulticastPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXMULTICASTPKTSr 0x000068b0

#define BCM53262_A0_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts.
 */
typedef union BCM53262_A0_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts[1];
	uint32_t _rxmulticastpkts;
} BCM53262_A0_RXMULTICASTPKTSr_t;

#define BCM53262_A0_RXMULTICASTPKTSr_CLR(r) (r).rxmulticastpkts[0] = 0
#define BCM53262_A0_RXMULTICASTPKTSr_SET(r,d) (r).rxmulticastpkts[0] = d
#define BCM53262_A0_RXMULTICASTPKTSr_GET(r) (r).rxmulticastpkts[0]


/*
 * These macros can be used to access RxMulticastPkts.
 */
#define BCM53262_A0_READ_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXMULTICASTPKTSr,(r._rxmulticastpkts),4)
#define BCM53262_A0_WRITE_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXMULTICASTPKTSr,&(r._rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTSr BCM53262_A0_RXMULTICASTPKTSr
#define RXMULTICASTPKTSr_SIZE BCM53262_A0_RXMULTICASTPKTSr_SIZE
typedef BCM53262_A0_RXMULTICASTPKTSr_t RXMULTICASTPKTSr_t;
#define RXMULTICASTPKTSr_CLR BCM53262_A0_RXMULTICASTPKTSr_CLR
#define RXMULTICASTPKTSr_SET BCM53262_A0_RXMULTICASTPKTSr_SET
#define RXMULTICASTPKTSr_GET BCM53262_A0_RXMULTICASTPKTSr_GET
#define READ_RXMULTICASTPKTSr BCM53262_A0_READ_RXMULTICASTPKTSr
#define WRITE_RXMULTICASTPKTSr BCM53262_A0_WRITE_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXMULTICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxOctets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 */
#define BCM53262_A0_RXOCTETSr 0x00006868

#define BCM53262_A0_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets.
 */
typedef union BCM53262_A0_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t rxoctets[2];
	uint32_t _rxoctets;
} BCM53262_A0_RXOCTETSr_t;

#define BCM53262_A0_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxoctets), 0, sizeof(BCM53262_A0_RXOCTETSr_t))
#define BCM53262_A0_RXOCTETSr_SET(r,i,d) (r).rxoctets[i] = d
#define BCM53262_A0_RXOCTETSr_GET(r,i) (r).rxoctets[i]


/*
 * These macros can be used to access RxOctets.
 */
#define BCM53262_A0_READ_RXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXOCTETSr,(r._rxoctets),8)
#define BCM53262_A0_WRITE_RXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXOCTETSr,&(r._rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETSr BCM53262_A0_RXOCTETSr
#define RXOCTETSr_SIZE BCM53262_A0_RXOCTETSr_SIZE
typedef BCM53262_A0_RXOCTETSr_t RXOCTETSr_t;
#define RXOCTETSr_CLR BCM53262_A0_RXOCTETSr_CLR
#define RXOCTETSr_SET BCM53262_A0_RXOCTETSr_SET
#define RXOCTETSr_GET BCM53262_A0_RXOCTETSr_GET
#define READ_RXOCTETSr BCM53262_A0_READ_RXOCTETSr
#define WRITE_RXOCTETSr BCM53262_A0_WRITE_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxOversizePkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXOVERSIZEPKTSr 0x00006890

#define BCM53262_A0_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts.
 */
typedef union BCM53262_A0_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts[1];
	uint32_t _rxoversizepkts;
} BCM53262_A0_RXOVERSIZEPKTSr_t;

#define BCM53262_A0_RXOVERSIZEPKTSr_CLR(r) (r).rxoversizepkts[0] = 0
#define BCM53262_A0_RXOVERSIZEPKTSr_SET(r,d) (r).rxoversizepkts[0] = d
#define BCM53262_A0_RXOVERSIZEPKTSr_GET(r) (r).rxoversizepkts[0]


/*
 * These macros can be used to access RxOversizePkts.
 */
#define BCM53262_A0_READ_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXOVERSIZEPKTSr,(r._rxoversizepkts),4)
#define BCM53262_A0_WRITE_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXOVERSIZEPKTSr,&(r._rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTSr BCM53262_A0_RXOVERSIZEPKTSr
#define RXOVERSIZEPKTSr_SIZE BCM53262_A0_RXOVERSIZEPKTSr_SIZE
typedef BCM53262_A0_RXOVERSIZEPKTSr_t RXOVERSIZEPKTSr_t;
#define RXOVERSIZEPKTSr_CLR BCM53262_A0_RXOVERSIZEPKTSr_CLR
#define RXOVERSIZEPKTSr_SET BCM53262_A0_RXOVERSIZEPKTSr_SET
#define RXOVERSIZEPKTSr_GET BCM53262_A0_RXOVERSIZEPKTSr_GET
#define READ_RXOVERSIZEPKTSr BCM53262_A0_READ_RXOVERSIZEPKTSr
#define WRITE_RXOVERSIZEPKTSr BCM53262_A0_WRITE_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXOVERSIZEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxPausePkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXPAUSEPKTSr 0x00006874

#define BCM53262_A0_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts.
 */
typedef union BCM53262_A0_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t rxpausepkts[1];
	uint32_t _rxpausepkts;
} BCM53262_A0_RXPAUSEPKTSr_t;

#define BCM53262_A0_RXPAUSEPKTSr_CLR(r) (r).rxpausepkts[0] = 0
#define BCM53262_A0_RXPAUSEPKTSr_SET(r,d) (r).rxpausepkts[0] = d
#define BCM53262_A0_RXPAUSEPKTSr_GET(r) (r).rxpausepkts[0]


/*
 * These macros can be used to access RxPausePkts.
 */
#define BCM53262_A0_READ_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXPAUSEPKTSr,(r._rxpausepkts),4)
#define BCM53262_A0_WRITE_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXPAUSEPKTSr,&(r._rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTSr BCM53262_A0_RXPAUSEPKTSr
#define RXPAUSEPKTSr_SIZE BCM53262_A0_RXPAUSEPKTSr_SIZE
typedef BCM53262_A0_RXPAUSEPKTSr_t RXPAUSEPKTSr_t;
#define RXPAUSEPKTSr_CLR BCM53262_A0_RXPAUSEPKTSr_CLR
#define RXPAUSEPKTSr_SET BCM53262_A0_RXPAUSEPKTSr_SET
#define RXPAUSEPKTSr_GET BCM53262_A0_RXPAUSEPKTSr_GET
#define READ_RXPAUSEPKTSr BCM53262_A0_READ_RXPAUSEPKTSr
#define WRITE_RXPAUSEPKTSr BCM53262_A0_WRITE_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXPAUSEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxSAChanges
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXSACHANGESr 0x000068b8

#define BCM53262_A0_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges.
 */
typedef union BCM53262_A0_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t rxsachanges[1];
	uint32_t _rxsachanges;
} BCM53262_A0_RXSACHANGESr_t;

#define BCM53262_A0_RXSACHANGESr_CLR(r) (r).rxsachanges[0] = 0
#define BCM53262_A0_RXSACHANGESr_SET(r,d) (r).rxsachanges[0] = d
#define BCM53262_A0_RXSACHANGESr_GET(r) (r).rxsachanges[0]


/*
 * These macros can be used to access RxSAChanges.
 */
#define BCM53262_A0_READ_RXSACHANGESr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXSACHANGESr,(r._rxsachanges),4)
#define BCM53262_A0_WRITE_RXSACHANGESr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXSACHANGESr,&(r._rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGESr BCM53262_A0_RXSACHANGESr
#define RXSACHANGESr_SIZE BCM53262_A0_RXSACHANGESr_SIZE
typedef BCM53262_A0_RXSACHANGESr_t RXSACHANGESr_t;
#define RXSACHANGESr_CLR BCM53262_A0_RXSACHANGESr_CLR
#define RXSACHANGESr_SET BCM53262_A0_RXSACHANGESr_SET
#define RXSACHANGESr_GET BCM53262_A0_RXSACHANGESr_GET
#define READ_RXSACHANGESr BCM53262_A0_READ_RXSACHANGESr
#define WRITE_RXSACHANGESr BCM53262_A0_WRITE_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXSACHANGESr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxUndersizePkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXUNDERSIZEPKTSr 0x00006870

#define BCM53262_A0_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts.
 */
typedef union BCM53262_A0_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts[1];
	uint32_t _rxundersizepkts;
} BCM53262_A0_RXUNDERSIZEPKTSr_t;

#define BCM53262_A0_RXUNDERSIZEPKTSr_CLR(r) (r).rxundersizepkts[0] = 0
#define BCM53262_A0_RXUNDERSIZEPKTSr_SET(r,d) (r).rxundersizepkts[0] = d
#define BCM53262_A0_RXUNDERSIZEPKTSr_GET(r) (r).rxundersizepkts[0]


/*
 * These macros can be used to access RxUndersizePkts.
 */
#define BCM53262_A0_READ_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXUNDERSIZEPKTSr,(r._rxundersizepkts),4)
#define BCM53262_A0_WRITE_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXUNDERSIZEPKTSr,&(r._rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTSr BCM53262_A0_RXUNDERSIZEPKTSr
#define RXUNDERSIZEPKTSr_SIZE BCM53262_A0_RXUNDERSIZEPKTSr_SIZE
typedef BCM53262_A0_RXUNDERSIZEPKTSr_t RXUNDERSIZEPKTSr_t;
#define RXUNDERSIZEPKTSr_CLR BCM53262_A0_RXUNDERSIZEPKTSr_CLR
#define RXUNDERSIZEPKTSr_SET BCM53262_A0_RXUNDERSIZEPKTSr_SET
#define RXUNDERSIZEPKTSr_GET BCM53262_A0_RXUNDERSIZEPKTSr_GET
#define READ_RXUNDERSIZEPKTSr BCM53262_A0_READ_RXUNDERSIZEPKTSr
#define WRITE_RXUNDERSIZEPKTSr BCM53262_A0_WRITE_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXUNDERSIZEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  RxUnicastPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_RXUNICASTPKTSr 0x000068ac

#define BCM53262_A0_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts.
 */
typedef union BCM53262_A0_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts[1];
	uint32_t _rxunicastpkts;
} BCM53262_A0_RXUNICASTPKTSr_t;

#define BCM53262_A0_RXUNICASTPKTSr_CLR(r) (r).rxunicastpkts[0] = 0
#define BCM53262_A0_RXUNICASTPKTSr_SET(r,d) (r).rxunicastpkts[0] = d
#define BCM53262_A0_RXUNICASTPKTSr_GET(r) (r).rxunicastpkts[0]


/*
 * These macros can be used to access RxUnicastPkts.
 */
#define BCM53262_A0_READ_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_RXUNICASTPKTSr,(r._rxunicastpkts),4)
#define BCM53262_A0_WRITE_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_RXUNICASTPKTSr,&(r._rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTSr BCM53262_A0_RXUNICASTPKTSr
#define RXUNICASTPKTSr_SIZE BCM53262_A0_RXUNICASTPKTSr_SIZE
typedef BCM53262_A0_RXUNICASTPKTSr_t RXUNICASTPKTSr_t;
#define RXUNICASTPKTSr_CLR BCM53262_A0_RXUNICASTPKTSr_CLR
#define RXUNICASTPKTSr_SET BCM53262_A0_RXUNICASTPKTSr_SET
#define RXUNICASTPKTSr_GET BCM53262_A0_RXUNICASTPKTSr_GET
#define READ_RXUNICASTPKTSr BCM53262_A0_READ_RXUNICASTPKTSr
#define WRITE_RXUNICASTPKTSr BCM53262_A0_WRITE_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_RXUNICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SCAN_RSLT_GP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Giga Port N Scan Result Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting,0: Half Duplex,1: Full Duplex.
 *     SPEED_R          Speed Mode2'b10 : 1000M2'b01: 100M2'b00 : 10M
 *     RXFLOW_CNTL      Software Rx Flow Control Enable.
 *     TXFLOW_CNTL      Software Tx Flow Control Enable.
 *     SCAN_TIMEOUT_ERR PHY scan register Time-Out.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_SCAN_RSLT_GPr 0x00190168

#define BCM53262_A0_SCAN_RSLT_GPr_SIZE 1

/*
 * This structure should be used to declare and program SCAN_RSLT_GP.
 */
typedef union BCM53262_A0_SCAN_RSLT_GPr_s {
	uint32_t v[1];
	uint32_t scan_rslt_gp[1];
	uint32_t _scan_rslt_gp;
} BCM53262_A0_SCAN_RSLT_GPr_t;

#define BCM53262_A0_SCAN_RSLT_GPr_CLR(r) (r).scan_rslt_gp[0] = 0
#define BCM53262_A0_SCAN_RSLT_GPr_SET(r,d) (r).scan_rslt_gp[0] = d
#define BCM53262_A0_SCAN_RSLT_GPr_GET(r) (r).scan_rslt_gp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SCAN_RSLT_GPr_LINK_STSf_GET(r) (((r).scan_rslt_gp[0]) & 0x1)
#define BCM53262_A0_SCAN_RSLT_GPr_LINK_STSf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_SCAN_RSLT_GPr_DUPLX_MODEf_GET(r) ((((r).scan_rslt_gp[0]) >> 1) & 0x1)
#define BCM53262_A0_SCAN_RSLT_GPr_DUPLX_MODEf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_SCAN_RSLT_GPr_SPEED_Rf_GET(r) ((((r).scan_rslt_gp[0]) >> 2) & 0x3)
#define BCM53262_A0_SCAN_RSLT_GPr_SPEED_Rf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_GET(r) ((((r).scan_rslt_gp[0]) >> 4) & 0x1)
#define BCM53262_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_GET(r) ((((r).scan_rslt_gp[0]) >> 5) & 0x1)
#define BCM53262_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_GET(r) ((((r).scan_rslt_gp[0]) >> 6) & 0x1)
#define BCM53262_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_SCAN_RSLT_GPr_RESERVED_Rf_GET(r) ((((r).scan_rslt_gp[0]) >> 7) & 0x1)
#define BCM53262_A0_SCAN_RSLT_GPr_RESERVED_Rf_SET(r,f) (r).scan_rslt_gp[0]=(((r).scan_rslt_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access SCAN_RSLT_GP.
 */
#define BCM53262_A0_READ_SCAN_RSLT_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_SCAN_RSLT_GPr,(r._scan_rslt_gp),1)
#define BCM53262_A0_WRITE_SCAN_RSLT_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_SCAN_RSLT_GPr,&(r._scan_rslt_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SCAN_RSLT_GPr BCM53262_A0_SCAN_RSLT_GPr
#define SCAN_RSLT_GPr_SIZE BCM53262_A0_SCAN_RSLT_GPr_SIZE
typedef BCM53262_A0_SCAN_RSLT_GPr_t SCAN_RSLT_GPr_t;
#define SCAN_RSLT_GPr_CLR BCM53262_A0_SCAN_RSLT_GPr_CLR
#define SCAN_RSLT_GPr_SET BCM53262_A0_SCAN_RSLT_GPr_SET
#define SCAN_RSLT_GPr_GET BCM53262_A0_SCAN_RSLT_GPr_GET
#define SCAN_RSLT_GPr_LINK_STSf_GET BCM53262_A0_SCAN_RSLT_GPr_LINK_STSf_GET
#define SCAN_RSLT_GPr_LINK_STSf_SET BCM53262_A0_SCAN_RSLT_GPr_LINK_STSf_SET
#define SCAN_RSLT_GPr_DUPLX_MODEf_GET BCM53262_A0_SCAN_RSLT_GPr_DUPLX_MODEf_GET
#define SCAN_RSLT_GPr_DUPLX_MODEf_SET BCM53262_A0_SCAN_RSLT_GPr_DUPLX_MODEf_SET
#define SCAN_RSLT_GPr_SPEED_Rf_GET BCM53262_A0_SCAN_RSLT_GPr_SPEED_Rf_GET
#define SCAN_RSLT_GPr_SPEED_Rf_SET BCM53262_A0_SCAN_RSLT_GPr_SPEED_Rf_SET
#define SCAN_RSLT_GPr_RXFLOW_CNTLf_GET BCM53262_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_GET
#define SCAN_RSLT_GPr_RXFLOW_CNTLf_SET BCM53262_A0_SCAN_RSLT_GPr_RXFLOW_CNTLf_SET
#define SCAN_RSLT_GPr_TXFLOW_CNTLf_GET BCM53262_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_GET
#define SCAN_RSLT_GPr_TXFLOW_CNTLf_SET BCM53262_A0_SCAN_RSLT_GPr_TXFLOW_CNTLf_SET
#define SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_GET BCM53262_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_GET
#define SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_SET BCM53262_A0_SCAN_RSLT_GPr_SCAN_TIMEOUT_ERRf_SET
#define SCAN_RSLT_GPr_RESERVED_Rf_GET BCM53262_A0_SCAN_RSLT_GPr_RESERVED_Rf_GET
#define SCAN_RSLT_GPr_RESERVED_Rf_SET BCM53262_A0_SCAN_RSLT_GPr_RESERVED_Rf_SET
#define READ_SCAN_RSLT_GPr BCM53262_A0_READ_SCAN_RSLT_GPr
#define WRITE_SCAN_RSLT_GPr BCM53262_A0_WRITE_SCAN_RSLT_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SCAN_RSLT_GPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SCAN_TIMEOUT
 * BLOCKS:   SYS
 * DESC:     Scan Timeout Register
 * SIZE:     8
 * FIELDS:
 *     SCAN_TIMEOUT     Scan Timeout
 */
#define BCM53262_A0_SCAN_TIMEOUTr 0x0000001f

#define BCM53262_A0_SCAN_TIMEOUTr_SIZE 1

/*
 * This structure should be used to declare and program SCAN_TIMEOUT.
 */
typedef union BCM53262_A0_SCAN_TIMEOUTr_s {
	uint32_t v[1];
	uint32_t scan_timeout[1];
	uint32_t _scan_timeout;
} BCM53262_A0_SCAN_TIMEOUTr_t;

#define BCM53262_A0_SCAN_TIMEOUTr_CLR(r) (r).scan_timeout[0] = 0
#define BCM53262_A0_SCAN_TIMEOUTr_SET(r,d) (r).scan_timeout[0] = d
#define BCM53262_A0_SCAN_TIMEOUTr_GET(r) (r).scan_timeout[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_GET(r) (((r).scan_timeout[0]) & 0xff)
#define BCM53262_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_SET(r,f) (r).scan_timeout[0]=(((r).scan_timeout[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SCAN_TIMEOUT.
 */
#define BCM53262_A0_READ_SCAN_TIMEOUTr(u,r) cdk_robo_reg_read(u,BCM53262_A0_SCAN_TIMEOUTr,(r._scan_timeout),1)
#define BCM53262_A0_WRITE_SCAN_TIMEOUTr(u,r) cdk_robo_reg_write(u,BCM53262_A0_SCAN_TIMEOUTr,&(r._scan_timeout),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SCAN_TIMEOUTr BCM53262_A0_SCAN_TIMEOUTr
#define SCAN_TIMEOUTr_SIZE BCM53262_A0_SCAN_TIMEOUTr_SIZE
typedef BCM53262_A0_SCAN_TIMEOUTr_t SCAN_TIMEOUTr_t;
#define SCAN_TIMEOUTr_CLR BCM53262_A0_SCAN_TIMEOUTr_CLR
#define SCAN_TIMEOUTr_SET BCM53262_A0_SCAN_TIMEOUTr_SET
#define SCAN_TIMEOUTr_GET BCM53262_A0_SCAN_TIMEOUTr_GET
#define SCAN_TIMEOUTr_SCAN_TIMEOUTf_GET BCM53262_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_GET
#define SCAN_TIMEOUTr_SCAN_TIMEOUTf_SET BCM53262_A0_SCAN_TIMEOUTr_SCAN_TIMEOUTf_SET
#define READ_SCAN_TIMEOUTr BCM53262_A0_READ_SCAN_TIMEOUTr
#define WRITE_SCAN_TIMEOUTr BCM53262_A0_WRITE_SCAN_TIMEOUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SCAN_TIMEOUTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SEC_TDIP0
 * BLOCKS:   SYS
 * DESC:     Security Trust Destination IP Register 0
 * SIZE:     64
 * FIELDS:
 *     DIP_MASK_REG_0   EAP Dsitination IP Mask Register 0
 *     DIP_SUB_REG_0    EAP Distination IP Subnet Register 0
 */
#define BCM53262_A0_SEC_TDIP0r 0x00004100

#define BCM53262_A0_SEC_TDIP0r_SIZE 8

/*
 * This structure should be used to declare and program SEC_TDIP0.
 */
typedef union BCM53262_A0_SEC_TDIP0r_s {
	uint32_t v[2];
	uint32_t sec_tdip0[2];
	uint32_t _sec_tdip0;
} BCM53262_A0_SEC_TDIP0r_t;

#define BCM53262_A0_SEC_TDIP0r_CLR(r) CDK_MEMSET(&((r)._sec_tdip0), 0, sizeof(BCM53262_A0_SEC_TDIP0r_t))
#define BCM53262_A0_SEC_TDIP0r_SET(r,i,d) (r).sec_tdip0[i] = d
#define BCM53262_A0_SEC_TDIP0r_GET(r,i) (r).sec_tdip0[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SEC_TDIP0r_DIP_MASK_REG_0f_GET(r) ((r).sec_tdip0[0])
#define BCM53262_A0_SEC_TDIP0r_DIP_MASK_REG_0f_SET(r,f) (r).sec_tdip0[0]=((uint32_t)f)
#define BCM53262_A0_SEC_TDIP0r_DIP_SUB_REG_0f_GET(r) ((r).sec_tdip0[1])
#define BCM53262_A0_SEC_TDIP0r_DIP_SUB_REG_0f_SET(r,f) (r).sec_tdip0[1]=((uint32_t)f)

/*
 * These macros can be used to access SEC_TDIP0.
 */
#define BCM53262_A0_READ_SEC_TDIP0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_SEC_TDIP0r,(r._sec_tdip0),8)
#define BCM53262_A0_WRITE_SEC_TDIP0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_SEC_TDIP0r,&(r._sec_tdip0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SEC_TDIP0r BCM53262_A0_SEC_TDIP0r
#define SEC_TDIP0r_SIZE BCM53262_A0_SEC_TDIP0r_SIZE
typedef BCM53262_A0_SEC_TDIP0r_t SEC_TDIP0r_t;
#define SEC_TDIP0r_CLR BCM53262_A0_SEC_TDIP0r_CLR
#define SEC_TDIP0r_SET BCM53262_A0_SEC_TDIP0r_SET
#define SEC_TDIP0r_GET BCM53262_A0_SEC_TDIP0r_GET
#define SEC_TDIP0r_DIP_MASK_REG_0f_GET BCM53262_A0_SEC_TDIP0r_DIP_MASK_REG_0f_GET
#define SEC_TDIP0r_DIP_MASK_REG_0f_SET BCM53262_A0_SEC_TDIP0r_DIP_MASK_REG_0f_SET
#define SEC_TDIP0r_DIP_SUB_REG_0f_GET BCM53262_A0_SEC_TDIP0r_DIP_SUB_REG_0f_GET
#define SEC_TDIP0r_DIP_SUB_REG_0f_SET BCM53262_A0_SEC_TDIP0r_DIP_SUB_REG_0f_SET
#define READ_SEC_TDIP0r BCM53262_A0_READ_SEC_TDIP0r
#define WRITE_SEC_TDIP0r BCM53262_A0_WRITE_SEC_TDIP0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SEC_TDIP0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SEC_TDIP1
 * BLOCKS:   SYS
 * DESC:     Security Trust Destination IP Register 1
 * SIZE:     64
 * FIELDS:
 *     DIP_MASK_REG_1   EAP Dsitination IP Mask Register 1
 *     DIP_SUB_REG_1    EAP Distination IP Subnet Register 1
 */
#define BCM53262_A0_SEC_TDIP1r 0x00004108

#define BCM53262_A0_SEC_TDIP1r_SIZE 8

/*
 * This structure should be used to declare and program SEC_TDIP1.
 */
typedef union BCM53262_A0_SEC_TDIP1r_s {
	uint32_t v[2];
	uint32_t sec_tdip1[2];
	uint32_t _sec_tdip1;
} BCM53262_A0_SEC_TDIP1r_t;

#define BCM53262_A0_SEC_TDIP1r_CLR(r) CDK_MEMSET(&((r)._sec_tdip1), 0, sizeof(BCM53262_A0_SEC_TDIP1r_t))
#define BCM53262_A0_SEC_TDIP1r_SET(r,i,d) (r).sec_tdip1[i] = d
#define BCM53262_A0_SEC_TDIP1r_GET(r,i) (r).sec_tdip1[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SEC_TDIP1r_DIP_MASK_REG_1f_GET(r) ((r).sec_tdip1[0])
#define BCM53262_A0_SEC_TDIP1r_DIP_MASK_REG_1f_SET(r,f) (r).sec_tdip1[0]=((uint32_t)f)
#define BCM53262_A0_SEC_TDIP1r_DIP_SUB_REG_1f_GET(r) ((r).sec_tdip1[1])
#define BCM53262_A0_SEC_TDIP1r_DIP_SUB_REG_1f_SET(r,f) (r).sec_tdip1[1]=((uint32_t)f)

/*
 * These macros can be used to access SEC_TDIP1.
 */
#define BCM53262_A0_READ_SEC_TDIP1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_SEC_TDIP1r,(r._sec_tdip1),8)
#define BCM53262_A0_WRITE_SEC_TDIP1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_SEC_TDIP1r,&(r._sec_tdip1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SEC_TDIP1r BCM53262_A0_SEC_TDIP1r
#define SEC_TDIP1r_SIZE BCM53262_A0_SEC_TDIP1r_SIZE
typedef BCM53262_A0_SEC_TDIP1r_t SEC_TDIP1r_t;
#define SEC_TDIP1r_CLR BCM53262_A0_SEC_TDIP1r_CLR
#define SEC_TDIP1r_SET BCM53262_A0_SEC_TDIP1r_SET
#define SEC_TDIP1r_GET BCM53262_A0_SEC_TDIP1r_GET
#define SEC_TDIP1r_DIP_MASK_REG_1f_GET BCM53262_A0_SEC_TDIP1r_DIP_MASK_REG_1f_GET
#define SEC_TDIP1r_DIP_MASK_REG_1f_SET BCM53262_A0_SEC_TDIP1r_DIP_MASK_REG_1f_SET
#define SEC_TDIP1r_DIP_SUB_REG_1f_GET BCM53262_A0_SEC_TDIP1r_DIP_SUB_REG_1f_GET
#define SEC_TDIP1r_DIP_SUB_REG_1f_SET BCM53262_A0_SEC_TDIP1r_DIP_SUB_REG_1f_SET
#define READ_SEC_TDIP1r BCM53262_A0_READ_SEC_TDIP1r
#define WRITE_SEC_TDIP1r BCM53262_A0_WRITE_SEC_TDIP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SEC_TDIP1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SGMII_CLR_CTL
 * BLOCKS:   SYS
 * DESC:     SGMII clear control Register
 * SIZE:     8
 * FIELDS:
 *     SGMII_CRC16_CLR_N This signal is the one to clear CRC16 register once it is read.Active low signal. 
 *     SGMII_STA_CLR_N  This signal is the one to clear sgmii tatus register once it is read.Active low signal.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_SGMII_CLR_CTLr 0x00000d08

#define BCM53262_A0_SGMII_CLR_CTLr_SIZE 1

/*
 * This structure should be used to declare and program SGMII_CLR_CTL.
 */
typedef union BCM53262_A0_SGMII_CLR_CTLr_s {
	uint32_t v[1];
	uint32_t sgmii_clr_ctl[1];
	uint32_t _sgmii_clr_ctl;
} BCM53262_A0_SGMII_CLR_CTLr_t;

#define BCM53262_A0_SGMII_CLR_CTLr_CLR(r) (r).sgmii_clr_ctl[0] = 0
#define BCM53262_A0_SGMII_CLR_CTLr_SET(r,d) (r).sgmii_clr_ctl[0] = d
#define BCM53262_A0_SGMII_CLR_CTLr_GET(r) (r).sgmii_clr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SGMII_CLR_CTLr_SGMII_CRC16_CLR_Nf_GET(r) (((r).sgmii_clr_ctl[0]) & 0x3)
#define BCM53262_A0_SGMII_CLR_CTLr_SGMII_CRC16_CLR_Nf_SET(r,f) (r).sgmii_clr_ctl[0]=(((r).sgmii_clr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_SGMII_CLR_CTLr_SGMII_STA_CLR_Nf_GET(r) ((((r).sgmii_clr_ctl[0]) >> 2) & 0x3)
#define BCM53262_A0_SGMII_CLR_CTLr_SGMII_STA_CLR_Nf_SET(r,f) (r).sgmii_clr_ctl[0]=(((r).sgmii_clr_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_SGMII_CLR_CTLr_RESERVED_Rf_GET(r) ((((r).sgmii_clr_ctl[0]) >> 4) & 0xf)
#define BCM53262_A0_SGMII_CLR_CTLr_RESERVED_Rf_SET(r,f) (r).sgmii_clr_ctl[0]=(((r).sgmii_clr_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access SGMII_CLR_CTL.
 */
#define BCM53262_A0_READ_SGMII_CLR_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_SGMII_CLR_CTLr,(r._sgmii_clr_ctl),1)
#define BCM53262_A0_WRITE_SGMII_CLR_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_SGMII_CLR_CTLr,&(r._sgmii_clr_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SGMII_CLR_CTLr BCM53262_A0_SGMII_CLR_CTLr
#define SGMII_CLR_CTLr_SIZE BCM53262_A0_SGMII_CLR_CTLr_SIZE
typedef BCM53262_A0_SGMII_CLR_CTLr_t SGMII_CLR_CTLr_t;
#define SGMII_CLR_CTLr_CLR BCM53262_A0_SGMII_CLR_CTLr_CLR
#define SGMII_CLR_CTLr_SET BCM53262_A0_SGMII_CLR_CTLr_SET
#define SGMII_CLR_CTLr_GET BCM53262_A0_SGMII_CLR_CTLr_GET
#define SGMII_CLR_CTLr_SGMII_CRC16_CLR_Nf_GET BCM53262_A0_SGMII_CLR_CTLr_SGMII_CRC16_CLR_Nf_GET
#define SGMII_CLR_CTLr_SGMII_CRC16_CLR_Nf_SET BCM53262_A0_SGMII_CLR_CTLr_SGMII_CRC16_CLR_Nf_SET
#define SGMII_CLR_CTLr_SGMII_STA_CLR_Nf_GET BCM53262_A0_SGMII_CLR_CTLr_SGMII_STA_CLR_Nf_GET
#define SGMII_CLR_CTLr_SGMII_STA_CLR_Nf_SET BCM53262_A0_SGMII_CLR_CTLr_SGMII_STA_CLR_Nf_SET
#define SGMII_CLR_CTLr_RESERVED_Rf_GET BCM53262_A0_SGMII_CLR_CTLr_RESERVED_Rf_GET
#define SGMII_CLR_CTLr_RESERVED_Rf_SET BCM53262_A0_SGMII_CLR_CTLr_RESERVED_Rf_SET
#define READ_SGMII_CLR_CTLr BCM53262_A0_READ_SGMII_CLR_CTLr
#define WRITE_SGMII_CLR_CTLr BCM53262_A0_WRITE_SGMII_CLR_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SGMII_CLR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SGMII_CTL_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port SGMII Control Register
 * SIZE:     16
 * FIELDS:
 *     TBI_LPBK         TBI loop-back for testability.
 *     REMOTE_LPBK      Remote loop-back for testability.
 *     SG_AN_DIS        When '1', Disable AutoNeg directly to Data Mode.
 *     AN_TST_MODE      Reduce timer for AutoNeg testing.
 *     CDET_EN          When '1', Disable comma detector.
 *     RX_SLATENCY_EN   Enable short latency function that makes RX side start sending preamble when CRS is detected.This bit is used when user plans to send non-ethernet packet.
 *     RESERVED_R       Reserved
 *     REV_PHASE        When '1', latch 10 bit data from analog SerDes by falling edge of clock, otherwise latch data at rising edge of clock.
 *     ERR_TIMER_EN     Enable error timer in Auto-Neg for testiblity.
 *     TX_SLATENCY_EN   0: assert 1-nibble (max) early preamble in 100/10 mode1: no early preamble is asserted
 *     AN_SEL           When '0', select SGMII Auto-Neg. Otherwise, select IEEE clause 37 complied Auto-Neg.
 *     PAUSE_R          To Set Pause bits in AutoNeg link code word. This only works when an_sel = '1'.
 *     REMOTE_FAULT_R   To Set remote fault bits in AutoNeg link code word. This only works when an_sel = '1'.
 *     FORCE_DATA_MODE  When '1', synchronization and data valid won't be detected.By setting this bit to '1' and en10b=1, cdet_en=1,user can use GMII to directly send and receive raw TBI data to and  from analog SerDes.
 */
#define BCM53262_A0_SGMII_CTL_GPr 0x00190d50

#define BCM53262_A0_SGMII_CTL_GPr_SIZE 2

/*
 * This structure should be used to declare and program SGMII_CTL_GP.
 */
typedef union BCM53262_A0_SGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t sgmii_ctl_gp[1];
	uint32_t _sgmii_ctl_gp;
} BCM53262_A0_SGMII_CTL_GPr_t;

#define BCM53262_A0_SGMII_CTL_GPr_CLR(r) (r).sgmii_ctl_gp[0] = 0
#define BCM53262_A0_SGMII_CTL_GPr_SET(r,d) (r).sgmii_ctl_gp[0] = d
#define BCM53262_A0_SGMII_CTL_GPr_GET(r) (r).sgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SGMII_CTL_GPr_TBI_LPBKf_GET(r) (((r).sgmii_ctl_gp[0]) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_TBI_LPBKf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_SGMII_CTL_GPr_REMOTE_LPBKf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_REMOTE_LPBKf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_SGMII_CTL_GPr_SG_AN_DISf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_SG_AN_DISf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_SGMII_CTL_GPr_AN_TST_MODEf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 3) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_AN_TST_MODEf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_SGMII_CTL_GPr_CDET_ENf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 4) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_CDET_ENf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_SGMII_CTL_GPr_RX_SLATENCY_ENf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 5) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_RX_SLATENCY_ENf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_SGMII_CTL_GPr_RESERVED_Rf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 6) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_RESERVED_Rf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_SGMII_CTL_GPr_REV_PHASEf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 7) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_REV_PHASEf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_SGMII_CTL_GPr_ERR_TIMER_ENf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 8) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_ERR_TIMER_ENf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_SGMII_CTL_GPr_TX_SLATENCY_ENf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 9) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_TX_SLATENCY_ENf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_SGMII_CTL_GPr_AN_SELf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 10) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_AN_SELf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_SGMII_CTL_GPr_PAUSE_Rf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 11) & 0x3)
#define BCM53262_A0_SGMII_CTL_GPr_PAUSE_Rf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53262_A0_SGMII_CTL_GPr_REMOTE_FAULT_Rf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 13) & 0x3)
#define BCM53262_A0_SGMII_CTL_GPr_REMOTE_FAULT_Rf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53262_A0_SGMII_CTL_GPr_FORCE_DATA_MODEf_GET(r) ((((r).sgmii_ctl_gp[0]) >> 15) & 0x1)
#define BCM53262_A0_SGMII_CTL_GPr_FORCE_DATA_MODEf_SET(r,f) (r).sgmii_ctl_gp[0]=(((r).sgmii_ctl_gp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SGMII_CTL_GP.
 */
#define BCM53262_A0_READ_SGMII_CTL_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_SGMII_CTL_GPr,(r._sgmii_ctl_gp),2)
#define BCM53262_A0_WRITE_SGMII_CTL_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_SGMII_CTL_GPr,&(r._sgmii_ctl_gp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SGMII_CTL_GPr BCM53262_A0_SGMII_CTL_GPr
#define SGMII_CTL_GPr_SIZE BCM53262_A0_SGMII_CTL_GPr_SIZE
typedef BCM53262_A0_SGMII_CTL_GPr_t SGMII_CTL_GPr_t;
#define SGMII_CTL_GPr_CLR BCM53262_A0_SGMII_CTL_GPr_CLR
#define SGMII_CTL_GPr_SET BCM53262_A0_SGMII_CTL_GPr_SET
#define SGMII_CTL_GPr_GET BCM53262_A0_SGMII_CTL_GPr_GET
#define SGMII_CTL_GPr_TBI_LPBKf_GET BCM53262_A0_SGMII_CTL_GPr_TBI_LPBKf_GET
#define SGMII_CTL_GPr_TBI_LPBKf_SET BCM53262_A0_SGMII_CTL_GPr_TBI_LPBKf_SET
#define SGMII_CTL_GPr_REMOTE_LPBKf_GET BCM53262_A0_SGMII_CTL_GPr_REMOTE_LPBKf_GET
#define SGMII_CTL_GPr_REMOTE_LPBKf_SET BCM53262_A0_SGMII_CTL_GPr_REMOTE_LPBKf_SET
#define SGMII_CTL_GPr_SG_AN_DISf_GET BCM53262_A0_SGMII_CTL_GPr_SG_AN_DISf_GET
#define SGMII_CTL_GPr_SG_AN_DISf_SET BCM53262_A0_SGMII_CTL_GPr_SG_AN_DISf_SET
#define SGMII_CTL_GPr_AN_TST_MODEf_GET BCM53262_A0_SGMII_CTL_GPr_AN_TST_MODEf_GET
#define SGMII_CTL_GPr_AN_TST_MODEf_SET BCM53262_A0_SGMII_CTL_GPr_AN_TST_MODEf_SET
#define SGMII_CTL_GPr_CDET_ENf_GET BCM53262_A0_SGMII_CTL_GPr_CDET_ENf_GET
#define SGMII_CTL_GPr_CDET_ENf_SET BCM53262_A0_SGMII_CTL_GPr_CDET_ENf_SET
#define SGMII_CTL_GPr_RX_SLATENCY_ENf_GET BCM53262_A0_SGMII_CTL_GPr_RX_SLATENCY_ENf_GET
#define SGMII_CTL_GPr_RX_SLATENCY_ENf_SET BCM53262_A0_SGMII_CTL_GPr_RX_SLATENCY_ENf_SET
#define SGMII_CTL_GPr_RESERVED_Rf_GET BCM53262_A0_SGMII_CTL_GPr_RESERVED_Rf_GET
#define SGMII_CTL_GPr_RESERVED_Rf_SET BCM53262_A0_SGMII_CTL_GPr_RESERVED_Rf_SET
#define SGMII_CTL_GPr_REV_PHASEf_GET BCM53262_A0_SGMII_CTL_GPr_REV_PHASEf_GET
#define SGMII_CTL_GPr_REV_PHASEf_SET BCM53262_A0_SGMII_CTL_GPr_REV_PHASEf_SET
#define SGMII_CTL_GPr_ERR_TIMER_ENf_GET BCM53262_A0_SGMII_CTL_GPr_ERR_TIMER_ENf_GET
#define SGMII_CTL_GPr_ERR_TIMER_ENf_SET BCM53262_A0_SGMII_CTL_GPr_ERR_TIMER_ENf_SET
#define SGMII_CTL_GPr_TX_SLATENCY_ENf_GET BCM53262_A0_SGMII_CTL_GPr_TX_SLATENCY_ENf_GET
#define SGMII_CTL_GPr_TX_SLATENCY_ENf_SET BCM53262_A0_SGMII_CTL_GPr_TX_SLATENCY_ENf_SET
#define SGMII_CTL_GPr_AN_SELf_GET BCM53262_A0_SGMII_CTL_GPr_AN_SELf_GET
#define SGMII_CTL_GPr_AN_SELf_SET BCM53262_A0_SGMII_CTL_GPr_AN_SELf_SET
#define SGMII_CTL_GPr_PAUSE_Rf_GET BCM53262_A0_SGMII_CTL_GPr_PAUSE_Rf_GET
#define SGMII_CTL_GPr_PAUSE_Rf_SET BCM53262_A0_SGMII_CTL_GPr_PAUSE_Rf_SET
#define SGMII_CTL_GPr_REMOTE_FAULT_Rf_GET BCM53262_A0_SGMII_CTL_GPr_REMOTE_FAULT_Rf_GET
#define SGMII_CTL_GPr_REMOTE_FAULT_Rf_SET BCM53262_A0_SGMII_CTL_GPr_REMOTE_FAULT_Rf_SET
#define SGMII_CTL_GPr_FORCE_DATA_MODEf_GET BCM53262_A0_SGMII_CTL_GPr_FORCE_DATA_MODEf_GET
#define SGMII_CTL_GPr_FORCE_DATA_MODEf_SET BCM53262_A0_SGMII_CTL_GPr_FORCE_DATA_MODEf_SET
#define READ_SGMII_CTL_GPr BCM53262_A0_READ_SGMII_CTL_GPr
#define WRITE_SGMII_CTL_GPr BCM53262_A0_WRITE_SGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SGMII_CTL_GPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SGMII_STA_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port SGMII Status Register
 * SIZE:     16
 * FIELDS:
 *     SG_AN_ERR        To indicate AN error.
 *     SG_AN_END        To indicate AN complete.
 *     SG_MAC_ACK       Indicate the MAC acknowledge bit status.
 *     COM_DET          Indicate comma detected.
 *     R_AN_STA_LOWER   To indicate the lowest AN FSM state variable.
 *     R_AN_STA_UPPER   To indicate the highest AN FSM state variable.
 *     SGMII_EN         SGMII enable indication.
 *     PR_DUPLEX        Priority resolution for duplex indication.
 *     PR_TX_PS_EN      The result of priority resolution to enable PAUSE transmit.
 *     PR_RX_PS_EN      The result of priority resolution to enable PAUSE receive.
 */
#define BCM53262_A0_SGMII_STA_GPr 0x00190d54

#define BCM53262_A0_SGMII_STA_GPr_SIZE 2

/*
 * This structure should be used to declare and program SGMII_STA_GP.
 */
typedef union BCM53262_A0_SGMII_STA_GPr_s {
	uint32_t v[1];
	uint32_t sgmii_sta_gp[1];
	uint32_t _sgmii_sta_gp;
} BCM53262_A0_SGMII_STA_GPr_t;

#define BCM53262_A0_SGMII_STA_GPr_CLR(r) (r).sgmii_sta_gp[0] = 0
#define BCM53262_A0_SGMII_STA_GPr_SET(r,d) (r).sgmii_sta_gp[0] = d
#define BCM53262_A0_SGMII_STA_GPr_GET(r) (r).sgmii_sta_gp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SGMII_STA_GPr_SG_AN_ERRf_GET(r) (((r).sgmii_sta_gp[0]) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_SG_AN_ERRf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_SGMII_STA_GPr_SG_AN_ENDf_GET(r) ((((r).sgmii_sta_gp[0]) >> 1) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_SG_AN_ENDf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_SGMII_STA_GPr_SG_MAC_ACKf_GET(r) ((((r).sgmii_sta_gp[0]) >> 2) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_SG_MAC_ACKf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_SGMII_STA_GPr_COM_DETf_GET(r) ((((r).sgmii_sta_gp[0]) >> 3) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_COM_DETf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_SGMII_STA_GPr_R_AN_STA_LOWERf_GET(r) ((((r).sgmii_sta_gp[0]) >> 4) & 0xf)
#define BCM53262_A0_SGMII_STA_GPr_R_AN_STA_LOWERf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53262_A0_SGMII_STA_GPr_R_AN_STA_UPPERf_GET(r) ((((r).sgmii_sta_gp[0]) >> 8) & 0xf)
#define BCM53262_A0_SGMII_STA_GPr_R_AN_STA_UPPERf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53262_A0_SGMII_STA_GPr_SGMII_ENf_GET(r) ((((r).sgmii_sta_gp[0]) >> 12) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_SGMII_ENf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_SGMII_STA_GPr_PR_DUPLEXf_GET(r) ((((r).sgmii_sta_gp[0]) >> 13) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_PR_DUPLEXf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_SGMII_STA_GPr_PR_TX_PS_ENf_GET(r) ((((r).sgmii_sta_gp[0]) >> 14) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_PR_TX_PS_ENf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_SGMII_STA_GPr_PR_RX_PS_ENf_GET(r) ((((r).sgmii_sta_gp[0]) >> 15) & 0x1)
#define BCM53262_A0_SGMII_STA_GPr_PR_RX_PS_ENf_SET(r,f) (r).sgmii_sta_gp[0]=(((r).sgmii_sta_gp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access SGMII_STA_GP.
 */
#define BCM53262_A0_READ_SGMII_STA_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_SGMII_STA_GPr,(r._sgmii_sta_gp),2)
#define BCM53262_A0_WRITE_SGMII_STA_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_SGMII_STA_GPr,&(r._sgmii_sta_gp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SGMII_STA_GPr BCM53262_A0_SGMII_STA_GPr
#define SGMII_STA_GPr_SIZE BCM53262_A0_SGMII_STA_GPr_SIZE
typedef BCM53262_A0_SGMII_STA_GPr_t SGMII_STA_GPr_t;
#define SGMII_STA_GPr_CLR BCM53262_A0_SGMII_STA_GPr_CLR
#define SGMII_STA_GPr_SET BCM53262_A0_SGMII_STA_GPr_SET
#define SGMII_STA_GPr_GET BCM53262_A0_SGMII_STA_GPr_GET
#define SGMII_STA_GPr_SG_AN_ERRf_GET BCM53262_A0_SGMII_STA_GPr_SG_AN_ERRf_GET
#define SGMII_STA_GPr_SG_AN_ERRf_SET BCM53262_A0_SGMII_STA_GPr_SG_AN_ERRf_SET
#define SGMII_STA_GPr_SG_AN_ENDf_GET BCM53262_A0_SGMII_STA_GPr_SG_AN_ENDf_GET
#define SGMII_STA_GPr_SG_AN_ENDf_SET BCM53262_A0_SGMII_STA_GPr_SG_AN_ENDf_SET
#define SGMII_STA_GPr_SG_MAC_ACKf_GET BCM53262_A0_SGMII_STA_GPr_SG_MAC_ACKf_GET
#define SGMII_STA_GPr_SG_MAC_ACKf_SET BCM53262_A0_SGMII_STA_GPr_SG_MAC_ACKf_SET
#define SGMII_STA_GPr_COM_DETf_GET BCM53262_A0_SGMII_STA_GPr_COM_DETf_GET
#define SGMII_STA_GPr_COM_DETf_SET BCM53262_A0_SGMII_STA_GPr_COM_DETf_SET
#define SGMII_STA_GPr_R_AN_STA_LOWERf_GET BCM53262_A0_SGMII_STA_GPr_R_AN_STA_LOWERf_GET
#define SGMII_STA_GPr_R_AN_STA_LOWERf_SET BCM53262_A0_SGMII_STA_GPr_R_AN_STA_LOWERf_SET
#define SGMII_STA_GPr_R_AN_STA_UPPERf_GET BCM53262_A0_SGMII_STA_GPr_R_AN_STA_UPPERf_GET
#define SGMII_STA_GPr_R_AN_STA_UPPERf_SET BCM53262_A0_SGMII_STA_GPr_R_AN_STA_UPPERf_SET
#define SGMII_STA_GPr_SGMII_ENf_GET BCM53262_A0_SGMII_STA_GPr_SGMII_ENf_GET
#define SGMII_STA_GPr_SGMII_ENf_SET BCM53262_A0_SGMII_STA_GPr_SGMII_ENf_SET
#define SGMII_STA_GPr_PR_DUPLEXf_GET BCM53262_A0_SGMII_STA_GPr_PR_DUPLEXf_GET
#define SGMII_STA_GPr_PR_DUPLEXf_SET BCM53262_A0_SGMII_STA_GPr_PR_DUPLEXf_SET
#define SGMII_STA_GPr_PR_TX_PS_ENf_GET BCM53262_A0_SGMII_STA_GPr_PR_TX_PS_ENf_GET
#define SGMII_STA_GPr_PR_TX_PS_ENf_SET BCM53262_A0_SGMII_STA_GPr_PR_TX_PS_ENf_SET
#define SGMII_STA_GPr_PR_RX_PS_ENf_GET BCM53262_A0_SGMII_STA_GPr_PR_RX_PS_ENf_GET
#define SGMII_STA_GPr_PR_RX_PS_ENf_SET BCM53262_A0_SGMII_STA_GPr_PR_RX_PS_ENf_SET
#define READ_SGMII_STA_GPr BCM53262_A0_READ_SGMII_STA_GPr
#define WRITE_SGMII_STA_GPr BCM53262_A0_WRITE_SGMII_STA_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SGMII_STA_GPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     6
 * FIELDS:
 *     CPIC             Software Block Flag for CPIC
 *     EPIC             Software Block Flag for EPIC
 *     EXP              Software Block Flag for EXP
 *     GPIC             Software Block Flag for GPIC
 *     SPI              Software Block Flag for SPI
 *     SYS              Software Block Flag for SYS
 */
#define BCM53262_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM53262_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 */
typedef union BCM53262_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM53262_A0_SOFTWARE_BLOCKMAP_t;

#define BCM53262_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM53262_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM53262_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SOFTWARE_BLOCKMAP_CPICf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM53262_A0_SOFTWARE_BLOCKMAP_CPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_SOFTWARE_BLOCKMAP_EPICf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM53262_A0_SOFTWARE_BLOCKMAP_EPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_SOFTWARE_BLOCKMAP_EXPf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM53262_A0_SOFTWARE_BLOCKMAP_EXPf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_SOFTWARE_BLOCKMAP_GPICf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM53262_A0_SOFTWARE_BLOCKMAP_GPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_SOFTWARE_BLOCKMAP_SPIf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM53262_A0_SOFTWARE_BLOCKMAP_SPIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_SOFTWARE_BLOCKMAP_SYSf_GET(r) ((((r).software_blockmap[0]) >> 5) & 0x1)
#define BCM53262_A0_SOFTWARE_BLOCKMAP_SYSf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM53262_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM53262_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM53262_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM53262_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM53262_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM53262_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_CPICf_GET BCM53262_A0_SOFTWARE_BLOCKMAP_CPICf_GET
#define SOFTWARE_BLOCKMAP_CPICf_SET BCM53262_A0_SOFTWARE_BLOCKMAP_CPICf_SET
#define SOFTWARE_BLOCKMAP_EPICf_GET BCM53262_A0_SOFTWARE_BLOCKMAP_EPICf_GET
#define SOFTWARE_BLOCKMAP_EPICf_SET BCM53262_A0_SOFTWARE_BLOCKMAP_EPICf_SET
#define SOFTWARE_BLOCKMAP_EXPf_GET BCM53262_A0_SOFTWARE_BLOCKMAP_EXPf_GET
#define SOFTWARE_BLOCKMAP_EXPf_SET BCM53262_A0_SOFTWARE_BLOCKMAP_EXPf_SET
#define SOFTWARE_BLOCKMAP_GPICf_GET BCM53262_A0_SOFTWARE_BLOCKMAP_GPICf_GET
#define SOFTWARE_BLOCKMAP_GPICf_SET BCM53262_A0_SOFTWARE_BLOCKMAP_GPICf_SET
#define SOFTWARE_BLOCKMAP_SPIf_GET BCM53262_A0_SOFTWARE_BLOCKMAP_SPIf_GET
#define SOFTWARE_BLOCKMAP_SPIf_SET BCM53262_A0_SOFTWARE_BLOCKMAP_SPIf_SET
#define SOFTWARE_BLOCKMAP_SYSf_GET BCM53262_A0_SOFTWARE_BLOCKMAP_SYSf_GET
#define SOFTWARE_BLOCKMAP_SYSf_SET BCM53262_A0_SOFTWARE_BLOCKMAP_SYSf_SET
#define READ_SOFTWARE_BLOCKMAP BCM53262_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM53262_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SOFTWARE_BLOCKMAP'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SPDSTS
 * BLOCKS:   SYS
 * DESC:     Port Speed Summary Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     PORT_SPD         Port Speed.bit47~0 field indicating the operating speed for each 10/ 100BASE-T port, IMP port, giga g0~g3 (bits 0-47 = 10/ 100BASE-T ports).1'b0 = 10 Mbps1'b1 = 100 Mbpsbit57~48 field indicating the operating speed for each 10/ 100/1000 giga port (bit 48~49 = IMP Port, bits 50~51 = Giga g0 Port, bit 52~53 = Giga g1 Port, bits 54~55 = Giga g2 Port, bit 56~57 = Giga g3 Port).2'b00 = 10 Mbps2'b01 = 100 Mbps2'b10 = 1000MbpsNote that port speed for the IMP port can only be reported for an external transceiver by:(a) using the SPD# strap to pass the transceiver's default state to the BCM5348M:(b) using the CPU to read the port speed via the MDC/MDIO interface and write this back to the IMP Port Status Override register,
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_SPDSTSr 0x00000220

#define BCM53262_A0_SPDSTSr_SIZE 8

/*
 * This structure should be used to declare and program SPDSTS.
 */
typedef union BCM53262_A0_SPDSTSr_s {
	uint32_t v[2];
	uint32_t spdsts[2];
	uint32_t _spdsts;
} BCM53262_A0_SPDSTSr_t;

#define BCM53262_A0_SPDSTSr_CLR(r) CDK_MEMSET(&((r)._spdsts), 0, sizeof(BCM53262_A0_SPDSTSr_t))
#define BCM53262_A0_SPDSTSr_SET(r,i,d) (r).spdsts[i] = d
#define BCM53262_A0_SPDSTSr_GET(r,i) (r).spdsts[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SPDSTSr_RESERVED_0Rf_GET(r) (((r).spdsts[0]) & 0xffffff)
#define BCM53262_A0_SPDSTSr_RESERVED_0Rf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_SPDSTSr_PORT_SPDf_GET(r,a) cdk_field_get((r).spdsts,24,57,a)
#define BCM53262_A0_SPDSTSr_PORT_SPDf_SET(r,a) cdk_field_set((r).spdsts,24,57,a)
#define BCM53262_A0_SPDSTSr_RESERVED_1Rf_GET(r) ((((r).spdsts[1]) >> 26) & 0x3f)
#define BCM53262_A0_SPDSTSr_RESERVED_1Rf_SET(r,f) (r).spdsts[1]=(((r).spdsts[1] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access SPDSTS.
 */
#define BCM53262_A0_READ_SPDSTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_SPDSTSr,(r._spdsts),8)
#define BCM53262_A0_WRITE_SPDSTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_SPDSTSr,&(r._spdsts),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPDSTSr BCM53262_A0_SPDSTSr
#define SPDSTSr_SIZE BCM53262_A0_SPDSTSr_SIZE
typedef BCM53262_A0_SPDSTSr_t SPDSTSr_t;
#define SPDSTSr_CLR BCM53262_A0_SPDSTSr_CLR
#define SPDSTSr_SET BCM53262_A0_SPDSTSr_SET
#define SPDSTSr_GET BCM53262_A0_SPDSTSr_GET
#define SPDSTSr_RESERVED_0Rf_GET BCM53262_A0_SPDSTSr_RESERVED_0Rf_GET
#define SPDSTSr_RESERVED_0Rf_SET BCM53262_A0_SPDSTSr_RESERVED_0Rf_SET
#define SPDSTSr_PORT_SPDf_GET BCM53262_A0_SPDSTSr_PORT_SPDf_GET
#define SPDSTSr_PORT_SPDf_SET BCM53262_A0_SPDSTSr_PORT_SPDf_SET
#define SPDSTSr_RESERVED_1Rf_GET BCM53262_A0_SPDSTSr_RESERVED_1Rf_GET
#define SPDSTSr_RESERVED_1Rf_SET BCM53262_A0_SPDSTSr_RESERVED_1Rf_SET
#define READ_SPDSTSr BCM53262_A0_READ_SPDSTSr
#define WRITE_SPDSTSr BCM53262_A0_WRITE_SPDSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SPDSTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SPECIAL_MNGT
 * BLOCKS:   SYS
 * DESC:     Special Management Control Register
 * SIZE:     8
 * FIELDS:
 *     PASS_BPDU_REVMCAST When port is in spanning tree disable mode, set this bit to trap BPDU, and all reserve_mcast.Note : Reserved multicast address is 01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F.
 *     PASS_ARP         When management mode is enabled and MIRX_BCEN bit is 1'b0 (Page 01h, Offset a0h, Bit 2), set this bit to allow ARP forwarding to IMP
 *     DYN_TRUNK_SEL    optional bit to select the soultion for dyn_trunk.
 *     EN_ALL0_DA_DROP  optional bit to process MAC_DA = 48'h0000_0000_0000.
 *     BYPASS_SPT_CHK   When set to 1'b1, incoming packet with DA = 01-80-c2-00-00-00 ~ 01-80-c2-00-00-10 will bypass spanning tree state schecking.
 *     EN_ARP_BYPASS_VLAN 0 : ARP frame will flood in VLAN domain but not send to IMP if IMP not in the same VLAN. (default)1 : ARP frame will flood in VLAN domain and copy to IMP even IMP is not in VLAN group.
 *     GIGA_PREFETCH_CTL Pre-fetch control for giga port.Test only.  Not to release to customers.
 *     IMP_PREFETCH_CTL Pre-fetch control for IMP port.Test only.  Not to release to customers.
 */
#define BCM53262_A0_SPECIAL_MNGTr 0x00000340

#define BCM53262_A0_SPECIAL_MNGTr_SIZE 1

/*
 * This structure should be used to declare and program SPECIAL_MNGT.
 */
typedef union BCM53262_A0_SPECIAL_MNGTr_s {
	uint32_t v[1];
	uint32_t special_mngt[1];
	uint32_t _special_mngt;
} BCM53262_A0_SPECIAL_MNGTr_t;

#define BCM53262_A0_SPECIAL_MNGTr_CLR(r) (r).special_mngt[0] = 0
#define BCM53262_A0_SPECIAL_MNGTr_SET(r,d) (r).special_mngt[0] = d
#define BCM53262_A0_SPECIAL_MNGTr_GET(r) (r).special_mngt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SPECIAL_MNGTr_PASS_BPDU_REVMCASTf_GET(r) (((r).special_mngt[0]) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_PASS_BPDU_REVMCASTf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_SPECIAL_MNGTr_PASS_ARPf_GET(r) ((((r).special_mngt[0]) >> 1) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_PASS_ARPf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_SPECIAL_MNGTr_DYN_TRUNK_SELf_GET(r) ((((r).special_mngt[0]) >> 2) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_DYN_TRUNK_SELf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_GET(r) ((((r).special_mngt[0]) >> 3) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_SPECIAL_MNGTr_BYPASS_SPT_CHKf_GET(r) ((((r).special_mngt[0]) >> 4) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_BYPASS_SPT_CHKf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_SPECIAL_MNGTr_EN_ARP_BYPASS_VLANf_GET(r) ((((r).special_mngt[0]) >> 5) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_EN_ARP_BYPASS_VLANf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_SPECIAL_MNGTr_GIGA_PREFETCH_CTLf_GET(r) ((((r).special_mngt[0]) >> 6) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_GIGA_PREFETCH_CTLf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_SPECIAL_MNGTr_IMP_PREFETCH_CTLf_GET(r) ((((r).special_mngt[0]) >> 7) & 0x1)
#define BCM53262_A0_SPECIAL_MNGTr_IMP_PREFETCH_CTLf_SET(r,f) (r).special_mngt[0]=(((r).special_mngt[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access SPECIAL_MNGT.
 */
#define BCM53262_A0_READ_SPECIAL_MNGTr(u,r) cdk_robo_reg_read(u,BCM53262_A0_SPECIAL_MNGTr,(r._special_mngt),1)
#define BCM53262_A0_WRITE_SPECIAL_MNGTr(u,r) cdk_robo_reg_write(u,BCM53262_A0_SPECIAL_MNGTr,&(r._special_mngt),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPECIAL_MNGTr BCM53262_A0_SPECIAL_MNGTr
#define SPECIAL_MNGTr_SIZE BCM53262_A0_SPECIAL_MNGTr_SIZE
typedef BCM53262_A0_SPECIAL_MNGTr_t SPECIAL_MNGTr_t;
#define SPECIAL_MNGTr_CLR BCM53262_A0_SPECIAL_MNGTr_CLR
#define SPECIAL_MNGTr_SET BCM53262_A0_SPECIAL_MNGTr_SET
#define SPECIAL_MNGTr_GET BCM53262_A0_SPECIAL_MNGTr_GET
#define SPECIAL_MNGTr_PASS_BPDU_REVMCASTf_GET BCM53262_A0_SPECIAL_MNGTr_PASS_BPDU_REVMCASTf_GET
#define SPECIAL_MNGTr_PASS_BPDU_REVMCASTf_SET BCM53262_A0_SPECIAL_MNGTr_PASS_BPDU_REVMCASTf_SET
#define SPECIAL_MNGTr_PASS_ARPf_GET BCM53262_A0_SPECIAL_MNGTr_PASS_ARPf_GET
#define SPECIAL_MNGTr_PASS_ARPf_SET BCM53262_A0_SPECIAL_MNGTr_PASS_ARPf_SET
#define SPECIAL_MNGTr_DYN_TRUNK_SELf_GET BCM53262_A0_SPECIAL_MNGTr_DYN_TRUNK_SELf_GET
#define SPECIAL_MNGTr_DYN_TRUNK_SELf_SET BCM53262_A0_SPECIAL_MNGTr_DYN_TRUNK_SELf_SET
#define SPECIAL_MNGTr_EN_ALL0_DA_DROPf_GET BCM53262_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_GET
#define SPECIAL_MNGTr_EN_ALL0_DA_DROPf_SET BCM53262_A0_SPECIAL_MNGTr_EN_ALL0_DA_DROPf_SET
#define SPECIAL_MNGTr_BYPASS_SPT_CHKf_GET BCM53262_A0_SPECIAL_MNGTr_BYPASS_SPT_CHKf_GET
#define SPECIAL_MNGTr_BYPASS_SPT_CHKf_SET BCM53262_A0_SPECIAL_MNGTr_BYPASS_SPT_CHKf_SET
#define SPECIAL_MNGTr_EN_ARP_BYPASS_VLANf_GET BCM53262_A0_SPECIAL_MNGTr_EN_ARP_BYPASS_VLANf_GET
#define SPECIAL_MNGTr_EN_ARP_BYPASS_VLANf_SET BCM53262_A0_SPECIAL_MNGTr_EN_ARP_BYPASS_VLANf_SET
#define SPECIAL_MNGTr_GIGA_PREFETCH_CTLf_GET BCM53262_A0_SPECIAL_MNGTr_GIGA_PREFETCH_CTLf_GET
#define SPECIAL_MNGTr_GIGA_PREFETCH_CTLf_SET BCM53262_A0_SPECIAL_MNGTr_GIGA_PREFETCH_CTLf_SET
#define SPECIAL_MNGTr_IMP_PREFETCH_CTLf_GET BCM53262_A0_SPECIAL_MNGTr_IMP_PREFETCH_CTLf_GET
#define SPECIAL_MNGTr_IMP_PREFETCH_CTLf_SET BCM53262_A0_SPECIAL_MNGTr_IMP_PREFETCH_CTLf_SET
#define READ_SPECIAL_MNGTr BCM53262_A0_READ_SPECIAL_MNGTr
#define WRITE_SPECIAL_MNGTr BCM53262_A0_WRITE_SPECIAL_MNGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SPECIAL_MNGTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SPTAGT
 * BLOCKS:   SYS
 * DESC:     Aging Time Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_TIME         Specifies the aging time in seconds for dynamically learned address.Maximum age time is 1,048,575 s. Note that while 802.1D specifiesa range of values of 10 - 1,000,000 s, this register does not enforcethis range. Setting the AGE_TIME to zero disables the aging process.
 *     SPTAGT_RSRV0     Reserved
 */
#define BCM53262_A0_SPTAGTr 0x00000304

#define BCM53262_A0_SPTAGTr_SIZE 4

/*
 * This structure should be used to declare and program SPTAGT.
 */
typedef union BCM53262_A0_SPTAGTr_s {
	uint32_t v[1];
	uint32_t sptagt[1];
	uint32_t _sptagt;
} BCM53262_A0_SPTAGTr_t;

#define BCM53262_A0_SPTAGTr_CLR(r) (r).sptagt[0] = 0
#define BCM53262_A0_SPTAGTr_SET(r,d) (r).sptagt[0] = d
#define BCM53262_A0_SPTAGTr_GET(r) (r).sptagt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SPTAGTr_AGE_TIMEf_GET(r) (((r).sptagt[0]) & 0xfffff)
#define BCM53262_A0_SPTAGTr_AGE_TIMEf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53262_A0_SPTAGTr_SPTAGT_RSRV0f_GET(r) ((((r).sptagt[0]) >> 20) & 0xfff)
#define BCM53262_A0_SPTAGTr_SPTAGT_RSRV0f_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access SPTAGT.
 */
#define BCM53262_A0_READ_SPTAGTr(u,r) cdk_robo_reg_read(u,BCM53262_A0_SPTAGTr,(r._sptagt),4)
#define BCM53262_A0_WRITE_SPTAGTr(u,r) cdk_robo_reg_write(u,BCM53262_A0_SPTAGTr,&(r._sptagt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPTAGTr BCM53262_A0_SPTAGTr
#define SPTAGTr_SIZE BCM53262_A0_SPTAGTr_SIZE
typedef BCM53262_A0_SPTAGTr_t SPTAGTr_t;
#define SPTAGTr_CLR BCM53262_A0_SPTAGTr_CLR
#define SPTAGTr_SET BCM53262_A0_SPTAGTr_SET
#define SPTAGTr_GET BCM53262_A0_SPTAGTr_GET
#define SPTAGTr_AGE_TIMEf_GET BCM53262_A0_SPTAGTr_AGE_TIMEf_GET
#define SPTAGTr_AGE_TIMEf_SET BCM53262_A0_SPTAGTr_AGE_TIMEf_SET
#define SPTAGTr_SPTAGT_RSRV0f_GET BCM53262_A0_SPTAGTr_SPTAGT_RSRV0f_GET
#define SPTAGTr_SPTAGT_RSRV0f_SET BCM53262_A0_SPTAGTr_SPTAGT_RSRV0f_SET
#define READ_SPTAGTr BCM53262_A0_READ_SPTAGTr
#define WRITE_SPTAGTr BCM53262_A0_WRITE_SPTAGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SPTAGTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  STRAP_STS
 * BLOCKS:   SYS
 * DESC:     Strap Status Register
 * SIZE:     32
 * FIELDS:
 *     ENFDXFLOW        Full Duplex port Flow Control Enable and Giga port TX Flow Control Enable.
 *     ENHDXFLOW        Half Duplex port Flow Control Enable.
 *     MEMFREQ          for BCM532622'b00 : sysclk is 100 MHz.2'b01 : sysclk is 105 MHz.2'b10 : sysclk is 111 MHz.2'b11 : sysclk is 125 MHz.for BCM532421'b0 : sysclk is 100 MHz.1'b1 : sysclk is 111 MHz.
 *     HW_FWDG_EN       1 : forwarding process enable.0 : turn off forwarding process. Assertion for dumb switch
 *     EN_GRX_FLOW      Full Duplex giga port RX Flow Control Enable.
 *     LEDMODE          LED modes.For BCM53262 : ledmode is bits[7:6].For BCM53242 : ledmode is bits[8:6].
 *     MDIX_DIS         Disable PHY MDIX function.
 *     SKIP_SRAMBIST    Turn off BIST/Memory clear function.
 *     BIST_CLRMEM      '1' select the BIST function,'0' selecl the memory clear function.
 *     RESERVED_0R      Reserved.
 *     PHY_POLL_DIS     0 : enable external EPHY/EGPHY polling,1 : disable external EPHY/EGPHY polling.
 *     STRAP_STS        For BCM53262 :Bits[16:15] CPU_EPROM.Bits[18:17] Reserved.Bits[19]    EB_16BIT.Bits[21:20] GIGA_IMP_IFSEL.CPU_EPROM :11 : EB bus interface.10 : Reserved.01 : CPU port play SPI interface,00 : CPU port plays EPROM interface.EB_16BIT :EB bus mode.0 : EB for 8bit mode.1 : EB for 16bit mode.GIGA_IMP_IFSEL :00 : RGMII01 : MII10 : RVMII11 : GMIIFor BCM53242 :Bits[15]    CPU_EPROM.Bits[17:16] GIGA0_IFSEL.Bits[19:18] GIGA1_IFSEL.Bits[20]    Reserved.Bits[21]    RVS_MII_EN.CPU_EPROM :1 : CPU port play SPI interface.0 : CPU port plays EPROM interface.GIGA_IFSEL :00 : RGMII01 : TBI10 : GMII11 : MIIRVS_MII_EN :1 : enable rmii mode for MII port.
 *     RESERVED_1R      Reserved.
 *     EN_EXTCLK        For BCM53262 :0 : disable external clk,1 : enable external clk.For BCM53242 :Reserved.
 *     EN_SYSCLK_PROBE  For BCM53262 :0 : disable sysclk probe1 : enable sysclk probeFor BCM53242 :Reserved.
 *     RESERVED_2R      Reserved.
 *     WRALLPHY         Update all PHY in the same time.
 *     RESERVED_3R      Reserved.
 */
#define BCM53262_A0_STRAP_STSr 0x00000050

#define BCM53262_A0_STRAP_STSr_SIZE 4

/*
 * This structure should be used to declare and program STRAP_STS.
 */
typedef union BCM53262_A0_STRAP_STSr_s {
	uint32_t v[1];
	uint32_t strap_sts[1];
	uint32_t _strap_sts;
} BCM53262_A0_STRAP_STSr_t;

#define BCM53262_A0_STRAP_STSr_CLR(r) (r).strap_sts[0] = 0
#define BCM53262_A0_STRAP_STSr_SET(r,d) (r).strap_sts[0] = d
#define BCM53262_A0_STRAP_STSr_GET(r) (r).strap_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_STRAP_STSr_ENFDXFLOWf_GET(r) (((r).strap_sts[0]) & 0x1)
#define BCM53262_A0_STRAP_STSr_ENFDXFLOWf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_STRAP_STSr_ENHDXFLOWf_GET(r) ((((r).strap_sts[0]) >> 1) & 0x1)
#define BCM53262_A0_STRAP_STSr_ENHDXFLOWf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_STRAP_STSr_MEMFREQf_GET(r) ((((r).strap_sts[0]) >> 2) & 0x3)
#define BCM53262_A0_STRAP_STSr_MEMFREQf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_STRAP_STSr_HW_FWDG_ENf_GET(r) ((((r).strap_sts[0]) >> 4) & 0x1)
#define BCM53262_A0_STRAP_STSr_HW_FWDG_ENf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_STRAP_STSr_EN_GRX_FLOWf_GET(r) ((((r).strap_sts[0]) >> 5) & 0x1)
#define BCM53262_A0_STRAP_STSr_EN_GRX_FLOWf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_STRAP_STSr_LEDMODEf_GET(r) ((((r).strap_sts[0]) >> 6) & 0x7)
#define BCM53262_A0_STRAP_STSr_LEDMODEf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53262_A0_STRAP_STSr_MDIX_DISf_GET(r) ((((r).strap_sts[0]) >> 9) & 0x1)
#define BCM53262_A0_STRAP_STSr_MDIX_DISf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_STRAP_STSr_SKIP_SRAMBISTf_GET(r) ((((r).strap_sts[0]) >> 10) & 0x1)
#define BCM53262_A0_STRAP_STSr_SKIP_SRAMBISTf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_STRAP_STSr_BIST_CLRMEMf_GET(r) ((((r).strap_sts[0]) >> 11) & 0x1)
#define BCM53262_A0_STRAP_STSr_BIST_CLRMEMf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_STRAP_STSr_RESERVED_0Rf_GET(r) ((((r).strap_sts[0]) >> 12) & 0x3)
#define BCM53262_A0_STRAP_STSr_RESERVED_0Rf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_STRAP_STSr_PHY_POLL_DISf_GET(r) ((((r).strap_sts[0]) >> 14) & 0x1)
#define BCM53262_A0_STRAP_STSr_PHY_POLL_DISf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_STRAP_STSr_STRAP_STSf_GET(r) ((((r).strap_sts[0]) >> 15) & 0x7f)
#define BCM53262_A0_STRAP_STSr_STRAP_STSf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53262_A0_STRAP_STSr_RESERVED_1Rf_GET(r) ((((r).strap_sts[0]) >> 22) & 0x7)
#define BCM53262_A0_STRAP_STSr_RESERVED_1Rf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM53262_A0_STRAP_STSr_EN_EXTCLKf_GET(r) ((((r).strap_sts[0]) >> 25) & 0x1)
#define BCM53262_A0_STRAP_STSr_EN_EXTCLKf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53262_A0_STRAP_STSr_EN_SYSCLK_PROBEf_GET(r) ((((r).strap_sts[0]) >> 26) & 0x1)
#define BCM53262_A0_STRAP_STSr_EN_SYSCLK_PROBEf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53262_A0_STRAP_STSr_RESERVED_2Rf_GET(r) ((((r).strap_sts[0]) >> 27) & 0x1)
#define BCM53262_A0_STRAP_STSr_RESERVED_2Rf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53262_A0_STRAP_STSr_WRALLPHYf_GET(r) ((((r).strap_sts[0]) >> 28) & 0x1)
#define BCM53262_A0_STRAP_STSr_WRALLPHYf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53262_A0_STRAP_STSr_RESERVED_3Rf_GET(r) ((((r).strap_sts[0]) >> 29) & 0x7)
#define BCM53262_A0_STRAP_STSr_RESERVED_3Rf_SET(r,f) (r).strap_sts[0]=(((r).strap_sts[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access STRAP_STS.
 */
#define BCM53262_A0_READ_STRAP_STSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_STRAP_STSr,(r._strap_sts),4)
#define BCM53262_A0_WRITE_STRAP_STSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_STRAP_STSr,&(r._strap_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STRAP_STSr BCM53262_A0_STRAP_STSr
#define STRAP_STSr_SIZE BCM53262_A0_STRAP_STSr_SIZE
typedef BCM53262_A0_STRAP_STSr_t STRAP_STSr_t;
#define STRAP_STSr_CLR BCM53262_A0_STRAP_STSr_CLR
#define STRAP_STSr_SET BCM53262_A0_STRAP_STSr_SET
#define STRAP_STSr_GET BCM53262_A0_STRAP_STSr_GET
#define STRAP_STSr_ENFDXFLOWf_GET BCM53262_A0_STRAP_STSr_ENFDXFLOWf_GET
#define STRAP_STSr_ENFDXFLOWf_SET BCM53262_A0_STRAP_STSr_ENFDXFLOWf_SET
#define STRAP_STSr_ENHDXFLOWf_GET BCM53262_A0_STRAP_STSr_ENHDXFLOWf_GET
#define STRAP_STSr_ENHDXFLOWf_SET BCM53262_A0_STRAP_STSr_ENHDXFLOWf_SET
#define STRAP_STSr_MEMFREQf_GET BCM53262_A0_STRAP_STSr_MEMFREQf_GET
#define STRAP_STSr_MEMFREQf_SET BCM53262_A0_STRAP_STSr_MEMFREQf_SET
#define STRAP_STSr_HW_FWDG_ENf_GET BCM53262_A0_STRAP_STSr_HW_FWDG_ENf_GET
#define STRAP_STSr_HW_FWDG_ENf_SET BCM53262_A0_STRAP_STSr_HW_FWDG_ENf_SET
#define STRAP_STSr_EN_GRX_FLOWf_GET BCM53262_A0_STRAP_STSr_EN_GRX_FLOWf_GET
#define STRAP_STSr_EN_GRX_FLOWf_SET BCM53262_A0_STRAP_STSr_EN_GRX_FLOWf_SET
#define STRAP_STSr_LEDMODEf_GET BCM53262_A0_STRAP_STSr_LEDMODEf_GET
#define STRAP_STSr_LEDMODEf_SET BCM53262_A0_STRAP_STSr_LEDMODEf_SET
#define STRAP_STSr_MDIX_DISf_GET BCM53262_A0_STRAP_STSr_MDIX_DISf_GET
#define STRAP_STSr_MDIX_DISf_SET BCM53262_A0_STRAP_STSr_MDIX_DISf_SET
#define STRAP_STSr_SKIP_SRAMBISTf_GET BCM53262_A0_STRAP_STSr_SKIP_SRAMBISTf_GET
#define STRAP_STSr_SKIP_SRAMBISTf_SET BCM53262_A0_STRAP_STSr_SKIP_SRAMBISTf_SET
#define STRAP_STSr_BIST_CLRMEMf_GET BCM53262_A0_STRAP_STSr_BIST_CLRMEMf_GET
#define STRAP_STSr_BIST_CLRMEMf_SET BCM53262_A0_STRAP_STSr_BIST_CLRMEMf_SET
#define STRAP_STSr_RESERVED_0Rf_GET BCM53262_A0_STRAP_STSr_RESERVED_0Rf_GET
#define STRAP_STSr_RESERVED_0Rf_SET BCM53262_A0_STRAP_STSr_RESERVED_0Rf_SET
#define STRAP_STSr_PHY_POLL_DISf_GET BCM53262_A0_STRAP_STSr_PHY_POLL_DISf_GET
#define STRAP_STSr_PHY_POLL_DISf_SET BCM53262_A0_STRAP_STSr_PHY_POLL_DISf_SET
#define STRAP_STSr_STRAP_STSf_GET BCM53262_A0_STRAP_STSr_STRAP_STSf_GET
#define STRAP_STSr_STRAP_STSf_SET BCM53262_A0_STRAP_STSr_STRAP_STSf_SET
#define STRAP_STSr_RESERVED_1Rf_GET BCM53262_A0_STRAP_STSr_RESERVED_1Rf_GET
#define STRAP_STSr_RESERVED_1Rf_SET BCM53262_A0_STRAP_STSr_RESERVED_1Rf_SET
#define STRAP_STSr_EN_EXTCLKf_GET BCM53262_A0_STRAP_STSr_EN_EXTCLKf_GET
#define STRAP_STSr_EN_EXTCLKf_SET BCM53262_A0_STRAP_STSr_EN_EXTCLKf_SET
#define STRAP_STSr_EN_SYSCLK_PROBEf_GET BCM53262_A0_STRAP_STSr_EN_SYSCLK_PROBEf_GET
#define STRAP_STSr_EN_SYSCLK_PROBEf_SET BCM53262_A0_STRAP_STSr_EN_SYSCLK_PROBEf_SET
#define STRAP_STSr_RESERVED_2Rf_GET BCM53262_A0_STRAP_STSr_RESERVED_2Rf_GET
#define STRAP_STSr_RESERVED_2Rf_SET BCM53262_A0_STRAP_STSr_RESERVED_2Rf_SET
#define STRAP_STSr_WRALLPHYf_GET BCM53262_A0_STRAP_STSr_WRALLPHYf_GET
#define STRAP_STSr_WRALLPHYf_SET BCM53262_A0_STRAP_STSr_WRALLPHYf_SET
#define STRAP_STSr_RESERVED_3Rf_GET BCM53262_A0_STRAP_STSr_RESERVED_3Rf_GET
#define STRAP_STSr_RESERVED_3Rf_SET BCM53262_A0_STRAP_STSr_RESERVED_3Rf_SET
#define READ_STRAP_STSr BCM53262_A0_READ_STRAP_STSr
#define WRITE_STRAP_STSr BCM53262_A0_WRITE_STRAP_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_STRAP_STSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  STS_CTL
 * BLOCKS:   SYS
 * DESC:     Status Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_IMPRX_PAUSE_NOTAG 
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_STS_CTLr 0x000001b0

#define BCM53262_A0_STS_CTLr_SIZE 1

/*
 * This structure should be used to declare and program STS_CTL.
 */
typedef union BCM53262_A0_STS_CTLr_s {
	uint32_t v[1];
	uint32_t sts_ctl[1];
	uint32_t _sts_ctl;
} BCM53262_A0_STS_CTLr_t;

#define BCM53262_A0_STS_CTLr_CLR(r) (r).sts_ctl[0] = 0
#define BCM53262_A0_STS_CTLr_SET(r,d) (r).sts_ctl[0] = d
#define BCM53262_A0_STS_CTLr_GET(r) (r).sts_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_STS_CTLr_EN_IMPRX_PAUSE_NOTAGf_GET(r) (((r).sts_ctl[0]) & 0x1)
#define BCM53262_A0_STS_CTLr_EN_IMPRX_PAUSE_NOTAGf_SET(r,f) (r).sts_ctl[0]=(((r).sts_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_STS_CTLr_RESERVED_Rf_GET(r) ((((r).sts_ctl[0]) >> 1) & 0x7f)
#define BCM53262_A0_STS_CTLr_RESERVED_Rf_SET(r,f) (r).sts_ctl[0]=(((r).sts_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access STS_CTL.
 */
#define BCM53262_A0_READ_STS_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_STS_CTLr,(r._sts_ctl),1)
#define BCM53262_A0_WRITE_STS_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_STS_CTLr,&(r._sts_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_CTLr BCM53262_A0_STS_CTLr
#define STS_CTLr_SIZE BCM53262_A0_STS_CTLr_SIZE
typedef BCM53262_A0_STS_CTLr_t STS_CTLr_t;
#define STS_CTLr_CLR BCM53262_A0_STS_CTLr_CLR
#define STS_CTLr_SET BCM53262_A0_STS_CTLr_SET
#define STS_CTLr_GET BCM53262_A0_STS_CTLr_GET
#define STS_CTLr_EN_IMPRX_PAUSE_NOTAGf_GET BCM53262_A0_STS_CTLr_EN_IMPRX_PAUSE_NOTAGf_GET
#define STS_CTLr_EN_IMPRX_PAUSE_NOTAGf_SET BCM53262_A0_STS_CTLr_EN_IMPRX_PAUSE_NOTAGf_SET
#define STS_CTLr_RESERVED_Rf_GET BCM53262_A0_STS_CTLr_RESERVED_Rf_GET
#define STS_CTLr_RESERVED_Rf_SET BCM53262_A0_STS_CTLr_RESERVED_Rf_SET
#define READ_STS_CTLr BCM53262_A0_READ_STS_CTLr
#define WRITE_STS_CTLr BCM53262_A0_WRITE_STS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_STS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  STS_OVERRIDE_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex,1: Full Duplex.
 *     GIGA_SPEED       Software Port Speed setting2'b10 : 1000M2'b01: 100M2'b00 : 10M
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_ORD           PHY scan register will be override.
 *     EN_PHY_SCAN      Enable External Phy Scan
 */
#define BCM53262_A0_STS_OVERRIDE_GPr 0x00190141

#define BCM53262_A0_STS_OVERRIDE_GPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_GP.
 */
typedef union BCM53262_A0_STS_OVERRIDE_GPr_s {
	uint32_t v[1];
	uint32_t sts_override_gp[1];
	uint32_t _sts_override_gp;
} BCM53262_A0_STS_OVERRIDE_GPr_t;

#define BCM53262_A0_STS_OVERRIDE_GPr_CLR(r) (r).sts_override_gp[0] = 0
#define BCM53262_A0_STS_OVERRIDE_GPr_SET(r,d) (r).sts_override_gp[0] = d
#define BCM53262_A0_STS_OVERRIDE_GPr_GET(r) (r).sts_override_gp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_STS_OVERRIDE_GPr_LINK_STSf_GET(r) (((r).sts_override_gp[0]) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_GPr_LINK_STSf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_GET(r) ((((r).sts_override_gp[0]) >> 1) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_GET(r) ((((r).sts_override_gp[0]) >> 2) & 0x3)
#define BCM53262_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_gp[0]) >> 4) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_gp[0]) >> 5) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_STS_OVERRIDE_GPr_SW_ORDf_GET(r) ((((r).sts_override_gp[0]) >> 6) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_GPr_SW_ORDf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_GET(r) ((((r).sts_override_gp[0]) >> 7) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_GP.
 */
#define BCM53262_A0_READ_STS_OVERRIDE_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_STS_OVERRIDE_GPr,(r._sts_override_gp),1)
#define BCM53262_A0_WRITE_STS_OVERRIDE_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_STS_OVERRIDE_GPr,&(r._sts_override_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_GPr BCM53262_A0_STS_OVERRIDE_GPr
#define STS_OVERRIDE_GPr_SIZE BCM53262_A0_STS_OVERRIDE_GPr_SIZE
typedef BCM53262_A0_STS_OVERRIDE_GPr_t STS_OVERRIDE_GPr_t;
#define STS_OVERRIDE_GPr_CLR BCM53262_A0_STS_OVERRIDE_GPr_CLR
#define STS_OVERRIDE_GPr_SET BCM53262_A0_STS_OVERRIDE_GPr_SET
#define STS_OVERRIDE_GPr_GET BCM53262_A0_STS_OVERRIDE_GPr_GET
#define STS_OVERRIDE_GPr_LINK_STSf_GET BCM53262_A0_STS_OVERRIDE_GPr_LINK_STSf_GET
#define STS_OVERRIDE_GPr_LINK_STSf_SET BCM53262_A0_STS_OVERRIDE_GPr_LINK_STSf_SET
#define STS_OVERRIDE_GPr_DUPLX_MODEf_GET BCM53262_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_GPr_DUPLX_MODEf_SET BCM53262_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_GPr_GIGA_SPEEDf_GET BCM53262_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_GET
#define STS_OVERRIDE_GPr_GIGA_SPEEDf_SET BCM53262_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_SET
#define STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET BCM53262_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET BCM53262_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET BCM53262_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET BCM53262_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_GPr_SW_ORDf_GET BCM53262_A0_STS_OVERRIDE_GPr_SW_ORDf_GET
#define STS_OVERRIDE_GPr_SW_ORDf_SET BCM53262_A0_STS_OVERRIDE_GPr_SW_ORDf_SET
#define STS_OVERRIDE_GPr_EN_PHY_SCANf_GET BCM53262_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_GET
#define STS_OVERRIDE_GPr_EN_PHY_SCANf_SET BCM53262_A0_STS_OVERRIDE_GPr_EN_PHY_SCANf_SET
#define READ_STS_OVERRIDE_GPr BCM53262_A0_READ_STS_OVERRIDE_GPr
#define WRITE_STS_OVERRIDE_GPr BCM53262_A0_WRITE_STS_OVERRIDE_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_STS_OVERRIDE_GPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  STS_OVERRIDE_IMP
 * BLOCKS:   CPIC
 * DESC:     MII Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex,1: Full Duplex.
 *     GIGA_SPEED       Software Port Speed setting2'b10 : 1000M2'b01: 100M2'b00 : 10M
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_ORD           PHY scan register will be override.
 *     EN_PHY_SCAN      Enable External Phy Scan
 */
#define BCM53262_A0_STS_OVERRIDE_IMPr 0x00000140

#define BCM53262_A0_STS_OVERRIDE_IMPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_IMP.
 */
typedef union BCM53262_A0_STS_OVERRIDE_IMPr_s {
	uint32_t v[1];
	uint32_t sts_override_imp[1];
	uint32_t _sts_override_imp;
} BCM53262_A0_STS_OVERRIDE_IMPr_t;

#define BCM53262_A0_STS_OVERRIDE_IMPr_CLR(r) (r).sts_override_imp[0] = 0
#define BCM53262_A0_STS_OVERRIDE_IMPr_SET(r,d) (r).sts_override_imp[0] = d
#define BCM53262_A0_STS_OVERRIDE_IMPr_GET(r) (r).sts_override_imp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET(r) (((r).sts_override_imp[0]) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET(r) ((((r).sts_override_imp[0]) >> 1) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_STS_OVERRIDE_IMPr_GIGA_SPEEDf_GET(r) ((((r).sts_override_imp[0]) >> 2) & 0x3)
#define BCM53262_A0_STS_OVERRIDE_IMPr_GIGA_SPEEDf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 4) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 5) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_STS_OVERRIDE_IMPr_SW_ORDf_GET(r) ((((r).sts_override_imp[0]) >> 6) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_IMPr_SW_ORDf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_STS_OVERRIDE_IMPr_EN_PHY_SCANf_GET(r) ((((r).sts_override_imp[0]) >> 7) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_IMPr_EN_PHY_SCANf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_IMP.
 */
#define BCM53262_A0_READ_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_STS_OVERRIDE_IMPr,(r._sts_override_imp),1)
#define BCM53262_A0_WRITE_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_STS_OVERRIDE_IMPr,&(r._sts_override_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_IMPr BCM53262_A0_STS_OVERRIDE_IMPr
#define STS_OVERRIDE_IMPr_SIZE BCM53262_A0_STS_OVERRIDE_IMPr_SIZE
typedef BCM53262_A0_STS_OVERRIDE_IMPr_t STS_OVERRIDE_IMPr_t;
#define STS_OVERRIDE_IMPr_CLR BCM53262_A0_STS_OVERRIDE_IMPr_CLR
#define STS_OVERRIDE_IMPr_SET BCM53262_A0_STS_OVERRIDE_IMPr_SET
#define STS_OVERRIDE_IMPr_GET BCM53262_A0_STS_OVERRIDE_IMPr_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_GET BCM53262_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_SET BCM53262_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_GET BCM53262_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_SET BCM53262_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_IMPr_GIGA_SPEEDf_GET BCM53262_A0_STS_OVERRIDE_IMPr_GIGA_SPEEDf_GET
#define STS_OVERRIDE_IMPr_GIGA_SPEEDf_SET BCM53262_A0_STS_OVERRIDE_IMPr_GIGA_SPEEDf_SET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET BCM53262_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET BCM53262_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET BCM53262_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET BCM53262_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_SW_ORDf_GET BCM53262_A0_STS_OVERRIDE_IMPr_SW_ORDf_GET
#define STS_OVERRIDE_IMPr_SW_ORDf_SET BCM53262_A0_STS_OVERRIDE_IMPr_SW_ORDf_SET
#define STS_OVERRIDE_IMPr_EN_PHY_SCANf_GET BCM53262_A0_STS_OVERRIDE_IMPr_EN_PHY_SCANf_GET
#define STS_OVERRIDE_IMPr_EN_PHY_SCANf_SET BCM53262_A0_STS_OVERRIDE_IMPr_EN_PHY_SCANf_SET
#define READ_STS_OVERRIDE_IMPr BCM53262_A0_READ_STS_OVERRIDE_IMPr
#define WRITE_STS_OVERRIDE_IMPr BCM53262_A0_WRITE_STS_OVERRIDE_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_STS_OVERRIDE_IMPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  STS_OVERRIDE_P
 * BLOCKS:   EPIC0
 * DESC:     MII Port N States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED_R          Software Port Speed setting1'b1: 100M1'b0 : 10M
 *     RESERVED_0R      Reserved
 *     FLOW_CNTL        Software Flow Control Enable
 *     SW_ORD           PHY scan register will be override.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_STS_OVERRIDE_Pr 0x00000128

#define BCM53262_A0_STS_OVERRIDE_Pr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_P.
 */
typedef union BCM53262_A0_STS_OVERRIDE_Pr_s {
	uint32_t v[1];
	uint32_t sts_override_p[1];
	uint32_t _sts_override_p;
} BCM53262_A0_STS_OVERRIDE_Pr_t;

#define BCM53262_A0_STS_OVERRIDE_Pr_CLR(r) (r).sts_override_p[0] = 0
#define BCM53262_A0_STS_OVERRIDE_Pr_SET(r,d) (r).sts_override_p[0] = d
#define BCM53262_A0_STS_OVERRIDE_Pr_GET(r) (r).sts_override_p[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_STS_OVERRIDE_Pr_LINK_STSf_GET(r) (((r).sts_override_p[0]) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_Pr_LINK_STSf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_GET(r) ((((r).sts_override_p[0]) >> 1) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_STS_OVERRIDE_Pr_SPEED_Rf_GET(r) ((((r).sts_override_p[0]) >> 2) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_Pr_SPEED_Rf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_0Rf_GET(r) ((((r).sts_override_p[0]) >> 3) & 0x3)
#define BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_0Rf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53262_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_GET(r) ((((r).sts_override_p[0]) >> 5) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_STS_OVERRIDE_Pr_SW_ORDf_GET(r) ((((r).sts_override_p[0]) >> 6) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_Pr_SW_ORDf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_1Rf_GET(r) ((((r).sts_override_p[0]) >> 7) & 0x1)
#define BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_1Rf_SET(r,f) (r).sts_override_p[0]=(((r).sts_override_p[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_P.
 */
#define BCM53262_A0_READ_STS_OVERRIDE_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_STS_OVERRIDE_Pr,(r._sts_override_p),1)
#define BCM53262_A0_WRITE_STS_OVERRIDE_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_STS_OVERRIDE_Pr,&(r._sts_override_p),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_Pr BCM53262_A0_STS_OVERRIDE_Pr
#define STS_OVERRIDE_Pr_SIZE BCM53262_A0_STS_OVERRIDE_Pr_SIZE
typedef BCM53262_A0_STS_OVERRIDE_Pr_t STS_OVERRIDE_Pr_t;
#define STS_OVERRIDE_Pr_CLR BCM53262_A0_STS_OVERRIDE_Pr_CLR
#define STS_OVERRIDE_Pr_SET BCM53262_A0_STS_OVERRIDE_Pr_SET
#define STS_OVERRIDE_Pr_GET BCM53262_A0_STS_OVERRIDE_Pr_GET
#define STS_OVERRIDE_Pr_LINK_STSf_GET BCM53262_A0_STS_OVERRIDE_Pr_LINK_STSf_GET
#define STS_OVERRIDE_Pr_LINK_STSf_SET BCM53262_A0_STS_OVERRIDE_Pr_LINK_STSf_SET
#define STS_OVERRIDE_Pr_DUPLX_MODEf_GET BCM53262_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_GET
#define STS_OVERRIDE_Pr_DUPLX_MODEf_SET BCM53262_A0_STS_OVERRIDE_Pr_DUPLX_MODEf_SET
#define STS_OVERRIDE_Pr_SPEED_Rf_GET BCM53262_A0_STS_OVERRIDE_Pr_SPEED_Rf_GET
#define STS_OVERRIDE_Pr_SPEED_Rf_SET BCM53262_A0_STS_OVERRIDE_Pr_SPEED_Rf_SET
#define STS_OVERRIDE_Pr_RESERVED_0Rf_GET BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_0Rf_GET
#define STS_OVERRIDE_Pr_RESERVED_0Rf_SET BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_0Rf_SET
#define STS_OVERRIDE_Pr_FLOW_CNTLf_GET BCM53262_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_GET
#define STS_OVERRIDE_Pr_FLOW_CNTLf_SET BCM53262_A0_STS_OVERRIDE_Pr_FLOW_CNTLf_SET
#define STS_OVERRIDE_Pr_SW_ORDf_GET BCM53262_A0_STS_OVERRIDE_Pr_SW_ORDf_GET
#define STS_OVERRIDE_Pr_SW_ORDf_SET BCM53262_A0_STS_OVERRIDE_Pr_SW_ORDf_SET
#define STS_OVERRIDE_Pr_RESERVED_1Rf_GET BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_1Rf_GET
#define STS_OVERRIDE_Pr_RESERVED_1Rf_SET BCM53262_A0_STS_OVERRIDE_Pr_RESERVED_1Rf_SET
#define READ_STS_OVERRIDE_Pr BCM53262_A0_READ_STS_OVERRIDE_Pr
#define WRITE_STS_OVERRIDE_Pr BCM53262_A0_WRITE_STS_OVERRIDE_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_STS_OVERRIDE_Pr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SWMODE
 * BLOCKS:   SYS
 * DESC:     Switch Mode Register
 * SIZE:     8
 * FIELDS:
 *     SW_FWDG_MODE     Software Forwarding Mode.1'b1: Managed Mode.1'b0: Unmanaged Mode.Programmed frome the inversed HW_FWDG_EN pin on power-on.Can be overwritten subsequently.
 *     SW_FWDG_EN       Software Forwarding Enable.1'b1: Frame forwarding is enable.1'b0: Frame forwarding is disable.Read frome HW_FWDG_EN pin on power-on. Can be overwritten subsequently.
 *     RTRY_LMT_DIS     Retry Limit Disable.1'b1: Disable the retry limit on all MAC ports(10/100).1'b0: Continue transmit after 15 retry collision attempts in Half Duplex mode.
 *     NOBLKCD          Always not to blockcarrier detected signal.1'b1: Not to block. txport will always defer to crs.1'b0: Block CD
 *     IPG              Programmable Inter-Packet-Gap.2'b11: 96 bit time.2'b10: 92 bit time.2'b01: 88 bit time.2'b01: 84 bit time.
 *     EARLY_IMPTX      Early Transmit for IMP port
 *     EARLY_TX         Early Transmit
 */
#define BCM53262_A0_SWMODEr 0x00000000

#define BCM53262_A0_SWMODEr_SIZE 1

/*
 * This structure should be used to declare and program SWMODE.
 */
typedef union BCM53262_A0_SWMODEr_s {
	uint32_t v[1];
	uint32_t swmode[1];
	uint32_t _swmode;
} BCM53262_A0_SWMODEr_t;

#define BCM53262_A0_SWMODEr_CLR(r) (r).swmode[0] = 0
#define BCM53262_A0_SWMODEr_SET(r,d) (r).swmode[0] = d
#define BCM53262_A0_SWMODEr_GET(r) (r).swmode[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SWMODEr_SW_FWDG_MODEf_GET(r) (((r).swmode[0]) & 0x1)
#define BCM53262_A0_SWMODEr_SW_FWDG_MODEf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_SWMODEr_SW_FWDG_ENf_GET(r) ((((r).swmode[0]) >> 1) & 0x1)
#define BCM53262_A0_SWMODEr_SW_FWDG_ENf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_SWMODEr_RTRY_LMT_DISf_GET(r) ((((r).swmode[0]) >> 2) & 0x1)
#define BCM53262_A0_SWMODEr_RTRY_LMT_DISf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_SWMODEr_NOBLKCDf_GET(r) ((((r).swmode[0]) >> 3) & 0x1)
#define BCM53262_A0_SWMODEr_NOBLKCDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_SWMODEr_IPGf_GET(r) ((((r).swmode[0]) >> 4) & 0x3)
#define BCM53262_A0_SWMODEr_IPGf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_SWMODEr_EARLY_IMPTXf_GET(r) ((((r).swmode[0]) >> 6) & 0x1)
#define BCM53262_A0_SWMODEr_EARLY_IMPTXf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_SWMODEr_EARLY_TXf_GET(r) ((((r).swmode[0]) >> 7) & 0x1)
#define BCM53262_A0_SWMODEr_EARLY_TXf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access SWMODE.
 */
#define BCM53262_A0_READ_SWMODEr(u,r) cdk_robo_reg_read(u,BCM53262_A0_SWMODEr,(r._swmode),1)
#define BCM53262_A0_WRITE_SWMODEr(u,r) cdk_robo_reg_write(u,BCM53262_A0_SWMODEr,&(r._swmode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWMODEr BCM53262_A0_SWMODEr
#define SWMODEr_SIZE BCM53262_A0_SWMODEr_SIZE
typedef BCM53262_A0_SWMODEr_t SWMODEr_t;
#define SWMODEr_CLR BCM53262_A0_SWMODEr_CLR
#define SWMODEr_SET BCM53262_A0_SWMODEr_SET
#define SWMODEr_GET BCM53262_A0_SWMODEr_GET
#define SWMODEr_SW_FWDG_MODEf_GET BCM53262_A0_SWMODEr_SW_FWDG_MODEf_GET
#define SWMODEr_SW_FWDG_MODEf_SET BCM53262_A0_SWMODEr_SW_FWDG_MODEf_SET
#define SWMODEr_SW_FWDG_ENf_GET BCM53262_A0_SWMODEr_SW_FWDG_ENf_GET
#define SWMODEr_SW_FWDG_ENf_SET BCM53262_A0_SWMODEr_SW_FWDG_ENf_SET
#define SWMODEr_RTRY_LMT_DISf_GET BCM53262_A0_SWMODEr_RTRY_LMT_DISf_GET
#define SWMODEr_RTRY_LMT_DISf_SET BCM53262_A0_SWMODEr_RTRY_LMT_DISf_SET
#define SWMODEr_NOBLKCDf_GET BCM53262_A0_SWMODEr_NOBLKCDf_GET
#define SWMODEr_NOBLKCDf_SET BCM53262_A0_SWMODEr_NOBLKCDf_SET
#define SWMODEr_IPGf_GET BCM53262_A0_SWMODEr_IPGf_GET
#define SWMODEr_IPGf_SET BCM53262_A0_SWMODEr_IPGf_SET
#define SWMODEr_EARLY_IMPTXf_GET BCM53262_A0_SWMODEr_EARLY_IMPTXf_GET
#define SWMODEr_EARLY_IMPTXf_SET BCM53262_A0_SWMODEr_EARLY_IMPTXf_SET
#define SWMODEr_EARLY_TXf_GET BCM53262_A0_SWMODEr_EARLY_TXf_GET
#define SWMODEr_EARLY_TXf_SET BCM53262_A0_SWMODEr_EARLY_TXf_SET
#define READ_SWMODEr BCM53262_A0_READ_SWMODEr
#define WRITE_SWMODEr BCM53262_A0_WRITE_SWMODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SWMODEr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  SW_FLOW_CON
 * BLOCKS:   SYS
 * DESC:     Sortware Flow Control Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     SW_FLOW_CON      Software to disable full/half duplex flow control for per-port (bit 47-24 for 10/100 port, bit 48 for mii rx port, bit 49 for mii tx port,bit50 for giga rx port g0, bit51 for giga tx port g0,bit52 for giga rx port g1, bit53 for giga tx port g1,bit54 for giga rx port g0, bit55 for giga tx port g2,bit56 for giga rx port g1, bit57 for giga tx port g3),1 : enable0 : disable
 *     RESERVED_1R      Reserved
 *     TXFLOW_HALF_MODE Reserved.Note : Not to release this bit to customer.
 *     SW_FLOE_CON_EN   Enable software override flow control result.
 */
#define BCM53262_A0_SW_FLOW_CONr 0x00000048

#define BCM53262_A0_SW_FLOW_CONr_SIZE 8

/*
 * This structure should be used to declare and program SW_FLOW_CON.
 */
typedef union BCM53262_A0_SW_FLOW_CONr_s {
	uint32_t v[2];
	uint32_t sw_flow_con[2];
	uint32_t _sw_flow_con;
} BCM53262_A0_SW_FLOW_CONr_t;

#define BCM53262_A0_SW_FLOW_CONr_CLR(r) CDK_MEMSET(&((r)._sw_flow_con), 0, sizeof(BCM53262_A0_SW_FLOW_CONr_t))
#define BCM53262_A0_SW_FLOW_CONr_SET(r,i,d) (r).sw_flow_con[i] = d
#define BCM53262_A0_SW_FLOW_CONr_GET(r,i) (r).sw_flow_con[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_SW_FLOW_CONr_RESERVED_0Rf_GET(r) (((r).sw_flow_con[0]) & 0xffffff)
#define BCM53262_A0_SW_FLOW_CONr_RESERVED_0Rf_SET(r,f) (r).sw_flow_con[0]=(((r).sw_flow_con[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_SW_FLOW_CONr_SW_FLOW_CONf_GET(r,a) cdk_field_get((r).sw_flow_con,24,57,a)
#define BCM53262_A0_SW_FLOW_CONr_SW_FLOW_CONf_SET(r,a) cdk_field_set((r).sw_flow_con,24,57,a)
#define BCM53262_A0_SW_FLOW_CONr_RESERVED_1Rf_GET(r) ((((r).sw_flow_con[1]) >> 26) & 0xf)
#define BCM53262_A0_SW_FLOW_CONr_RESERVED_1Rf_SET(r,f) (r).sw_flow_con[1]=(((r).sw_flow_con[1] & ~((uint32_t)0xf << 26)) | ((((uint32_t)f) & 0xf) << 26))
#define BCM53262_A0_SW_FLOW_CONr_TXFLOW_HALF_MODEf_GET(r) ((((r).sw_flow_con[1]) >> 30) & 0x1)
#define BCM53262_A0_SW_FLOW_CONr_TXFLOW_HALF_MODEf_SET(r,f) (r).sw_flow_con[1]=(((r).sw_flow_con[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53262_A0_SW_FLOW_CONr_SW_FLOE_CON_ENf_GET(r) ((((r).sw_flow_con[1]) >> 31) & 0x1)
#define BCM53262_A0_SW_FLOW_CONr_SW_FLOE_CON_ENf_SET(r,f) (r).sw_flow_con[1]=(((r).sw_flow_con[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access SW_FLOW_CON.
 */
#define BCM53262_A0_READ_SW_FLOW_CONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_SW_FLOW_CONr,(r._sw_flow_con),8)
#define BCM53262_A0_WRITE_SW_FLOW_CONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_SW_FLOW_CONr,&(r._sw_flow_con),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SW_FLOW_CONr BCM53262_A0_SW_FLOW_CONr
#define SW_FLOW_CONr_SIZE BCM53262_A0_SW_FLOW_CONr_SIZE
typedef BCM53262_A0_SW_FLOW_CONr_t SW_FLOW_CONr_t;
#define SW_FLOW_CONr_CLR BCM53262_A0_SW_FLOW_CONr_CLR
#define SW_FLOW_CONr_SET BCM53262_A0_SW_FLOW_CONr_SET
#define SW_FLOW_CONr_GET BCM53262_A0_SW_FLOW_CONr_GET
#define SW_FLOW_CONr_RESERVED_0Rf_GET BCM53262_A0_SW_FLOW_CONr_RESERVED_0Rf_GET
#define SW_FLOW_CONr_RESERVED_0Rf_SET BCM53262_A0_SW_FLOW_CONr_RESERVED_0Rf_SET
#define SW_FLOW_CONr_SW_FLOW_CONf_GET BCM53262_A0_SW_FLOW_CONr_SW_FLOW_CONf_GET
#define SW_FLOW_CONr_SW_FLOW_CONf_SET BCM53262_A0_SW_FLOW_CONr_SW_FLOW_CONf_SET
#define SW_FLOW_CONr_RESERVED_1Rf_GET BCM53262_A0_SW_FLOW_CONr_RESERVED_1Rf_GET
#define SW_FLOW_CONr_RESERVED_1Rf_SET BCM53262_A0_SW_FLOW_CONr_RESERVED_1Rf_SET
#define SW_FLOW_CONr_TXFLOW_HALF_MODEf_GET BCM53262_A0_SW_FLOW_CONr_TXFLOW_HALF_MODEf_GET
#define SW_FLOW_CONr_TXFLOW_HALF_MODEf_SET BCM53262_A0_SW_FLOW_CONr_TXFLOW_HALF_MODEf_SET
#define SW_FLOW_CONr_SW_FLOE_CON_ENf_GET BCM53262_A0_SW_FLOW_CONr_SW_FLOE_CON_ENf_GET
#define SW_FLOW_CONr_SW_FLOE_CON_ENf_SET BCM53262_A0_SW_FLOW_CONr_SW_FLOE_CON_ENf_SET
#define READ_SW_FLOW_CONr BCM53262_A0_READ_SW_FLOW_CONr
#define WRITE_SW_FLOW_CONr BCM53262_A0_WRITE_SW_FLOW_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_SW_FLOW_CONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_Pkts1024toMaxOctets
 * BLOCKS:   SYS
 * DESC:     Rx 1024 to Max Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_PKTS1024TOMAXOCTETSr 0x0000858c

#define BCM53262_A0_S_PKTS1024TOMAXOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts1024toMaxOctets.
 */
typedef union BCM53262_A0_S_PKTS1024TOMAXOCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts1024tomaxoctets[1];
	uint32_t _s_pkts1024tomaxoctets;
} BCM53262_A0_S_PKTS1024TOMAXOCTETSr_t;

#define BCM53262_A0_S_PKTS1024TOMAXOCTETSr_CLR(r) (r).s_pkts1024tomaxoctets[0] = 0
#define BCM53262_A0_S_PKTS1024TOMAXOCTETSr_SET(r,d) (r).s_pkts1024tomaxoctets[0] = d
#define BCM53262_A0_S_PKTS1024TOMAXOCTETSr_GET(r) (r).s_pkts1024tomaxoctets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_PKTS1024TOMAXOCTETSr_COUNTSf_GET(r) ((r).s_pkts1024tomaxoctets[0])
#define BCM53262_A0_S_PKTS1024TOMAXOCTETSr_COUNTSf_SET(r,f) (r).s_pkts1024tomaxoctets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts1024toMaxOctets.
 */
#define BCM53262_A0_READ_S_PKTS1024TOMAXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_PKTS1024TOMAXOCTETSr,(r._s_pkts1024tomaxoctets),4)
#define BCM53262_A0_WRITE_S_PKTS1024TOMAXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_PKTS1024TOMAXOCTETSr,&(r._s_pkts1024tomaxoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS1024TOMAXOCTETSr BCM53262_A0_S_PKTS1024TOMAXOCTETSr
#define S_PKTS1024TOMAXOCTETSr_SIZE BCM53262_A0_S_PKTS1024TOMAXOCTETSr_SIZE
typedef BCM53262_A0_S_PKTS1024TOMAXOCTETSr_t S_PKTS1024TOMAXOCTETSr_t;
#define S_PKTS1024TOMAXOCTETSr_CLR BCM53262_A0_S_PKTS1024TOMAXOCTETSr_CLR
#define S_PKTS1024TOMAXOCTETSr_SET BCM53262_A0_S_PKTS1024TOMAXOCTETSr_SET
#define S_PKTS1024TOMAXOCTETSr_GET BCM53262_A0_S_PKTS1024TOMAXOCTETSr_GET
#define S_PKTS1024TOMAXOCTETSr_COUNTSf_GET BCM53262_A0_S_PKTS1024TOMAXOCTETSr_COUNTSf_GET
#define S_PKTS1024TOMAXOCTETSr_COUNTSf_SET BCM53262_A0_S_PKTS1024TOMAXOCTETSr_COUNTSf_SET
#define READ_S_PKTS1024TOMAXOCTETSr BCM53262_A0_READ_S_PKTS1024TOMAXOCTETSr
#define WRITE_S_PKTS1024TOMAXOCTETSr BCM53262_A0_WRITE_S_PKTS1024TOMAXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_PKTS1024TOMAXOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_Pkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_PKTS128TO255OCTETSr 0x00008580

#define BCM53262_A0_S_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts128to255Octets.
 */
typedef union BCM53262_A0_S_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts128to255octets[1];
	uint32_t _s_pkts128to255octets;
} BCM53262_A0_S_PKTS128TO255OCTETSr_t;

#define BCM53262_A0_S_PKTS128TO255OCTETSr_CLR(r) (r).s_pkts128to255octets[0] = 0
#define BCM53262_A0_S_PKTS128TO255OCTETSr_SET(r,d) (r).s_pkts128to255octets[0] = d
#define BCM53262_A0_S_PKTS128TO255OCTETSr_GET(r) (r).s_pkts128to255octets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_PKTS128TO255OCTETSr_COUNTSf_GET(r) ((r).s_pkts128to255octets[0])
#define BCM53262_A0_S_PKTS128TO255OCTETSr_COUNTSf_SET(r,f) (r).s_pkts128to255octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts128to255Octets.
 */
#define BCM53262_A0_READ_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_PKTS128TO255OCTETSr,(r._s_pkts128to255octets),4)
#define BCM53262_A0_WRITE_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_PKTS128TO255OCTETSr,&(r._s_pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS128TO255OCTETSr BCM53262_A0_S_PKTS128TO255OCTETSr
#define S_PKTS128TO255OCTETSr_SIZE BCM53262_A0_S_PKTS128TO255OCTETSr_SIZE
typedef BCM53262_A0_S_PKTS128TO255OCTETSr_t S_PKTS128TO255OCTETSr_t;
#define S_PKTS128TO255OCTETSr_CLR BCM53262_A0_S_PKTS128TO255OCTETSr_CLR
#define S_PKTS128TO255OCTETSr_SET BCM53262_A0_S_PKTS128TO255OCTETSr_SET
#define S_PKTS128TO255OCTETSr_GET BCM53262_A0_S_PKTS128TO255OCTETSr_GET
#define S_PKTS128TO255OCTETSr_COUNTSf_GET BCM53262_A0_S_PKTS128TO255OCTETSr_COUNTSf_GET
#define S_PKTS128TO255OCTETSr_COUNTSf_SET BCM53262_A0_S_PKTS128TO255OCTETSr_COUNTSf_SET
#define READ_S_PKTS128TO255OCTETSr BCM53262_A0_READ_S_PKTS128TO255OCTETSr
#define WRITE_S_PKTS128TO255OCTETSr BCM53262_A0_WRITE_S_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_PKTS128TO255OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_Pkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_PKTS256TO511OCTETSr 0x00008584

#define BCM53262_A0_S_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts256to511Octets.
 */
typedef union BCM53262_A0_S_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts256to511octets[1];
	uint32_t _s_pkts256to511octets;
} BCM53262_A0_S_PKTS256TO511OCTETSr_t;

#define BCM53262_A0_S_PKTS256TO511OCTETSr_CLR(r) (r).s_pkts256to511octets[0] = 0
#define BCM53262_A0_S_PKTS256TO511OCTETSr_SET(r,d) (r).s_pkts256to511octets[0] = d
#define BCM53262_A0_S_PKTS256TO511OCTETSr_GET(r) (r).s_pkts256to511octets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_PKTS256TO511OCTETSr_COUNTSf_GET(r) ((r).s_pkts256to511octets[0])
#define BCM53262_A0_S_PKTS256TO511OCTETSr_COUNTSf_SET(r,f) (r).s_pkts256to511octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts256to511Octets.
 */
#define BCM53262_A0_READ_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_PKTS256TO511OCTETSr,(r._s_pkts256to511octets),4)
#define BCM53262_A0_WRITE_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_PKTS256TO511OCTETSr,&(r._s_pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS256TO511OCTETSr BCM53262_A0_S_PKTS256TO511OCTETSr
#define S_PKTS256TO511OCTETSr_SIZE BCM53262_A0_S_PKTS256TO511OCTETSr_SIZE
typedef BCM53262_A0_S_PKTS256TO511OCTETSr_t S_PKTS256TO511OCTETSr_t;
#define S_PKTS256TO511OCTETSr_CLR BCM53262_A0_S_PKTS256TO511OCTETSr_CLR
#define S_PKTS256TO511OCTETSr_SET BCM53262_A0_S_PKTS256TO511OCTETSr_SET
#define S_PKTS256TO511OCTETSr_GET BCM53262_A0_S_PKTS256TO511OCTETSr_GET
#define S_PKTS256TO511OCTETSr_COUNTSf_GET BCM53262_A0_S_PKTS256TO511OCTETSr_COUNTSf_GET
#define S_PKTS256TO511OCTETSr_COUNTSf_SET BCM53262_A0_S_PKTS256TO511OCTETSr_COUNTSf_SET
#define READ_S_PKTS256TO511OCTETSr BCM53262_A0_READ_S_PKTS256TO511OCTETSr
#define WRITE_S_PKTS256TO511OCTETSr BCM53262_A0_WRITE_S_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_PKTS256TO511OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_Pkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_PKTS512TO1023OCTETSr 0x00008588

#define BCM53262_A0_S_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts512to1023Octets.
 */
typedef union BCM53262_A0_S_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts512to1023octets[1];
	uint32_t _s_pkts512to1023octets;
} BCM53262_A0_S_PKTS512TO1023OCTETSr_t;

#define BCM53262_A0_S_PKTS512TO1023OCTETSr_CLR(r) (r).s_pkts512to1023octets[0] = 0
#define BCM53262_A0_S_PKTS512TO1023OCTETSr_SET(r,d) (r).s_pkts512to1023octets[0] = d
#define BCM53262_A0_S_PKTS512TO1023OCTETSr_GET(r) (r).s_pkts512to1023octets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_PKTS512TO1023OCTETSr_COUNTSf_GET(r) ((r).s_pkts512to1023octets[0])
#define BCM53262_A0_S_PKTS512TO1023OCTETSr_COUNTSf_SET(r,f) (r).s_pkts512to1023octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts512to1023Octets.
 */
#define BCM53262_A0_READ_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_PKTS512TO1023OCTETSr,(r._s_pkts512to1023octets),4)
#define BCM53262_A0_WRITE_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_PKTS512TO1023OCTETSr,&(r._s_pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS512TO1023OCTETSr BCM53262_A0_S_PKTS512TO1023OCTETSr
#define S_PKTS512TO1023OCTETSr_SIZE BCM53262_A0_S_PKTS512TO1023OCTETSr_SIZE
typedef BCM53262_A0_S_PKTS512TO1023OCTETSr_t S_PKTS512TO1023OCTETSr_t;
#define S_PKTS512TO1023OCTETSr_CLR BCM53262_A0_S_PKTS512TO1023OCTETSr_CLR
#define S_PKTS512TO1023OCTETSr_SET BCM53262_A0_S_PKTS512TO1023OCTETSr_SET
#define S_PKTS512TO1023OCTETSr_GET BCM53262_A0_S_PKTS512TO1023OCTETSr_GET
#define S_PKTS512TO1023OCTETSr_COUNTSf_GET BCM53262_A0_S_PKTS512TO1023OCTETSr_COUNTSf_GET
#define S_PKTS512TO1023OCTETSr_COUNTSf_SET BCM53262_A0_S_PKTS512TO1023OCTETSr_COUNTSf_SET
#define READ_S_PKTS512TO1023OCTETSr BCM53262_A0_READ_S_PKTS512TO1023OCTETSr
#define WRITE_S_PKTS512TO1023OCTETSr BCM53262_A0_WRITE_S_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_PKTS512TO1023OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_Pkts64Octets
 * BLOCKS:   SYS
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_PKTS64OCTETSr 0x00008578

#define BCM53262_A0_S_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts64Octets.
 */
typedef union BCM53262_A0_S_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts64octets[1];
	uint32_t _s_pkts64octets;
} BCM53262_A0_S_PKTS64OCTETSr_t;

#define BCM53262_A0_S_PKTS64OCTETSr_CLR(r) (r).s_pkts64octets[0] = 0
#define BCM53262_A0_S_PKTS64OCTETSr_SET(r,d) (r).s_pkts64octets[0] = d
#define BCM53262_A0_S_PKTS64OCTETSr_GET(r) (r).s_pkts64octets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_PKTS64OCTETSr_COUNTSf_GET(r) ((r).s_pkts64octets[0])
#define BCM53262_A0_S_PKTS64OCTETSr_COUNTSf_SET(r,f) (r).s_pkts64octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts64Octets.
 */
#define BCM53262_A0_READ_S_PKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_PKTS64OCTETSr,(r._s_pkts64octets),4)
#define BCM53262_A0_WRITE_S_PKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_PKTS64OCTETSr,&(r._s_pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS64OCTETSr BCM53262_A0_S_PKTS64OCTETSr
#define S_PKTS64OCTETSr_SIZE BCM53262_A0_S_PKTS64OCTETSr_SIZE
typedef BCM53262_A0_S_PKTS64OCTETSr_t S_PKTS64OCTETSr_t;
#define S_PKTS64OCTETSr_CLR BCM53262_A0_S_PKTS64OCTETSr_CLR
#define S_PKTS64OCTETSr_SET BCM53262_A0_S_PKTS64OCTETSr_SET
#define S_PKTS64OCTETSr_GET BCM53262_A0_S_PKTS64OCTETSr_GET
#define S_PKTS64OCTETSr_COUNTSf_GET BCM53262_A0_S_PKTS64OCTETSr_COUNTSf_GET
#define S_PKTS64OCTETSr_COUNTSf_SET BCM53262_A0_S_PKTS64OCTETSr_COUNTSf_SET
#define READ_S_PKTS64OCTETSr BCM53262_A0_READ_S_PKTS64OCTETSr
#define WRITE_S_PKTS64OCTETSr BCM53262_A0_WRITE_S_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_PKTS64OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_Pkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_PKTS65TO127OCTETSr 0x0000857c

#define BCM53262_A0_S_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts65to127Octets.
 */
typedef union BCM53262_A0_S_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts65to127octets[1];
	uint32_t _s_pkts65to127octets;
} BCM53262_A0_S_PKTS65TO127OCTETSr_t;

#define BCM53262_A0_S_PKTS65TO127OCTETSr_CLR(r) (r).s_pkts65to127octets[0] = 0
#define BCM53262_A0_S_PKTS65TO127OCTETSr_SET(r,d) (r).s_pkts65to127octets[0] = d
#define BCM53262_A0_S_PKTS65TO127OCTETSr_GET(r) (r).s_pkts65to127octets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_PKTS65TO127OCTETSr_COUNTSf_GET(r) ((r).s_pkts65to127octets[0])
#define BCM53262_A0_S_PKTS65TO127OCTETSr_COUNTSf_SET(r,f) (r).s_pkts65to127octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts65to127Octets.
 */
#define BCM53262_A0_READ_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_PKTS65TO127OCTETSr,(r._s_pkts65to127octets),4)
#define BCM53262_A0_WRITE_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_PKTS65TO127OCTETSr,&(r._s_pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS65TO127OCTETSr BCM53262_A0_S_PKTS65TO127OCTETSr
#define S_PKTS65TO127OCTETSr_SIZE BCM53262_A0_S_PKTS65TO127OCTETSr_SIZE
typedef BCM53262_A0_S_PKTS65TO127OCTETSr_t S_PKTS65TO127OCTETSr_t;
#define S_PKTS65TO127OCTETSr_CLR BCM53262_A0_S_PKTS65TO127OCTETSr_CLR
#define S_PKTS65TO127OCTETSr_SET BCM53262_A0_S_PKTS65TO127OCTETSr_SET
#define S_PKTS65TO127OCTETSr_GET BCM53262_A0_S_PKTS65TO127OCTETSr_GET
#define S_PKTS65TO127OCTETSr_COUNTSf_GET BCM53262_A0_S_PKTS65TO127OCTETSr_COUNTSf_GET
#define S_PKTS65TO127OCTETSr_COUNTSf_SET BCM53262_A0_S_PKTS65TO127OCTETSr_COUNTSf_SET
#define READ_S_PKTS65TO127OCTETSr BCM53262_A0_READ_S_PKTS65TO127OCTETSr
#define WRITE_S_PKTS65TO127OCTETSr BCM53262_A0_WRITE_S_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_PKTS65TO127OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RXSymblErr
 * BLOCKS:   SYS
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXSYMBLERRr 0x000085c4

#define BCM53262_A0_S_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program S_RXSymblErr.
 */
typedef union BCM53262_A0_S_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t s_rxsymblerr[1];
	uint32_t _s_rxsymblerr;
} BCM53262_A0_S_RXSYMBLERRr_t;

#define BCM53262_A0_S_RXSYMBLERRr_CLR(r) (r).s_rxsymblerr[0] = 0
#define BCM53262_A0_S_RXSYMBLERRr_SET(r,d) (r).s_rxsymblerr[0] = d
#define BCM53262_A0_S_RXSYMBLERRr_GET(r) (r).s_rxsymblerr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXSYMBLERRr_COUNTSf_GET(r) ((r).s_rxsymblerr[0])
#define BCM53262_A0_S_RXSYMBLERRr_COUNTSf_SET(r,f) (r).s_rxsymblerr[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXSymblErr.
 */
#define BCM53262_A0_READ_S_RXSYMBLERRr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXSYMBLERRr,(r._s_rxsymblerr),4)
#define BCM53262_A0_WRITE_S_RXSYMBLERRr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXSYMBLERRr,&(r._s_rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSYMBLERRr BCM53262_A0_S_RXSYMBLERRr
#define S_RXSYMBLERRr_SIZE BCM53262_A0_S_RXSYMBLERRr_SIZE
typedef BCM53262_A0_S_RXSYMBLERRr_t S_RXSYMBLERRr_t;
#define S_RXSYMBLERRr_CLR BCM53262_A0_S_RXSYMBLERRr_CLR
#define S_RXSYMBLERRr_SET BCM53262_A0_S_RXSYMBLERRr_SET
#define S_RXSYMBLERRr_GET BCM53262_A0_S_RXSYMBLERRr_GET
#define S_RXSYMBLERRr_COUNTSf_GET BCM53262_A0_S_RXSYMBLERRr_COUNTSf_GET
#define S_RXSYMBLERRr_COUNTSf_SET BCM53262_A0_S_RXSYMBLERRr_COUNTSf_SET
#define READ_S_RXSYMBLERRr BCM53262_A0_READ_S_RXSYMBLERRr
#define WRITE_S_RXSYMBLERRr BCM53262_A0_WRITE_S_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXSYMBLERRr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXALIGNMENTERRORSr 0x00008598

#define BCM53262_A0_S_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxAlignmentErrors.
 */
typedef union BCM53262_A0_S_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxalignmenterrors[1];
	uint32_t _s_rxalignmenterrors;
} BCM53262_A0_S_RXALIGNMENTERRORSr_t;

#define BCM53262_A0_S_RXALIGNMENTERRORSr_CLR(r) (r).s_rxalignmenterrors[0] = 0
#define BCM53262_A0_S_RXALIGNMENTERRORSr_SET(r,d) (r).s_rxalignmenterrors[0] = d
#define BCM53262_A0_S_RXALIGNMENTERRORSr_GET(r) (r).s_rxalignmenterrors[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXALIGNMENTERRORSr_COUNTSf_GET(r) ((r).s_rxalignmenterrors[0])
#define BCM53262_A0_S_RXALIGNMENTERRORSr_COUNTSf_SET(r,f) (r).s_rxalignmenterrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxAlignmentErrors.
 */
#define BCM53262_A0_READ_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXALIGNMENTERRORSr,(r._s_rxalignmenterrors),4)
#define BCM53262_A0_WRITE_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXALIGNMENTERRORSr,&(r._s_rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXALIGNMENTERRORSr BCM53262_A0_S_RXALIGNMENTERRORSr
#define S_RXALIGNMENTERRORSr_SIZE BCM53262_A0_S_RXALIGNMENTERRORSr_SIZE
typedef BCM53262_A0_S_RXALIGNMENTERRORSr_t S_RXALIGNMENTERRORSr_t;
#define S_RXALIGNMENTERRORSr_CLR BCM53262_A0_S_RXALIGNMENTERRORSr_CLR
#define S_RXALIGNMENTERRORSr_SET BCM53262_A0_S_RXALIGNMENTERRORSr_SET
#define S_RXALIGNMENTERRORSr_GET BCM53262_A0_S_RXALIGNMENTERRORSr_GET
#define S_RXALIGNMENTERRORSr_COUNTSf_GET BCM53262_A0_S_RXALIGNMENTERRORSr_COUNTSf_GET
#define S_RXALIGNMENTERRORSr_COUNTSf_SET BCM53262_A0_S_RXALIGNMENTERRORSr_COUNTSf_SET
#define READ_S_RXALIGNMENTERRORSr BCM53262_A0_READ_S_RXALIGNMENTERRORSr
#define WRITE_S_RXALIGNMENTERRORSr BCM53262_A0_WRITE_S_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXALIGNMENTERRORSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxBroadcastPkt
 * BLOCKS:   SYS
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXBROADCASTPKTr 0x000085b4

#define BCM53262_A0_S_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_RxBroadcastPkt.
 */
typedef union BCM53262_A0_S_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t s_rxbroadcastpkt[1];
	uint32_t _s_rxbroadcastpkt;
} BCM53262_A0_S_RXBROADCASTPKTr_t;

#define BCM53262_A0_S_RXBROADCASTPKTr_CLR(r) (r).s_rxbroadcastpkt[0] = 0
#define BCM53262_A0_S_RXBROADCASTPKTr_SET(r,d) (r).s_rxbroadcastpkt[0] = d
#define BCM53262_A0_S_RXBROADCASTPKTr_GET(r) (r).s_rxbroadcastpkt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXBROADCASTPKTr_COUNTSf_GET(r) ((r).s_rxbroadcastpkt[0])
#define BCM53262_A0_S_RXBROADCASTPKTr_COUNTSf_SET(r,f) (r).s_rxbroadcastpkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxBroadcastPkt.
 */
#define BCM53262_A0_READ_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXBROADCASTPKTr,(r._s_rxbroadcastpkt),4)
#define BCM53262_A0_WRITE_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXBROADCASTPKTr,&(r._s_rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXBROADCASTPKTr BCM53262_A0_S_RXBROADCASTPKTr
#define S_RXBROADCASTPKTr_SIZE BCM53262_A0_S_RXBROADCASTPKTr_SIZE
typedef BCM53262_A0_S_RXBROADCASTPKTr_t S_RXBROADCASTPKTr_t;
#define S_RXBROADCASTPKTr_CLR BCM53262_A0_S_RXBROADCASTPKTr_CLR
#define S_RXBROADCASTPKTr_SET BCM53262_A0_S_RXBROADCASTPKTr_SET
#define S_RXBROADCASTPKTr_GET BCM53262_A0_S_RXBROADCASTPKTr_GET
#define S_RXBROADCASTPKTr_COUNTSf_GET BCM53262_A0_S_RXBROADCASTPKTr_COUNTSf_GET
#define S_RXBROADCASTPKTr_COUNTSf_SET BCM53262_A0_S_RXBROADCASTPKTr_COUNTSf_SET
#define READ_S_RXBROADCASTPKTr BCM53262_A0_READ_S_RXBROADCASTPKTr
#define WRITE_S_RXBROADCASTPKTr BCM53262_A0_WRITE_S_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXBROADCASTPKTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxDropPkts
 * BLOCKS:   SYS
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXDROPPKTSr 0x000085a8

#define BCM53262_A0_S_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxDropPkts.
 */
typedef union BCM53262_A0_S_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxdroppkts[1];
	uint32_t _s_rxdroppkts;
} BCM53262_A0_S_RXDROPPKTSr_t;

#define BCM53262_A0_S_RXDROPPKTSr_CLR(r) (r).s_rxdroppkts[0] = 0
#define BCM53262_A0_S_RXDROPPKTSr_SET(r,d) (r).s_rxdroppkts[0] = d
#define BCM53262_A0_S_RXDROPPKTSr_GET(r) (r).s_rxdroppkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXDROPPKTSr_COUNTSf_GET(r) ((r).s_rxdroppkts[0])
#define BCM53262_A0_S_RXDROPPKTSr_COUNTSf_SET(r,f) (r).s_rxdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxDropPkts.
 */
#define BCM53262_A0_READ_S_RXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXDROPPKTSr,(r._s_rxdroppkts),4)
#define BCM53262_A0_WRITE_S_RXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXDROPPKTSr,&(r._s_rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDROPPKTSr BCM53262_A0_S_RXDROPPKTSr
#define S_RXDROPPKTSr_SIZE BCM53262_A0_S_RXDROPPKTSr_SIZE
typedef BCM53262_A0_S_RXDROPPKTSr_t S_RXDROPPKTSr_t;
#define S_RXDROPPKTSr_CLR BCM53262_A0_S_RXDROPPKTSr_CLR
#define S_RXDROPPKTSr_SET BCM53262_A0_S_RXDROPPKTSr_SET
#define S_RXDROPPKTSr_GET BCM53262_A0_S_RXDROPPKTSr_GET
#define S_RXDROPPKTSr_COUNTSf_GET BCM53262_A0_S_RXDROPPKTSr_COUNTSf_GET
#define S_RXDROPPKTSr_COUNTSf_SET BCM53262_A0_S_RXDROPPKTSr_COUNTSf_SET
#define READ_S_RXDROPPKTSr BCM53262_A0_READ_S_RXDROPPKTSr
#define WRITE_S_RXDROPPKTSr BCM53262_A0_WRITE_S_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXDROPPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxExcessSizeDisc
 * BLOCKS:   SYS
 * DESC:     Rx Excess Size Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXEXCESSSIZEDISCr 0x000085c0

#define BCM53262_A0_S_RXEXCESSSIZEDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_RxExcessSizeDisc.
 */
typedef union BCM53262_A0_S_RXEXCESSSIZEDISCr_s {
	uint32_t v[1];
	uint32_t s_rxexcesssizedisc[1];
	uint32_t _s_rxexcesssizedisc;
} BCM53262_A0_S_RXEXCESSSIZEDISCr_t;

#define BCM53262_A0_S_RXEXCESSSIZEDISCr_CLR(r) (r).s_rxexcesssizedisc[0] = 0
#define BCM53262_A0_S_RXEXCESSSIZEDISCr_SET(r,d) (r).s_rxexcesssizedisc[0] = d
#define BCM53262_A0_S_RXEXCESSSIZEDISCr_GET(r) (r).s_rxexcesssizedisc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXEXCESSSIZEDISCr_COUNTSf_GET(r) ((r).s_rxexcesssizedisc[0])
#define BCM53262_A0_S_RXEXCESSSIZEDISCr_COUNTSf_SET(r,f) (r).s_rxexcesssizedisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxExcessSizeDisc.
 */
#define BCM53262_A0_READ_S_RXEXCESSSIZEDISCr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXEXCESSSIZEDISCr,(r._s_rxexcesssizedisc),4)
#define BCM53262_A0_WRITE_S_RXEXCESSSIZEDISCr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXEXCESSSIZEDISCr,&(r._s_rxexcesssizedisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXEXCESSSIZEDISCr BCM53262_A0_S_RXEXCESSSIZEDISCr
#define S_RXEXCESSSIZEDISCr_SIZE BCM53262_A0_S_RXEXCESSSIZEDISCr_SIZE
typedef BCM53262_A0_S_RXEXCESSSIZEDISCr_t S_RXEXCESSSIZEDISCr_t;
#define S_RXEXCESSSIZEDISCr_CLR BCM53262_A0_S_RXEXCESSSIZEDISCr_CLR
#define S_RXEXCESSSIZEDISCr_SET BCM53262_A0_S_RXEXCESSSIZEDISCr_SET
#define S_RXEXCESSSIZEDISCr_GET BCM53262_A0_S_RXEXCESSSIZEDISCr_GET
#define S_RXEXCESSSIZEDISCr_COUNTSf_GET BCM53262_A0_S_RXEXCESSSIZEDISCr_COUNTSf_GET
#define S_RXEXCESSSIZEDISCr_COUNTSf_SET BCM53262_A0_S_RXEXCESSSIZEDISCr_COUNTSf_SET
#define READ_S_RXEXCESSSIZEDISCr BCM53262_A0_READ_S_RXEXCESSSIZEDISCr
#define WRITE_S_RXEXCESSSIZEDISCr BCM53262_A0_WRITE_S_RXEXCESSSIZEDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXEXCESSSIZEDISCr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXFCSERRORSr 0x0000859c

#define BCM53262_A0_S_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFCSErrors.
 */
typedef union BCM53262_A0_S_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxfcserrors[1];
	uint32_t _s_rxfcserrors;
} BCM53262_A0_S_RXFCSERRORSr_t;

#define BCM53262_A0_S_RXFCSERRORSr_CLR(r) (r).s_rxfcserrors[0] = 0
#define BCM53262_A0_S_RXFCSERRORSr_SET(r,d) (r).s_rxfcserrors[0] = d
#define BCM53262_A0_S_RXFCSERRORSr_GET(r) (r).s_rxfcserrors[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXFCSERRORSr_COUNTSf_GET(r) ((r).s_rxfcserrors[0])
#define BCM53262_A0_S_RXFCSERRORSr_COUNTSf_SET(r,f) (r).s_rxfcserrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFCSErrors.
 */
#define BCM53262_A0_READ_S_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXFCSERRORSr,(r._s_rxfcserrors),4)
#define BCM53262_A0_WRITE_S_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXFCSERRORSr,&(r._s_rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFCSERRORSr BCM53262_A0_S_RXFCSERRORSr
#define S_RXFCSERRORSr_SIZE BCM53262_A0_S_RXFCSERRORSr_SIZE
typedef BCM53262_A0_S_RXFCSERRORSr_t S_RXFCSERRORSr_t;
#define S_RXFCSERRORSr_CLR BCM53262_A0_S_RXFCSERRORSr_CLR
#define S_RXFCSERRORSr_SET BCM53262_A0_S_RXFCSERRORSr_SET
#define S_RXFCSERRORSr_GET BCM53262_A0_S_RXFCSERRORSr_GET
#define S_RXFCSERRORSr_COUNTSf_GET BCM53262_A0_S_RXFCSERRORSr_COUNTSf_GET
#define S_RXFCSERRORSr_COUNTSf_SET BCM53262_A0_S_RXFCSERRORSr_COUNTSf_SET
#define READ_S_RXFCSERRORSr BCM53262_A0_READ_S_RXFCSERRORSr
#define WRITE_S_RXFCSERRORSr BCM53262_A0_WRITE_S_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXFCSERRORSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxFragments
 * BLOCKS:   SYS
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXFRAGMENTSr 0x000085bc

#define BCM53262_A0_S_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFragments.
 */
typedef union BCM53262_A0_S_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t s_rxfragments[1];
	uint32_t _s_rxfragments;
} BCM53262_A0_S_RXFRAGMENTSr_t;

#define BCM53262_A0_S_RXFRAGMENTSr_CLR(r) (r).s_rxfragments[0] = 0
#define BCM53262_A0_S_RXFRAGMENTSr_SET(r,d) (r).s_rxfragments[0] = d
#define BCM53262_A0_S_RXFRAGMENTSr_GET(r) (r).s_rxfragments[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXFRAGMENTSr_COUNTSf_GET(r) ((r).s_rxfragments[0])
#define BCM53262_A0_S_RXFRAGMENTSr_COUNTSf_SET(r,f) (r).s_rxfragments[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFragments.
 */
#define BCM53262_A0_READ_S_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXFRAGMENTSr,(r._s_rxfragments),4)
#define BCM53262_A0_WRITE_S_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXFRAGMENTSr,&(r._s_rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFRAGMENTSr BCM53262_A0_S_RXFRAGMENTSr
#define S_RXFRAGMENTSr_SIZE BCM53262_A0_S_RXFRAGMENTSr_SIZE
typedef BCM53262_A0_S_RXFRAGMENTSr_t S_RXFRAGMENTSr_t;
#define S_RXFRAGMENTSr_CLR BCM53262_A0_S_RXFRAGMENTSr_CLR
#define S_RXFRAGMENTSr_SET BCM53262_A0_S_RXFRAGMENTSr_SET
#define S_RXFRAGMENTSr_GET BCM53262_A0_S_RXFRAGMENTSr_GET
#define S_RXFRAGMENTSr_COUNTSf_GET BCM53262_A0_S_RXFRAGMENTSr_COUNTSf_GET
#define S_RXFRAGMENTSr_COUNTSf_SET BCM53262_A0_S_RXFRAGMENTSr_COUNTSf_SET
#define READ_S_RXFRAGMENTSr BCM53262_A0_READ_S_RXFRAGMENTSr
#define WRITE_S_RXFRAGMENTSr BCM53262_A0_WRITE_S_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXFRAGMENTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxFwdDiscPkts
 * BLOCKS:   SYS
 * DESC:     Rx Forward Discard Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXFWDDISCPKTSr 0x000085c8

#define BCM53262_A0_S_RXFWDDISCPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFwdDiscPkts.
 */
typedef union BCM53262_A0_S_RXFWDDISCPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxfwddiscpkts[1];
	uint32_t _s_rxfwddiscpkts;
} BCM53262_A0_S_RXFWDDISCPKTSr_t;

#define BCM53262_A0_S_RXFWDDISCPKTSr_CLR(r) (r).s_rxfwddiscpkts[0] = 0
#define BCM53262_A0_S_RXFWDDISCPKTSr_SET(r,d) (r).s_rxfwddiscpkts[0] = d
#define BCM53262_A0_S_RXFWDDISCPKTSr_GET(r) (r).s_rxfwddiscpkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXFWDDISCPKTSr_COUNTSf_GET(r) ((r).s_rxfwddiscpkts[0])
#define BCM53262_A0_S_RXFWDDISCPKTSr_COUNTSf_SET(r,f) (r).s_rxfwddiscpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFwdDiscPkts.
 */
#define BCM53262_A0_READ_S_RXFWDDISCPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXFWDDISCPKTSr,(r._s_rxfwddiscpkts),4)
#define BCM53262_A0_WRITE_S_RXFWDDISCPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXFWDDISCPKTSr,&(r._s_rxfwddiscpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFWDDISCPKTSr BCM53262_A0_S_RXFWDDISCPKTSr
#define S_RXFWDDISCPKTSr_SIZE BCM53262_A0_S_RXFWDDISCPKTSr_SIZE
typedef BCM53262_A0_S_RXFWDDISCPKTSr_t S_RXFWDDISCPKTSr_t;
#define S_RXFWDDISCPKTSr_CLR BCM53262_A0_S_RXFWDDISCPKTSr_CLR
#define S_RXFWDDISCPKTSr_SET BCM53262_A0_S_RXFWDDISCPKTSr_SET
#define S_RXFWDDISCPKTSr_GET BCM53262_A0_S_RXFWDDISCPKTSr_GET
#define S_RXFWDDISCPKTSr_COUNTSf_GET BCM53262_A0_S_RXFWDDISCPKTSr_COUNTSf_GET
#define S_RXFWDDISCPKTSr_COUNTSf_SET BCM53262_A0_S_RXFWDDISCPKTSr_COUNTSf_SET
#define READ_S_RXFWDDISCPKTSr BCM53262_A0_READ_S_RXFWDDISCPKTSr
#define WRITE_S_RXFWDDISCPKTSr BCM53262_A0_WRITE_S_RXFWDDISCPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXFWDDISCPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXGOODOCTETSr 0x000085a0

#define BCM53262_A0_S_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxGoodOctets.
 */
typedef union BCM53262_A0_S_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxgoodoctets[2];
	uint32_t _s_rxgoodoctets;
} BCM53262_A0_S_RXGOODOCTETSr_t;

#define BCM53262_A0_S_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxgoodoctets), 0, sizeof(BCM53262_A0_S_RXGOODOCTETSr_t))
#define BCM53262_A0_S_RXGOODOCTETSr_SET(r,i,d) (r).s_rxgoodoctets[i] = d
#define BCM53262_A0_S_RXGOODOCTETSr_GET(r,i) (r).s_rxgoodoctets[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXGOODOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_rxgoodoctets,0,63,a)
#define BCM53262_A0_S_RXGOODOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_rxgoodoctets,0,63,a)

/*
 * These macros can be used to access S_RxGoodOctets.
 */
#define BCM53262_A0_READ_S_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXGOODOCTETSr,(r._s_rxgoodoctets),8)
#define BCM53262_A0_WRITE_S_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXGOODOCTETSr,&(r._s_rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXGOODOCTETSr BCM53262_A0_S_RXGOODOCTETSr
#define S_RXGOODOCTETSr_SIZE BCM53262_A0_S_RXGOODOCTETSr_SIZE
typedef BCM53262_A0_S_RXGOODOCTETSr_t S_RXGOODOCTETSr_t;
#define S_RXGOODOCTETSr_CLR BCM53262_A0_S_RXGOODOCTETSr_CLR
#define S_RXGOODOCTETSr_SET BCM53262_A0_S_RXGOODOCTETSr_SET
#define S_RXGOODOCTETSr_GET BCM53262_A0_S_RXGOODOCTETSr_GET
#define S_RXGOODOCTETSr_COUNTSf_GET BCM53262_A0_S_RXGOODOCTETSr_COUNTSf_GET
#define S_RXGOODOCTETSr_COUNTSf_SET BCM53262_A0_S_RXGOODOCTETSr_COUNTSf_SET
#define READ_S_RXGOODOCTETSr BCM53262_A0_READ_S_RXGOODOCTETSr
#define WRITE_S_RXGOODOCTETSr BCM53262_A0_WRITE_S_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXGOODOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxJabbers
 * BLOCKS:   SYS
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXJABBERSr 0x00008594

#define BCM53262_A0_S_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxJabbers.
 */
typedef union BCM53262_A0_S_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t s_rxjabbers[1];
	uint32_t _s_rxjabbers;
} BCM53262_A0_S_RXJABBERSr_t;

#define BCM53262_A0_S_RXJABBERSr_CLR(r) (r).s_rxjabbers[0] = 0
#define BCM53262_A0_S_RXJABBERSr_SET(r,d) (r).s_rxjabbers[0] = d
#define BCM53262_A0_S_RXJABBERSr_GET(r) (r).s_rxjabbers[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXJABBERSr_COUNTSf_GET(r) ((r).s_rxjabbers[0])
#define BCM53262_A0_S_RXJABBERSr_COUNTSf_SET(r,f) (r).s_rxjabbers[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxJabbers.
 */
#define BCM53262_A0_READ_S_RXJABBERSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXJABBERSr,(r._s_rxjabbers),4)
#define BCM53262_A0_WRITE_S_RXJABBERSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXJABBERSr,&(r._s_rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXJABBERSr BCM53262_A0_S_RXJABBERSr
#define S_RXJABBERSr_SIZE BCM53262_A0_S_RXJABBERSr_SIZE
typedef BCM53262_A0_S_RXJABBERSr_t S_RXJABBERSr_t;
#define S_RXJABBERSr_CLR BCM53262_A0_S_RXJABBERSr_CLR
#define S_RXJABBERSr_SET BCM53262_A0_S_RXJABBERSr_SET
#define S_RXJABBERSr_GET BCM53262_A0_S_RXJABBERSr_GET
#define S_RXJABBERSr_COUNTSf_GET BCM53262_A0_S_RXJABBERSr_COUNTSf_GET
#define S_RXJABBERSr_COUNTSf_SET BCM53262_A0_S_RXJABBERSr_COUNTSf_SET
#define READ_S_RXJABBERSr BCM53262_A0_READ_S_RXJABBERSr
#define WRITE_S_RXJABBERSr BCM53262_A0_WRITE_S_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXJABBERSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXMULTICASTPKTSr 0x000085b0

#define BCM53262_A0_S_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxMulticastPkts.
 */
typedef union BCM53262_A0_S_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxmulticastpkts[1];
	uint32_t _s_rxmulticastpkts;
} BCM53262_A0_S_RXMULTICASTPKTSr_t;

#define BCM53262_A0_S_RXMULTICASTPKTSr_CLR(r) (r).s_rxmulticastpkts[0] = 0
#define BCM53262_A0_S_RXMULTICASTPKTSr_SET(r,d) (r).s_rxmulticastpkts[0] = d
#define BCM53262_A0_S_RXMULTICASTPKTSr_GET(r) (r).s_rxmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXMULTICASTPKTSr_COUNTSf_GET(r) ((r).s_rxmulticastpkts[0])
#define BCM53262_A0_S_RXMULTICASTPKTSr_COUNTSf_SET(r,f) (r).s_rxmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxMulticastPkts.
 */
#define BCM53262_A0_READ_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXMULTICASTPKTSr,(r._s_rxmulticastpkts),4)
#define BCM53262_A0_WRITE_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXMULTICASTPKTSr,&(r._s_rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXMULTICASTPKTSr BCM53262_A0_S_RXMULTICASTPKTSr
#define S_RXMULTICASTPKTSr_SIZE BCM53262_A0_S_RXMULTICASTPKTSr_SIZE
typedef BCM53262_A0_S_RXMULTICASTPKTSr_t S_RXMULTICASTPKTSr_t;
#define S_RXMULTICASTPKTSr_CLR BCM53262_A0_S_RXMULTICASTPKTSr_CLR
#define S_RXMULTICASTPKTSr_SET BCM53262_A0_S_RXMULTICASTPKTSr_SET
#define S_RXMULTICASTPKTSr_GET BCM53262_A0_S_RXMULTICASTPKTSr_GET
#define S_RXMULTICASTPKTSr_COUNTSf_GET BCM53262_A0_S_RXMULTICASTPKTSr_COUNTSf_GET
#define S_RXMULTICASTPKTSr_COUNTSf_SET BCM53262_A0_S_RXMULTICASTPKTSr_COUNTSf_SET
#define READ_S_RXMULTICASTPKTSr BCM53262_A0_READ_S_RXMULTICASTPKTSr
#define WRITE_S_RXMULTICASTPKTSr BCM53262_A0_WRITE_S_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXMULTICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxOctets
 * BLOCKS:   SYS
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXOCTETSr 0x00008568

#define BCM53262_A0_S_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxOctets.
 */
typedef union BCM53262_A0_S_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxoctets[2];
	uint32_t _s_rxoctets;
} BCM53262_A0_S_RXOCTETSr_t;

#define BCM53262_A0_S_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxoctets), 0, sizeof(BCM53262_A0_S_RXOCTETSr_t))
#define BCM53262_A0_S_RXOCTETSr_SET(r,i,d) (r).s_rxoctets[i] = d
#define BCM53262_A0_S_RXOCTETSr_GET(r,i) (r).s_rxoctets[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_rxoctets,0,63,a)
#define BCM53262_A0_S_RXOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_rxoctets,0,63,a)

/*
 * These macros can be used to access S_RxOctets.
 */
#define BCM53262_A0_READ_S_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXOCTETSr,(r._s_rxoctets),8)
#define BCM53262_A0_WRITE_S_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXOCTETSr,&(r._s_rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOCTETSr BCM53262_A0_S_RXOCTETSr
#define S_RXOCTETSr_SIZE BCM53262_A0_S_RXOCTETSr_SIZE
typedef BCM53262_A0_S_RXOCTETSr_t S_RXOCTETSr_t;
#define S_RXOCTETSr_CLR BCM53262_A0_S_RXOCTETSr_CLR
#define S_RXOCTETSr_SET BCM53262_A0_S_RXOCTETSr_SET
#define S_RXOCTETSr_GET BCM53262_A0_S_RXOCTETSr_GET
#define S_RXOCTETSr_COUNTSf_GET BCM53262_A0_S_RXOCTETSr_COUNTSf_GET
#define S_RXOCTETSr_COUNTSf_SET BCM53262_A0_S_RXOCTETSr_COUNTSf_SET
#define READ_S_RXOCTETSr BCM53262_A0_READ_S_RXOCTETSr
#define WRITE_S_RXOCTETSr BCM53262_A0_WRITE_S_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXOVERSIZEPKTSr 0x00008590

#define BCM53262_A0_S_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxOversizePkts.
 */
typedef union BCM53262_A0_S_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxoversizepkts[1];
	uint32_t _s_rxoversizepkts;
} BCM53262_A0_S_RXOVERSIZEPKTSr_t;

#define BCM53262_A0_S_RXOVERSIZEPKTSr_CLR(r) (r).s_rxoversizepkts[0] = 0
#define BCM53262_A0_S_RXOVERSIZEPKTSr_SET(r,d) (r).s_rxoversizepkts[0] = d
#define BCM53262_A0_S_RXOVERSIZEPKTSr_GET(r) (r).s_rxoversizepkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXOVERSIZEPKTSr_COUNTSf_GET(r) ((r).s_rxoversizepkts[0])
#define BCM53262_A0_S_RXOVERSIZEPKTSr_COUNTSf_SET(r,f) (r).s_rxoversizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxOversizePkts.
 */
#define BCM53262_A0_READ_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXOVERSIZEPKTSr,(r._s_rxoversizepkts),4)
#define BCM53262_A0_WRITE_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXOVERSIZEPKTSr,&(r._s_rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOVERSIZEPKTSr BCM53262_A0_S_RXOVERSIZEPKTSr
#define S_RXOVERSIZEPKTSr_SIZE BCM53262_A0_S_RXOVERSIZEPKTSr_SIZE
typedef BCM53262_A0_S_RXOVERSIZEPKTSr_t S_RXOVERSIZEPKTSr_t;
#define S_RXOVERSIZEPKTSr_CLR BCM53262_A0_S_RXOVERSIZEPKTSr_CLR
#define S_RXOVERSIZEPKTSr_SET BCM53262_A0_S_RXOVERSIZEPKTSr_SET
#define S_RXOVERSIZEPKTSr_GET BCM53262_A0_S_RXOVERSIZEPKTSr_GET
#define S_RXOVERSIZEPKTSr_COUNTSf_GET BCM53262_A0_S_RXOVERSIZEPKTSr_COUNTSf_GET
#define S_RXOVERSIZEPKTSr_COUNTSf_SET BCM53262_A0_S_RXOVERSIZEPKTSr_COUNTSf_SET
#define READ_S_RXOVERSIZEPKTSr BCM53262_A0_READ_S_RXOVERSIZEPKTSr
#define WRITE_S_RXOVERSIZEPKTSr BCM53262_A0_WRITE_S_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXOVERSIZEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxPausePkts
 * BLOCKS:   SYS
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXPAUSEPKTSr 0x00008574

#define BCM53262_A0_S_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPausePkts.
 */
typedef union BCM53262_A0_S_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxpausepkts[1];
	uint32_t _s_rxpausepkts;
} BCM53262_A0_S_RXPAUSEPKTSr_t;

#define BCM53262_A0_S_RXPAUSEPKTSr_CLR(r) (r).s_rxpausepkts[0] = 0
#define BCM53262_A0_S_RXPAUSEPKTSr_SET(r,d) (r).s_rxpausepkts[0] = d
#define BCM53262_A0_S_RXPAUSEPKTSr_GET(r) (r).s_rxpausepkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXPAUSEPKTSr_COUNTSf_GET(r) ((r).s_rxpausepkts[0])
#define BCM53262_A0_S_RXPAUSEPKTSr_COUNTSf_SET(r,f) (r).s_rxpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxPausePkts.
 */
#define BCM53262_A0_READ_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXPAUSEPKTSr,(r._s_rxpausepkts),4)
#define BCM53262_A0_WRITE_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXPAUSEPKTSr,&(r._s_rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPAUSEPKTSr BCM53262_A0_S_RXPAUSEPKTSr
#define S_RXPAUSEPKTSr_SIZE BCM53262_A0_S_RXPAUSEPKTSr_SIZE
typedef BCM53262_A0_S_RXPAUSEPKTSr_t S_RXPAUSEPKTSr_t;
#define S_RXPAUSEPKTSr_CLR BCM53262_A0_S_RXPAUSEPKTSr_CLR
#define S_RXPAUSEPKTSr_SET BCM53262_A0_S_RXPAUSEPKTSr_SET
#define S_RXPAUSEPKTSr_GET BCM53262_A0_S_RXPAUSEPKTSr_GET
#define S_RXPAUSEPKTSr_COUNTSf_GET BCM53262_A0_S_RXPAUSEPKTSr_COUNTSf_GET
#define S_RXPAUSEPKTSr_COUNTSf_SET BCM53262_A0_S_RXPAUSEPKTSr_COUNTSf_SET
#define READ_S_RXPAUSEPKTSr BCM53262_A0_READ_S_RXPAUSEPKTSr
#define WRITE_S_RXPAUSEPKTSr BCM53262_A0_WRITE_S_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXPAUSEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxSAChanges
 * BLOCKS:   SYS
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXSACHANGESr 0x000085b8

#define BCM53262_A0_S_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program S_RxSAChanges.
 */
typedef union BCM53262_A0_S_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t s_rxsachanges[1];
	uint32_t _s_rxsachanges;
} BCM53262_A0_S_RXSACHANGESr_t;

#define BCM53262_A0_S_RXSACHANGESr_CLR(r) (r).s_rxsachanges[0] = 0
#define BCM53262_A0_S_RXSACHANGESr_SET(r,d) (r).s_rxsachanges[0] = d
#define BCM53262_A0_S_RXSACHANGESr_GET(r) (r).s_rxsachanges[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXSACHANGESr_COUNTSf_GET(r) ((r).s_rxsachanges[0])
#define BCM53262_A0_S_RXSACHANGESr_COUNTSf_SET(r,f) (r).s_rxsachanges[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxSAChanges.
 */
#define BCM53262_A0_READ_S_RXSACHANGESr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXSACHANGESr,(r._s_rxsachanges),4)
#define BCM53262_A0_WRITE_S_RXSACHANGESr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXSACHANGESr,&(r._s_rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSACHANGESr BCM53262_A0_S_RXSACHANGESr
#define S_RXSACHANGESr_SIZE BCM53262_A0_S_RXSACHANGESr_SIZE
typedef BCM53262_A0_S_RXSACHANGESr_t S_RXSACHANGESr_t;
#define S_RXSACHANGESr_CLR BCM53262_A0_S_RXSACHANGESr_CLR
#define S_RXSACHANGESr_SET BCM53262_A0_S_RXSACHANGESr_SET
#define S_RXSACHANGESr_GET BCM53262_A0_S_RXSACHANGESr_GET
#define S_RXSACHANGESr_COUNTSf_GET BCM53262_A0_S_RXSACHANGESr_COUNTSf_GET
#define S_RXSACHANGESr_COUNTSf_SET BCM53262_A0_S_RXSACHANGESr_COUNTSf_SET
#define READ_S_RXSACHANGESr BCM53262_A0_READ_S_RXSACHANGESr
#define WRITE_S_RXSACHANGESr BCM53262_A0_WRITE_S_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXSACHANGESr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXUNDERSIZEPKTSr 0x00008570

#define BCM53262_A0_S_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUndersizePkts.
 */
typedef union BCM53262_A0_S_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxundersizepkts[1];
	uint32_t _s_rxundersizepkts;
} BCM53262_A0_S_RXUNDERSIZEPKTSr_t;

#define BCM53262_A0_S_RXUNDERSIZEPKTSr_CLR(r) (r).s_rxundersizepkts[0] = 0
#define BCM53262_A0_S_RXUNDERSIZEPKTSr_SET(r,d) (r).s_rxundersizepkts[0] = d
#define BCM53262_A0_S_RXUNDERSIZEPKTSr_GET(r) (r).s_rxundersizepkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXUNDERSIZEPKTSr_COUNTSf_GET(r) ((r).s_rxundersizepkts[0])
#define BCM53262_A0_S_RXUNDERSIZEPKTSr_COUNTSf_SET(r,f) (r).s_rxundersizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUndersizePkts.
 */
#define BCM53262_A0_READ_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXUNDERSIZEPKTSr,(r._s_rxundersizepkts),4)
#define BCM53262_A0_WRITE_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXUNDERSIZEPKTSr,&(r._s_rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNDERSIZEPKTSr BCM53262_A0_S_RXUNDERSIZEPKTSr
#define S_RXUNDERSIZEPKTSr_SIZE BCM53262_A0_S_RXUNDERSIZEPKTSr_SIZE
typedef BCM53262_A0_S_RXUNDERSIZEPKTSr_t S_RXUNDERSIZEPKTSr_t;
#define S_RXUNDERSIZEPKTSr_CLR BCM53262_A0_S_RXUNDERSIZEPKTSr_CLR
#define S_RXUNDERSIZEPKTSr_SET BCM53262_A0_S_RXUNDERSIZEPKTSr_SET
#define S_RXUNDERSIZEPKTSr_GET BCM53262_A0_S_RXUNDERSIZEPKTSr_GET
#define S_RXUNDERSIZEPKTSr_COUNTSf_GET BCM53262_A0_S_RXUNDERSIZEPKTSr_COUNTSf_GET
#define S_RXUNDERSIZEPKTSr_COUNTSf_SET BCM53262_A0_S_RXUNDERSIZEPKTSr_COUNTSf_SET
#define READ_S_RXUNDERSIZEPKTSr BCM53262_A0_READ_S_RXUNDERSIZEPKTSr
#define WRITE_S_RXUNDERSIZEPKTSr BCM53262_A0_WRITE_S_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXUNDERSIZEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_RXUNICASTPKTSr 0x000085ac

#define BCM53262_A0_S_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUnicastPkts.
 */
typedef union BCM53262_A0_S_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxunicastpkts[1];
	uint32_t _s_rxunicastpkts;
} BCM53262_A0_S_RXUNICASTPKTSr_t;

#define BCM53262_A0_S_RXUNICASTPKTSr_CLR(r) (r).s_rxunicastpkts[0] = 0
#define BCM53262_A0_S_RXUNICASTPKTSr_SET(r,d) (r).s_rxunicastpkts[0] = d
#define BCM53262_A0_S_RXUNICASTPKTSr_GET(r) (r).s_rxunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_RXUNICASTPKTSr_COUNTSf_GET(r) ((r).s_rxunicastpkts[0])
#define BCM53262_A0_S_RXUNICASTPKTSr_COUNTSf_SET(r,f) (r).s_rxunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUnicastPkts.
 */
#define BCM53262_A0_READ_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_RXUNICASTPKTSr,(r._s_rxunicastpkts),4)
#define BCM53262_A0_WRITE_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_RXUNICASTPKTSr,&(r._s_rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNICASTPKTSr BCM53262_A0_S_RXUNICASTPKTSr
#define S_RXUNICASTPKTSr_SIZE BCM53262_A0_S_RXUNICASTPKTSr_SIZE
typedef BCM53262_A0_S_RXUNICASTPKTSr_t S_RXUNICASTPKTSr_t;
#define S_RXUNICASTPKTSr_CLR BCM53262_A0_S_RXUNICASTPKTSr_CLR
#define S_RXUNICASTPKTSr_SET BCM53262_A0_S_RXUNICASTPKTSr_SET
#define S_RXUNICASTPKTSr_GET BCM53262_A0_S_RXUNICASTPKTSr_GET
#define S_RXUNICASTPKTSr_COUNTSf_GET BCM53262_A0_S_RXUNICASTPKTSr_COUNTSf_GET
#define S_RXUNICASTPKTSr_COUNTSf_SET BCM53262_A0_S_RXUNICASTPKTSr_COUNTSf_SET
#define READ_S_RXUNICASTPKTSr BCM53262_A0_READ_S_RXUNICASTPKTSr
#define WRITE_S_RXUNICASTPKTSr BCM53262_A0_WRITE_S_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_RXUNICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXBROADCASTPKTSr 0x00008510

#define BCM53262_A0_S_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxBroadcastPkts.
 */
typedef union BCM53262_A0_S_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txbroadcastpkts[1];
	uint32_t _s_txbroadcastpkts;
} BCM53262_A0_S_TXBROADCASTPKTSr_t;

#define BCM53262_A0_S_TXBROADCASTPKTSr_CLR(r) (r).s_txbroadcastpkts[0] = 0
#define BCM53262_A0_S_TXBROADCASTPKTSr_SET(r,d) (r).s_txbroadcastpkts[0] = d
#define BCM53262_A0_S_TXBROADCASTPKTSr_GET(r) (r).s_txbroadcastpkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXBROADCASTPKTSr_COUNTSf_GET(r) ((r).s_txbroadcastpkts[0])
#define BCM53262_A0_S_TXBROADCASTPKTSr_COUNTSf_SET(r,f) (r).s_txbroadcastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxBroadcastPkts.
 */
#define BCM53262_A0_READ_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXBROADCASTPKTSr,(r._s_txbroadcastpkts),4)
#define BCM53262_A0_WRITE_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXBROADCASTPKTSr,&(r._s_txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXBROADCASTPKTSr BCM53262_A0_S_TXBROADCASTPKTSr
#define S_TXBROADCASTPKTSr_SIZE BCM53262_A0_S_TXBROADCASTPKTSr_SIZE
typedef BCM53262_A0_S_TXBROADCASTPKTSr_t S_TXBROADCASTPKTSr_t;
#define S_TXBROADCASTPKTSr_CLR BCM53262_A0_S_TXBROADCASTPKTSr_CLR
#define S_TXBROADCASTPKTSr_SET BCM53262_A0_S_TXBROADCASTPKTSr_SET
#define S_TXBROADCASTPKTSr_GET BCM53262_A0_S_TXBROADCASTPKTSr_GET
#define S_TXBROADCASTPKTSr_COUNTSf_GET BCM53262_A0_S_TXBROADCASTPKTSr_COUNTSf_GET
#define S_TXBROADCASTPKTSr_COUNTSf_SET BCM53262_A0_S_TXBROADCASTPKTSr_COUNTSf_SET
#define READ_S_TXBROADCASTPKTSr BCM53262_A0_READ_S_TXBROADCASTPKTSr
#define WRITE_S_TXBROADCASTPKTSr BCM53262_A0_WRITE_S_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXBROADCASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxCollisions
 * BLOCKS:   SYS
 * DESC:     Tx Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXCOLLISIONSr 0x0000851c

#define BCM53262_A0_S_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxCollisions.
 */
typedef union BCM53262_A0_S_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txcollisions[1];
	uint32_t _s_txcollisions;
} BCM53262_A0_S_TXCOLLISIONSr_t;

#define BCM53262_A0_S_TXCOLLISIONSr_CLR(r) (r).s_txcollisions[0] = 0
#define BCM53262_A0_S_TXCOLLISIONSr_SET(r,d) (r).s_txcollisions[0] = d
#define BCM53262_A0_S_TXCOLLISIONSr_GET(r) (r).s_txcollisions[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXCOLLISIONSr_COUNTSf_GET(r) ((r).s_txcollisions[0])
#define BCM53262_A0_S_TXCOLLISIONSr_COUNTSf_SET(r,f) (r).s_txcollisions[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxCollisions.
 */
#define BCM53262_A0_READ_S_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXCOLLISIONSr,(r._s_txcollisions),4)
#define BCM53262_A0_WRITE_S_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXCOLLISIONSr,&(r._s_txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXCOLLISIONSr BCM53262_A0_S_TXCOLLISIONSr
#define S_TXCOLLISIONSr_SIZE BCM53262_A0_S_TXCOLLISIONSr_SIZE
typedef BCM53262_A0_S_TXCOLLISIONSr_t S_TXCOLLISIONSr_t;
#define S_TXCOLLISIONSr_CLR BCM53262_A0_S_TXCOLLISIONSr_CLR
#define S_TXCOLLISIONSr_SET BCM53262_A0_S_TXCOLLISIONSr_SET
#define S_TXCOLLISIONSr_GET BCM53262_A0_S_TXCOLLISIONSr_GET
#define S_TXCOLLISIONSr_COUNTSf_GET BCM53262_A0_S_TXCOLLISIONSr_COUNTSf_GET
#define S_TXCOLLISIONSr_COUNTSf_SET BCM53262_A0_S_TXCOLLISIONSr_COUNTSf_SET
#define READ_S_TXCOLLISIONSr BCM53262_A0_READ_S_TXCOLLISIONSr
#define WRITE_S_TXCOLLISIONSr BCM53262_A0_WRITE_S_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXCOLLISIONSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXDEFERREDTRANSMITr 0x00008528

#define BCM53262_A0_S_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDeferredTransmit.
 */
typedef union BCM53262_A0_S_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t s_txdeferredtransmit[1];
	uint32_t _s_txdeferredtransmit;
} BCM53262_A0_S_TXDEFERREDTRANSMITr_t;

#define BCM53262_A0_S_TXDEFERREDTRANSMITr_CLR(r) (r).s_txdeferredtransmit[0] = 0
#define BCM53262_A0_S_TXDEFERREDTRANSMITr_SET(r,d) (r).s_txdeferredtransmit[0] = d
#define BCM53262_A0_S_TXDEFERREDTRANSMITr_GET(r) (r).s_txdeferredtransmit[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXDEFERREDTRANSMITr_COUNTSf_GET(r) ((r).s_txdeferredtransmit[0])
#define BCM53262_A0_S_TXDEFERREDTRANSMITr_COUNTSf_SET(r,f) (r).s_txdeferredtransmit[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDeferredTransmit.
 */
#define BCM53262_A0_READ_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXDEFERREDTRANSMITr,(r._s_txdeferredtransmit),4)
#define BCM53262_A0_WRITE_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXDEFERREDTRANSMITr,&(r._s_txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDEFERREDTRANSMITr BCM53262_A0_S_TXDEFERREDTRANSMITr
#define S_TXDEFERREDTRANSMITr_SIZE BCM53262_A0_S_TXDEFERREDTRANSMITr_SIZE
typedef BCM53262_A0_S_TXDEFERREDTRANSMITr_t S_TXDEFERREDTRANSMITr_t;
#define S_TXDEFERREDTRANSMITr_CLR BCM53262_A0_S_TXDEFERREDTRANSMITr_CLR
#define S_TXDEFERREDTRANSMITr_SET BCM53262_A0_S_TXDEFERREDTRANSMITr_SET
#define S_TXDEFERREDTRANSMITr_GET BCM53262_A0_S_TXDEFERREDTRANSMITr_GET
#define S_TXDEFERREDTRANSMITr_COUNTSf_GET BCM53262_A0_S_TXDEFERREDTRANSMITr_COUNTSf_GET
#define S_TXDEFERREDTRANSMITr_COUNTSf_SET BCM53262_A0_S_TXDEFERREDTRANSMITr_COUNTSf_SET
#define READ_S_TXDEFERREDTRANSMITr BCM53262_A0_READ_S_TXDEFERREDTRANSMITr
#define WRITE_S_TXDEFERREDTRANSMITr BCM53262_A0_WRITE_S_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXDEFERREDTRANSMITr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxDropPkts
 * BLOCKS:   SYS
 * DESC:     TX Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXDROPPKTSr 0x00008508

#define BCM53262_A0_S_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDropPkts.
 */
typedef union BCM53262_A0_S_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_txdroppkts[1];
	uint32_t _s_txdroppkts;
} BCM53262_A0_S_TXDROPPKTSr_t;

#define BCM53262_A0_S_TXDROPPKTSr_CLR(r) (r).s_txdroppkts[0] = 0
#define BCM53262_A0_S_TXDROPPKTSr_SET(r,d) (r).s_txdroppkts[0] = d
#define BCM53262_A0_S_TXDROPPKTSr_GET(r) (r).s_txdroppkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXDROPPKTSr_COUNTSf_GET(r) ((r).s_txdroppkts[0])
#define BCM53262_A0_S_TXDROPPKTSr_COUNTSf_SET(r,f) (r).s_txdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDropPkts.
 */
#define BCM53262_A0_READ_S_TXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXDROPPKTSr,(r._s_txdroppkts),4)
#define BCM53262_A0_WRITE_S_TXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXDROPPKTSr,&(r._s_txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDROPPKTSr BCM53262_A0_S_TXDROPPKTSr
#define S_TXDROPPKTSr_SIZE BCM53262_A0_S_TXDROPPKTSr_SIZE
typedef BCM53262_A0_S_TXDROPPKTSr_t S_TXDROPPKTSr_t;
#define S_TXDROPPKTSr_CLR BCM53262_A0_S_TXDROPPKTSr_CLR
#define S_TXDROPPKTSr_SET BCM53262_A0_S_TXDROPPKTSr_SET
#define S_TXDROPPKTSr_GET BCM53262_A0_S_TXDROPPKTSr_GET
#define S_TXDROPPKTSr_COUNTSf_GET BCM53262_A0_S_TXDROPPKTSr_COUNTSf_GET
#define S_TXDROPPKTSr_COUNTSf_SET BCM53262_A0_S_TXDROPPKTSr_COUNTSf_SET
#define READ_S_TXDROPPKTSr BCM53262_A0_READ_S_TXDROPPKTSr
#define WRITE_S_TXDROPPKTSr BCM53262_A0_WRITE_S_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXDROPPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXEXCESSIVECOLLISIONr 0x00008530

#define BCM53262_A0_S_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxExcessiveCollision.
 */
typedef union BCM53262_A0_S_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txexcessivecollision[1];
	uint32_t _s_txexcessivecollision;
} BCM53262_A0_S_TXEXCESSIVECOLLISIONr_t;

#define BCM53262_A0_S_TXEXCESSIVECOLLISIONr_CLR(r) (r).s_txexcessivecollision[0] = 0
#define BCM53262_A0_S_TXEXCESSIVECOLLISIONr_SET(r,d) (r).s_txexcessivecollision[0] = d
#define BCM53262_A0_S_TXEXCESSIVECOLLISIONr_GET(r) (r).s_txexcessivecollision[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_GET(r) ((r).s_txexcessivecollision[0])
#define BCM53262_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_SET(r,f) (r).s_txexcessivecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxExcessiveCollision.
 */
#define BCM53262_A0_READ_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXEXCESSIVECOLLISIONr,(r._s_txexcessivecollision),4)
#define BCM53262_A0_WRITE_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXEXCESSIVECOLLISIONr,&(r._s_txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXEXCESSIVECOLLISIONr BCM53262_A0_S_TXEXCESSIVECOLLISIONr
#define S_TXEXCESSIVECOLLISIONr_SIZE BCM53262_A0_S_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53262_A0_S_TXEXCESSIVECOLLISIONr_t S_TXEXCESSIVECOLLISIONr_t;
#define S_TXEXCESSIVECOLLISIONr_CLR BCM53262_A0_S_TXEXCESSIVECOLLISIONr_CLR
#define S_TXEXCESSIVECOLLISIONr_SET BCM53262_A0_S_TXEXCESSIVECOLLISIONr_SET
#define S_TXEXCESSIVECOLLISIONr_GET BCM53262_A0_S_TXEXCESSIVECOLLISIONr_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTSf_GET BCM53262_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTSf_SET BCM53262_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_SET
#define READ_S_TXEXCESSIVECOLLISIONr BCM53262_A0_READ_S_TXEXCESSIVECOLLISIONr
#define WRITE_S_TXEXCESSIVECOLLISIONr BCM53262_A0_WRITE_S_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXEXCESSIVECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxFrameInDisc
 * BLOCKS:   SYS
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXFRAMEINDISCr 0x00008534

#define BCM53262_A0_S_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_TxFrameInDisc.
 */
typedef union BCM53262_A0_S_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t s_txframeindisc[1];
	uint32_t _s_txframeindisc;
} BCM53262_A0_S_TXFRAMEINDISCr_t;

#define BCM53262_A0_S_TXFRAMEINDISCr_CLR(r) (r).s_txframeindisc[0] = 0
#define BCM53262_A0_S_TXFRAMEINDISCr_SET(r,d) (r).s_txframeindisc[0] = d
#define BCM53262_A0_S_TXFRAMEINDISCr_GET(r) (r).s_txframeindisc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXFRAMEINDISCr_COUNTSf_GET(r) ((r).s_txframeindisc[0])
#define BCM53262_A0_S_TXFRAMEINDISCr_COUNTSf_SET(r,f) (r).s_txframeindisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxFrameInDisc.
 */
#define BCM53262_A0_READ_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXFRAMEINDISCr,(r._s_txframeindisc),4)
#define BCM53262_A0_WRITE_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXFRAMEINDISCr,&(r._s_txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXFRAMEINDISCr BCM53262_A0_S_TXFRAMEINDISCr
#define S_TXFRAMEINDISCr_SIZE BCM53262_A0_S_TXFRAMEINDISCr_SIZE
typedef BCM53262_A0_S_TXFRAMEINDISCr_t S_TXFRAMEINDISCr_t;
#define S_TXFRAMEINDISCr_CLR BCM53262_A0_S_TXFRAMEINDISCr_CLR
#define S_TXFRAMEINDISCr_SET BCM53262_A0_S_TXFRAMEINDISCr_SET
#define S_TXFRAMEINDISCr_GET BCM53262_A0_S_TXFRAMEINDISCr_GET
#define S_TXFRAMEINDISCr_COUNTSf_GET BCM53262_A0_S_TXFRAMEINDISCr_COUNTSf_GET
#define S_TXFRAMEINDISCr_COUNTSf_SET BCM53262_A0_S_TXFRAMEINDISCr_COUNTSf_SET
#define READ_S_TXFRAMEINDISCr BCM53262_A0_READ_S_TXFRAMEINDISCr
#define WRITE_S_TXFRAMEINDISCr BCM53262_A0_WRITE_S_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXFRAMEINDISCr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxLateCollision
 * BLOCKS:   SYS
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXLATECOLLISIONr 0x0000852c

#define BCM53262_A0_S_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxLateCollision.
 */
typedef union BCM53262_A0_S_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txlatecollision[1];
	uint32_t _s_txlatecollision;
} BCM53262_A0_S_TXLATECOLLISIONr_t;

#define BCM53262_A0_S_TXLATECOLLISIONr_CLR(r) (r).s_txlatecollision[0] = 0
#define BCM53262_A0_S_TXLATECOLLISIONr_SET(r,d) (r).s_txlatecollision[0] = d
#define BCM53262_A0_S_TXLATECOLLISIONr_GET(r) (r).s_txlatecollision[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXLATECOLLISIONr_COUNTSf_GET(r) ((r).s_txlatecollision[0])
#define BCM53262_A0_S_TXLATECOLLISIONr_COUNTSf_SET(r,f) (r).s_txlatecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxLateCollision.
 */
#define BCM53262_A0_READ_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXLATECOLLISIONr,(r._s_txlatecollision),4)
#define BCM53262_A0_WRITE_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXLATECOLLISIONr,&(r._s_txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXLATECOLLISIONr BCM53262_A0_S_TXLATECOLLISIONr
#define S_TXLATECOLLISIONr_SIZE BCM53262_A0_S_TXLATECOLLISIONr_SIZE
typedef BCM53262_A0_S_TXLATECOLLISIONr_t S_TXLATECOLLISIONr_t;
#define S_TXLATECOLLISIONr_CLR BCM53262_A0_S_TXLATECOLLISIONr_CLR
#define S_TXLATECOLLISIONr_SET BCM53262_A0_S_TXLATECOLLISIONr_SET
#define S_TXLATECOLLISIONr_GET BCM53262_A0_S_TXLATECOLLISIONr_GET
#define S_TXLATECOLLISIONr_COUNTSf_GET BCM53262_A0_S_TXLATECOLLISIONr_COUNTSf_GET
#define S_TXLATECOLLISIONr_COUNTSf_SET BCM53262_A0_S_TXLATECOLLISIONr_COUNTSf_SET
#define READ_S_TXLATECOLLISIONr BCM53262_A0_READ_S_TXLATECOLLISIONr
#define WRITE_S_TXLATECOLLISIONr BCM53262_A0_WRITE_S_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXLATECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXMULTICASTPKTSr 0x00008514

#define BCM53262_A0_S_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMulticastPkts.
 */
typedef union BCM53262_A0_S_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txmulticastpkts[1];
	uint32_t _s_txmulticastpkts;
} BCM53262_A0_S_TXMULTICASTPKTSr_t;

#define BCM53262_A0_S_TXMULTICASTPKTSr_CLR(r) (r).s_txmulticastpkts[0] = 0
#define BCM53262_A0_S_TXMULTICASTPKTSr_SET(r,d) (r).s_txmulticastpkts[0] = d
#define BCM53262_A0_S_TXMULTICASTPKTSr_GET(r) (r).s_txmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXMULTICASTPKTSr_COUNTSf_GET(r) ((r).s_txmulticastpkts[0])
#define BCM53262_A0_S_TXMULTICASTPKTSr_COUNTSf_SET(r,f) (r).s_txmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMulticastPkts.
 */
#define BCM53262_A0_READ_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXMULTICASTPKTSr,(r._s_txmulticastpkts),4)
#define BCM53262_A0_WRITE_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXMULTICASTPKTSr,&(r._s_txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTICASTPKTSr BCM53262_A0_S_TXMULTICASTPKTSr
#define S_TXMULTICASTPKTSr_SIZE BCM53262_A0_S_TXMULTICASTPKTSr_SIZE
typedef BCM53262_A0_S_TXMULTICASTPKTSr_t S_TXMULTICASTPKTSr_t;
#define S_TXMULTICASTPKTSr_CLR BCM53262_A0_S_TXMULTICASTPKTSr_CLR
#define S_TXMULTICASTPKTSr_SET BCM53262_A0_S_TXMULTICASTPKTSr_SET
#define S_TXMULTICASTPKTSr_GET BCM53262_A0_S_TXMULTICASTPKTSr_GET
#define S_TXMULTICASTPKTSr_COUNTSf_GET BCM53262_A0_S_TXMULTICASTPKTSr_COUNTSf_GET
#define S_TXMULTICASTPKTSr_COUNTSf_SET BCM53262_A0_S_TXMULTICASTPKTSr_COUNTSf_SET
#define READ_S_TXMULTICASTPKTSr BCM53262_A0_READ_S_TXMULTICASTPKTSr
#define WRITE_S_TXMULTICASTPKTSr BCM53262_A0_WRITE_S_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXMULTICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxMultipleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXMULTIPLECOLLISIONr 0x00008524

#define BCM53262_A0_S_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMultipleCollision.
 */
typedef union BCM53262_A0_S_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txmultiplecollision[1];
	uint32_t _s_txmultiplecollision;
} BCM53262_A0_S_TXMULTIPLECOLLISIONr_t;

#define BCM53262_A0_S_TXMULTIPLECOLLISIONr_CLR(r) (r).s_txmultiplecollision[0] = 0
#define BCM53262_A0_S_TXMULTIPLECOLLISIONr_SET(r,d) (r).s_txmultiplecollision[0] = d
#define BCM53262_A0_S_TXMULTIPLECOLLISIONr_GET(r) (r).s_txmultiplecollision[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_GET(r) ((r).s_txmultiplecollision[0])
#define BCM53262_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_SET(r,f) (r).s_txmultiplecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMultipleCollision.
 */
#define BCM53262_A0_READ_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXMULTIPLECOLLISIONr,(r._s_txmultiplecollision),4)
#define BCM53262_A0_WRITE_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXMULTIPLECOLLISIONr,&(r._s_txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTIPLECOLLISIONr BCM53262_A0_S_TXMULTIPLECOLLISIONr
#define S_TXMULTIPLECOLLISIONr_SIZE BCM53262_A0_S_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53262_A0_S_TXMULTIPLECOLLISIONr_t S_TXMULTIPLECOLLISIONr_t;
#define S_TXMULTIPLECOLLISIONr_CLR BCM53262_A0_S_TXMULTIPLECOLLISIONr_CLR
#define S_TXMULTIPLECOLLISIONr_SET BCM53262_A0_S_TXMULTIPLECOLLISIONr_SET
#define S_TXMULTIPLECOLLISIONr_GET BCM53262_A0_S_TXMULTIPLECOLLISIONr_GET
#define S_TXMULTIPLECOLLISIONr_COUNTSf_GET BCM53262_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_GET
#define S_TXMULTIPLECOLLISIONr_COUNTSf_SET BCM53262_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_SET
#define READ_S_TXMULTIPLECOLLISIONr BCM53262_A0_READ_S_TXMULTIPLECOLLISIONr
#define WRITE_S_TXMULTIPLECOLLISIONr BCM53262_A0_WRITE_S_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXMULTIPLECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxOctets
 * BLOCKS:   SYS
 * DESC:     Tx Octets
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXOCTETSr 0x00008500

#define BCM53262_A0_S_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxOctets.
 */
typedef union BCM53262_A0_S_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txoctets[2];
	uint32_t _s_txoctets;
} BCM53262_A0_S_TXOCTETSr_t;

#define BCM53262_A0_S_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txoctets), 0, sizeof(BCM53262_A0_S_TXOCTETSr_t))
#define BCM53262_A0_S_TXOCTETSr_SET(r,i,d) (r).s_txoctets[i] = d
#define BCM53262_A0_S_TXOCTETSr_GET(r,i) (r).s_txoctets[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_txoctets,0,63,a)
#define BCM53262_A0_S_TXOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_txoctets,0,63,a)

/*
 * These macros can be used to access S_TxOctets.
 */
#define BCM53262_A0_READ_S_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXOCTETSr,(r._s_txoctets),8)
#define BCM53262_A0_WRITE_S_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXOCTETSr,&(r._s_txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXOCTETSr BCM53262_A0_S_TXOCTETSr
#define S_TXOCTETSr_SIZE BCM53262_A0_S_TXOCTETSr_SIZE
typedef BCM53262_A0_S_TXOCTETSr_t S_TXOCTETSr_t;
#define S_TXOCTETSr_CLR BCM53262_A0_S_TXOCTETSr_CLR
#define S_TXOCTETSr_SET BCM53262_A0_S_TXOCTETSr_SET
#define S_TXOCTETSr_GET BCM53262_A0_S_TXOCTETSr_GET
#define S_TXOCTETSr_COUNTSf_GET BCM53262_A0_S_TXOCTETSr_COUNTSf_GET
#define S_TXOCTETSr_COUNTSf_SET BCM53262_A0_S_TXOCTETSr_COUNTSf_SET
#define READ_S_TXOCTETSr BCM53262_A0_READ_S_TXOCTETSr
#define WRITE_S_TXOCTETSr BCM53262_A0_WRITE_S_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxPausePkts
 * BLOCKS:   SYS
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXPAUSEPKTSr 0x0000850c

#define BCM53262_A0_S_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPausePkts.
 */
typedef union BCM53262_A0_S_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_txpausepkts[1];
	uint32_t _s_txpausepkts;
} BCM53262_A0_S_TXPAUSEPKTSr_t;

#define BCM53262_A0_S_TXPAUSEPKTSr_CLR(r) (r).s_txpausepkts[0] = 0
#define BCM53262_A0_S_TXPAUSEPKTSr_SET(r,d) (r).s_txpausepkts[0] = d
#define BCM53262_A0_S_TXPAUSEPKTSr_GET(r) (r).s_txpausepkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXPAUSEPKTSr_COUNTSf_GET(r) ((r).s_txpausepkts[0])
#define BCM53262_A0_S_TXPAUSEPKTSr_COUNTSf_SET(r,f) (r).s_txpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxPausePkts.
 */
#define BCM53262_A0_READ_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXPAUSEPKTSr,(r._s_txpausepkts),4)
#define BCM53262_A0_WRITE_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXPAUSEPKTSr,&(r._s_txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPAUSEPKTSr BCM53262_A0_S_TXPAUSEPKTSr
#define S_TXPAUSEPKTSr_SIZE BCM53262_A0_S_TXPAUSEPKTSr_SIZE
typedef BCM53262_A0_S_TXPAUSEPKTSr_t S_TXPAUSEPKTSr_t;
#define S_TXPAUSEPKTSr_CLR BCM53262_A0_S_TXPAUSEPKTSr_CLR
#define S_TXPAUSEPKTSr_SET BCM53262_A0_S_TXPAUSEPKTSr_SET
#define S_TXPAUSEPKTSr_GET BCM53262_A0_S_TXPAUSEPKTSr_GET
#define S_TXPAUSEPKTSr_COUNTSf_GET BCM53262_A0_S_TXPAUSEPKTSr_COUNTSf_GET
#define S_TXPAUSEPKTSr_COUNTSf_SET BCM53262_A0_S_TXPAUSEPKTSr_COUNTSf_SET
#define READ_S_TXPAUSEPKTSr BCM53262_A0_READ_S_TXPAUSEPKTSr
#define WRITE_S_TXPAUSEPKTSr BCM53262_A0_WRITE_S_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXPAUSEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS0Octets
 * BLOCKS:   SYS
 * DESC:     Tx QoS#0 Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS0OCTETSr 0x0000853c

#define BCM53262_A0_S_TXQOS0OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxQoS0Octets.
 */
typedef union BCM53262_A0_S_TXQOS0OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqos0octets[2];
	uint32_t _s_txqos0octets;
} BCM53262_A0_S_TXQOS0OCTETSr_t;

#define BCM53262_A0_S_TXQOS0OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqos0octets), 0, sizeof(BCM53262_A0_S_TXQOS0OCTETSr_t))
#define BCM53262_A0_S_TXQOS0OCTETSr_SET(r,i,d) (r).s_txqos0octets[i] = d
#define BCM53262_A0_S_TXQOS0OCTETSr_GET(r,i) (r).s_txqos0octets[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS0OCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_txqos0octets,0,63,a)
#define BCM53262_A0_S_TXQOS0OCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_txqos0octets,0,63,a)

/*
 * These macros can be used to access S_TxQoS0Octets.
 */
#define BCM53262_A0_READ_S_TXQOS0OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS0OCTETSr,(r._s_txqos0octets),8)
#define BCM53262_A0_WRITE_S_TXQOS0OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS0OCTETSr,&(r._s_txqos0octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS0OCTETSr BCM53262_A0_S_TXQOS0OCTETSr
#define S_TXQOS0OCTETSr_SIZE BCM53262_A0_S_TXQOS0OCTETSr_SIZE
typedef BCM53262_A0_S_TXQOS0OCTETSr_t S_TXQOS0OCTETSr_t;
#define S_TXQOS0OCTETSr_CLR BCM53262_A0_S_TXQOS0OCTETSr_CLR
#define S_TXQOS0OCTETSr_SET BCM53262_A0_S_TXQOS0OCTETSr_SET
#define S_TXQOS0OCTETSr_GET BCM53262_A0_S_TXQOS0OCTETSr_GET
#define S_TXQOS0OCTETSr_COUNTSf_GET BCM53262_A0_S_TXQOS0OCTETSr_COUNTSf_GET
#define S_TXQOS0OCTETSr_COUNTSf_SET BCM53262_A0_S_TXQOS0OCTETSr_COUNTSf_SET
#define READ_S_TXQOS0OCTETSr BCM53262_A0_READ_S_TXQOS0OCTETSr
#define WRITE_S_TXQOS0OCTETSr BCM53262_A0_WRITE_S_TXQOS0OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS0OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS0Pkts
 * BLOCKS:   SYS
 * DESC:     Tx QoS#0 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS0PKTSr 0x00008538

#define BCM53262_A0_S_TXQOS0PKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxQoS0Pkts.
 */
typedef union BCM53262_A0_S_TXQOS0PKTSr_s {
	uint32_t v[1];
	uint32_t s_txqos0pkts[1];
	uint32_t _s_txqos0pkts;
} BCM53262_A0_S_TXQOS0PKTSr_t;

#define BCM53262_A0_S_TXQOS0PKTSr_CLR(r) (r).s_txqos0pkts[0] = 0
#define BCM53262_A0_S_TXQOS0PKTSr_SET(r,d) (r).s_txqos0pkts[0] = d
#define BCM53262_A0_S_TXQOS0PKTSr_GET(r) (r).s_txqos0pkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS0PKTSr_COUNTSf_GET(r) ((r).s_txqos0pkts[0])
#define BCM53262_A0_S_TXQOS0PKTSr_COUNTSf_SET(r,f) (r).s_txqos0pkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQoS0Pkts.
 */
#define BCM53262_A0_READ_S_TXQOS0PKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS0PKTSr,(r._s_txqos0pkts),4)
#define BCM53262_A0_WRITE_S_TXQOS0PKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS0PKTSr,&(r._s_txqos0pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS0PKTSr BCM53262_A0_S_TXQOS0PKTSr
#define S_TXQOS0PKTSr_SIZE BCM53262_A0_S_TXQOS0PKTSr_SIZE
typedef BCM53262_A0_S_TXQOS0PKTSr_t S_TXQOS0PKTSr_t;
#define S_TXQOS0PKTSr_CLR BCM53262_A0_S_TXQOS0PKTSr_CLR
#define S_TXQOS0PKTSr_SET BCM53262_A0_S_TXQOS0PKTSr_SET
#define S_TXQOS0PKTSr_GET BCM53262_A0_S_TXQOS0PKTSr_GET
#define S_TXQOS0PKTSr_COUNTSf_GET BCM53262_A0_S_TXQOS0PKTSr_COUNTSf_GET
#define S_TXQOS0PKTSr_COUNTSf_SET BCM53262_A0_S_TXQOS0PKTSr_COUNTSf_SET
#define READ_S_TXQOS0PKTSr BCM53262_A0_READ_S_TXQOS0PKTSr
#define WRITE_S_TXQOS0PKTSr BCM53262_A0_WRITE_S_TXQOS0PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS0PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS1Octets
 * BLOCKS:   SYS
 * DESC:     Tx QoS#1 Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS1OCTETSr 0x00008548

#define BCM53262_A0_S_TXQOS1OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxQoS1Octets.
 */
typedef union BCM53262_A0_S_TXQOS1OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqos1octets[2];
	uint32_t _s_txqos1octets;
} BCM53262_A0_S_TXQOS1OCTETSr_t;

#define BCM53262_A0_S_TXQOS1OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqos1octets), 0, sizeof(BCM53262_A0_S_TXQOS1OCTETSr_t))
#define BCM53262_A0_S_TXQOS1OCTETSr_SET(r,i,d) (r).s_txqos1octets[i] = d
#define BCM53262_A0_S_TXQOS1OCTETSr_GET(r,i) (r).s_txqos1octets[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS1OCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_txqos1octets,0,63,a)
#define BCM53262_A0_S_TXQOS1OCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_txqos1octets,0,63,a)

/*
 * These macros can be used to access S_TxQoS1Octets.
 */
#define BCM53262_A0_READ_S_TXQOS1OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS1OCTETSr,(r._s_txqos1octets),8)
#define BCM53262_A0_WRITE_S_TXQOS1OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS1OCTETSr,&(r._s_txqos1octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS1OCTETSr BCM53262_A0_S_TXQOS1OCTETSr
#define S_TXQOS1OCTETSr_SIZE BCM53262_A0_S_TXQOS1OCTETSr_SIZE
typedef BCM53262_A0_S_TXQOS1OCTETSr_t S_TXQOS1OCTETSr_t;
#define S_TXQOS1OCTETSr_CLR BCM53262_A0_S_TXQOS1OCTETSr_CLR
#define S_TXQOS1OCTETSr_SET BCM53262_A0_S_TXQOS1OCTETSr_SET
#define S_TXQOS1OCTETSr_GET BCM53262_A0_S_TXQOS1OCTETSr_GET
#define S_TXQOS1OCTETSr_COUNTSf_GET BCM53262_A0_S_TXQOS1OCTETSr_COUNTSf_GET
#define S_TXQOS1OCTETSr_COUNTSf_SET BCM53262_A0_S_TXQOS1OCTETSr_COUNTSf_SET
#define READ_S_TXQOS1OCTETSr BCM53262_A0_READ_S_TXQOS1OCTETSr
#define WRITE_S_TXQOS1OCTETSr BCM53262_A0_WRITE_S_TXQOS1OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS1OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS1Pkts
 * BLOCKS:   SYS
 * DESC:     Tx QoS#1 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS1PKTSr 0x00008544

#define BCM53262_A0_S_TXQOS1PKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxQoS1Pkts.
 */
typedef union BCM53262_A0_S_TXQOS1PKTSr_s {
	uint32_t v[1];
	uint32_t s_txqos1pkts[1];
	uint32_t _s_txqos1pkts;
} BCM53262_A0_S_TXQOS1PKTSr_t;

#define BCM53262_A0_S_TXQOS1PKTSr_CLR(r) (r).s_txqos1pkts[0] = 0
#define BCM53262_A0_S_TXQOS1PKTSr_SET(r,d) (r).s_txqos1pkts[0] = d
#define BCM53262_A0_S_TXQOS1PKTSr_GET(r) (r).s_txqos1pkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS1PKTSr_COUNTSf_GET(r) ((r).s_txqos1pkts[0])
#define BCM53262_A0_S_TXQOS1PKTSr_COUNTSf_SET(r,f) (r).s_txqos1pkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQoS1Pkts.
 */
#define BCM53262_A0_READ_S_TXQOS1PKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS1PKTSr,(r._s_txqos1pkts),4)
#define BCM53262_A0_WRITE_S_TXQOS1PKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS1PKTSr,&(r._s_txqos1pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS1PKTSr BCM53262_A0_S_TXQOS1PKTSr
#define S_TXQOS1PKTSr_SIZE BCM53262_A0_S_TXQOS1PKTSr_SIZE
typedef BCM53262_A0_S_TXQOS1PKTSr_t S_TXQOS1PKTSr_t;
#define S_TXQOS1PKTSr_CLR BCM53262_A0_S_TXQOS1PKTSr_CLR
#define S_TXQOS1PKTSr_SET BCM53262_A0_S_TXQOS1PKTSr_SET
#define S_TXQOS1PKTSr_GET BCM53262_A0_S_TXQOS1PKTSr_GET
#define S_TXQOS1PKTSr_COUNTSf_GET BCM53262_A0_S_TXQOS1PKTSr_COUNTSf_GET
#define S_TXQOS1PKTSr_COUNTSf_SET BCM53262_A0_S_TXQOS1PKTSr_COUNTSf_SET
#define READ_S_TXQOS1PKTSr BCM53262_A0_READ_S_TXQOS1PKTSr
#define WRITE_S_TXQOS1PKTSr BCM53262_A0_WRITE_S_TXQOS1PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS1PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS2Octets
 * BLOCKS:   SYS
 * DESC:     Tx QoS#2 Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS2OCTETSr 0x00008554

#define BCM53262_A0_S_TXQOS2OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxQoS2Octets.
 */
typedef union BCM53262_A0_S_TXQOS2OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqos2octets[2];
	uint32_t _s_txqos2octets;
} BCM53262_A0_S_TXQOS2OCTETSr_t;

#define BCM53262_A0_S_TXQOS2OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqos2octets), 0, sizeof(BCM53262_A0_S_TXQOS2OCTETSr_t))
#define BCM53262_A0_S_TXQOS2OCTETSr_SET(r,i,d) (r).s_txqos2octets[i] = d
#define BCM53262_A0_S_TXQOS2OCTETSr_GET(r,i) (r).s_txqos2octets[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS2OCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_txqos2octets,0,63,a)
#define BCM53262_A0_S_TXQOS2OCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_txqos2octets,0,63,a)

/*
 * These macros can be used to access S_TxQoS2Octets.
 */
#define BCM53262_A0_READ_S_TXQOS2OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS2OCTETSr,(r._s_txqos2octets),8)
#define BCM53262_A0_WRITE_S_TXQOS2OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS2OCTETSr,&(r._s_txqos2octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS2OCTETSr BCM53262_A0_S_TXQOS2OCTETSr
#define S_TXQOS2OCTETSr_SIZE BCM53262_A0_S_TXQOS2OCTETSr_SIZE
typedef BCM53262_A0_S_TXQOS2OCTETSr_t S_TXQOS2OCTETSr_t;
#define S_TXQOS2OCTETSr_CLR BCM53262_A0_S_TXQOS2OCTETSr_CLR
#define S_TXQOS2OCTETSr_SET BCM53262_A0_S_TXQOS2OCTETSr_SET
#define S_TXQOS2OCTETSr_GET BCM53262_A0_S_TXQOS2OCTETSr_GET
#define S_TXQOS2OCTETSr_COUNTSf_GET BCM53262_A0_S_TXQOS2OCTETSr_COUNTSf_GET
#define S_TXQOS2OCTETSr_COUNTSf_SET BCM53262_A0_S_TXQOS2OCTETSr_COUNTSf_SET
#define READ_S_TXQOS2OCTETSr BCM53262_A0_READ_S_TXQOS2OCTETSr
#define WRITE_S_TXQOS2OCTETSr BCM53262_A0_WRITE_S_TXQOS2OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS2OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS2Pkts
 * BLOCKS:   SYS
 * DESC:     Tx QoS#2 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS2PKTSr 0x00008550

#define BCM53262_A0_S_TXQOS2PKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxQoS2Pkts.
 */
typedef union BCM53262_A0_S_TXQOS2PKTSr_s {
	uint32_t v[1];
	uint32_t s_txqos2pkts[1];
	uint32_t _s_txqos2pkts;
} BCM53262_A0_S_TXQOS2PKTSr_t;

#define BCM53262_A0_S_TXQOS2PKTSr_CLR(r) (r).s_txqos2pkts[0] = 0
#define BCM53262_A0_S_TXQOS2PKTSr_SET(r,d) (r).s_txqos2pkts[0] = d
#define BCM53262_A0_S_TXQOS2PKTSr_GET(r) (r).s_txqos2pkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS2PKTSr_COUNTSf_GET(r) ((r).s_txqos2pkts[0])
#define BCM53262_A0_S_TXQOS2PKTSr_COUNTSf_SET(r,f) (r).s_txqos2pkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQoS2Pkts.
 */
#define BCM53262_A0_READ_S_TXQOS2PKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS2PKTSr,(r._s_txqos2pkts),4)
#define BCM53262_A0_WRITE_S_TXQOS2PKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS2PKTSr,&(r._s_txqos2pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS2PKTSr BCM53262_A0_S_TXQOS2PKTSr
#define S_TXQOS2PKTSr_SIZE BCM53262_A0_S_TXQOS2PKTSr_SIZE
typedef BCM53262_A0_S_TXQOS2PKTSr_t S_TXQOS2PKTSr_t;
#define S_TXQOS2PKTSr_CLR BCM53262_A0_S_TXQOS2PKTSr_CLR
#define S_TXQOS2PKTSr_SET BCM53262_A0_S_TXQOS2PKTSr_SET
#define S_TXQOS2PKTSr_GET BCM53262_A0_S_TXQOS2PKTSr_GET
#define S_TXQOS2PKTSr_COUNTSf_GET BCM53262_A0_S_TXQOS2PKTSr_COUNTSf_GET
#define S_TXQOS2PKTSr_COUNTSf_SET BCM53262_A0_S_TXQOS2PKTSr_COUNTSf_SET
#define READ_S_TXQOS2PKTSr BCM53262_A0_READ_S_TXQOS2PKTSr
#define WRITE_S_TXQOS2PKTSr BCM53262_A0_WRITE_S_TXQOS2PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS2PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS3Octets
 * BLOCKS:   SYS
 * DESC:     Tx QoS#3 Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS3OCTETSr 0x00008560

#define BCM53262_A0_S_TXQOS3OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxQoS3Octets.
 */
typedef union BCM53262_A0_S_TXQOS3OCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqos3octets[2];
	uint32_t _s_txqos3octets;
} BCM53262_A0_S_TXQOS3OCTETSr_t;

#define BCM53262_A0_S_TXQOS3OCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqos3octets), 0, sizeof(BCM53262_A0_S_TXQOS3OCTETSr_t))
#define BCM53262_A0_S_TXQOS3OCTETSr_SET(r,i,d) (r).s_txqos3octets[i] = d
#define BCM53262_A0_S_TXQOS3OCTETSr_GET(r,i) (r).s_txqos3octets[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS3OCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_txqos3octets,0,63,a)
#define BCM53262_A0_S_TXQOS3OCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_txqos3octets,0,63,a)

/*
 * These macros can be used to access S_TxQoS3Octets.
 */
#define BCM53262_A0_READ_S_TXQOS3OCTETSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS3OCTETSr,(r._s_txqos3octets),8)
#define BCM53262_A0_WRITE_S_TXQOS3OCTETSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS3OCTETSr,&(r._s_txqos3octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS3OCTETSr BCM53262_A0_S_TXQOS3OCTETSr
#define S_TXQOS3OCTETSr_SIZE BCM53262_A0_S_TXQOS3OCTETSr_SIZE
typedef BCM53262_A0_S_TXQOS3OCTETSr_t S_TXQOS3OCTETSr_t;
#define S_TXQOS3OCTETSr_CLR BCM53262_A0_S_TXQOS3OCTETSr_CLR
#define S_TXQOS3OCTETSr_SET BCM53262_A0_S_TXQOS3OCTETSr_SET
#define S_TXQOS3OCTETSr_GET BCM53262_A0_S_TXQOS3OCTETSr_GET
#define S_TXQOS3OCTETSr_COUNTSf_GET BCM53262_A0_S_TXQOS3OCTETSr_COUNTSf_GET
#define S_TXQOS3OCTETSr_COUNTSf_SET BCM53262_A0_S_TXQOS3OCTETSr_COUNTSf_SET
#define READ_S_TXQOS3OCTETSr BCM53262_A0_READ_S_TXQOS3OCTETSr
#define WRITE_S_TXQOS3OCTETSr BCM53262_A0_WRITE_S_TXQOS3OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS3OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxQoS3Pkts
 * BLOCKS:   SYS
 * DESC:     Tx QoS#3 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXQOS3PKTSr 0x0000855c

#define BCM53262_A0_S_TXQOS3PKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxQoS3Pkts.
 */
typedef union BCM53262_A0_S_TXQOS3PKTSr_s {
	uint32_t v[1];
	uint32_t s_txqos3pkts[1];
	uint32_t _s_txqos3pkts;
} BCM53262_A0_S_TXQOS3PKTSr_t;

#define BCM53262_A0_S_TXQOS3PKTSr_CLR(r) (r).s_txqos3pkts[0] = 0
#define BCM53262_A0_S_TXQOS3PKTSr_SET(r,d) (r).s_txqos3pkts[0] = d
#define BCM53262_A0_S_TXQOS3PKTSr_GET(r) (r).s_txqos3pkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXQOS3PKTSr_COUNTSf_GET(r) ((r).s_txqos3pkts[0])
#define BCM53262_A0_S_TXQOS3PKTSr_COUNTSf_SET(r,f) (r).s_txqos3pkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQoS3Pkts.
 */
#define BCM53262_A0_READ_S_TXQOS3PKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXQOS3PKTSr,(r._s_txqos3pkts),4)
#define BCM53262_A0_WRITE_S_TXQOS3PKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXQOS3PKTSr,&(r._s_txqos3pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOS3PKTSr BCM53262_A0_S_TXQOS3PKTSr
#define S_TXQOS3PKTSr_SIZE BCM53262_A0_S_TXQOS3PKTSr_SIZE
typedef BCM53262_A0_S_TXQOS3PKTSr_t S_TXQOS3PKTSr_t;
#define S_TXQOS3PKTSr_CLR BCM53262_A0_S_TXQOS3PKTSr_CLR
#define S_TXQOS3PKTSr_SET BCM53262_A0_S_TXQOS3PKTSr_SET
#define S_TXQOS3PKTSr_GET BCM53262_A0_S_TXQOS3PKTSr_GET
#define S_TXQOS3PKTSr_COUNTSf_GET BCM53262_A0_S_TXQOS3PKTSr_COUNTSf_GET
#define S_TXQOS3PKTSr_COUNTSf_SET BCM53262_A0_S_TXQOS3PKTSr_COUNTSf_SET
#define READ_S_TXQOS3PKTSr BCM53262_A0_READ_S_TXQOS3PKTSr
#define WRITE_S_TXQOS3PKTSr BCM53262_A0_WRITE_S_TXQOS3PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXQOS3PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxSingleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXSINGLECOLLISIONr 0x00008520

#define BCM53262_A0_S_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxSingleCollision.
 */
typedef union BCM53262_A0_S_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txsinglecollision[1];
	uint32_t _s_txsinglecollision;
} BCM53262_A0_S_TXSINGLECOLLISIONr_t;

#define BCM53262_A0_S_TXSINGLECOLLISIONr_CLR(r) (r).s_txsinglecollision[0] = 0
#define BCM53262_A0_S_TXSINGLECOLLISIONr_SET(r,d) (r).s_txsinglecollision[0] = d
#define BCM53262_A0_S_TXSINGLECOLLISIONr_GET(r) (r).s_txsinglecollision[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXSINGLECOLLISIONr_COUNTSf_GET(r) ((r).s_txsinglecollision[0])
#define BCM53262_A0_S_TXSINGLECOLLISIONr_COUNTSf_SET(r,f) (r).s_txsinglecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxSingleCollision.
 */
#define BCM53262_A0_READ_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXSINGLECOLLISIONr,(r._s_txsinglecollision),4)
#define BCM53262_A0_WRITE_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXSINGLECOLLISIONr,&(r._s_txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXSINGLECOLLISIONr BCM53262_A0_S_TXSINGLECOLLISIONr
#define S_TXSINGLECOLLISIONr_SIZE BCM53262_A0_S_TXSINGLECOLLISIONr_SIZE
typedef BCM53262_A0_S_TXSINGLECOLLISIONr_t S_TXSINGLECOLLISIONr_t;
#define S_TXSINGLECOLLISIONr_CLR BCM53262_A0_S_TXSINGLECOLLISIONr_CLR
#define S_TXSINGLECOLLISIONr_SET BCM53262_A0_S_TXSINGLECOLLISIONr_SET
#define S_TXSINGLECOLLISIONr_GET BCM53262_A0_S_TXSINGLECOLLISIONr_GET
#define S_TXSINGLECOLLISIONr_COUNTSf_GET BCM53262_A0_S_TXSINGLECOLLISIONr_COUNTSf_GET
#define S_TXSINGLECOLLISIONr_COUNTSf_SET BCM53262_A0_S_TXSINGLECOLLISIONr_COUNTSf_SET
#define READ_S_TXSINGLECOLLISIONr BCM53262_A0_READ_S_TXSINGLECOLLISIONr
#define WRITE_S_TXSINGLECOLLISIONr BCM53262_A0_WRITE_S_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXSINGLECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  S_TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 */
#define BCM53262_A0_S_TXUNICASTPKTSr 0x00008518

#define BCM53262_A0_S_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxUnicastPkts.
 */
typedef union BCM53262_A0_S_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txunicastpkts[1];
	uint32_t _s_txunicastpkts;
} BCM53262_A0_S_TXUNICASTPKTSr_t;

#define BCM53262_A0_S_TXUNICASTPKTSr_CLR(r) (r).s_txunicastpkts[0] = 0
#define BCM53262_A0_S_TXUNICASTPKTSr_SET(r,d) (r).s_txunicastpkts[0] = d
#define BCM53262_A0_S_TXUNICASTPKTSr_GET(r) (r).s_txunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_S_TXUNICASTPKTSr_COUNTSf_GET(r) ((r).s_txunicastpkts[0])
#define BCM53262_A0_S_TXUNICASTPKTSr_COUNTSf_SET(r,f) (r).s_txunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxUnicastPkts.
 */
#define BCM53262_A0_READ_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_S_TXUNICASTPKTSr,(r._s_txunicastpkts),4)
#define BCM53262_A0_WRITE_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_S_TXUNICASTPKTSr,&(r._s_txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXUNICASTPKTSr BCM53262_A0_S_TXUNICASTPKTSr
#define S_TXUNICASTPKTSr_SIZE BCM53262_A0_S_TXUNICASTPKTSr_SIZE
typedef BCM53262_A0_S_TXUNICASTPKTSr_t S_TXUNICASTPKTSr_t;
#define S_TXUNICASTPKTSr_CLR BCM53262_A0_S_TXUNICASTPKTSr_CLR
#define S_TXUNICASTPKTSr_SET BCM53262_A0_S_TXUNICASTPKTSr_SET
#define S_TXUNICASTPKTSr_GET BCM53262_A0_S_TXUNICASTPKTSr_GET
#define S_TXUNICASTPKTSr_COUNTSf_GET BCM53262_A0_S_TXUNICASTPKTSr_COUNTSf_GET
#define S_TXUNICASTPKTSr_COUNTSf_SET BCM53262_A0_S_TXUNICASTPKTSr_COUNTSf_SET
#define READ_S_TXUNICASTPKTSr BCM53262_A0_READ_S_TXUNICASTPKTSr
#define WRITE_S_TXUNICASTPKTSr BCM53262_A0_WRITE_S_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_S_TXUNICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TBI_CTL
 * BLOCKS:   SYS
 * DESC:     TBI Control Register
 * SIZE:     16
 * FIELDS:
 *     MR_MAIN_RESET    Software reset, Hight enable (will be extendad to 1.7us long internally)
 *     RESERVED_R       Reserved
 *     MR_FD            AN Full duplex capability.If this bit is set to '1', SerDes AutoNeg advertises full duplex ability.The mr_hd and mr_fd can be set to '1' at the same time to indicate able to support half/full duplex.Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 *     MR_HD            AN Half duplex capability.If this bit is set to '1', SerDes AutoNeg advertises half duplex ability.The mr_hd and mr_fd can be set to '1' at the same time to indicate able to support half/full duplex.Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 *     FIBER_MODE       Enable fiber mode. Active high. Enabling fiber mode will affect AutoNeg function.When '1', the autoneg complies with IEEE claus 37 defined AutoNeg,otherwise, it is SGMII Autoneg.Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 *     RESERVED_1R      Reserved
 *     SGMII_RESTART_AN The signal is used to restart SGMII autoneg. Active high .Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 *     BYPASS_10B       Bypass TBI edcode/encode function.Bit0 : port 49 (Giga 0).Bit1 : port 50 (Giga 1).
 */
#define BCM53262_A0_TBI_CTLr 0x00000d00

#define BCM53262_A0_TBI_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TBI_CTL.
 */
typedef union BCM53262_A0_TBI_CTLr_s {
	uint32_t v[1];
	uint32_t tbi_ctl[1];
	uint32_t _tbi_ctl;
} BCM53262_A0_TBI_CTLr_t;

#define BCM53262_A0_TBI_CTLr_CLR(r) (r).tbi_ctl[0] = 0
#define BCM53262_A0_TBI_CTLr_SET(r,d) (r).tbi_ctl[0] = d
#define BCM53262_A0_TBI_CTLr_GET(r) (r).tbi_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TBI_CTLr_MR_MAIN_RESETf_GET(r) (((r).tbi_ctl[0]) & 0x3)
#define BCM53262_A0_TBI_CTLr_MR_MAIN_RESETf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_TBI_CTLr_RESERVED_Rf_GET(r) ((((r).tbi_ctl[0]) >> 2) & 0x3)
#define BCM53262_A0_TBI_CTLr_RESERVED_Rf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_TBI_CTLr_MR_FDf_GET(r) ((((r).tbi_ctl[0]) >> 4) & 0x3)
#define BCM53262_A0_TBI_CTLr_MR_FDf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_TBI_CTLr_MR_HDf_GET(r) ((((r).tbi_ctl[0]) >> 6) & 0x3)
#define BCM53262_A0_TBI_CTLr_MR_HDf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53262_A0_TBI_CTLr_FIBER_MODEf_GET(r) ((((r).tbi_ctl[0]) >> 8) & 0x3)
#define BCM53262_A0_TBI_CTLr_FIBER_MODEf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53262_A0_TBI_CTLr_RESERVED_1Rf_GET(r) ((((r).tbi_ctl[0]) >> 10) & 0x3)
#define BCM53262_A0_TBI_CTLr_RESERVED_1Rf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_TBI_CTLr_SGMII_RESTART_ANf_GET(r) ((((r).tbi_ctl[0]) >> 12) & 0x3)
#define BCM53262_A0_TBI_CTLr_SGMII_RESTART_ANf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_TBI_CTLr_BYPASS_10Bf_GET(r) ((((r).tbi_ctl[0]) >> 14) & 0x3)
#define BCM53262_A0_TBI_CTLr_BYPASS_10Bf_SET(r,f) (r).tbi_ctl[0]=(((r).tbi_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access TBI_CTL.
 */
#define BCM53262_A0_READ_TBI_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_TBI_CTLr,(r._tbi_ctl),2)
#define BCM53262_A0_WRITE_TBI_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_TBI_CTLr,&(r._tbi_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TBI_CTLr BCM53262_A0_TBI_CTLr
#define TBI_CTLr_SIZE BCM53262_A0_TBI_CTLr_SIZE
typedef BCM53262_A0_TBI_CTLr_t TBI_CTLr_t;
#define TBI_CTLr_CLR BCM53262_A0_TBI_CTLr_CLR
#define TBI_CTLr_SET BCM53262_A0_TBI_CTLr_SET
#define TBI_CTLr_GET BCM53262_A0_TBI_CTLr_GET
#define TBI_CTLr_MR_MAIN_RESETf_GET BCM53262_A0_TBI_CTLr_MR_MAIN_RESETf_GET
#define TBI_CTLr_MR_MAIN_RESETf_SET BCM53262_A0_TBI_CTLr_MR_MAIN_RESETf_SET
#define TBI_CTLr_RESERVED_Rf_GET BCM53262_A0_TBI_CTLr_RESERVED_Rf_GET
#define TBI_CTLr_RESERVED_Rf_SET BCM53262_A0_TBI_CTLr_RESERVED_Rf_SET
#define TBI_CTLr_MR_FDf_GET BCM53262_A0_TBI_CTLr_MR_FDf_GET
#define TBI_CTLr_MR_FDf_SET BCM53262_A0_TBI_CTLr_MR_FDf_SET
#define TBI_CTLr_MR_HDf_GET BCM53262_A0_TBI_CTLr_MR_HDf_GET
#define TBI_CTLr_MR_HDf_SET BCM53262_A0_TBI_CTLr_MR_HDf_SET
#define TBI_CTLr_FIBER_MODEf_GET BCM53262_A0_TBI_CTLr_FIBER_MODEf_GET
#define TBI_CTLr_FIBER_MODEf_SET BCM53262_A0_TBI_CTLr_FIBER_MODEf_SET
#define TBI_CTLr_RESERVED_1Rf_GET BCM53262_A0_TBI_CTLr_RESERVED_1Rf_GET
#define TBI_CTLr_RESERVED_1Rf_SET BCM53262_A0_TBI_CTLr_RESERVED_1Rf_SET
#define TBI_CTLr_SGMII_RESTART_ANf_GET BCM53262_A0_TBI_CTLr_SGMII_RESTART_ANf_GET
#define TBI_CTLr_SGMII_RESTART_ANf_SET BCM53262_A0_TBI_CTLr_SGMII_RESTART_ANf_SET
#define TBI_CTLr_BYPASS_10Bf_GET BCM53262_A0_TBI_CTLr_BYPASS_10Bf_GET
#define TBI_CTLr_BYPASS_10Bf_SET BCM53262_A0_TBI_CTLr_BYPASS_10Bf_SET
#define READ_TBI_CTLr BCM53262_A0_READ_TBI_CTLr
#define WRITE_TBI_CTLr BCM53262_A0_WRITE_TBI_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TBI_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TH_PCTL
 * BLOCKS:   EPIC0
 * DESC:     10/100 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     MIRX_DIS         Disables the receive function of the port at the MAC level.
 *     MITX_DIS         Disables the transmit function of the port at the MAC level.
 *     RESERVED_R       Reserved
 *     MISTP_STATE      CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3'b000: No Spanning Tree(Unmanaged mode).3'b001: Disable State(default for managed mode).3'b010: Blocking State.3'b011: Listening State.3'b100: Learning State.3'b101: Forwarding State.3'b110 - 3'b111: Reserved.Programmed frome the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 */
#define BCM53262_A0_TH_PCTLr 0x00000188

#define BCM53262_A0_TH_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program TH_PCTL.
 */
typedef union BCM53262_A0_TH_PCTLr_s {
	uint32_t v[1];
	uint32_t th_pctl[1];
	uint32_t _th_pctl;
} BCM53262_A0_TH_PCTLr_t;

#define BCM53262_A0_TH_PCTLr_CLR(r) (r).th_pctl[0] = 0
#define BCM53262_A0_TH_PCTLr_SET(r,d) (r).th_pctl[0] = d
#define BCM53262_A0_TH_PCTLr_GET(r) (r).th_pctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TH_PCTLr_MIRX_DISf_GET(r) (((r).th_pctl[0]) & 0x1)
#define BCM53262_A0_TH_PCTLr_MIRX_DISf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_TH_PCTLr_MITX_DISf_GET(r) ((((r).th_pctl[0]) >> 1) & 0x1)
#define BCM53262_A0_TH_PCTLr_MITX_DISf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_TH_PCTLr_RESERVED_Rf_GET(r) ((((r).th_pctl[0]) >> 2) & 0x7)
#define BCM53262_A0_TH_PCTLr_RESERVED_Rf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53262_A0_TH_PCTLr_MISTP_STATEf_GET(r) ((((r).th_pctl[0]) >> 5) & 0x7)
#define BCM53262_A0_TH_PCTLr_MISTP_STATEf_SET(r,f) (r).th_pctl[0]=(((r).th_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access TH_PCTL.
 */
#define BCM53262_A0_READ_TH_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TH_PCTLr,(r._th_pctl),1)
#define BCM53262_A0_WRITE_TH_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TH_PCTLr,&(r._th_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TH_PCTLr BCM53262_A0_TH_PCTLr
#define TH_PCTLr_SIZE BCM53262_A0_TH_PCTLr_SIZE
typedef BCM53262_A0_TH_PCTLr_t TH_PCTLr_t;
#define TH_PCTLr_CLR BCM53262_A0_TH_PCTLr_CLR
#define TH_PCTLr_SET BCM53262_A0_TH_PCTLr_SET
#define TH_PCTLr_GET BCM53262_A0_TH_PCTLr_GET
#define TH_PCTLr_MIRX_DISf_GET BCM53262_A0_TH_PCTLr_MIRX_DISf_GET
#define TH_PCTLr_MIRX_DISf_SET BCM53262_A0_TH_PCTLr_MIRX_DISf_SET
#define TH_PCTLr_MITX_DISf_GET BCM53262_A0_TH_PCTLr_MITX_DISf_GET
#define TH_PCTLr_MITX_DISf_SET BCM53262_A0_TH_PCTLr_MITX_DISf_SET
#define TH_PCTLr_RESERVED_Rf_GET BCM53262_A0_TH_PCTLr_RESERVED_Rf_GET
#define TH_PCTLr_RESERVED_Rf_SET BCM53262_A0_TH_PCTLr_RESERVED_Rf_SET
#define TH_PCTLr_MISTP_STATEf_GET BCM53262_A0_TH_PCTLr_MISTP_STATEf_GET
#define TH_PCTLr_MISTP_STATEf_SET BCM53262_A0_TH_PCTLr_MISTP_STATEf_SET
#define READ_TH_PCTLr BCM53262_A0_READ_TH_PCTLr
#define WRITE_TH_PCTLr BCM53262_A0_WRITE_TH_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TH_PCTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_DLF_DROP_THRESH_Q1
 * BLOCKS:   SYS
 * DESC:     Total-Q1 BC/DLF Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_BC_DROP_THRESH_Q1 Total BC drop threshold for Q1.
 *     TOTAL_DLF_DROP_THRESH_Q1 Total DLF drop threshold for Q1.
 */
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r 0x00000ad0

#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_DLF_DROP_THRESH_Q1.
 */
typedef union BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_s {
	uint32_t v[1];
	uint32_t total_dlf_drop_thresh_q1[1];
	uint32_t _total_dlf_drop_thresh_q1;
} BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_t;

#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_CLR(r) (r).total_dlf_drop_thresh_q1[0] = 0
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_SET(r,d) (r).total_dlf_drop_thresh_q1[0] = d
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_GET(r) (r).total_dlf_drop_thresh_q1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_BC_DROP_THRESH_Q1f_GET(r) (((r).total_dlf_drop_thresh_q1[0]) & 0xff)
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_BC_DROP_THRESH_Q1f_SET(r,f) (r).total_dlf_drop_thresh_q1[0]=(((r).total_dlf_drop_thresh_q1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_DLF_DROP_THRESH_Q1f_GET(r) ((((r).total_dlf_drop_thresh_q1[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_DLF_DROP_THRESH_Q1f_SET(r,f) (r).total_dlf_drop_thresh_q1[0]=(((r).total_dlf_drop_thresh_q1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_DLF_DROP_THRESH_Q1.
 */
#define BCM53262_A0_READ_TOTAL_DLF_DROP_THRESH_Q1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r,(r._total_dlf_drop_thresh_q1),2)
#define BCM53262_A0_WRITE_TOTAL_DLF_DROP_THRESH_Q1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r,&(r._total_dlf_drop_thresh_q1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_DLF_DROP_THRESH_Q1r BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r
#define TOTAL_DLF_DROP_THRESH_Q1r_SIZE BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_SIZE
typedef BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_t TOTAL_DLF_DROP_THRESH_Q1r_t;
#define TOTAL_DLF_DROP_THRESH_Q1r_CLR BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_CLR
#define TOTAL_DLF_DROP_THRESH_Q1r_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_SET
#define TOTAL_DLF_DROP_THRESH_Q1r_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_GET
#define TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_BC_DROP_THRESH_Q1f_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_BC_DROP_THRESH_Q1f_GET
#define TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_BC_DROP_THRESH_Q1f_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_BC_DROP_THRESH_Q1f_SET
#define TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_DLF_DROP_THRESH_Q1f_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_DLF_DROP_THRESH_Q1f_GET
#define TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_DLF_DROP_THRESH_Q1f_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r_TOTAL_DLF_DROP_THRESH_Q1f_SET
#define READ_TOTAL_DLF_DROP_THRESH_Q1r BCM53262_A0_READ_TOTAL_DLF_DROP_THRESH_Q1r
#define WRITE_TOTAL_DLF_DROP_THRESH_Q1r BCM53262_A0_WRITE_TOTAL_DLF_DROP_THRESH_Q1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_DLF_DROP_THRESH_Q2
 * BLOCKS:   SYS
 * DESC:     Total-Q2 BC/DLF Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_BC_DROP_THRESH_Q2 Total BC drop threshold for Q2.
 *     TOTAL_DLF_DROP_THRESH_Q2 Total DLF drop threshold for Q2.
 */
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r 0x00000ad2

#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_DLF_DROP_THRESH_Q2.
 */
typedef union BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_s {
	uint32_t v[1];
	uint32_t total_dlf_drop_thresh_q2[1];
	uint32_t _total_dlf_drop_thresh_q2;
} BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_t;

#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_CLR(r) (r).total_dlf_drop_thresh_q2[0] = 0
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_SET(r,d) (r).total_dlf_drop_thresh_q2[0] = d
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_GET(r) (r).total_dlf_drop_thresh_q2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_BC_DROP_THRESH_Q2f_GET(r) (((r).total_dlf_drop_thresh_q2[0]) & 0xff)
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_BC_DROP_THRESH_Q2f_SET(r,f) (r).total_dlf_drop_thresh_q2[0]=(((r).total_dlf_drop_thresh_q2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_DLF_DROP_THRESH_Q2f_GET(r) ((((r).total_dlf_drop_thresh_q2[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_DLF_DROP_THRESH_Q2f_SET(r,f) (r).total_dlf_drop_thresh_q2[0]=(((r).total_dlf_drop_thresh_q2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_DLF_DROP_THRESH_Q2.
 */
#define BCM53262_A0_READ_TOTAL_DLF_DROP_THRESH_Q2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r,(r._total_dlf_drop_thresh_q2),2)
#define BCM53262_A0_WRITE_TOTAL_DLF_DROP_THRESH_Q2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r,&(r._total_dlf_drop_thresh_q2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_DLF_DROP_THRESH_Q2r BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r
#define TOTAL_DLF_DROP_THRESH_Q2r_SIZE BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_SIZE
typedef BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_t TOTAL_DLF_DROP_THRESH_Q2r_t;
#define TOTAL_DLF_DROP_THRESH_Q2r_CLR BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_CLR
#define TOTAL_DLF_DROP_THRESH_Q2r_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_SET
#define TOTAL_DLF_DROP_THRESH_Q2r_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_GET
#define TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_BC_DROP_THRESH_Q2f_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_BC_DROP_THRESH_Q2f_GET
#define TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_BC_DROP_THRESH_Q2f_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_BC_DROP_THRESH_Q2f_SET
#define TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_DLF_DROP_THRESH_Q2f_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_DLF_DROP_THRESH_Q2f_GET
#define TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_DLF_DROP_THRESH_Q2f_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r_TOTAL_DLF_DROP_THRESH_Q2f_SET
#define READ_TOTAL_DLF_DROP_THRESH_Q2r BCM53262_A0_READ_TOTAL_DLF_DROP_THRESH_Q2r
#define WRITE_TOTAL_DLF_DROP_THRESH_Q2r BCM53262_A0_WRITE_TOTAL_DLF_DROP_THRESH_Q2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_DLF_DROP_THRESH_Q3
 * BLOCKS:   SYS
 * DESC:     Total-Q3 BC/DLF Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_BC_DROP_THRESH_Q3 Total BC drop threshold for Q3.
 *     TOTAL_DLF_DROP_THRESH_Q3 Total DLF drop threshold for Q3.
 */
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r 0x00000ad4

#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_DLF_DROP_THRESH_Q3.
 */
typedef union BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_s {
	uint32_t v[1];
	uint32_t total_dlf_drop_thresh_q3[1];
	uint32_t _total_dlf_drop_thresh_q3;
} BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_t;

#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_CLR(r) (r).total_dlf_drop_thresh_q3[0] = 0
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_SET(r,d) (r).total_dlf_drop_thresh_q3[0] = d
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_GET(r) (r).total_dlf_drop_thresh_q3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_BC_DROP_THRESH_Q3f_GET(r) (((r).total_dlf_drop_thresh_q3[0]) & 0xff)
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_BC_DROP_THRESH_Q3f_SET(r,f) (r).total_dlf_drop_thresh_q3[0]=(((r).total_dlf_drop_thresh_q3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_DLF_DROP_THRESH_Q3f_GET(r) ((((r).total_dlf_drop_thresh_q3[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_DLF_DROP_THRESH_Q3f_SET(r,f) (r).total_dlf_drop_thresh_q3[0]=(((r).total_dlf_drop_thresh_q3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_DLF_DROP_THRESH_Q3.
 */
#define BCM53262_A0_READ_TOTAL_DLF_DROP_THRESH_Q3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r,(r._total_dlf_drop_thresh_q3),2)
#define BCM53262_A0_WRITE_TOTAL_DLF_DROP_THRESH_Q3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r,&(r._total_dlf_drop_thresh_q3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_DLF_DROP_THRESH_Q3r BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r
#define TOTAL_DLF_DROP_THRESH_Q3r_SIZE BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_SIZE
typedef BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_t TOTAL_DLF_DROP_THRESH_Q3r_t;
#define TOTAL_DLF_DROP_THRESH_Q3r_CLR BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_CLR
#define TOTAL_DLF_DROP_THRESH_Q3r_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_SET
#define TOTAL_DLF_DROP_THRESH_Q3r_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_GET
#define TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_BC_DROP_THRESH_Q3f_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_BC_DROP_THRESH_Q3f_GET
#define TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_BC_DROP_THRESH_Q3f_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_BC_DROP_THRESH_Q3f_SET
#define TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_DLF_DROP_THRESH_Q3f_GET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_DLF_DROP_THRESH_Q3f_GET
#define TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_DLF_DROP_THRESH_Q3f_SET BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r_TOTAL_DLF_DROP_THRESH_Q3f_SET
#define READ_TOTAL_DLF_DROP_THRESH_Q3r BCM53262_A0_READ_TOTAL_DLF_DROP_THRESH_Q3r
#define WRITE_TOTAL_DLF_DROP_THRESH_Q3r BCM53262_A0_WRITE_TOTAL_DLF_DROP_THRESH_Q3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_DLF_DROP_THRESH_Q3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_DROP_THRESH_Q1
 * BLOCKS:   SYS
 * DESC:     Total-Q1 UC/MC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *     TL_DROP_TH_Q1    Total drop threshold for Q1.
 */
#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r 0x00000ac2

#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_DROP_THRESH_Q1.
 */
typedef union BCM53262_A0_TOTAL_DROP_THRESH_Q1r_s {
	uint32_t v[1];
	uint32_t total_drop_thresh_q1[1];
	uint32_t _total_drop_thresh_q1;
} BCM53262_A0_TOTAL_DROP_THRESH_Q1r_t;

#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_CLR(r) (r).total_drop_thresh_q1[0] = 0
#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_SET(r,d) (r).total_drop_thresh_q1[0] = d
#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_GET(r) (r).total_drop_thresh_q1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_RESERVED_Rf_GET(r) (((r).total_drop_thresh_q1[0]) & 0xff)
#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_RESERVED_Rf_SET(r,f) (r).total_drop_thresh_q1[0]=(((r).total_drop_thresh_q1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_TL_DROP_TH_Q1f_GET(r) ((((r).total_drop_thresh_q1[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_DROP_THRESH_Q1r_TL_DROP_TH_Q1f_SET(r,f) (r).total_drop_thresh_q1[0]=(((r).total_drop_thresh_q1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_DROP_THRESH_Q1.
 */
#define BCM53262_A0_READ_TOTAL_DROP_THRESH_Q1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_DROP_THRESH_Q1r,(r._total_drop_thresh_q1),2)
#define BCM53262_A0_WRITE_TOTAL_DROP_THRESH_Q1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_DROP_THRESH_Q1r,&(r._total_drop_thresh_q1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_DROP_THRESH_Q1r BCM53262_A0_TOTAL_DROP_THRESH_Q1r
#define TOTAL_DROP_THRESH_Q1r_SIZE BCM53262_A0_TOTAL_DROP_THRESH_Q1r_SIZE
typedef BCM53262_A0_TOTAL_DROP_THRESH_Q1r_t TOTAL_DROP_THRESH_Q1r_t;
#define TOTAL_DROP_THRESH_Q1r_CLR BCM53262_A0_TOTAL_DROP_THRESH_Q1r_CLR
#define TOTAL_DROP_THRESH_Q1r_SET BCM53262_A0_TOTAL_DROP_THRESH_Q1r_SET
#define TOTAL_DROP_THRESH_Q1r_GET BCM53262_A0_TOTAL_DROP_THRESH_Q1r_GET
#define TOTAL_DROP_THRESH_Q1r_RESERVED_Rf_GET BCM53262_A0_TOTAL_DROP_THRESH_Q1r_RESERVED_Rf_GET
#define TOTAL_DROP_THRESH_Q1r_RESERVED_Rf_SET BCM53262_A0_TOTAL_DROP_THRESH_Q1r_RESERVED_Rf_SET
#define TOTAL_DROP_THRESH_Q1r_TL_DROP_TH_Q1f_GET BCM53262_A0_TOTAL_DROP_THRESH_Q1r_TL_DROP_TH_Q1f_GET
#define TOTAL_DROP_THRESH_Q1r_TL_DROP_TH_Q1f_SET BCM53262_A0_TOTAL_DROP_THRESH_Q1r_TL_DROP_TH_Q1f_SET
#define READ_TOTAL_DROP_THRESH_Q1r BCM53262_A0_READ_TOTAL_DROP_THRESH_Q1r
#define WRITE_TOTAL_DROP_THRESH_Q1r BCM53262_A0_WRITE_TOTAL_DROP_THRESH_Q1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_DROP_THRESH_Q1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_DROP_THRESH_Q2
 * BLOCKS:   SYS
 * DESC:     Total-Q2 UC/MC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *     TL_DROP_TH_Q2    Total drop threshold for Q2.
 */
#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r 0x00000ac6

#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_DROP_THRESH_Q2.
 */
typedef union BCM53262_A0_TOTAL_DROP_THRESH_Q2r_s {
	uint32_t v[1];
	uint32_t total_drop_thresh_q2[1];
	uint32_t _total_drop_thresh_q2;
} BCM53262_A0_TOTAL_DROP_THRESH_Q2r_t;

#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_CLR(r) (r).total_drop_thresh_q2[0] = 0
#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_SET(r,d) (r).total_drop_thresh_q2[0] = d
#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_GET(r) (r).total_drop_thresh_q2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_RESERVED_Rf_GET(r) (((r).total_drop_thresh_q2[0]) & 0xff)
#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_RESERVED_Rf_SET(r,f) (r).total_drop_thresh_q2[0]=(((r).total_drop_thresh_q2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_TL_DROP_TH_Q2f_GET(r) ((((r).total_drop_thresh_q2[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_DROP_THRESH_Q2r_TL_DROP_TH_Q2f_SET(r,f) (r).total_drop_thresh_q2[0]=(((r).total_drop_thresh_q2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_DROP_THRESH_Q2.
 */
#define BCM53262_A0_READ_TOTAL_DROP_THRESH_Q2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_DROP_THRESH_Q2r,(r._total_drop_thresh_q2),2)
#define BCM53262_A0_WRITE_TOTAL_DROP_THRESH_Q2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_DROP_THRESH_Q2r,&(r._total_drop_thresh_q2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_DROP_THRESH_Q2r BCM53262_A0_TOTAL_DROP_THRESH_Q2r
#define TOTAL_DROP_THRESH_Q2r_SIZE BCM53262_A0_TOTAL_DROP_THRESH_Q2r_SIZE
typedef BCM53262_A0_TOTAL_DROP_THRESH_Q2r_t TOTAL_DROP_THRESH_Q2r_t;
#define TOTAL_DROP_THRESH_Q2r_CLR BCM53262_A0_TOTAL_DROP_THRESH_Q2r_CLR
#define TOTAL_DROP_THRESH_Q2r_SET BCM53262_A0_TOTAL_DROP_THRESH_Q2r_SET
#define TOTAL_DROP_THRESH_Q2r_GET BCM53262_A0_TOTAL_DROP_THRESH_Q2r_GET
#define TOTAL_DROP_THRESH_Q2r_RESERVED_Rf_GET BCM53262_A0_TOTAL_DROP_THRESH_Q2r_RESERVED_Rf_GET
#define TOTAL_DROP_THRESH_Q2r_RESERVED_Rf_SET BCM53262_A0_TOTAL_DROP_THRESH_Q2r_RESERVED_Rf_SET
#define TOTAL_DROP_THRESH_Q2r_TL_DROP_TH_Q2f_GET BCM53262_A0_TOTAL_DROP_THRESH_Q2r_TL_DROP_TH_Q2f_GET
#define TOTAL_DROP_THRESH_Q2r_TL_DROP_TH_Q2f_SET BCM53262_A0_TOTAL_DROP_THRESH_Q2r_TL_DROP_TH_Q2f_SET
#define READ_TOTAL_DROP_THRESH_Q2r BCM53262_A0_READ_TOTAL_DROP_THRESH_Q2r
#define WRITE_TOTAL_DROP_THRESH_Q2r BCM53262_A0_WRITE_TOTAL_DROP_THRESH_Q2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_DROP_THRESH_Q2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_DROP_THRESH_Q3
 * BLOCKS:   SYS
 * DESC:     Total-Q3 UC/MC Drop Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *     TL_DROP_TH_Q3    Total drop threshold for Q3.
 */
#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r 0x00000aca

#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_DROP_THRESH_Q3.
 */
typedef union BCM53262_A0_TOTAL_DROP_THRESH_Q3r_s {
	uint32_t v[1];
	uint32_t total_drop_thresh_q3[1];
	uint32_t _total_drop_thresh_q3;
} BCM53262_A0_TOTAL_DROP_THRESH_Q3r_t;

#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_CLR(r) (r).total_drop_thresh_q3[0] = 0
#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_SET(r,d) (r).total_drop_thresh_q3[0] = d
#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_GET(r) (r).total_drop_thresh_q3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_RESERVED_Rf_GET(r) (((r).total_drop_thresh_q3[0]) & 0xff)
#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_RESERVED_Rf_SET(r,f) (r).total_drop_thresh_q3[0]=(((r).total_drop_thresh_q3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_TL_DROP_TH_Q3f_GET(r) ((((r).total_drop_thresh_q3[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_DROP_THRESH_Q3r_TL_DROP_TH_Q3f_SET(r,f) (r).total_drop_thresh_q3[0]=(((r).total_drop_thresh_q3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_DROP_THRESH_Q3.
 */
#define BCM53262_A0_READ_TOTAL_DROP_THRESH_Q3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_DROP_THRESH_Q3r,(r._total_drop_thresh_q3),2)
#define BCM53262_A0_WRITE_TOTAL_DROP_THRESH_Q3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_DROP_THRESH_Q3r,&(r._total_drop_thresh_q3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_DROP_THRESH_Q3r BCM53262_A0_TOTAL_DROP_THRESH_Q3r
#define TOTAL_DROP_THRESH_Q3r_SIZE BCM53262_A0_TOTAL_DROP_THRESH_Q3r_SIZE
typedef BCM53262_A0_TOTAL_DROP_THRESH_Q3r_t TOTAL_DROP_THRESH_Q3r_t;
#define TOTAL_DROP_THRESH_Q3r_CLR BCM53262_A0_TOTAL_DROP_THRESH_Q3r_CLR
#define TOTAL_DROP_THRESH_Q3r_SET BCM53262_A0_TOTAL_DROP_THRESH_Q3r_SET
#define TOTAL_DROP_THRESH_Q3r_GET BCM53262_A0_TOTAL_DROP_THRESH_Q3r_GET
#define TOTAL_DROP_THRESH_Q3r_RESERVED_Rf_GET BCM53262_A0_TOTAL_DROP_THRESH_Q3r_RESERVED_Rf_GET
#define TOTAL_DROP_THRESH_Q3r_RESERVED_Rf_SET BCM53262_A0_TOTAL_DROP_THRESH_Q3r_RESERVED_Rf_SET
#define TOTAL_DROP_THRESH_Q3r_TL_DROP_TH_Q3f_GET BCM53262_A0_TOTAL_DROP_THRESH_Q3r_TL_DROP_TH_Q3f_GET
#define TOTAL_DROP_THRESH_Q3r_TL_DROP_TH_Q3f_SET BCM53262_A0_TOTAL_DROP_THRESH_Q3r_TL_DROP_TH_Q3f_SET
#define READ_TOTAL_DROP_THRESH_Q3r BCM53262_A0_READ_TOTAL_DROP_THRESH_Q3r
#define WRITE_TOTAL_DROP_THRESH_Q3r BCM53262_A0_WRITE_TOTAL_DROP_THRESH_Q3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_DROP_THRESH_Q3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_HYST_THRESH_Q1
 * BLOCKS:   SYS
 * DESC:     Total-Q1 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     TL_PAUSE_TH_Q1   Total pause threshold for Q1.
 *     TL_HYST_TH_Q1    
 */
#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r 0x00000ac0

#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_HYST_THRESH_Q1.
 */
typedef union BCM53262_A0_TOTAL_HYST_THRESH_Q1r_s {
	uint32_t v[1];
	uint32_t total_hyst_thresh_q1[1];
	uint32_t _total_hyst_thresh_q1;
} BCM53262_A0_TOTAL_HYST_THRESH_Q1r_t;

#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_CLR(r) (r).total_hyst_thresh_q1[0] = 0
#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_SET(r,d) (r).total_hyst_thresh_q1[0] = d
#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_GET(r) (r).total_hyst_thresh_q1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_PAUSE_TH_Q1f_GET(r) (((r).total_hyst_thresh_q1[0]) & 0xff)
#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_PAUSE_TH_Q1f_SET(r,f) (r).total_hyst_thresh_q1[0]=(((r).total_hyst_thresh_q1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_HYST_TH_Q1f_GET(r) ((((r).total_hyst_thresh_q1[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_HYST_TH_Q1f_SET(r,f) (r).total_hyst_thresh_q1[0]=(((r).total_hyst_thresh_q1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_HYST_THRESH_Q1.
 */
#define BCM53262_A0_READ_TOTAL_HYST_THRESH_Q1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_HYST_THRESH_Q1r,(r._total_hyst_thresh_q1),2)
#define BCM53262_A0_WRITE_TOTAL_HYST_THRESH_Q1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_HYST_THRESH_Q1r,&(r._total_hyst_thresh_q1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_HYST_THRESH_Q1r BCM53262_A0_TOTAL_HYST_THRESH_Q1r
#define TOTAL_HYST_THRESH_Q1r_SIZE BCM53262_A0_TOTAL_HYST_THRESH_Q1r_SIZE
typedef BCM53262_A0_TOTAL_HYST_THRESH_Q1r_t TOTAL_HYST_THRESH_Q1r_t;
#define TOTAL_HYST_THRESH_Q1r_CLR BCM53262_A0_TOTAL_HYST_THRESH_Q1r_CLR
#define TOTAL_HYST_THRESH_Q1r_SET BCM53262_A0_TOTAL_HYST_THRESH_Q1r_SET
#define TOTAL_HYST_THRESH_Q1r_GET BCM53262_A0_TOTAL_HYST_THRESH_Q1r_GET
#define TOTAL_HYST_THRESH_Q1r_TL_PAUSE_TH_Q1f_GET BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_PAUSE_TH_Q1f_GET
#define TOTAL_HYST_THRESH_Q1r_TL_PAUSE_TH_Q1f_SET BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_PAUSE_TH_Q1f_SET
#define TOTAL_HYST_THRESH_Q1r_TL_HYST_TH_Q1f_GET BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_HYST_TH_Q1f_GET
#define TOTAL_HYST_THRESH_Q1r_TL_HYST_TH_Q1f_SET BCM53262_A0_TOTAL_HYST_THRESH_Q1r_TL_HYST_TH_Q1f_SET
#define READ_TOTAL_HYST_THRESH_Q1r BCM53262_A0_READ_TOTAL_HYST_THRESH_Q1r
#define WRITE_TOTAL_HYST_THRESH_Q1r BCM53262_A0_WRITE_TOTAL_HYST_THRESH_Q1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_HYST_THRESH_Q1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_HYST_THRESH_Q2
 * BLOCKS:   SYS
 * DESC:     Total-Q2 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     TL_PAUSE_TH_Q2   Total pause threshold for Q2.
 *     TL_HYST_TH_Q2    
 */
#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r 0x00000ac4

#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_HYST_THRESH_Q2.
 */
typedef union BCM53262_A0_TOTAL_HYST_THRESH_Q2r_s {
	uint32_t v[1];
	uint32_t total_hyst_thresh_q2[1];
	uint32_t _total_hyst_thresh_q2;
} BCM53262_A0_TOTAL_HYST_THRESH_Q2r_t;

#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_CLR(r) (r).total_hyst_thresh_q2[0] = 0
#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_SET(r,d) (r).total_hyst_thresh_q2[0] = d
#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_GET(r) (r).total_hyst_thresh_q2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_PAUSE_TH_Q2f_GET(r) (((r).total_hyst_thresh_q2[0]) & 0xff)
#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_PAUSE_TH_Q2f_SET(r,f) (r).total_hyst_thresh_q2[0]=(((r).total_hyst_thresh_q2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_HYST_TH_Q2f_GET(r) ((((r).total_hyst_thresh_q2[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_HYST_TH_Q2f_SET(r,f) (r).total_hyst_thresh_q2[0]=(((r).total_hyst_thresh_q2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_HYST_THRESH_Q2.
 */
#define BCM53262_A0_READ_TOTAL_HYST_THRESH_Q2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_HYST_THRESH_Q2r,(r._total_hyst_thresh_q2),2)
#define BCM53262_A0_WRITE_TOTAL_HYST_THRESH_Q2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_HYST_THRESH_Q2r,&(r._total_hyst_thresh_q2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_HYST_THRESH_Q2r BCM53262_A0_TOTAL_HYST_THRESH_Q2r
#define TOTAL_HYST_THRESH_Q2r_SIZE BCM53262_A0_TOTAL_HYST_THRESH_Q2r_SIZE
typedef BCM53262_A0_TOTAL_HYST_THRESH_Q2r_t TOTAL_HYST_THRESH_Q2r_t;
#define TOTAL_HYST_THRESH_Q2r_CLR BCM53262_A0_TOTAL_HYST_THRESH_Q2r_CLR
#define TOTAL_HYST_THRESH_Q2r_SET BCM53262_A0_TOTAL_HYST_THRESH_Q2r_SET
#define TOTAL_HYST_THRESH_Q2r_GET BCM53262_A0_TOTAL_HYST_THRESH_Q2r_GET
#define TOTAL_HYST_THRESH_Q2r_TL_PAUSE_TH_Q2f_GET BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_PAUSE_TH_Q2f_GET
#define TOTAL_HYST_THRESH_Q2r_TL_PAUSE_TH_Q2f_SET BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_PAUSE_TH_Q2f_SET
#define TOTAL_HYST_THRESH_Q2r_TL_HYST_TH_Q2f_GET BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_HYST_TH_Q2f_GET
#define TOTAL_HYST_THRESH_Q2r_TL_HYST_TH_Q2f_SET BCM53262_A0_TOTAL_HYST_THRESH_Q2r_TL_HYST_TH_Q2f_SET
#define READ_TOTAL_HYST_THRESH_Q2r BCM53262_A0_READ_TOTAL_HYST_THRESH_Q2r
#define WRITE_TOTAL_HYST_THRESH_Q2r BCM53262_A0_WRITE_TOTAL_HYST_THRESH_Q2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_HYST_THRESH_Q2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_HYST_THRESH_Q3
 * BLOCKS:   SYS
 * DESC:     Total-Q3 Hyst/Pause Threshold Control Register
 * SIZE:     16
 * FIELDS:
 *     TL_PAUSE_TH_Q3   Total pause threshold for Q3.
 *     TL_HYST_TH_Q3    
 */
#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r 0x00000ac8

#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_HYST_THRESH_Q3.
 */
typedef union BCM53262_A0_TOTAL_HYST_THRESH_Q3r_s {
	uint32_t v[1];
	uint32_t total_hyst_thresh_q3[1];
	uint32_t _total_hyst_thresh_q3;
} BCM53262_A0_TOTAL_HYST_THRESH_Q3r_t;

#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_CLR(r) (r).total_hyst_thresh_q3[0] = 0
#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_SET(r,d) (r).total_hyst_thresh_q3[0] = d
#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_GET(r) (r).total_hyst_thresh_q3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_PAUSE_TH_Q3f_GET(r) (((r).total_hyst_thresh_q3[0]) & 0xff)
#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_PAUSE_TH_Q3f_SET(r,f) (r).total_hyst_thresh_q3[0]=(((r).total_hyst_thresh_q3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_HYST_TH_Q3f_GET(r) ((((r).total_hyst_thresh_q3[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_HYST_TH_Q3f_SET(r,f) (r).total_hyst_thresh_q3[0]=(((r).total_hyst_thresh_q3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_HYST_THRESH_Q3.
 */
#define BCM53262_A0_READ_TOTAL_HYST_THRESH_Q3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_HYST_THRESH_Q3r,(r._total_hyst_thresh_q3),2)
#define BCM53262_A0_WRITE_TOTAL_HYST_THRESH_Q3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_HYST_THRESH_Q3r,&(r._total_hyst_thresh_q3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_HYST_THRESH_Q3r BCM53262_A0_TOTAL_HYST_THRESH_Q3r
#define TOTAL_HYST_THRESH_Q3r_SIZE BCM53262_A0_TOTAL_HYST_THRESH_Q3r_SIZE
typedef BCM53262_A0_TOTAL_HYST_THRESH_Q3r_t TOTAL_HYST_THRESH_Q3r_t;
#define TOTAL_HYST_THRESH_Q3r_CLR BCM53262_A0_TOTAL_HYST_THRESH_Q3r_CLR
#define TOTAL_HYST_THRESH_Q3r_SET BCM53262_A0_TOTAL_HYST_THRESH_Q3r_SET
#define TOTAL_HYST_THRESH_Q3r_GET BCM53262_A0_TOTAL_HYST_THRESH_Q3r_GET
#define TOTAL_HYST_THRESH_Q3r_TL_PAUSE_TH_Q3f_GET BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_PAUSE_TH_Q3f_GET
#define TOTAL_HYST_THRESH_Q3r_TL_PAUSE_TH_Q3f_SET BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_PAUSE_TH_Q3f_SET
#define TOTAL_HYST_THRESH_Q3r_TL_HYST_TH_Q3f_GET BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_HYST_TH_Q3f_GET
#define TOTAL_HYST_THRESH_Q3r_TL_HYST_TH_Q3f_SET BCM53262_A0_TOTAL_HYST_THRESH_Q3r_TL_HYST_TH_Q3f_SET
#define READ_TOTAL_HYST_THRESH_Q3r BCM53262_A0_READ_TOTAL_HYST_THRESH_Q3r
#define WRITE_TOTAL_HYST_THRESH_Q3r BCM53262_A0_WRITE_TOTAL_HYST_THRESH_Q3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_HYST_THRESH_Q3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_MC_DROP_IMP_THRESH
 * BLOCKS:   SYS
 * DESC:     LAN_to_IMP Multicast Control2 Register
 * SIZE:     16
 * FIELDS:
 *     TL_MC_DROP_IMP_TH Total use threshold for MC traffic from LAN to IMP.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr 0x00000aa4

#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_MC_DROP_IMP_THRESH.
 */
typedef union BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_s {
	uint32_t v[1];
	uint32_t total_mc_drop_imp_thresh[1];
	uint32_t _total_mc_drop_imp_thresh;
} BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_t;

#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_CLR(r) (r).total_mc_drop_imp_thresh[0] = 0
#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_SET(r,d) (r).total_mc_drop_imp_thresh[0] = d
#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_GET(r) (r).total_mc_drop_imp_thresh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_TL_MC_DROP_IMP_THf_GET(r) (((r).total_mc_drop_imp_thresh[0]) & 0xff)
#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_TL_MC_DROP_IMP_THf_SET(r,f) (r).total_mc_drop_imp_thresh[0]=(((r).total_mc_drop_imp_thresh[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_RESERVED_Rf_GET(r) ((((r).total_mc_drop_imp_thresh[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_RESERVED_Rf_SET(r,f) (r).total_mc_drop_imp_thresh[0]=(((r).total_mc_drop_imp_thresh[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_MC_DROP_IMP_THRESH.
 */
#define BCM53262_A0_READ_TOTAL_MC_DROP_IMP_THRESHr(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr,(r._total_mc_drop_imp_thresh),2)
#define BCM53262_A0_WRITE_TOTAL_MC_DROP_IMP_THRESHr(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr,&(r._total_mc_drop_imp_thresh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_MC_DROP_IMP_THRESHr BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr
#define TOTAL_MC_DROP_IMP_THRESHr_SIZE BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_SIZE
typedef BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_t TOTAL_MC_DROP_IMP_THRESHr_t;
#define TOTAL_MC_DROP_IMP_THRESHr_CLR BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_CLR
#define TOTAL_MC_DROP_IMP_THRESHr_SET BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_SET
#define TOTAL_MC_DROP_IMP_THRESHr_GET BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_GET
#define TOTAL_MC_DROP_IMP_THRESHr_TL_MC_DROP_IMP_THf_GET BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_TL_MC_DROP_IMP_THf_GET
#define TOTAL_MC_DROP_IMP_THRESHr_TL_MC_DROP_IMP_THf_SET BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_TL_MC_DROP_IMP_THf_SET
#define TOTAL_MC_DROP_IMP_THRESHr_RESERVED_Rf_GET BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_RESERVED_Rf_GET
#define TOTAL_MC_DROP_IMP_THRESHr_RESERVED_Rf_SET BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr_RESERVED_Rf_SET
#define READ_TOTAL_MC_DROP_IMP_THRESHr BCM53262_A0_READ_TOTAL_MC_DROP_IMP_THRESHr
#define WRITE_TOTAL_MC_DROP_IMP_THRESHr BCM53262_A0_WRITE_TOTAL_MC_DROP_IMP_THRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_MC_DROP_IMP_THRESHr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TOTAL_PAUSE_IMP_THRESH
 * BLOCKS:   SYS
 * DESC:     IMP_to_LAN Control2 Register
 * SIZE:     16
 * FIELDS:
 *     TL_PAUSE_IMP_TH  If total used buffer is over this threshold, pause congestion status observed by IMP will not re-map to hyst.
 *     TL_DROP_IMP_TH   If total used buffer is over this threshold, drop congestion status observed by IMP will not re-map to pause.
 */
#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr 0x00000ab2

#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_SIZE 2

/*
 * This structure should be used to declare and program TOTAL_PAUSE_IMP_THRESH.
 */
typedef union BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_s {
	uint32_t v[1];
	uint32_t total_pause_imp_thresh[1];
	uint32_t _total_pause_imp_thresh;
} BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_t;

#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_CLR(r) (r).total_pause_imp_thresh[0] = 0
#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_SET(r,d) (r).total_pause_imp_thresh[0] = d
#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_GET(r) (r).total_pause_imp_thresh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_PAUSE_IMP_THf_GET(r) (((r).total_pause_imp_thresh[0]) & 0xff)
#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_PAUSE_IMP_THf_SET(r,f) (r).total_pause_imp_thresh[0]=(((r).total_pause_imp_thresh[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_DROP_IMP_THf_GET(r) ((((r).total_pause_imp_thresh[0]) >> 8) & 0xff)
#define BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_DROP_IMP_THf_SET(r,f) (r).total_pause_imp_thresh[0]=(((r).total_pause_imp_thresh[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access TOTAL_PAUSE_IMP_THRESH.
 */
#define BCM53262_A0_READ_TOTAL_PAUSE_IMP_THRESHr(u,r) cdk_robo_reg_read(u,BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr,(r._total_pause_imp_thresh),2)
#define BCM53262_A0_WRITE_TOTAL_PAUSE_IMP_THRESHr(u,r) cdk_robo_reg_write(u,BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr,&(r._total_pause_imp_thresh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_PAUSE_IMP_THRESHr BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr
#define TOTAL_PAUSE_IMP_THRESHr_SIZE BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_SIZE
typedef BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_t TOTAL_PAUSE_IMP_THRESHr_t;
#define TOTAL_PAUSE_IMP_THRESHr_CLR BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_CLR
#define TOTAL_PAUSE_IMP_THRESHr_SET BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_SET
#define TOTAL_PAUSE_IMP_THRESHr_GET BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_GET
#define TOTAL_PAUSE_IMP_THRESHr_TL_PAUSE_IMP_THf_GET BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_PAUSE_IMP_THf_GET
#define TOTAL_PAUSE_IMP_THRESHr_TL_PAUSE_IMP_THf_SET BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_PAUSE_IMP_THf_SET
#define TOTAL_PAUSE_IMP_THRESHr_TL_DROP_IMP_THf_GET BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_DROP_IMP_THf_GET
#define TOTAL_PAUSE_IMP_THRESHr_TL_DROP_IMP_THf_SET BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr_TL_DROP_IMP_THf_SET
#define READ_TOTAL_PAUSE_IMP_THRESHr BCM53262_A0_READ_TOTAL_PAUSE_IMP_THRESHr
#define WRITE_TOTAL_PAUSE_IMP_THRESHr BCM53262_A0_WRITE_TOTAL_PAUSE_IMP_THRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TOTAL_PAUSE_IMP_THRESHr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TRUNK_GRP_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group X Control Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     TRUNK_PORT_MAP   	trunk port mapping setting.	(max 8 ports on one trunk group)
 *     EN_TRUNK_GRP     Enable The Trunk group.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_TRUNK_GRP_CTLr 0x00003110

#define BCM53262_A0_TRUNK_GRP_CTLr_SIZE 8

/*
 * This structure should be used to declare and program TRUNK_GRP_CTL.
 */
typedef union BCM53262_A0_TRUNK_GRP_CTLr_s {
	uint32_t v[2];
	uint32_t trunk_grp_ctl[2];
	uint32_t _trunk_grp_ctl;
} BCM53262_A0_TRUNK_GRP_CTLr_t;

#define BCM53262_A0_TRUNK_GRP_CTLr_CLR(r) CDK_MEMSET(&((r)._trunk_grp_ctl), 0, sizeof(BCM53262_A0_TRUNK_GRP_CTLr_t))
#define BCM53262_A0_TRUNK_GRP_CTLr_SET(r,i,d) (r).trunk_grp_ctl[i] = d
#define BCM53262_A0_TRUNK_GRP_CTLr_GET(r,i) (r).trunk_grp_ctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_0Rf_GET(r) (((r).trunk_grp_ctl[0]) & 0xffffff)
#define BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_0Rf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_TRUNK_GRP_CTLr_TRUNK_PORT_MAPf_GET(r) cdk_field32_get((r).trunk_grp_ctl,24,52)
#define BCM53262_A0_TRUNK_GRP_CTLr_TRUNK_PORT_MAPf_SET(r,f) cdk_field32_set((r).trunk_grp_ctl,24,52,f)
#define BCM53262_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET(r) ((((r).trunk_grp_ctl[1]) >> 21) & 0x1)
#define BCM53262_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET(r,f) (r).trunk_grp_ctl[1]=(((r).trunk_grp_ctl[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_1Rf_GET(r) ((((r).trunk_grp_ctl[1]) >> 22) & 0x3ff)
#define BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_1Rf_SET(r,f) (r).trunk_grp_ctl[1]=(((r).trunk_grp_ctl[1] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access TRUNK_GRP_CTL.
 */
#define BCM53262_A0_READ_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_TRUNK_GRP_CTLr+(8*(i)),(r._trunk_grp_ctl),8)
#define BCM53262_A0_WRITE_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_TRUNK_GRP_CTLr+(8*(i)),&(r._trunk_grp_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_CTLr BCM53262_A0_TRUNK_GRP_CTLr
#define TRUNK_GRP_CTLr_SIZE BCM53262_A0_TRUNK_GRP_CTLr_SIZE
typedef BCM53262_A0_TRUNK_GRP_CTLr_t TRUNK_GRP_CTLr_t;
#define TRUNK_GRP_CTLr_CLR BCM53262_A0_TRUNK_GRP_CTLr_CLR
#define TRUNK_GRP_CTLr_SET BCM53262_A0_TRUNK_GRP_CTLr_SET
#define TRUNK_GRP_CTLr_GET BCM53262_A0_TRUNK_GRP_CTLr_GET
#define TRUNK_GRP_CTLr_RESERVED_0Rf_GET BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_0Rf_GET
#define TRUNK_GRP_CTLr_RESERVED_0Rf_SET BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_0Rf_SET
#define TRUNK_GRP_CTLr_TRUNK_PORT_MAPf_GET BCM53262_A0_TRUNK_GRP_CTLr_TRUNK_PORT_MAPf_GET
#define TRUNK_GRP_CTLr_TRUNK_PORT_MAPf_SET BCM53262_A0_TRUNK_GRP_CTLr_TRUNK_PORT_MAPf_SET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET BCM53262_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET BCM53262_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET
#define TRUNK_GRP_CTLr_RESERVED_1Rf_GET BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_1Rf_GET
#define TRUNK_GRP_CTLr_RESERVED_1Rf_SET BCM53262_A0_TRUNK_GRP_CTLr_RESERVED_1Rf_SET
#define READ_TRUNK_GRP_CTLr BCM53262_A0_READ_TRUNK_GRP_CTLr
#define WRITE_TRUNK_GRP_CTLr BCM53262_A0_WRITE_TRUNK_GRP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TRUNK_GRP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TRUST_CVLAN
 * BLOCKS:   SYS
 * DESC:     VLAN2VLAN Control Registers
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     TRUST_CVLAN      Set to 1'b1 to trust the VID of the incoming 802.1Q tag.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_TRUST_CVLANr 0x000034b8

#define BCM53262_A0_TRUST_CVLANr_SIZE 8

/*
 * This structure should be used to declare and program TRUST_CVLAN.
 */
typedef union BCM53262_A0_TRUST_CVLANr_s {
	uint32_t v[2];
	uint32_t trust_cvlan[2];
	uint32_t _trust_cvlan;
} BCM53262_A0_TRUST_CVLANr_t;

#define BCM53262_A0_TRUST_CVLANr_CLR(r) CDK_MEMSET(&((r)._trust_cvlan), 0, sizeof(BCM53262_A0_TRUST_CVLANr_t))
#define BCM53262_A0_TRUST_CVLANr_SET(r,i,d) (r).trust_cvlan[i] = d
#define BCM53262_A0_TRUST_CVLANr_GET(r,i) (r).trust_cvlan[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TRUST_CVLANr_RESERVED_0Rf_GET(r) (((r).trust_cvlan[0]) & 0xffffff)
#define BCM53262_A0_TRUST_CVLANr_RESERVED_0Rf_SET(r,f) (r).trust_cvlan[0]=(((r).trust_cvlan[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_TRUST_CVLANr_TRUST_CVLANf_GET(r) cdk_field32_get((r).trust_cvlan,24,52)
#define BCM53262_A0_TRUST_CVLANr_TRUST_CVLANf_SET(r,f) cdk_field32_set((r).trust_cvlan,24,52,f)
#define BCM53262_A0_TRUST_CVLANr_RESERVED_1Rf_GET(r) ((((r).trust_cvlan[1]) >> 21) & 0x7ff)
#define BCM53262_A0_TRUST_CVLANr_RESERVED_1Rf_SET(r,f) (r).trust_cvlan[1]=(((r).trust_cvlan[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access TRUST_CVLAN.
 */
#define BCM53262_A0_READ_TRUST_CVLANr(u,r) cdk_robo_reg_read(u,BCM53262_A0_TRUST_CVLANr,(r._trust_cvlan),8)
#define BCM53262_A0_WRITE_TRUST_CVLANr(u,r) cdk_robo_reg_write(u,BCM53262_A0_TRUST_CVLANr,&(r._trust_cvlan),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUST_CVLANr BCM53262_A0_TRUST_CVLANr
#define TRUST_CVLANr_SIZE BCM53262_A0_TRUST_CVLANr_SIZE
typedef BCM53262_A0_TRUST_CVLANr_t TRUST_CVLANr_t;
#define TRUST_CVLANr_CLR BCM53262_A0_TRUST_CVLANr_CLR
#define TRUST_CVLANr_SET BCM53262_A0_TRUST_CVLANr_SET
#define TRUST_CVLANr_GET BCM53262_A0_TRUST_CVLANr_GET
#define TRUST_CVLANr_RESERVED_0Rf_GET BCM53262_A0_TRUST_CVLANr_RESERVED_0Rf_GET
#define TRUST_CVLANr_RESERVED_0Rf_SET BCM53262_A0_TRUST_CVLANr_RESERVED_0Rf_SET
#define TRUST_CVLANr_TRUST_CVLANf_GET BCM53262_A0_TRUST_CVLANr_TRUST_CVLANf_GET
#define TRUST_CVLANr_TRUST_CVLANf_SET BCM53262_A0_TRUST_CVLANr_TRUST_CVLANf_SET
#define TRUST_CVLANr_RESERVED_1Rf_GET BCM53262_A0_TRUST_CVLANr_RESERVED_1Rf_GET
#define TRUST_CVLANr_RESERVED_1Rf_SET BCM53262_A0_TRUST_CVLANr_RESERVED_1Rf_SET
#define READ_TRUST_CVLANr BCM53262_A0_READ_TRUST_CVLANr
#define WRITE_TRUST_CVLANr BCM53262_A0_WRITE_TRUST_CVLANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TRUST_CVLANr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for TX Registrer
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     TX_PAUSE_PASS    Ignore TX pause through map.1 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_TX_PAUSE_PASSr 0x00000098

#define BCM53262_A0_TX_PAUSE_PASSr_SIZE 8

/*
 * This structure should be used to declare and program TX_PAUSE_PASS.
 */
typedef union BCM53262_A0_TX_PAUSE_PASSr_s {
	uint32_t v[2];
	uint32_t tx_pause_pass[2];
	uint32_t _tx_pause_pass;
} BCM53262_A0_TX_PAUSE_PASSr_t;

#define BCM53262_A0_TX_PAUSE_PASSr_CLR(r) CDK_MEMSET(&((r)._tx_pause_pass), 0, sizeof(BCM53262_A0_TX_PAUSE_PASSr_t))
#define BCM53262_A0_TX_PAUSE_PASSr_SET(r,i,d) (r).tx_pause_pass[i] = d
#define BCM53262_A0_TX_PAUSE_PASSr_GET(r,i) (r).tx_pause_pass[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_TX_PAUSE_PASSr_RESERVED_0Rf_GET(r) (((r).tx_pause_pass[0]) & 0xffffff)
#define BCM53262_A0_TX_PAUSE_PASSr_RESERVED_0Rf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET(r) cdk_field32_get((r).tx_pause_pass,24,52)
#define BCM53262_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET(r,f) cdk_field32_set((r).tx_pause_pass,24,52,f)
#define BCM53262_A0_TX_PAUSE_PASSr_RESERVED_1Rf_GET(r) ((((r).tx_pause_pass[1]) >> 21) & 0x7ff)
#define BCM53262_A0_TX_PAUSE_PASSr_RESERVED_1Rf_SET(r,f) (r).tx_pause_pass[1]=(((r).tx_pause_pass[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access TX_PAUSE_PASS.
 */
#define BCM53262_A0_READ_TX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53262_A0_TX_PAUSE_PASSr,(r._tx_pause_pass),8)
#define BCM53262_A0_WRITE_TX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53262_A0_TX_PAUSE_PASSr,&(r._tx_pause_pass),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PAUSE_PASSr BCM53262_A0_TX_PAUSE_PASSr
#define TX_PAUSE_PASSr_SIZE BCM53262_A0_TX_PAUSE_PASSr_SIZE
typedef BCM53262_A0_TX_PAUSE_PASSr_t TX_PAUSE_PASSr_t;
#define TX_PAUSE_PASSr_CLR BCM53262_A0_TX_PAUSE_PASSr_CLR
#define TX_PAUSE_PASSr_SET BCM53262_A0_TX_PAUSE_PASSr_SET
#define TX_PAUSE_PASSr_GET BCM53262_A0_TX_PAUSE_PASSr_GET
#define TX_PAUSE_PASSr_RESERVED_0Rf_GET BCM53262_A0_TX_PAUSE_PASSr_RESERVED_0Rf_GET
#define TX_PAUSE_PASSr_RESERVED_0Rf_SET BCM53262_A0_TX_PAUSE_PASSr_RESERVED_0Rf_SET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET BCM53262_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET BCM53262_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET
#define TX_PAUSE_PASSr_RESERVED_1Rf_GET BCM53262_A0_TX_PAUSE_PASSr_RESERVED_1Rf_GET
#define TX_PAUSE_PASSr_RESERVED_1Rf_SET BCM53262_A0_TX_PAUSE_PASSr_RESERVED_1Rf_SET
#define READ_TX_PAUSE_PASSr BCM53262_A0_READ_TX_PAUSE_PASSr
#define WRITE_TX_PAUSE_PASSr BCM53262_A0_WRITE_TX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TX_PAUSE_PASSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxBroadcastPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXBROADCASTPKTSr 0x00006810

#define BCM53262_A0_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts.
 */
typedef union BCM53262_A0_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts[1];
	uint32_t _txbroadcastpkts;
} BCM53262_A0_TXBROADCASTPKTSr_t;

#define BCM53262_A0_TXBROADCASTPKTSr_CLR(r) (r).txbroadcastpkts[0] = 0
#define BCM53262_A0_TXBROADCASTPKTSr_SET(r,d) (r).txbroadcastpkts[0] = d
#define BCM53262_A0_TXBROADCASTPKTSr_GET(r) (r).txbroadcastpkts[0]


/*
 * These macros can be used to access TxBroadcastPkts.
 */
#define BCM53262_A0_READ_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXBROADCASTPKTSr,(r._txbroadcastpkts),4)
#define BCM53262_A0_WRITE_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXBROADCASTPKTSr,&(r._txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTSr BCM53262_A0_TXBROADCASTPKTSr
#define TXBROADCASTPKTSr_SIZE BCM53262_A0_TXBROADCASTPKTSr_SIZE
typedef BCM53262_A0_TXBROADCASTPKTSr_t TXBROADCASTPKTSr_t;
#define TXBROADCASTPKTSr_CLR BCM53262_A0_TXBROADCASTPKTSr_CLR
#define TXBROADCASTPKTSr_SET BCM53262_A0_TXBROADCASTPKTSr_SET
#define TXBROADCASTPKTSr_GET BCM53262_A0_TXBROADCASTPKTSr_GET
#define READ_TXBROADCASTPKTSr BCM53262_A0_READ_TXBROADCASTPKTSr
#define WRITE_TXBROADCASTPKTSr BCM53262_A0_WRITE_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXBROADCASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxCollisions
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Collision Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXCOLLISIONSr 0x0000681c

#define BCM53262_A0_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions.
 */
typedef union BCM53262_A0_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txcollisions[1];
	uint32_t _txcollisions;
} BCM53262_A0_TXCOLLISIONSr_t;

#define BCM53262_A0_TXCOLLISIONSr_CLR(r) (r).txcollisions[0] = 0
#define BCM53262_A0_TXCOLLISIONSr_SET(r,d) (r).txcollisions[0] = d
#define BCM53262_A0_TXCOLLISIONSr_GET(r) (r).txcollisions[0]


/*
 * These macros can be used to access TxCollisions.
 */
#define BCM53262_A0_READ_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXCOLLISIONSr,(r._txcollisions),4)
#define BCM53262_A0_WRITE_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXCOLLISIONSr,&(r._txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONSr BCM53262_A0_TXCOLLISIONSr
#define TXCOLLISIONSr_SIZE BCM53262_A0_TXCOLLISIONSr_SIZE
typedef BCM53262_A0_TXCOLLISIONSr_t TXCOLLISIONSr_t;
#define TXCOLLISIONSr_CLR BCM53262_A0_TXCOLLISIONSr_CLR
#define TXCOLLISIONSr_SET BCM53262_A0_TXCOLLISIONSr_SET
#define TXCOLLISIONSr_GET BCM53262_A0_TXCOLLISIONSr_GET
#define READ_TXCOLLISIONSr BCM53262_A0_READ_TXCOLLISIONSr
#define WRITE_TXCOLLISIONSr BCM53262_A0_WRITE_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXCOLLISIONSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxDeferredTransmit
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXDEFERREDTRANSMITr 0x00006828

#define BCM53262_A0_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit.
 */
typedef union BCM53262_A0_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit[1];
	uint32_t _txdeferredtransmit;
} BCM53262_A0_TXDEFERREDTRANSMITr_t;

#define BCM53262_A0_TXDEFERREDTRANSMITr_CLR(r) (r).txdeferredtransmit[0] = 0
#define BCM53262_A0_TXDEFERREDTRANSMITr_SET(r,d) (r).txdeferredtransmit[0] = d
#define BCM53262_A0_TXDEFERREDTRANSMITr_GET(r) (r).txdeferredtransmit[0]


/*
 * These macros can be used to access TxDeferredTransmit.
 */
#define BCM53262_A0_READ_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXDEFERREDTRANSMITr,(r._txdeferredtransmit),4)
#define BCM53262_A0_WRITE_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXDEFERREDTRANSMITr,&(r._txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMITr BCM53262_A0_TXDEFERREDTRANSMITr
#define TXDEFERREDTRANSMITr_SIZE BCM53262_A0_TXDEFERREDTRANSMITr_SIZE
typedef BCM53262_A0_TXDEFERREDTRANSMITr_t TXDEFERREDTRANSMITr_t;
#define TXDEFERREDTRANSMITr_CLR BCM53262_A0_TXDEFERREDTRANSMITr_CLR
#define TXDEFERREDTRANSMITr_SET BCM53262_A0_TXDEFERREDTRANSMITr_SET
#define TXDEFERREDTRANSMITr_GET BCM53262_A0_TXDEFERREDTRANSMITr_GET
#define READ_TXDEFERREDTRANSMITr BCM53262_A0_READ_TXDEFERREDTRANSMITr
#define WRITE_TXDEFERREDTRANSMITr BCM53262_A0_WRITE_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXDEFERREDTRANSMITr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxDropPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     TX Drop Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXDROPPKTSr 0x00006808

#define BCM53262_A0_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts.
 */
typedef union BCM53262_A0_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t txdroppkts[1];
	uint32_t _txdroppkts;
} BCM53262_A0_TXDROPPKTSr_t;

#define BCM53262_A0_TXDROPPKTSr_CLR(r) (r).txdroppkts[0] = 0
#define BCM53262_A0_TXDROPPKTSr_SET(r,d) (r).txdroppkts[0] = d
#define BCM53262_A0_TXDROPPKTSr_GET(r) (r).txdroppkts[0]


/*
 * These macros can be used to access TxDropPkts.
 */
#define BCM53262_A0_READ_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXDROPPKTSr,(r._txdroppkts),4)
#define BCM53262_A0_WRITE_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXDROPPKTSr,&(r._txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTSr BCM53262_A0_TXDROPPKTSr
#define TXDROPPKTSr_SIZE BCM53262_A0_TXDROPPKTSr_SIZE
typedef BCM53262_A0_TXDROPPKTSr_t TXDROPPKTSr_t;
#define TXDROPPKTSr_CLR BCM53262_A0_TXDROPPKTSr_CLR
#define TXDROPPKTSr_SET BCM53262_A0_TXDROPPKTSr_SET
#define TXDROPPKTSr_GET BCM53262_A0_TXDROPPKTSr_GET
#define READ_TXDROPPKTSr BCM53262_A0_READ_TXDROPPKTSr
#define WRITE_TXDROPPKTSr BCM53262_A0_WRITE_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXDROPPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxExcessiveCollision
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXEXCESSIVECOLLISIONr 0x00006830

#define BCM53262_A0_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision.
 */
typedef union BCM53262_A0_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision[1];
	uint32_t _txexcessivecollision;
} BCM53262_A0_TXEXCESSIVECOLLISIONr_t;

#define BCM53262_A0_TXEXCESSIVECOLLISIONr_CLR(r) (r).txexcessivecollision[0] = 0
#define BCM53262_A0_TXEXCESSIVECOLLISIONr_SET(r,d) (r).txexcessivecollision[0] = d
#define BCM53262_A0_TXEXCESSIVECOLLISIONr_GET(r) (r).txexcessivecollision[0]


/*
 * These macros can be used to access TxExcessiveCollision.
 */
#define BCM53262_A0_READ_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXEXCESSIVECOLLISIONr,(r._txexcessivecollision),4)
#define BCM53262_A0_WRITE_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXEXCESSIVECOLLISIONr,&(r._txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISIONr BCM53262_A0_TXEXCESSIVECOLLISIONr
#define TXEXCESSIVECOLLISIONr_SIZE BCM53262_A0_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53262_A0_TXEXCESSIVECOLLISIONr_t TXEXCESSIVECOLLISIONr_t;
#define TXEXCESSIVECOLLISIONr_CLR BCM53262_A0_TXEXCESSIVECOLLISIONr_CLR
#define TXEXCESSIVECOLLISIONr_SET BCM53262_A0_TXEXCESSIVECOLLISIONr_SET
#define TXEXCESSIVECOLLISIONr_GET BCM53262_A0_TXEXCESSIVECOLLISIONr_GET
#define READ_TXEXCESSIVECOLLISIONr BCM53262_A0_READ_TXEXCESSIVECOLLISIONr
#define WRITE_TXEXCESSIVECOLLISIONr BCM53262_A0_WRITE_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXEXCESSIVECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxFrameInDisc
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXFRAMEINDISCr 0x00006834

#define BCM53262_A0_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc.
 */
typedef union BCM53262_A0_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t txframeindisc[1];
	uint32_t _txframeindisc;
} BCM53262_A0_TXFRAMEINDISCr_t;

#define BCM53262_A0_TXFRAMEINDISCr_CLR(r) (r).txframeindisc[0] = 0
#define BCM53262_A0_TXFRAMEINDISCr_SET(r,d) (r).txframeindisc[0] = d
#define BCM53262_A0_TXFRAMEINDISCr_GET(r) (r).txframeindisc[0]


/*
 * These macros can be used to access TxFrameInDisc.
 */
#define BCM53262_A0_READ_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXFRAMEINDISCr,(r._txframeindisc),4)
#define BCM53262_A0_WRITE_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXFRAMEINDISCr,&(r._txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISCr BCM53262_A0_TXFRAMEINDISCr
#define TXFRAMEINDISCr_SIZE BCM53262_A0_TXFRAMEINDISCr_SIZE
typedef BCM53262_A0_TXFRAMEINDISCr_t TXFRAMEINDISCr_t;
#define TXFRAMEINDISCr_CLR BCM53262_A0_TXFRAMEINDISCr_CLR
#define TXFRAMEINDISCr_SET BCM53262_A0_TXFRAMEINDISCr_SET
#define TXFRAMEINDISCr_GET BCM53262_A0_TXFRAMEINDISCr_GET
#define READ_TXFRAMEINDISCr BCM53262_A0_READ_TXFRAMEINDISCr
#define WRITE_TXFRAMEINDISCr BCM53262_A0_WRITE_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXFRAMEINDISCr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxLateCollision
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXLATECOLLISIONr 0x0000682c

#define BCM53262_A0_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision.
 */
typedef union BCM53262_A0_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txlatecollision[1];
	uint32_t _txlatecollision;
} BCM53262_A0_TXLATECOLLISIONr_t;

#define BCM53262_A0_TXLATECOLLISIONr_CLR(r) (r).txlatecollision[0] = 0
#define BCM53262_A0_TXLATECOLLISIONr_SET(r,d) (r).txlatecollision[0] = d
#define BCM53262_A0_TXLATECOLLISIONr_GET(r) (r).txlatecollision[0]


/*
 * These macros can be used to access TxLateCollision.
 */
#define BCM53262_A0_READ_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXLATECOLLISIONr,(r._txlatecollision),4)
#define BCM53262_A0_WRITE_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXLATECOLLISIONr,&(r._txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISIONr BCM53262_A0_TXLATECOLLISIONr
#define TXLATECOLLISIONr_SIZE BCM53262_A0_TXLATECOLLISIONr_SIZE
typedef BCM53262_A0_TXLATECOLLISIONr_t TXLATECOLLISIONr_t;
#define TXLATECOLLISIONr_CLR BCM53262_A0_TXLATECOLLISIONr_CLR
#define TXLATECOLLISIONr_SET BCM53262_A0_TXLATECOLLISIONr_SET
#define TXLATECOLLISIONr_GET BCM53262_A0_TXLATECOLLISIONr_GET
#define READ_TXLATECOLLISIONr BCM53262_A0_READ_TXLATECOLLISIONr
#define WRITE_TXLATECOLLISIONr BCM53262_A0_WRITE_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXLATECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxMulticastPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXMULTICASTPKTSr 0x00006814

#define BCM53262_A0_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts.
 */
typedef union BCM53262_A0_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts[1];
	uint32_t _txmulticastpkts;
} BCM53262_A0_TXMULTICASTPKTSr_t;

#define BCM53262_A0_TXMULTICASTPKTSr_CLR(r) (r).txmulticastpkts[0] = 0
#define BCM53262_A0_TXMULTICASTPKTSr_SET(r,d) (r).txmulticastpkts[0] = d
#define BCM53262_A0_TXMULTICASTPKTSr_GET(r) (r).txmulticastpkts[0]


/*
 * These macros can be used to access TxMulticastPkts.
 */
#define BCM53262_A0_READ_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXMULTICASTPKTSr,(r._txmulticastpkts),4)
#define BCM53262_A0_WRITE_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXMULTICASTPKTSr,&(r._txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTSr BCM53262_A0_TXMULTICASTPKTSr
#define TXMULTICASTPKTSr_SIZE BCM53262_A0_TXMULTICASTPKTSr_SIZE
typedef BCM53262_A0_TXMULTICASTPKTSr_t TXMULTICASTPKTSr_t;
#define TXMULTICASTPKTSr_CLR BCM53262_A0_TXMULTICASTPKTSr_CLR
#define TXMULTICASTPKTSr_SET BCM53262_A0_TXMULTICASTPKTSr_SET
#define TXMULTICASTPKTSr_GET BCM53262_A0_TXMULTICASTPKTSr_GET
#define READ_TXMULTICASTPKTSr BCM53262_A0_READ_TXMULTICASTPKTSr
#define WRITE_TXMULTICASTPKTSr BCM53262_A0_WRITE_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXMULTICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxMultipleCollision
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXMULTIPLECOLLISIONr 0x00006824

#define BCM53262_A0_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision.
 */
typedef union BCM53262_A0_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision[1];
	uint32_t _txmultiplecollision;
} BCM53262_A0_TXMULTIPLECOLLISIONr_t;

#define BCM53262_A0_TXMULTIPLECOLLISIONr_CLR(r) (r).txmultiplecollision[0] = 0
#define BCM53262_A0_TXMULTIPLECOLLISIONr_SET(r,d) (r).txmultiplecollision[0] = d
#define BCM53262_A0_TXMULTIPLECOLLISIONr_GET(r) (r).txmultiplecollision[0]


/*
 * These macros can be used to access TxMultipleCollision.
 */
#define BCM53262_A0_READ_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXMULTIPLECOLLISIONr,(r._txmultiplecollision),4)
#define BCM53262_A0_WRITE_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXMULTIPLECOLLISIONr,&(r._txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISIONr BCM53262_A0_TXMULTIPLECOLLISIONr
#define TXMULTIPLECOLLISIONr_SIZE BCM53262_A0_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53262_A0_TXMULTIPLECOLLISIONr_t TXMULTIPLECOLLISIONr_t;
#define TXMULTIPLECOLLISIONr_CLR BCM53262_A0_TXMULTIPLECOLLISIONr_CLR
#define TXMULTIPLECOLLISIONr_SET BCM53262_A0_TXMULTIPLECOLLISIONr_SET
#define TXMULTIPLECOLLISIONr_GET BCM53262_A0_TXMULTIPLECOLLISIONr_GET
#define READ_TXMULTIPLECOLLISIONr BCM53262_A0_READ_TXMULTIPLECOLLISIONr
#define WRITE_TXMULTIPLECOLLISIONr BCM53262_A0_WRITE_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXMULTIPLECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxOctets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Octets
 * SIZE:     64
 */
#define BCM53262_A0_TXOCTETSr 0x00006800

#define BCM53262_A0_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets.
 */
typedef union BCM53262_A0_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t txoctets[2];
	uint32_t _txoctets;
} BCM53262_A0_TXOCTETSr_t;

#define BCM53262_A0_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._txoctets), 0, sizeof(BCM53262_A0_TXOCTETSr_t))
#define BCM53262_A0_TXOCTETSr_SET(r,i,d) (r).txoctets[i] = d
#define BCM53262_A0_TXOCTETSr_GET(r,i) (r).txoctets[i]


/*
 * These macros can be used to access TxOctets.
 */
#define BCM53262_A0_READ_TXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXOCTETSr,(r._txoctets),8)
#define BCM53262_A0_WRITE_TXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXOCTETSr,&(r._txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETSr BCM53262_A0_TXOCTETSr
#define TXOCTETSr_SIZE BCM53262_A0_TXOCTETSr_SIZE
typedef BCM53262_A0_TXOCTETSr_t TXOCTETSr_t;
#define TXOCTETSr_CLR BCM53262_A0_TXOCTETSr_CLR
#define TXOCTETSr_SET BCM53262_A0_TXOCTETSr_SET
#define TXOCTETSr_GET BCM53262_A0_TXOCTETSr_GET
#define READ_TXOCTETSr BCM53262_A0_READ_TXOCTETSr
#define WRITE_TXOCTETSr BCM53262_A0_WRITE_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXOCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxPausePkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXPAUSEPKTSr 0x0000680c

#define BCM53262_A0_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts.
 */
typedef union BCM53262_A0_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t txpausepkts[1];
	uint32_t _txpausepkts;
} BCM53262_A0_TXPAUSEPKTSr_t;

#define BCM53262_A0_TXPAUSEPKTSr_CLR(r) (r).txpausepkts[0] = 0
#define BCM53262_A0_TXPAUSEPKTSr_SET(r,d) (r).txpausepkts[0] = d
#define BCM53262_A0_TXPAUSEPKTSr_GET(r) (r).txpausepkts[0]


/*
 * These macros can be used to access TxPausePkts.
 */
#define BCM53262_A0_READ_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXPAUSEPKTSr,(r._txpausepkts),4)
#define BCM53262_A0_WRITE_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXPAUSEPKTSr,&(r._txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTSr BCM53262_A0_TXPAUSEPKTSr
#define TXPAUSEPKTSr_SIZE BCM53262_A0_TXPAUSEPKTSr_SIZE
typedef BCM53262_A0_TXPAUSEPKTSr_t TXPAUSEPKTSr_t;
#define TXPAUSEPKTSr_CLR BCM53262_A0_TXPAUSEPKTSr_CLR
#define TXPAUSEPKTSr_SET BCM53262_A0_TXPAUSEPKTSr_SET
#define TXPAUSEPKTSr_GET BCM53262_A0_TXPAUSEPKTSr_GET
#define READ_TXPAUSEPKTSr BCM53262_A0_READ_TXPAUSEPKTSr
#define WRITE_TXPAUSEPKTSr BCM53262_A0_WRITE_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXPAUSEPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS0Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#0 Packet Octets Counter
 * SIZE:     64
 */
#define BCM53262_A0_TXQOS0OCTETSr 0x0000683c

#define BCM53262_A0_TXQOS0OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxQoS0Octets.
 */
typedef union BCM53262_A0_TXQOS0OCTETSr_s {
	uint32_t v[2];
	uint32_t txqos0octets[2];
	uint32_t _txqos0octets;
} BCM53262_A0_TXQOS0OCTETSr_t;

#define BCM53262_A0_TXQOS0OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqos0octets), 0, sizeof(BCM53262_A0_TXQOS0OCTETSr_t))
#define BCM53262_A0_TXQOS0OCTETSr_SET(r,i,d) (r).txqos0octets[i] = d
#define BCM53262_A0_TXQOS0OCTETSr_GET(r,i) (r).txqos0octets[i]


/*
 * These macros can be used to access TxQoS0Octets.
 */
#define BCM53262_A0_READ_TXQOS0OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS0OCTETSr,(r._txqos0octets),8)
#define BCM53262_A0_WRITE_TXQOS0OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS0OCTETSr,&(r._txqos0octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS0OCTETSr BCM53262_A0_TXQOS0OCTETSr
#define TXQOS0OCTETSr_SIZE BCM53262_A0_TXQOS0OCTETSr_SIZE
typedef BCM53262_A0_TXQOS0OCTETSr_t TXQOS0OCTETSr_t;
#define TXQOS0OCTETSr_CLR BCM53262_A0_TXQOS0OCTETSr_CLR
#define TXQOS0OCTETSr_SET BCM53262_A0_TXQOS0OCTETSr_SET
#define TXQOS0OCTETSr_GET BCM53262_A0_TXQOS0OCTETSr_GET
#define READ_TXQOS0OCTETSr BCM53262_A0_READ_TXQOS0OCTETSr
#define WRITE_TXQOS0OCTETSr BCM53262_A0_WRITE_TXQOS0OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS0OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS0Pkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#0 Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXQOS0PKTSr 0x00006838

#define BCM53262_A0_TXQOS0PKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxQoS0Pkts.
 */
typedef union BCM53262_A0_TXQOS0PKTSr_s {
	uint32_t v[1];
	uint32_t txqos0pkts[1];
	uint32_t _txqos0pkts;
} BCM53262_A0_TXQOS0PKTSr_t;

#define BCM53262_A0_TXQOS0PKTSr_CLR(r) (r).txqos0pkts[0] = 0
#define BCM53262_A0_TXQOS0PKTSr_SET(r,d) (r).txqos0pkts[0] = d
#define BCM53262_A0_TXQOS0PKTSr_GET(r) (r).txqos0pkts[0]


/*
 * These macros can be used to access TxQoS0Pkts.
 */
#define BCM53262_A0_READ_TXQOS0PKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS0PKTSr,(r._txqos0pkts),4)
#define BCM53262_A0_WRITE_TXQOS0PKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS0PKTSr,&(r._txqos0pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS0PKTSr BCM53262_A0_TXQOS0PKTSr
#define TXQOS0PKTSr_SIZE BCM53262_A0_TXQOS0PKTSr_SIZE
typedef BCM53262_A0_TXQOS0PKTSr_t TXQOS0PKTSr_t;
#define TXQOS0PKTSr_CLR BCM53262_A0_TXQOS0PKTSr_CLR
#define TXQOS0PKTSr_SET BCM53262_A0_TXQOS0PKTSr_SET
#define TXQOS0PKTSr_GET BCM53262_A0_TXQOS0PKTSr_GET
#define READ_TXQOS0PKTSr BCM53262_A0_READ_TXQOS0PKTSr
#define WRITE_TXQOS0PKTSr BCM53262_A0_WRITE_TXQOS0PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS0PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS1Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#1 Packet Octets Counter
 * SIZE:     64
 */
#define BCM53262_A0_TXQOS1OCTETSr 0x00006848

#define BCM53262_A0_TXQOS1OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxQoS1Octets.
 */
typedef union BCM53262_A0_TXQOS1OCTETSr_s {
	uint32_t v[2];
	uint32_t txqos1octets[2];
	uint32_t _txqos1octets;
} BCM53262_A0_TXQOS1OCTETSr_t;

#define BCM53262_A0_TXQOS1OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqos1octets), 0, sizeof(BCM53262_A0_TXQOS1OCTETSr_t))
#define BCM53262_A0_TXQOS1OCTETSr_SET(r,i,d) (r).txqos1octets[i] = d
#define BCM53262_A0_TXQOS1OCTETSr_GET(r,i) (r).txqos1octets[i]


/*
 * These macros can be used to access TxQoS1Octets.
 */
#define BCM53262_A0_READ_TXQOS1OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS1OCTETSr,(r._txqos1octets),8)
#define BCM53262_A0_WRITE_TXQOS1OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS1OCTETSr,&(r._txqos1octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS1OCTETSr BCM53262_A0_TXQOS1OCTETSr
#define TXQOS1OCTETSr_SIZE BCM53262_A0_TXQOS1OCTETSr_SIZE
typedef BCM53262_A0_TXQOS1OCTETSr_t TXQOS1OCTETSr_t;
#define TXQOS1OCTETSr_CLR BCM53262_A0_TXQOS1OCTETSr_CLR
#define TXQOS1OCTETSr_SET BCM53262_A0_TXQOS1OCTETSr_SET
#define TXQOS1OCTETSr_GET BCM53262_A0_TXQOS1OCTETSr_GET
#define READ_TXQOS1OCTETSr BCM53262_A0_READ_TXQOS1OCTETSr
#define WRITE_TXQOS1OCTETSr BCM53262_A0_WRITE_TXQOS1OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS1OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS1Pkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#1 Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXQOS1PKTSr 0x00006844

#define BCM53262_A0_TXQOS1PKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxQoS1Pkts.
 */
typedef union BCM53262_A0_TXQOS1PKTSr_s {
	uint32_t v[1];
	uint32_t txqos1pkts[1];
	uint32_t _txqos1pkts;
} BCM53262_A0_TXQOS1PKTSr_t;

#define BCM53262_A0_TXQOS1PKTSr_CLR(r) (r).txqos1pkts[0] = 0
#define BCM53262_A0_TXQOS1PKTSr_SET(r,d) (r).txqos1pkts[0] = d
#define BCM53262_A0_TXQOS1PKTSr_GET(r) (r).txqos1pkts[0]


/*
 * These macros can be used to access TxQoS1Pkts.
 */
#define BCM53262_A0_READ_TXQOS1PKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS1PKTSr,(r._txqos1pkts),4)
#define BCM53262_A0_WRITE_TXQOS1PKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS1PKTSr,&(r._txqos1pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS1PKTSr BCM53262_A0_TXQOS1PKTSr
#define TXQOS1PKTSr_SIZE BCM53262_A0_TXQOS1PKTSr_SIZE
typedef BCM53262_A0_TXQOS1PKTSr_t TXQOS1PKTSr_t;
#define TXQOS1PKTSr_CLR BCM53262_A0_TXQOS1PKTSr_CLR
#define TXQOS1PKTSr_SET BCM53262_A0_TXQOS1PKTSr_SET
#define TXQOS1PKTSr_GET BCM53262_A0_TXQOS1PKTSr_GET
#define READ_TXQOS1PKTSr BCM53262_A0_READ_TXQOS1PKTSr
#define WRITE_TXQOS1PKTSr BCM53262_A0_WRITE_TXQOS1PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS1PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS2Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#2 Packet Octets Counter
 * SIZE:     64
 */
#define BCM53262_A0_TXQOS2OCTETSr 0x00006854

#define BCM53262_A0_TXQOS2OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxQoS2Octets.
 */
typedef union BCM53262_A0_TXQOS2OCTETSr_s {
	uint32_t v[2];
	uint32_t txqos2octets[2];
	uint32_t _txqos2octets;
} BCM53262_A0_TXQOS2OCTETSr_t;

#define BCM53262_A0_TXQOS2OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqos2octets), 0, sizeof(BCM53262_A0_TXQOS2OCTETSr_t))
#define BCM53262_A0_TXQOS2OCTETSr_SET(r,i,d) (r).txqos2octets[i] = d
#define BCM53262_A0_TXQOS2OCTETSr_GET(r,i) (r).txqos2octets[i]


/*
 * These macros can be used to access TxQoS2Octets.
 */
#define BCM53262_A0_READ_TXQOS2OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS2OCTETSr,(r._txqos2octets),8)
#define BCM53262_A0_WRITE_TXQOS2OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS2OCTETSr,&(r._txqos2octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS2OCTETSr BCM53262_A0_TXQOS2OCTETSr
#define TXQOS2OCTETSr_SIZE BCM53262_A0_TXQOS2OCTETSr_SIZE
typedef BCM53262_A0_TXQOS2OCTETSr_t TXQOS2OCTETSr_t;
#define TXQOS2OCTETSr_CLR BCM53262_A0_TXQOS2OCTETSr_CLR
#define TXQOS2OCTETSr_SET BCM53262_A0_TXQOS2OCTETSr_SET
#define TXQOS2OCTETSr_GET BCM53262_A0_TXQOS2OCTETSr_GET
#define READ_TXQOS2OCTETSr BCM53262_A0_READ_TXQOS2OCTETSr
#define WRITE_TXQOS2OCTETSr BCM53262_A0_WRITE_TXQOS2OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS2OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS2Pkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#2 Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXQOS2PKTSr 0x00006850

#define BCM53262_A0_TXQOS2PKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxQoS2Pkts.
 */
typedef union BCM53262_A0_TXQOS2PKTSr_s {
	uint32_t v[1];
	uint32_t txqos2pkts[1];
	uint32_t _txqos2pkts;
} BCM53262_A0_TXQOS2PKTSr_t;

#define BCM53262_A0_TXQOS2PKTSr_CLR(r) (r).txqos2pkts[0] = 0
#define BCM53262_A0_TXQOS2PKTSr_SET(r,d) (r).txqos2pkts[0] = d
#define BCM53262_A0_TXQOS2PKTSr_GET(r) (r).txqos2pkts[0]


/*
 * These macros can be used to access TxQoS2Pkts.
 */
#define BCM53262_A0_READ_TXQOS2PKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS2PKTSr,(r._txqos2pkts),4)
#define BCM53262_A0_WRITE_TXQOS2PKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS2PKTSr,&(r._txqos2pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS2PKTSr BCM53262_A0_TXQOS2PKTSr
#define TXQOS2PKTSr_SIZE BCM53262_A0_TXQOS2PKTSr_SIZE
typedef BCM53262_A0_TXQOS2PKTSr_t TXQOS2PKTSr_t;
#define TXQOS2PKTSr_CLR BCM53262_A0_TXQOS2PKTSr_CLR
#define TXQOS2PKTSr_SET BCM53262_A0_TXQOS2PKTSr_SET
#define TXQOS2PKTSr_GET BCM53262_A0_TXQOS2PKTSr_GET
#define READ_TXQOS2PKTSr BCM53262_A0_READ_TXQOS2PKTSr
#define WRITE_TXQOS2PKTSr BCM53262_A0_WRITE_TXQOS2PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS2PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS3Octets
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#3 Packet Octets Counter
 * SIZE:     64
 */
#define BCM53262_A0_TXQOS3OCTETSr 0x00006860

#define BCM53262_A0_TXQOS3OCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxQoS3Octets.
 */
typedef union BCM53262_A0_TXQOS3OCTETSr_s {
	uint32_t v[2];
	uint32_t txqos3octets[2];
	uint32_t _txqos3octets;
} BCM53262_A0_TXQOS3OCTETSr_t;

#define BCM53262_A0_TXQOS3OCTETSr_CLR(r) CDK_MEMSET(&((r)._txqos3octets), 0, sizeof(BCM53262_A0_TXQOS3OCTETSr_t))
#define BCM53262_A0_TXQOS3OCTETSr_SET(r,i,d) (r).txqos3octets[i] = d
#define BCM53262_A0_TXQOS3OCTETSr_GET(r,i) (r).txqos3octets[i]


/*
 * These macros can be used to access TxQoS3Octets.
 */
#define BCM53262_A0_READ_TXQOS3OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS3OCTETSr,(r._txqos3octets),8)
#define BCM53262_A0_WRITE_TXQOS3OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS3OCTETSr,&(r._txqos3octets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS3OCTETSr BCM53262_A0_TXQOS3OCTETSr
#define TXQOS3OCTETSr_SIZE BCM53262_A0_TXQOS3OCTETSr_SIZE
typedef BCM53262_A0_TXQOS3OCTETSr_t TXQOS3OCTETSr_t;
#define TXQOS3OCTETSr_CLR BCM53262_A0_TXQOS3OCTETSr_CLR
#define TXQOS3OCTETSr_SET BCM53262_A0_TXQOS3OCTETSr_SET
#define TXQOS3OCTETSr_GET BCM53262_A0_TXQOS3OCTETSr_GET
#define READ_TXQOS3OCTETSr BCM53262_A0_READ_TXQOS3OCTETSr
#define WRITE_TXQOS3OCTETSr BCM53262_A0_WRITE_TXQOS3OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS3OCTETSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxQoS3Pkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx QoS#3 Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXQOS3PKTSr 0x0000685c

#define BCM53262_A0_TXQOS3PKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxQoS3Pkts.
 */
typedef union BCM53262_A0_TXQOS3PKTSr_s {
	uint32_t v[1];
	uint32_t txqos3pkts[1];
	uint32_t _txqos3pkts;
} BCM53262_A0_TXQOS3PKTSr_t;

#define BCM53262_A0_TXQOS3PKTSr_CLR(r) (r).txqos3pkts[0] = 0
#define BCM53262_A0_TXQOS3PKTSr_SET(r,d) (r).txqos3pkts[0] = d
#define BCM53262_A0_TXQOS3PKTSr_GET(r) (r).txqos3pkts[0]


/*
 * These macros can be used to access TxQoS3Pkts.
 */
#define BCM53262_A0_READ_TXQOS3PKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXQOS3PKTSr,(r._txqos3pkts),4)
#define BCM53262_A0_WRITE_TXQOS3PKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXQOS3PKTSr,&(r._txqos3pkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOS3PKTSr BCM53262_A0_TXQOS3PKTSr
#define TXQOS3PKTSr_SIZE BCM53262_A0_TXQOS3PKTSr_SIZE
typedef BCM53262_A0_TXQOS3PKTSr_t TXQOS3PKTSr_t;
#define TXQOS3PKTSr_CLR BCM53262_A0_TXQOS3PKTSr_CLR
#define TXQOS3PKTSr_SET BCM53262_A0_TXQOS3PKTSr_SET
#define TXQOS3PKTSr_GET BCM53262_A0_TXQOS3PKTSr_GET
#define READ_TXQOS3PKTSr BCM53262_A0_READ_TXQOS3PKTSr
#define WRITE_TXQOS3PKTSr BCM53262_A0_WRITE_TXQOS3PKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXQOS3PKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxSingleCollision
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXSINGLECOLLISIONr 0x00006820

#define BCM53262_A0_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision.
 */
typedef union BCM53262_A0_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txsinglecollision[1];
	uint32_t _txsinglecollision;
} BCM53262_A0_TXSINGLECOLLISIONr_t;

#define BCM53262_A0_TXSINGLECOLLISIONr_CLR(r) (r).txsinglecollision[0] = 0
#define BCM53262_A0_TXSINGLECOLLISIONr_SET(r,d) (r).txsinglecollision[0] = d
#define BCM53262_A0_TXSINGLECOLLISIONr_GET(r) (r).txsinglecollision[0]


/*
 * These macros can be used to access TxSingleCollision.
 */
#define BCM53262_A0_READ_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXSINGLECOLLISIONr,(r._txsinglecollision),4)
#define BCM53262_A0_WRITE_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXSINGLECOLLISIONr,&(r._txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISIONr BCM53262_A0_TXSINGLECOLLISIONr
#define TXSINGLECOLLISIONr_SIZE BCM53262_A0_TXSINGLECOLLISIONr_SIZE
typedef BCM53262_A0_TXSINGLECOLLISIONr_t TXSINGLECOLLISIONr_t;
#define TXSINGLECOLLISIONr_CLR BCM53262_A0_TXSINGLECOLLISIONr_CLR
#define TXSINGLECOLLISIONr_SET BCM53262_A0_TXSINGLECOLLISIONr_SET
#define TXSINGLECOLLISIONr_GET BCM53262_A0_TXSINGLECOLLISIONr_GET
#define READ_TXSINGLECOLLISIONr BCM53262_A0_READ_TXSINGLECOLLISIONr
#define WRITE_TXSINGLECOLLISIONr BCM53262_A0_WRITE_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXSINGLECOLLISIONr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  TxUnicastPkts
 * BLOCKS:   EPIC0 CPIC GPIC0
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 */
#define BCM53262_A0_TXUNICASTPKTSr 0x00006818

#define BCM53262_A0_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts.
 */
typedef union BCM53262_A0_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txunicastpkts[1];
	uint32_t _txunicastpkts;
} BCM53262_A0_TXUNICASTPKTSr_t;

#define BCM53262_A0_TXUNICASTPKTSr_CLR(r) (r).txunicastpkts[0] = 0
#define BCM53262_A0_TXUNICASTPKTSr_SET(r,d) (r).txunicastpkts[0] = d
#define BCM53262_A0_TXUNICASTPKTSr_GET(r) (r).txunicastpkts[0]


/*
 * These macros can be used to access TxUnicastPkts.
 */
#define BCM53262_A0_READ_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_TXUNICASTPKTSr,(r._txunicastpkts),4)
#define BCM53262_A0_WRITE_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_TXUNICASTPKTSr,&(r._txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTSr BCM53262_A0_TXUNICASTPKTSr
#define TXUNICASTPKTSr_SIZE BCM53262_A0_TXUNICASTPKTSr_SIZE
typedef BCM53262_A0_TXUNICASTPKTSr_t TXUNICASTPKTSr_t;
#define TXUNICASTPKTSr_CLR BCM53262_A0_TXUNICASTPKTSr_CLR
#define TXUNICASTPKTSr_SET BCM53262_A0_TXUNICASTPKTSr_SET
#define TXUNICASTPKTSr_GET BCM53262_A0_TXUNICASTPKTSr_GET
#define READ_TXUNICASTPKTSr BCM53262_A0_READ_TXUNICASTPKTSr
#define WRITE_TXUNICASTPKTSr BCM53262_A0_WRITE_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_TXUNICASTPKTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  ULF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Unicast Lookup Fail Forward Map Register
 * SIZE:     64
 * FIELDS:
 *     RESERVED_R       Reserved
 *     ULF_FWD_MAP      Unicast Lookup Fail Forawrd MapBit 52 : Giga port g3Bit 51 : Giga port g2Bit 50 : Giga port g1Bit 49 : Giga port g0Bit 48 : IMP portBit 47-24 : Local 10/100 port.
 *     ULF_FWD_RESERVED Reserved
 */
#define BCM53262_A0_ULF_DROP_MAPr 0x00000030

#define BCM53262_A0_ULF_DROP_MAPr_SIZE 8

/*
 * This structure should be used to declare and program ULF_DROP_MAP.
 */
typedef union BCM53262_A0_ULF_DROP_MAPr_s {
	uint32_t v[2];
	uint32_t ulf_drop_map[2];
	uint32_t _ulf_drop_map;
} BCM53262_A0_ULF_DROP_MAPr_t;

#define BCM53262_A0_ULF_DROP_MAPr_CLR(r) CDK_MEMSET(&((r)._ulf_drop_map), 0, sizeof(BCM53262_A0_ULF_DROP_MAPr_t))
#define BCM53262_A0_ULF_DROP_MAPr_SET(r,i,d) (r).ulf_drop_map[i] = d
#define BCM53262_A0_ULF_DROP_MAPr_GET(r,i) (r).ulf_drop_map[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_ULF_DROP_MAPr_RESERVED_Rf_GET(r) (((r).ulf_drop_map[0]) & 0xffffff)
#define BCM53262_A0_ULF_DROP_MAPr_RESERVED_Rf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_MAPf_GET(r) cdk_field32_get((r).ulf_drop_map,24,52)
#define BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_MAPf_SET(r,f) cdk_field32_set((r).ulf_drop_map,24,52,f)
#define BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_RESERVEDf_GET(r) ((((r).ulf_drop_map[1]) >> 21) & 0x7ff)
#define BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_RESERVEDf_SET(r,f) (r).ulf_drop_map[1]=(((r).ulf_drop_map[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access ULF_DROP_MAP.
 */
#define BCM53262_A0_READ_ULF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_ULF_DROP_MAPr,(r._ulf_drop_map),8)
#define BCM53262_A0_WRITE_ULF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_ULF_DROP_MAPr,&(r._ulf_drop_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ULF_DROP_MAPr BCM53262_A0_ULF_DROP_MAPr
#define ULF_DROP_MAPr_SIZE BCM53262_A0_ULF_DROP_MAPr_SIZE
typedef BCM53262_A0_ULF_DROP_MAPr_t ULF_DROP_MAPr_t;
#define ULF_DROP_MAPr_CLR BCM53262_A0_ULF_DROP_MAPr_CLR
#define ULF_DROP_MAPr_SET BCM53262_A0_ULF_DROP_MAPr_SET
#define ULF_DROP_MAPr_GET BCM53262_A0_ULF_DROP_MAPr_GET
#define ULF_DROP_MAPr_RESERVED_Rf_GET BCM53262_A0_ULF_DROP_MAPr_RESERVED_Rf_GET
#define ULF_DROP_MAPr_RESERVED_Rf_SET BCM53262_A0_ULF_DROP_MAPr_RESERVED_Rf_SET
#define ULF_DROP_MAPr_ULF_FWD_MAPf_GET BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_MAPf_GET
#define ULF_DROP_MAPr_ULF_FWD_MAPf_SET BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_MAPf_SET
#define ULF_DROP_MAPr_ULF_FWD_RESERVEDf_GET BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_RESERVEDf_GET
#define ULF_DROP_MAPr_ULF_FWD_RESERVEDf_SET BCM53262_A0_ULF_DROP_MAPr_ULF_FWD_RESERVEDf_SET
#define READ_ULF_DROP_MAPr BCM53262_A0_READ_ULF_DROP_MAPr
#define WRITE_ULF_DROP_MAPr BCM53262_A0_WRITE_ULF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_ULF_DROP_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VID_RANGE_CHECKER
 * BLOCKS:   SYS
 * DESC:     VID Range Checker Register
 * SIZE:     32
 * FIELDS:
 *     SMALL            Small Value.Large >= xxxx >= Small
 *     RESERVED_0R      Reserved.
 *     LARGE            Large Value.Large >= xxxx >= Small
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_VID_RANGE_CHECKERr 0x00002130

#define BCM53262_A0_VID_RANGE_CHECKERr_SIZE 4

/*
 * This structure should be used to declare and program VID_RANGE_CHECKER.
 */
typedef union BCM53262_A0_VID_RANGE_CHECKERr_s {
	uint32_t v[1];
	uint32_t vid_range_checker[1];
	uint32_t _vid_range_checker;
} BCM53262_A0_VID_RANGE_CHECKERr_t;

#define BCM53262_A0_VID_RANGE_CHECKERr_CLR(r) (r).vid_range_checker[0] = 0
#define BCM53262_A0_VID_RANGE_CHECKERr_SET(r,d) (r).vid_range_checker[0] = d
#define BCM53262_A0_VID_RANGE_CHECKERr_GET(r) (r).vid_range_checker[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VID_RANGE_CHECKERr_SMALLf_GET(r) (((r).vid_range_checker[0]) & 0xfff)
#define BCM53262_A0_VID_RANGE_CHECKERr_SMALLf_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_0Rf_GET(r) ((((r).vid_range_checker[0]) >> 12) & 0xf)
#define BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_0Rf_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53262_A0_VID_RANGE_CHECKERr_LARGEf_GET(r) ((((r).vid_range_checker[0]) >> 16) & 0xfff)
#define BCM53262_A0_VID_RANGE_CHECKERr_LARGEf_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_1Rf_GET(r) ((((r).vid_range_checker[0]) >> 28) & 0xf)
#define BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_1Rf_SET(r,f) (r).vid_range_checker[0]=(((r).vid_range_checker[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access VID_RANGE_CHECKER.
 */
#define BCM53262_A0_READ_VID_RANGE_CHECKERr(u,i,r) cdk_robo_reg_read(u,BCM53262_A0_VID_RANGE_CHECKERr+(4*(i)),(r._vid_range_checker),4)
#define BCM53262_A0_WRITE_VID_RANGE_CHECKERr(u,i,r) cdk_robo_reg_write(u,BCM53262_A0_VID_RANGE_CHECKERr+(4*(i)),&(r._vid_range_checker),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VID_RANGE_CHECKERr BCM53262_A0_VID_RANGE_CHECKERr
#define VID_RANGE_CHECKERr_SIZE BCM53262_A0_VID_RANGE_CHECKERr_SIZE
typedef BCM53262_A0_VID_RANGE_CHECKERr_t VID_RANGE_CHECKERr_t;
#define VID_RANGE_CHECKERr_CLR BCM53262_A0_VID_RANGE_CHECKERr_CLR
#define VID_RANGE_CHECKERr_SET BCM53262_A0_VID_RANGE_CHECKERr_SET
#define VID_RANGE_CHECKERr_GET BCM53262_A0_VID_RANGE_CHECKERr_GET
#define VID_RANGE_CHECKERr_SMALLf_GET BCM53262_A0_VID_RANGE_CHECKERr_SMALLf_GET
#define VID_RANGE_CHECKERr_SMALLf_SET BCM53262_A0_VID_RANGE_CHECKERr_SMALLf_SET
#define VID_RANGE_CHECKERr_RESERVED_0Rf_GET BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_0Rf_GET
#define VID_RANGE_CHECKERr_RESERVED_0Rf_SET BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_0Rf_SET
#define VID_RANGE_CHECKERr_LARGEf_GET BCM53262_A0_VID_RANGE_CHECKERr_LARGEf_GET
#define VID_RANGE_CHECKERr_LARGEf_SET BCM53262_A0_VID_RANGE_CHECKERr_LARGEf_SET
#define VID_RANGE_CHECKERr_RESERVED_1Rf_GET BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_1Rf_GET
#define VID_RANGE_CHECKERr_RESERVED_1Rf_SET BCM53262_A0_VID_RANGE_CHECKERr_RESERVED_1Rf_SET
#define READ_VID_RANGE_CHECKERr BCM53262_A0_READ_VID_RANGE_CHECKERr
#define WRITE_VID_RANGE_CHECKERr BCM53262_A0_WRITE_VID_RANGE_CHECKERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VID_RANGE_CHECKERr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  VLAN2VLAN
 * BLOCKS:   SYS
 * DESC:     Statistic RAM
 * SIZE:     32
 * FIELDS:
 *     NEW_VID_R        New VID
 *     M_MODE           Mapping mode
 *     RESVD            Reserved
 */
#define BCM53262_A0_VLAN2VLANm 0x40040538

#define BCM53262_A0_VLAN2VLANm_MIN 0
#define BCM53262_A0_VLAN2VLANm_MAX 4095
#define BCM53262_A0_VLAN2VLANm_CMAX(u) 4095
#define BCM53262_A0_VLAN2VLANm_SIZE 4

/*
 * This structure should be used to declare and program VLAN2VLAN.
 */
typedef union BCM53262_A0_VLAN2VLANm_s {
	uint32_t v[1];
	uint32_t vlan2vlan[1];
	uint32_t _vlan2vlan;
} BCM53262_A0_VLAN2VLANm_t;

#define BCM53262_A0_VLAN2VLANm_CLR(r) (r).vlan2vlan[0] = 0
#define BCM53262_A0_VLAN2VLANm_SET(r,d) (r).vlan2vlan[0] = d
#define BCM53262_A0_VLAN2VLANm_GET(r) (r).vlan2vlan[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN2VLANm_NEW_VID_Rf_GET(r) (((r).vlan2vlan[0]) & 0xfff)
#define BCM53262_A0_VLAN2VLANm_NEW_VID_Rf_SET(r,f) (r).vlan2vlan[0]=(((r).vlan2vlan[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_VLAN2VLANm_M_MODEf_GET(r) ((((r).vlan2vlan[0]) >> 12) & 0x1)
#define BCM53262_A0_VLAN2VLANm_M_MODEf_SET(r,f) (r).vlan2vlan[0]=(((r).vlan2vlan[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_VLAN2VLANm_RESVDf_GET(r) ((((r).vlan2vlan[0]) >> 13) & 0x7ffff)
#define BCM53262_A0_VLAN2VLANm_RESVDf_SET(r,f) (r).vlan2vlan[0]=(((r).vlan2vlan[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access VLAN2VLAN.
 */
#define BCM53262_A0_READ_VLAN2VLANm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_VLAN2VLANm,i,(m),4)
#define BCM53262_A0_WRITE_VLAN2VLANm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_VLAN2VLANm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN2VLANm BCM53262_A0_VLAN2VLANm
#define VLAN2VLANm_MIN BCM53262_A0_VLAN2VLANm_MIN
#define VLAN2VLANm_MAX BCM53262_A0_VLAN2VLANm_MAX
#define VLAN2VLANm_CMAX(u) BCM53262_A0_VLAN2VLANm_CMAX(u)
#define VLAN2VLANm_SIZE BCM53262_A0_VLAN2VLANm_SIZE
typedef BCM53262_A0_VLAN2VLANm_t VLAN2VLANm_t;
#define VLAN2VLANm_CLR BCM53262_A0_VLAN2VLANm_CLR
#define VLAN2VLANm_SET BCM53262_A0_VLAN2VLANm_SET
#define VLAN2VLANm_GET BCM53262_A0_VLAN2VLANm_GET
#define VLAN2VLANm_NEW_VID_Rf_GET BCM53262_A0_VLAN2VLANm_NEW_VID_Rf_GET
#define VLAN2VLANm_NEW_VID_Rf_SET BCM53262_A0_VLAN2VLANm_NEW_VID_Rf_SET
#define VLAN2VLANm_M_MODEf_GET BCM53262_A0_VLAN2VLANm_M_MODEf_GET
#define VLAN2VLANm_M_MODEf_SET BCM53262_A0_VLAN2VLANm_M_MODEf_SET
#define VLAN2VLANm_RESVDf_GET BCM53262_A0_VLAN2VLANm_RESVDf_GET
#define VLAN2VLANm_RESVDf_SET BCM53262_A0_VLAN2VLANm_RESVDf_SET
#define READ_VLAN2VLANm BCM53262_A0_READ_VLAN2VLANm
#define WRITE_VLAN2VLANm BCM53262_A0_WRITE_VLAN2VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN2VLANm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN2VLAN_CTL
 * BLOCKS:   SYS
 * DESC:     VLAN2VLAN Control Registers
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     VLAN2VLAN_CTL    VLAN2VLAN Control Registers.When set to 1, enable VLAN2VLAN table lookup.
 *     RESERVED_1R      Reserved.
 */
#define BCM53262_A0_VLAN2VLAN_CTLr 0x000034a0

#define BCM53262_A0_VLAN2VLAN_CTLr_SIZE 8

/*
 * This structure should be used to declare and program VLAN2VLAN_CTL.
 */
typedef union BCM53262_A0_VLAN2VLAN_CTLr_s {
	uint32_t v[2];
	uint32_t vlan2vlan_ctl[2];
	uint32_t _vlan2vlan_ctl;
} BCM53262_A0_VLAN2VLAN_CTLr_t;

#define BCM53262_A0_VLAN2VLAN_CTLr_CLR(r) CDK_MEMSET(&((r)._vlan2vlan_ctl), 0, sizeof(BCM53262_A0_VLAN2VLAN_CTLr_t))
#define BCM53262_A0_VLAN2VLAN_CTLr_SET(r,i,d) (r).vlan2vlan_ctl[i] = d
#define BCM53262_A0_VLAN2VLAN_CTLr_GET(r,i) (r).vlan2vlan_ctl[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_0Rf_GET(r) (((r).vlan2vlan_ctl[0]) & 0xffffff)
#define BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_0Rf_SET(r,f) (r).vlan2vlan_ctl[0]=(((r).vlan2vlan_ctl[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_VLAN2VLAN_CTLr_VLAN2VLAN_CTLf_GET(r) cdk_field32_get((r).vlan2vlan_ctl,24,52)
#define BCM53262_A0_VLAN2VLAN_CTLr_VLAN2VLAN_CTLf_SET(r,f) cdk_field32_set((r).vlan2vlan_ctl,24,52,f)
#define BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_1Rf_GET(r) ((((r).vlan2vlan_ctl[1]) >> 21) & 0x7ff)
#define BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_1Rf_SET(r,f) (r).vlan2vlan_ctl[1]=(((r).vlan2vlan_ctl[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access VLAN2VLAN_CTL.
 */
#define BCM53262_A0_READ_VLAN2VLAN_CTLr(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN2VLAN_CTLr,(r._vlan2vlan_ctl),8)
#define BCM53262_A0_WRITE_VLAN2VLAN_CTLr(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN2VLAN_CTLr,&(r._vlan2vlan_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN2VLAN_CTLr BCM53262_A0_VLAN2VLAN_CTLr
#define VLAN2VLAN_CTLr_SIZE BCM53262_A0_VLAN2VLAN_CTLr_SIZE
typedef BCM53262_A0_VLAN2VLAN_CTLr_t VLAN2VLAN_CTLr_t;
#define VLAN2VLAN_CTLr_CLR BCM53262_A0_VLAN2VLAN_CTLr_CLR
#define VLAN2VLAN_CTLr_SET BCM53262_A0_VLAN2VLAN_CTLr_SET
#define VLAN2VLAN_CTLr_GET BCM53262_A0_VLAN2VLAN_CTLr_GET
#define VLAN2VLAN_CTLr_RESERVED_0Rf_GET BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_0Rf_GET
#define VLAN2VLAN_CTLr_RESERVED_0Rf_SET BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_0Rf_SET
#define VLAN2VLAN_CTLr_VLAN2VLAN_CTLf_GET BCM53262_A0_VLAN2VLAN_CTLr_VLAN2VLAN_CTLf_GET
#define VLAN2VLAN_CTLr_VLAN2VLAN_CTLf_SET BCM53262_A0_VLAN2VLAN_CTLr_VLAN2VLAN_CTLf_SET
#define VLAN2VLAN_CTLr_RESERVED_1Rf_GET BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_1Rf_GET
#define VLAN2VLAN_CTLr_RESERVED_1Rf_SET BCM53262_A0_VLAN2VLAN_CTLr_RESERVED_1Rf_SET
#define READ_VLAN2VLAN_CTLr BCM53262_A0_READ_VLAN2VLAN_CTLr
#define WRITE_VLAN2VLAN_CTLr BCM53262_A0_WRITE_VLAN2VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN2VLAN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * MEMORY:  VLAN_1Q
 * BLOCKS:   SYS
 * DESC:     VLAN Table
 * SIZE:     192
 * FIELDS:
 *     RESERVED0_R      Reserved
 *     FORWARD_MAP      Untag port bitmapbit24-bit47 = 10/100 ports,bit48 = MII port,bit49-bit51 = Giga ports,
 *     RESERVED1_R      Reserved
 *     UNTAG_MAP        Untag port bitmapbit0-bit23 = 10/100 ports,bit24 = MII port,bit25-bit26 = Giga ports,
 *     RESERVED2_R      Reserved
 *     MSPT_ID          MSTP ID
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     RESERVED3_R      Reserved
 */
#define BCM53262_A0_VLAN_1Qm 0x40010538

#define BCM53262_A0_VLAN_1Qm_MIN 0
#define BCM53262_A0_VLAN_1Qm_MAX 4095
#define BCM53262_A0_VLAN_1Qm_CMAX(u) 4095
#define BCM53262_A0_VLAN_1Qm_SIZE 24

/*
 * This structure should be used to declare and program VLAN_1Q.
 */
typedef union BCM53262_A0_VLAN_1Qm_s {
	uint32_t v[6];
	uint32_t vlan_1q[6];
	uint32_t _vlan_1q;
} BCM53262_A0_VLAN_1Qm_t;

#define BCM53262_A0_VLAN_1Qm_CLR(r) CDK_MEMSET(&((r)._vlan_1q), 0, sizeof(BCM53262_A0_VLAN_1Qm_t))
#define BCM53262_A0_VLAN_1Qm_SET(r,i,d) (r).vlan_1q[i] = d
#define BCM53262_A0_VLAN_1Qm_GET(r,i) (r).vlan_1q[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_1Qm_RESERVED0_Rf_GET(r) (((r).vlan_1q[0]) & 0xffffff)
#define BCM53262_A0_VLAN_1Qm_RESERVED0_Rf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_VLAN_1Qm_FORWARD_MAPf_GET(r) cdk_field32_get((r).vlan_1q,24,52)
#define BCM53262_A0_VLAN_1Qm_FORWARD_MAPf_SET(r,f) cdk_field32_set((r).vlan_1q,24,52,f)
#define BCM53262_A0_VLAN_1Qm_RESERVED1_Rf_GET(r,a) cdk_field_get((r).vlan_1q,53,87,a)
#define BCM53262_A0_VLAN_1Qm_RESERVED1_Rf_SET(r,a) cdk_field_set((r).vlan_1q,53,87,a)
#define BCM53262_A0_VLAN_1Qm_UNTAG_MAPf_GET(r) cdk_field32_get((r).vlan_1q,88,116)
#define BCM53262_A0_VLAN_1Qm_UNTAG_MAPf_SET(r,f) cdk_field32_set((r).vlan_1q,88,116,f)
#define BCM53262_A0_VLAN_1Qm_RESERVED2_Rf_GET(r) ((((r).vlan_1q[3]) >> 21) & 0x7ff)
#define BCM53262_A0_VLAN_1Qm_RESERVED2_Rf_SET(r,f) (r).vlan_1q[3]=(((r).vlan_1q[3] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))
#define BCM53262_A0_VLAN_1Qm_MSPT_IDf_GET(r) (((r).vlan_1q[4]) & 0xff)
#define BCM53262_A0_VLAN_1Qm_MSPT_IDf_SET(r,f) (r).vlan_1q[4]=(((r).vlan_1q[4] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_VLAN_1Qm_FWD_MODEf_GET(r) ((((r).vlan_1q[4]) >> 8) & 0x1)
#define BCM53262_A0_VLAN_1Qm_FWD_MODEf_SET(r,f) (r).vlan_1q[4]=(((r).vlan_1q[4] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_VLAN_1Qm_RESERVED3_Rf_GET(r,a) cdk_field_get((r).vlan_1q,137,191,a)
#define BCM53262_A0_VLAN_1Qm_RESERVED3_Rf_SET(r,a) cdk_field_set((r).vlan_1q,137,191,a)

/*
 * These macros can be used to access VLAN_1Q.
 */
#define BCM53262_A0_READ_VLAN_1Qm(u,i,m) cdk_robo_mem_read(u,BCM53262_A0_VLAN_1Qm,i,(m),24)
#define BCM53262_A0_WRITE_VLAN_1Qm(u,i,m) cdk_robo_mem_write(u,BCM53262_A0_VLAN_1Qm,i,&(m),24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_1Qm BCM53262_A0_VLAN_1Qm
#define VLAN_1Qm_MIN BCM53262_A0_VLAN_1Qm_MIN
#define VLAN_1Qm_MAX BCM53262_A0_VLAN_1Qm_MAX
#define VLAN_1Qm_CMAX(u) BCM53262_A0_VLAN_1Qm_CMAX(u)
#define VLAN_1Qm_SIZE BCM53262_A0_VLAN_1Qm_SIZE
typedef BCM53262_A0_VLAN_1Qm_t VLAN_1Qm_t;
#define VLAN_1Qm_CLR BCM53262_A0_VLAN_1Qm_CLR
#define VLAN_1Qm_SET BCM53262_A0_VLAN_1Qm_SET
#define VLAN_1Qm_GET BCM53262_A0_VLAN_1Qm_GET
#define VLAN_1Qm_RESERVED0_Rf_GET BCM53262_A0_VLAN_1Qm_RESERVED0_Rf_GET
#define VLAN_1Qm_RESERVED0_Rf_SET BCM53262_A0_VLAN_1Qm_RESERVED0_Rf_SET
#define VLAN_1Qm_FORWARD_MAPf_GET BCM53262_A0_VLAN_1Qm_FORWARD_MAPf_GET
#define VLAN_1Qm_FORWARD_MAPf_SET BCM53262_A0_VLAN_1Qm_FORWARD_MAPf_SET
#define VLAN_1Qm_RESERVED1_Rf_GET BCM53262_A0_VLAN_1Qm_RESERVED1_Rf_GET
#define VLAN_1Qm_RESERVED1_Rf_SET BCM53262_A0_VLAN_1Qm_RESERVED1_Rf_SET
#define VLAN_1Qm_UNTAG_MAPf_GET BCM53262_A0_VLAN_1Qm_UNTAG_MAPf_GET
#define VLAN_1Qm_UNTAG_MAPf_SET BCM53262_A0_VLAN_1Qm_UNTAG_MAPf_SET
#define VLAN_1Qm_RESERVED2_Rf_GET BCM53262_A0_VLAN_1Qm_RESERVED2_Rf_GET
#define VLAN_1Qm_RESERVED2_Rf_SET BCM53262_A0_VLAN_1Qm_RESERVED2_Rf_SET
#define VLAN_1Qm_MSPT_IDf_GET BCM53262_A0_VLAN_1Qm_MSPT_IDf_GET
#define VLAN_1Qm_MSPT_IDf_SET BCM53262_A0_VLAN_1Qm_MSPT_IDf_SET
#define VLAN_1Qm_FWD_MODEf_GET BCM53262_A0_VLAN_1Qm_FWD_MODEf_GET
#define VLAN_1Qm_FWD_MODEf_SET BCM53262_A0_VLAN_1Qm_FWD_MODEf_SET
#define VLAN_1Qm_RESERVED3_Rf_GET BCM53262_A0_VLAN_1Qm_RESERVED3_Rf_GET
#define VLAN_1Qm_RESERVED3_Rf_SET BCM53262_A0_VLAN_1Qm_RESERVED3_Rf_SET
#define READ_VLAN_1Qm BCM53262_A0_READ_VLAN_1Qm
#define WRITE_VLAN_1Qm BCM53262_A0_WRITE_VLAN_1Qm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_1Qm'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN_CTRL0
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 0 Registers
 * SIZE:     8
 * FIELDS:
 *     P8021_FM_CTRL    Internal use only ,NOT for standard release802.1P Frame Control (this is for priority-tagged frames which carry tags with null VID)00 = No Change01 = Change Priority (3 bits)10 = Change VID (12 bits)11 = Change priority and VID (16 bits)Note : This two bits for single-chip only.  For cross-chip, please use Presv_non_1q bit. (Page 34h, Offset 5h, Bit 6)Note : Not to release this field to customers.
 *     Q8021_FM_CTRL    Internal use only ,NOT for standard release802.1Q Frame Control00 = No Change01 = Change Priority (3 bits)10 = Change VID (12 bits)11 = Change priority and VID (16 bits)
 *     EN_DROP_MISSVID_FM Enable Drop Missed VID PacketWhen asserted, the frames which matches DA but not VLAN ID will be dropped.Note : Please do not release this bit to customer.  This is not a used mode.
 *     VLAN_LEARN_MODE  VID_MAC Control11 : Use [VID,MAC] to decide how to foward packets.10 : Reserved01: Reserved00: Use [MAC] to hash ARL table
 *     VLAN_EN          802.1Q VLAN Enable1 = Enable 802.1q VLAN function.
 */
#define BCM53262_A0_VLAN_CTRL0r 0x00003400

#define BCM53262_A0_VLAN_CTRL0r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL0.
 */
typedef union BCM53262_A0_VLAN_CTRL0r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl0[1];
	uint32_t _vlan_ctrl0;
} BCM53262_A0_VLAN_CTRL0r_t;

#define BCM53262_A0_VLAN_CTRL0r_CLR(r) (r).vlan_ctrl0[0] = 0
#define BCM53262_A0_VLAN_CTRL0r_SET(r,d) (r).vlan_ctrl0[0] = d
#define BCM53262_A0_VLAN_CTRL0r_GET(r) (r).vlan_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_CTRL0r_P8021_FM_CTRLf_GET(r) (((r).vlan_ctrl0[0]) & 0x3)
#define BCM53262_A0_VLAN_CTRL0r_P8021_FM_CTRLf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53262_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_GET(r) ((((r).vlan_ctrl0[0]) >> 2) & 0x3)
#define BCM53262_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_VLAN_CTRL0r_EN_DROP_MISSVID_FMf_GET(r) ((((r).vlan_ctrl0[0]) >> 4) & 0x1)
#define BCM53262_A0_VLAN_CTRL0r_EN_DROP_MISSVID_FMf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET(r) ((((r).vlan_ctrl0[0]) >> 5) & 0x3)
#define BCM53262_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53262_A0_VLAN_CTRL0r_VLAN_ENf_GET(r) ((((r).vlan_ctrl0[0]) >> 7) & 0x1)
#define BCM53262_A0_VLAN_CTRL0r_VLAN_ENf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL0.
 */
#define BCM53262_A0_READ_VLAN_CTRL0r(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN_CTRL0r,(r._vlan_ctrl0),1)
#define BCM53262_A0_WRITE_VLAN_CTRL0r(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN_CTRL0r,&(r._vlan_ctrl0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL0r BCM53262_A0_VLAN_CTRL0r
#define VLAN_CTRL0r_SIZE BCM53262_A0_VLAN_CTRL0r_SIZE
typedef BCM53262_A0_VLAN_CTRL0r_t VLAN_CTRL0r_t;
#define VLAN_CTRL0r_CLR BCM53262_A0_VLAN_CTRL0r_CLR
#define VLAN_CTRL0r_SET BCM53262_A0_VLAN_CTRL0r_SET
#define VLAN_CTRL0r_GET BCM53262_A0_VLAN_CTRL0r_GET
#define VLAN_CTRL0r_P8021_FM_CTRLf_GET BCM53262_A0_VLAN_CTRL0r_P8021_FM_CTRLf_GET
#define VLAN_CTRL0r_P8021_FM_CTRLf_SET BCM53262_A0_VLAN_CTRL0r_P8021_FM_CTRLf_SET
#define VLAN_CTRL0r_Q8021_FM_CTRLf_GET BCM53262_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_GET
#define VLAN_CTRL0r_Q8021_FM_CTRLf_SET BCM53262_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_SET
#define VLAN_CTRL0r_EN_DROP_MISSVID_FMf_GET BCM53262_A0_VLAN_CTRL0r_EN_DROP_MISSVID_FMf_GET
#define VLAN_CTRL0r_EN_DROP_MISSVID_FMf_SET BCM53262_A0_VLAN_CTRL0r_EN_DROP_MISSVID_FMf_SET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_GET BCM53262_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_SET BCM53262_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET
#define VLAN_CTRL0r_VLAN_ENf_GET BCM53262_A0_VLAN_CTRL0r_VLAN_ENf_GET
#define VLAN_CTRL0r_VLAN_ENf_SET BCM53262_A0_VLAN_CTRL0r_VLAN_ENf_SET
#define READ_VLAN_CTRL0r BCM53262_A0_READ_VLAN_CTRL0r
#define WRITE_VLAN_CTRL0r BCM53262_A0_WRITE_VLAN_CTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_CTRL0r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN_CTRL1
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 1 Registers
 * SIZE:     8
 * FIELDS:
 *     SPECI_FWD_MAP_CHK 0 : bypass 1Q VLAN forwarding map check1 : enable 1Q VLAN forwarding map check, untagged  special entry MAC address received packet will use default tag to get its forwarding map.
 *     SPECI_UNTAG_MAP_CHK 0 : bypass 1Q VLAN untag map check, untagged special entry MAC address received packet will remove default tag on transmitting side;    and tagged special entry MAC address received packet will always be tagged om trandmitting side.1 : enable 1Q VLAN untag map check, untagged special entry MAC address received packet will use default tag to get its untag tag.
 *     EN_RSV_MCAST_FWDMAP 0 : bypass 1Q VLAN forwarding map check1 : enable 1Q VLAN forwarding map check, untagged  RSV_MCAST_UNTAG received packet will use default tag to get its forwarding map.
 *     EN_RSV_MCAST_UNTAG 0 : bypass 1Q VLAN untag map check, untagged RSV_MCAST (excluding GMRP/GVRP) received packet will remove default tag on transmitting side;    and tagged RSV_MCAST (excluding GMRP/GVRP) received packet will always be tagged om trandmitting side.1 : enable 1Q VLAN untag map check, untagged RSV_MCAST (excluding GMRP/GVRP) received packet will use default tag to get its untag tag.
 *     VLAN_CTRL1_RSRV0 Reserved
 *     EN_IPMC_BYPASS_FWDMAP 0 : bypass 1Q VLAN forwarding map check.1 : enable 1Q VLAN forwarding map check, untagged  IPMC received packet will use default tag to get its forwarding map.
 *     EN_IPMC_BYPASS_UNTAG 0 : bypass 1Q VLAN untag map check, untagged IPMC received packet will remove default tag on transmitting side;    and tagged IPMC received packet will always be tagged om trandmitting side.1 : enable 1Q VLAN untag map check, untagged IPMC received packet will use default tag to get its untag tag.
 *     VLAN_CTRL1_RSRV1 Reserved
 */
#define BCM53262_A0_VLAN_CTRL1r 0x00003401

#define BCM53262_A0_VLAN_CTRL1r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL1.
 */
typedef union BCM53262_A0_VLAN_CTRL1r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl1[1];
	uint32_t _vlan_ctrl1;
} BCM53262_A0_VLAN_CTRL1r_t;

#define BCM53262_A0_VLAN_CTRL1r_CLR(r) (r).vlan_ctrl1[0] = 0
#define BCM53262_A0_VLAN_CTRL1r_SET(r,d) (r).vlan_ctrl1[0] = d
#define BCM53262_A0_VLAN_CTRL1r_GET(r) (r).vlan_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_CTRL1r_SPECI_FWD_MAP_CHKf_GET(r) (((r).vlan_ctrl1[0]) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_SPECI_FWD_MAP_CHKf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_VLAN_CTRL1r_SPECI_UNTAG_MAP_CHKf_GET(r) ((((r).vlan_ctrl1[0]) >> 1) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_SPECI_UNTAG_MAP_CHKf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 2) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 3) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV0f_GET(r) ((((r).vlan_ctrl1[0]) >> 4) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV0f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 5) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 6) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV1f_GET(r) ((((r).vlan_ctrl1[0]) >> 7) & 0x1)
#define BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV1f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL1.
 */
#define BCM53262_A0_READ_VLAN_CTRL1r(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN_CTRL1r,(r._vlan_ctrl1),1)
#define BCM53262_A0_WRITE_VLAN_CTRL1r(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN_CTRL1r,&(r._vlan_ctrl1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL1r BCM53262_A0_VLAN_CTRL1r
#define VLAN_CTRL1r_SIZE BCM53262_A0_VLAN_CTRL1r_SIZE
typedef BCM53262_A0_VLAN_CTRL1r_t VLAN_CTRL1r_t;
#define VLAN_CTRL1r_CLR BCM53262_A0_VLAN_CTRL1r_CLR
#define VLAN_CTRL1r_SET BCM53262_A0_VLAN_CTRL1r_SET
#define VLAN_CTRL1r_GET BCM53262_A0_VLAN_CTRL1r_GET
#define VLAN_CTRL1r_SPECI_FWD_MAP_CHKf_GET BCM53262_A0_VLAN_CTRL1r_SPECI_FWD_MAP_CHKf_GET
#define VLAN_CTRL1r_SPECI_FWD_MAP_CHKf_SET BCM53262_A0_VLAN_CTRL1r_SPECI_FWD_MAP_CHKf_SET
#define VLAN_CTRL1r_SPECI_UNTAG_MAP_CHKf_GET BCM53262_A0_VLAN_CTRL1r_SPECI_UNTAG_MAP_CHKf_GET
#define VLAN_CTRL1r_SPECI_UNTAG_MAP_CHKf_SET BCM53262_A0_VLAN_CTRL1r_SPECI_UNTAG_MAP_CHKf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET BCM53262_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET
#define VLAN_CTRL1r_VLAN_CTRL1_RSRV0f_GET BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV0f_GET
#define VLAN_CTRL1r_VLAN_CTRL1_RSRV0f_SET BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV0f_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET BCM53262_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET
#define VLAN_CTRL1r_VLAN_CTRL1_RSRV1f_GET BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV1f_GET
#define VLAN_CTRL1r_VLAN_CTRL1_RSRV1f_SET BCM53262_A0_VLAN_CTRL1r_VLAN_CTRL1_RSRV1f_SET
#define READ_VLAN_CTRL1r BCM53262_A0_READ_VLAN_CTRL1r
#define WRITE_VLAN_CTRL1r BCM53262_A0_WRITE_VLAN_CTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_CTRL1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN_CTRL2
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 2 Registers
 * SIZE:     8
 * FIELDS:
 *     DIS_RST_BYTELEN  Disable_rst_load_bytelen (for Giga-port only)Note : Not to release this field to customers.
 *     STD_OVSZ_DROP    Std_ovsz_dropNote : Not to release this field to customers.
 *     EN_MIIM_BYPASS_V_FWDMAP When set to 1, frames received by MII_manage port will by pass V_fwdmap checking.** Untagged frame received by MII_manage port will never be tagged.
 *     EN_MIIM_BYPASS_V_UNTAG When set to 1, frames received by MII_manage port will by pass V_untagmap.
 *     RESERVED_R       Reserved
 *     EN_GMRP_GVRP_V_FWDMAP When set to 1,  GMRP,GVRP will be checked by v_fwdmap** this rule do not apply to MII_manage and SPI ports
 *     EN_GMRP_GVRP_UNTAG_MAP When set to 1, r GMRP,GVRP will be checked by v_untagmap** this rule do not apply to MII_manage and SPI ports
 *     EN_REMAP_PRI     Internal use only ,NOT for standard releaseEnable Remap Priority Field.When asserted, the pri_field (3bits) in ingress frame (802.1Q frame or priority tagged frame) will be remapped to a new val ue based on re_map_reg[23:0]. The CFI bit will be preserved as original frame.** When enable this feature, control0[1:0] has to be either 01, or 11.and control0[3:2] has to be either 01, or 11.** managed IMP port do not support V_tagging. So they can not support pri remap.
 */
#define BCM53262_A0_VLAN_CTRL2r 0x00003402

#define BCM53262_A0_VLAN_CTRL2r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL2.
 */
typedef union BCM53262_A0_VLAN_CTRL2r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl2[1];
	uint32_t _vlan_ctrl2;
} BCM53262_A0_VLAN_CTRL2r_t;

#define BCM53262_A0_VLAN_CTRL2r_CLR(r) (r).vlan_ctrl2[0] = 0
#define BCM53262_A0_VLAN_CTRL2r_SET(r,d) (r).vlan_ctrl2[0] = d
#define BCM53262_A0_VLAN_CTRL2r_GET(r) (r).vlan_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_CTRL2r_DIS_RST_BYTELENf_GET(r) (((r).vlan_ctrl2[0]) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_DIS_RST_BYTELENf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_VLAN_CTRL2r_STD_OVSZ_DROPf_GET(r) ((((r).vlan_ctrl2[0]) >> 1) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_STD_OVSZ_DROPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 2) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_GET(r) ((((r).vlan_ctrl2[0]) >> 3) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_VLAN_CTRL2r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl2[0]) >> 4) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 5) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 6) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_VLAN_CTRL2r_EN_REMAP_PRIf_GET(r) ((((r).vlan_ctrl2[0]) >> 7) & 0x1)
#define BCM53262_A0_VLAN_CTRL2r_EN_REMAP_PRIf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL2.
 */
#define BCM53262_A0_READ_VLAN_CTRL2r(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN_CTRL2r,(r._vlan_ctrl2),1)
#define BCM53262_A0_WRITE_VLAN_CTRL2r(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN_CTRL2r,&(r._vlan_ctrl2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL2r BCM53262_A0_VLAN_CTRL2r
#define VLAN_CTRL2r_SIZE BCM53262_A0_VLAN_CTRL2r_SIZE
typedef BCM53262_A0_VLAN_CTRL2r_t VLAN_CTRL2r_t;
#define VLAN_CTRL2r_CLR BCM53262_A0_VLAN_CTRL2r_CLR
#define VLAN_CTRL2r_SET BCM53262_A0_VLAN_CTRL2r_SET
#define VLAN_CTRL2r_GET BCM53262_A0_VLAN_CTRL2r_GET
#define VLAN_CTRL2r_DIS_RST_BYTELENf_GET BCM53262_A0_VLAN_CTRL2r_DIS_RST_BYTELENf_GET
#define VLAN_CTRL2r_DIS_RST_BYTELENf_SET BCM53262_A0_VLAN_CTRL2r_DIS_RST_BYTELENf_SET
#define VLAN_CTRL2r_STD_OVSZ_DROPf_GET BCM53262_A0_VLAN_CTRL2r_STD_OVSZ_DROPf_GET
#define VLAN_CTRL2r_STD_OVSZ_DROPf_SET BCM53262_A0_VLAN_CTRL2r_STD_OVSZ_DROPf_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_GET BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_SET BCM53262_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_SET
#define VLAN_CTRL2r_RESERVED_Rf_GET BCM53262_A0_VLAN_CTRL2r_RESERVED_Rf_GET
#define VLAN_CTRL2r_RESERVED_Rf_SET BCM53262_A0_VLAN_CTRL2r_RESERVED_Rf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET BCM53262_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET
#define VLAN_CTRL2r_EN_REMAP_PRIf_GET BCM53262_A0_VLAN_CTRL2r_EN_REMAP_PRIf_GET
#define VLAN_CTRL2r_EN_REMAP_PRIf_SET BCM53262_A0_VLAN_CTRL2r_EN_REMAP_PRIf_SET
#define READ_VLAN_CTRL2r BCM53262_A0_READ_VLAN_CTRL2r
#define WRITE_VLAN_CTRL2r BCM53262_A0_WRITE_VLAN_CTRL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_CTRL2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN_CTRL3
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 3 Registers
 * SIZE:     64
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     EN_DROP_NON1Q    When enabled , any non_1Q frame will be dropped by this port. Ports 52-0 respectively.
 *     RESERVED_1R      Reserved
 *     IBM_REQ          0: VID==12'hfff frame will be treated as VID violation frame.1: VID==12'hfff frame will not be treated as VID violation frame.
 */
#define BCM53262_A0_VLAN_CTRL3r 0x00003408

#define BCM53262_A0_VLAN_CTRL3r_SIZE 8

/*
 * This structure should be used to declare and program VLAN_CTRL3.
 */
typedef union BCM53262_A0_VLAN_CTRL3r_s {
	uint32_t v[2];
	uint32_t vlan_ctrl3[2];
	uint32_t _vlan_ctrl3;
} BCM53262_A0_VLAN_CTRL3r_t;

#define BCM53262_A0_VLAN_CTRL3r_CLR(r) CDK_MEMSET(&((r)._vlan_ctrl3), 0, sizeof(BCM53262_A0_VLAN_CTRL3r_t))
#define BCM53262_A0_VLAN_CTRL3r_SET(r,i,d) (r).vlan_ctrl3[i] = d
#define BCM53262_A0_VLAN_CTRL3r_GET(r,i) (r).vlan_ctrl3[i]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_CTRL3r_RESERVED_0Rf_GET(r) (((r).vlan_ctrl3[0]) & 0xffffff)
#define BCM53262_A0_VLAN_CTRL3r_RESERVED_0Rf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET(r) cdk_field32_get((r).vlan_ctrl3,24,52)
#define BCM53262_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET(r,f) cdk_field32_set((r).vlan_ctrl3,24,52,f)
#define BCM53262_A0_VLAN_CTRL3r_RESERVED_1Rf_GET(r) ((((r).vlan_ctrl3[1]) >> 21) & 0x3ff)
#define BCM53262_A0_VLAN_CTRL3r_RESERVED_1Rf_SET(r,f) (r).vlan_ctrl3[1]=(((r).vlan_ctrl3[1] & ~((uint32_t)0x3ff << 21)) | ((((uint32_t)f) & 0x3ff) << 21))
#define BCM53262_A0_VLAN_CTRL3r_IBM_REQf_GET(r) ((((r).vlan_ctrl3[1]) >> 31) & 0x1)
#define BCM53262_A0_VLAN_CTRL3r_IBM_REQf_SET(r,f) (r).vlan_ctrl3[1]=(((r).vlan_ctrl3[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access VLAN_CTRL3.
 */
#define BCM53262_A0_READ_VLAN_CTRL3r(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN_CTRL3r,(r._vlan_ctrl3),8)
#define BCM53262_A0_WRITE_VLAN_CTRL3r(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN_CTRL3r,&(r._vlan_ctrl3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL3r BCM53262_A0_VLAN_CTRL3r
#define VLAN_CTRL3r_SIZE BCM53262_A0_VLAN_CTRL3r_SIZE
typedef BCM53262_A0_VLAN_CTRL3r_t VLAN_CTRL3r_t;
#define VLAN_CTRL3r_CLR BCM53262_A0_VLAN_CTRL3r_CLR
#define VLAN_CTRL3r_SET BCM53262_A0_VLAN_CTRL3r_SET
#define VLAN_CTRL3r_GET BCM53262_A0_VLAN_CTRL3r_GET
#define VLAN_CTRL3r_RESERVED_0Rf_GET BCM53262_A0_VLAN_CTRL3r_RESERVED_0Rf_GET
#define VLAN_CTRL3r_RESERVED_0Rf_SET BCM53262_A0_VLAN_CTRL3r_RESERVED_0Rf_SET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_GET BCM53262_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_SET BCM53262_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET
#define VLAN_CTRL3r_RESERVED_1Rf_GET BCM53262_A0_VLAN_CTRL3r_RESERVED_1Rf_GET
#define VLAN_CTRL3r_RESERVED_1Rf_SET BCM53262_A0_VLAN_CTRL3r_RESERVED_1Rf_SET
#define VLAN_CTRL3r_IBM_REQf_GET BCM53262_A0_VLAN_CTRL3r_IBM_REQf_GET
#define VLAN_CTRL3r_IBM_REQf_SET BCM53262_A0_VLAN_CTRL3r_IBM_REQf_SET
#define READ_VLAN_CTRL3r BCM53262_A0_READ_VLAN_CTRL3r
#define WRITE_VLAN_CTRL3r BCM53262_A0_WRITE_VLAN_CTRL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_CTRL3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN_CTRL4
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 4 Registers
 * SIZE:     8
 * FIELDS:
 *     OPT_UTAG_LEN     Option bit for untag frame length1 : length + 40 : length + 0Note : Not to release this field to customers.
 *     EN_V2V_INDEX_BY_INPORT Only valid for 53242/53262 B0.When set to 0, VID[11:0] as an index to search VLAN2VLAN table.When set to 1, {(PORTID-24)[4:0], VID[6:0]} as an index to search VLAN2VALN table.
 *     RESERVED_R       Reserved
 *     EN_MGE_REV_GMRP  When set to 1, management port ( the port with CPU) will be the destination port of GMRP frame.
 *     EN_MGE_REV_GVRP  When set to 1. management port ( the port with CPU) willbe the destination port of GVRP frame.
 *     INGR_VID_CHK     00: forward ingress VID violation frame( VID is not in v_fwdmap). But do not learn in ARL table.01: Drop frame if frame has VID violation.10: Do not check ingress VID violation.** This rule do not apply to SPI and MII_management port
 */
#define BCM53262_A0_VLAN_CTRL4r 0x00003403

#define BCM53262_A0_VLAN_CTRL4r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL4.
 */
typedef union BCM53262_A0_VLAN_CTRL4r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl4[1];
	uint32_t _vlan_ctrl4;
} BCM53262_A0_VLAN_CTRL4r_t;

#define BCM53262_A0_VLAN_CTRL4r_CLR(r) (r).vlan_ctrl4[0] = 0
#define BCM53262_A0_VLAN_CTRL4r_SET(r,d) (r).vlan_ctrl4[0] = d
#define BCM53262_A0_VLAN_CTRL4r_GET(r) (r).vlan_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_CTRL4r_OPT_UTAG_LENf_GET(r) (((r).vlan_ctrl4[0]) & 0x1)
#define BCM53262_A0_VLAN_CTRL4r_OPT_UTAG_LENf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_VLAN_CTRL4r_EN_V2V_INDEX_BY_INPORTf_GET(r) ((((r).vlan_ctrl4[0]) >> 1) & 0x1)
#define BCM53262_A0_VLAN_CTRL4r_EN_V2V_INDEX_BY_INPORTf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_VLAN_CTRL4r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl4[0]) >> 2) & 0x3)
#define BCM53262_A0_VLAN_CTRL4r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 4) & 0x1)
#define BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 5) & 0x1)
#define BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET(r) ((((r).vlan_ctrl4[0]) >> 6) & 0x3)
#define BCM53262_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access VLAN_CTRL4.
 */
#define BCM53262_A0_READ_VLAN_CTRL4r(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN_CTRL4r,(r._vlan_ctrl4),1)
#define BCM53262_A0_WRITE_VLAN_CTRL4r(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN_CTRL4r,&(r._vlan_ctrl4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL4r BCM53262_A0_VLAN_CTRL4r
#define VLAN_CTRL4r_SIZE BCM53262_A0_VLAN_CTRL4r_SIZE
typedef BCM53262_A0_VLAN_CTRL4r_t VLAN_CTRL4r_t;
#define VLAN_CTRL4r_CLR BCM53262_A0_VLAN_CTRL4r_CLR
#define VLAN_CTRL4r_SET BCM53262_A0_VLAN_CTRL4r_SET
#define VLAN_CTRL4r_GET BCM53262_A0_VLAN_CTRL4r_GET
#define VLAN_CTRL4r_OPT_UTAG_LENf_GET BCM53262_A0_VLAN_CTRL4r_OPT_UTAG_LENf_GET
#define VLAN_CTRL4r_OPT_UTAG_LENf_SET BCM53262_A0_VLAN_CTRL4r_OPT_UTAG_LENf_SET
#define VLAN_CTRL4r_EN_V2V_INDEX_BY_INPORTf_GET BCM53262_A0_VLAN_CTRL4r_EN_V2V_INDEX_BY_INPORTf_GET
#define VLAN_CTRL4r_EN_V2V_INDEX_BY_INPORTf_SET BCM53262_A0_VLAN_CTRL4r_EN_V2V_INDEX_BY_INPORTf_SET
#define VLAN_CTRL4r_RESERVED_Rf_GET BCM53262_A0_VLAN_CTRL4r_RESERVED_Rf_GET
#define VLAN_CTRL4r_RESERVED_Rf_SET BCM53262_A0_VLAN_CTRL4r_RESERVED_Rf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET BCM53262_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET
#define VLAN_CTRL4r_INGR_VID_CHKf_GET BCM53262_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET
#define VLAN_CTRL4r_INGR_VID_CHKf_SET BCM53262_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET
#define READ_VLAN_CTRL4r BCM53262_A0_READ_VLAN_CTRL4r
#define WRITE_VLAN_CTRL4r BCM53262_A0_WRITE_VLAN_CTRL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_CTRL4r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN_CTRL5
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 5 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     EN_CPU_RX_BYPASS_CRCCHK When set to 1, The management port (MII or SPI) with CPU on it will ignore any CRC ( BRCM tag frame, or Ethernet frame).When set to 0: The management port will check both CRC. Work as old 5318/5328.** In old 5325/28 design, management port need to calculate CRC for Ethernet frame and BRCM tagged frame. Those two CRC calculations take a lot of CPU power and are not needed. With this option, CPU do not need to calculate CRC for BRCM frame. If global_1Q_control5_g[2]=1, then CPU do not need to generate Ethernet CRC either--->Ehernet CRC will be generated by SPI port.
 *     RESERVED_1R      Reserved
 *     DROP_VTABLE_MISS When set to 1, a frame with V_table miss will be droppedWhen set to 0, will trap to IMP instead of flooding.
 *     STRICT_SFD_DETECT Using for Gigabit port only (Port 48,49,50,51 abd 52).When set to 1, drop frames with no preamble and start with SFD regardless of the phase of rx_clk at which nibble data of SFD is received.When set to 0, drop such frames only at certain phase of the nibble data of SFD.Note : Not to release this field to customers.
 *     DIS_EGRESS_BYPASS_TRUNK When set to 1, egress directly frames from management port will NOT bypass trunking checking.When set to 0, egress directly frames from management port will bypass trunking checking.
 *     PRESV_NON1Q      When set to 1, non-1q imconing frames will not be changed.
 *     LEARN_VID_VIO    When set to 1, the SA of incoming packet will be learned even its VID is violated.Note : Not to release this field to customers.
 */
#define BCM53262_A0_VLAN_CTRL5r 0x00003404

#define BCM53262_A0_VLAN_CTRL5r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL5.
 */
typedef union BCM53262_A0_VLAN_CTRL5r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl5[1];
	uint32_t _vlan_ctrl5;
} BCM53262_A0_VLAN_CTRL5r_t;

#define BCM53262_A0_VLAN_CTRL5r_CLR(r) (r).vlan_ctrl5[0] = 0
#define BCM53262_A0_VLAN_CTRL5r_SET(r,d) (r).vlan_ctrl5[0] = d
#define BCM53262_A0_VLAN_CTRL5r_GET(r) (r).vlan_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_CTRL5r_RESERVED_0Rf_GET(r) (((r).vlan_ctrl5[0]) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_RESERVED_0Rf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_GET(r) ((((r).vlan_ctrl5[0]) >> 1) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_VLAN_CTRL5r_RESERVED_1Rf_GET(r) ((((r).vlan_ctrl5[0]) >> 2) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_RESERVED_1Rf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET(r) ((((r).vlan_ctrl5[0]) >> 3) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_VLAN_CTRL5r_STRICT_SFD_DETECTf_GET(r) ((((r).vlan_ctrl5[0]) >> 4) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_STRICT_SFD_DETECTf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_VLAN_CTRL5r_DIS_EGRESS_BYPASS_TRUNKf_GET(r) ((((r).vlan_ctrl5[0]) >> 5) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_DIS_EGRESS_BYPASS_TRUNKf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET(r) ((((r).vlan_ctrl5[0]) >> 6) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_VLAN_CTRL5r_LEARN_VID_VIOf_GET(r) ((((r).vlan_ctrl5[0]) >> 7) & 0x1)
#define BCM53262_A0_VLAN_CTRL5r_LEARN_VID_VIOf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL5.
 */
#define BCM53262_A0_READ_VLAN_CTRL5r(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN_CTRL5r,(r._vlan_ctrl5),1)
#define BCM53262_A0_WRITE_VLAN_CTRL5r(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN_CTRL5r,&(r._vlan_ctrl5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL5r BCM53262_A0_VLAN_CTRL5r
#define VLAN_CTRL5r_SIZE BCM53262_A0_VLAN_CTRL5r_SIZE
typedef BCM53262_A0_VLAN_CTRL5r_t VLAN_CTRL5r_t;
#define VLAN_CTRL5r_CLR BCM53262_A0_VLAN_CTRL5r_CLR
#define VLAN_CTRL5r_SET BCM53262_A0_VLAN_CTRL5r_SET
#define VLAN_CTRL5r_GET BCM53262_A0_VLAN_CTRL5r_GET
#define VLAN_CTRL5r_RESERVED_0Rf_GET BCM53262_A0_VLAN_CTRL5r_RESERVED_0Rf_GET
#define VLAN_CTRL5r_RESERVED_0Rf_SET BCM53262_A0_VLAN_CTRL5r_RESERVED_0Rf_SET
#define VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_GET BCM53262_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_SET BCM53262_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_SET
#define VLAN_CTRL5r_RESERVED_1Rf_GET BCM53262_A0_VLAN_CTRL5r_RESERVED_1Rf_GET
#define VLAN_CTRL5r_RESERVED_1Rf_SET BCM53262_A0_VLAN_CTRL5r_RESERVED_1Rf_SET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_GET BCM53262_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_SET BCM53262_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET
#define VLAN_CTRL5r_STRICT_SFD_DETECTf_GET BCM53262_A0_VLAN_CTRL5r_STRICT_SFD_DETECTf_GET
#define VLAN_CTRL5r_STRICT_SFD_DETECTf_SET BCM53262_A0_VLAN_CTRL5r_STRICT_SFD_DETECTf_SET
#define VLAN_CTRL5r_DIS_EGRESS_BYPASS_TRUNKf_GET BCM53262_A0_VLAN_CTRL5r_DIS_EGRESS_BYPASS_TRUNKf_GET
#define VLAN_CTRL5r_DIS_EGRESS_BYPASS_TRUNKf_SET BCM53262_A0_VLAN_CTRL5r_DIS_EGRESS_BYPASS_TRUNKf_SET
#define VLAN_CTRL5r_PRESV_NON1Qf_GET BCM53262_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET
#define VLAN_CTRL5r_PRESV_NON1Qf_SET BCM53262_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET
#define VLAN_CTRL5r_LEARN_VID_VIOf_GET BCM53262_A0_VLAN_CTRL5r_LEARN_VID_VIOf_GET
#define VLAN_CTRL5r_LEARN_VID_VIOf_SET BCM53262_A0_VLAN_CTRL5r_LEARN_VID_VIOf_SET
#define READ_VLAN_CTRL5r BCM53262_A0_READ_VLAN_CTRL5r
#define WRITE_VLAN_CTRL5r BCM53262_A0_WRITE_VLAN_CTRL5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_CTRL5r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  VLAN_REMAP
 * BLOCKS:   SYS
 * DESC:     Priority Remap Registers(Internal use only ,NOT for standard release)
 * SIZE:     32
 * FIELDS:
 *     REMAP            Internal use only ,NOT for standard release.When  1) global_1Q_control1[8]=1 and2) control0[0]=1 and3) control0[2] =1 .Then we will remap the original frames's  pri to the one in re_map_reg[23:0] . The mapping rule are:OLD PRI            NEW PRI------------------------------------000               re_map_reg[2:0]001               re_map_reg[5:3]010               re_map_reg[8:6]011               re_map_reg[11:9]100               re_map_reg[14:12]101               re_map_reg[17:15]110               re_map_reg[20:18]111               re_map_reg[23:21]** If incomming frame is pri_tagged frame, or tagged frame, Then we will re_mapped it's pri field if re_maping feature is enabled.** If incoming frame is an un_tagged frame, then we will use pri in default_tag as new pri.
 *     NOT2RELEASE      
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_VLAN_REMAPr 0x00003480

#define BCM53262_A0_VLAN_REMAPr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_REMAP.
 */
typedef union BCM53262_A0_VLAN_REMAPr_s {
	uint32_t v[1];
	uint32_t vlan_remap[1];
	uint32_t _vlan_remap;
} BCM53262_A0_VLAN_REMAPr_t;

#define BCM53262_A0_VLAN_REMAPr_CLR(r) (r).vlan_remap[0] = 0
#define BCM53262_A0_VLAN_REMAPr_SET(r,d) (r).vlan_remap[0] = d
#define BCM53262_A0_VLAN_REMAPr_GET(r) (r).vlan_remap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_VLAN_REMAPr_REMAPf_GET(r) (((r).vlan_remap[0]) & 0xffffff)
#define BCM53262_A0_VLAN_REMAPr_REMAPf_SET(r,f) (r).vlan_remap[0]=(((r).vlan_remap[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53262_A0_VLAN_REMAPr_NOT2RELEASEf_GET(r) ((((r).vlan_remap[0]) >> 24) & 0x1)
#define BCM53262_A0_VLAN_REMAPr_NOT2RELEASEf_SET(r,f) (r).vlan_remap[0]=(((r).vlan_remap[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53262_A0_VLAN_REMAPr_RESERVED_Rf_GET(r) ((((r).vlan_remap[0]) >> 25) & 0x7f)
#define BCM53262_A0_VLAN_REMAPr_RESERVED_Rf_SET(r,f) (r).vlan_remap[0]=(((r).vlan_remap[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access VLAN_REMAP.
 */
#define BCM53262_A0_READ_VLAN_REMAPr(u,r) cdk_robo_reg_read(u,BCM53262_A0_VLAN_REMAPr,(r._vlan_remap),4)
#define BCM53262_A0_WRITE_VLAN_REMAPr(u,r) cdk_robo_reg_write(u,BCM53262_A0_VLAN_REMAPr,&(r._vlan_remap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_REMAPr BCM53262_A0_VLAN_REMAPr
#define VLAN_REMAPr_SIZE BCM53262_A0_VLAN_REMAPr_SIZE
typedef BCM53262_A0_VLAN_REMAPr_t VLAN_REMAPr_t;
#define VLAN_REMAPr_CLR BCM53262_A0_VLAN_REMAPr_CLR
#define VLAN_REMAPr_SET BCM53262_A0_VLAN_REMAPr_SET
#define VLAN_REMAPr_GET BCM53262_A0_VLAN_REMAPr_GET
#define VLAN_REMAPr_REMAPf_GET BCM53262_A0_VLAN_REMAPr_REMAPf_GET
#define VLAN_REMAPr_REMAPf_SET BCM53262_A0_VLAN_REMAPr_REMAPf_SET
#define VLAN_REMAPr_NOT2RELEASEf_GET BCM53262_A0_VLAN_REMAPr_NOT2RELEASEf_GET
#define VLAN_REMAPr_NOT2RELEASEf_SET BCM53262_A0_VLAN_REMAPr_NOT2RELEASEf_SET
#define VLAN_REMAPr_RESERVED_Rf_GET BCM53262_A0_VLAN_REMAPr_RESERVED_Rf_GET
#define VLAN_REMAPr_RESERVED_Rf_SET BCM53262_A0_VLAN_REMAPr_RESERVED_Rf_SET
#define READ_VLAN_REMAPr BCM53262_A0_READ_VLAN_REMAPr
#define WRITE_VLAN_REMAPr BCM53262_A0_WRITE_VLAN_REMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_VLAN_REMAPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_ANADV
 * BLOCKS:   GPIC0
 * DESC:     1000-X Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0R      Fixed value: indicates 802.3.
 *     FDX              1 = advertise full-duplex.0 = do not advertise full-duplex.default value by adv_fdx_def.
 *     HDX              1 = advertise half-duplex.0 = do not advertise half-duplex.default value by adv_hdx_def.
 *     PAUSE_R          00 = no pause.01 = symmetric pause.10 = asymmetric pause toward link partner.11 = both symmetric pause and asymmetric.pause toward local device.default value by pause_def[1:0].
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   00 = no remote f ault01 = link failure10 = of.ine11 = auto-negotiation error
 *     RESERVED_R       Reserved
 *     NEXT_PAGE        1 = Next Page Operation supported;0 = Next Page Operation disabled.
 */
#define BCM53262_A0_X1K_ANADVr 0x0000b808

#define BCM53262_A0_X1K_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program X1K_ANADV.
 */
typedef union BCM53262_A0_X1K_ANADVr_s {
	uint32_t v[1];
	uint32_t x1k_anadv[1];
	uint32_t _x1k_anadv;
} BCM53262_A0_X1K_ANADVr_t;

#define BCM53262_A0_X1K_ANADVr_CLR(r) (r).x1k_anadv[0] = 0
#define BCM53262_A0_X1K_ANADVr_SET(r,d) (r).x1k_anadv[0] = d
#define BCM53262_A0_X1K_ANADVr_GET(r) (r).x1k_anadv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_ANADVr_RESERVED_0Rf_GET(r) (((r).x1k_anadv[0]) & 0x1f)
#define BCM53262_A0_X1K_ANADVr_RESERVED_0Rf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_X1K_ANADVr_FDXf_GET(r) ((((r).x1k_anadv[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_ANADVr_FDXf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_ANADVr_HDXf_GET(r) ((((r).x1k_anadv[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_ANADVr_HDXf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_ANADVr_PAUSE_Rf_GET(r) ((((r).x1k_anadv[0]) >> 7) & 0x3)
#define BCM53262_A0_X1K_ANADVr_PAUSE_Rf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53262_A0_X1K_ANADVr_RESERVED_1Rf_GET(r) ((((r).x1k_anadv[0]) >> 9) & 0x7)
#define BCM53262_A0_X1K_ANADVr_RESERVED_1Rf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53262_A0_X1K_ANADVr_REMOTE_FAULT_Rf_GET(r) ((((r).x1k_anadv[0]) >> 12) & 0x3)
#define BCM53262_A0_X1K_ANADVr_REMOTE_FAULT_Rf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_X1K_ANADVr_RESERVED_Rf_GET(r) ((((r).x1k_anadv[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_ANADVr_RESERVED_Rf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_ANADVr_NEXT_PAGEf_GET(r) ((((r).x1k_anadv[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_ANADVr_NEXT_PAGEf_SET(r,f) (r).x1k_anadv[0]=(((r).x1k_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_ANADV.
 */
#define BCM53262_A0_READ_X1K_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_ANADVr,(r._x1k_anadv),2)
#define BCM53262_A0_WRITE_X1K_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_ANADVr,&(r._x1k_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_ANADVr BCM53262_A0_X1K_ANADVr
#define X1K_ANADVr_SIZE BCM53262_A0_X1K_ANADVr_SIZE
typedef BCM53262_A0_X1K_ANADVr_t X1K_ANADVr_t;
#define X1K_ANADVr_CLR BCM53262_A0_X1K_ANADVr_CLR
#define X1K_ANADVr_SET BCM53262_A0_X1K_ANADVr_SET
#define X1K_ANADVr_GET BCM53262_A0_X1K_ANADVr_GET
#define X1K_ANADVr_RESERVED_0Rf_GET BCM53262_A0_X1K_ANADVr_RESERVED_0Rf_GET
#define X1K_ANADVr_RESERVED_0Rf_SET BCM53262_A0_X1K_ANADVr_RESERVED_0Rf_SET
#define X1K_ANADVr_FDXf_GET BCM53262_A0_X1K_ANADVr_FDXf_GET
#define X1K_ANADVr_FDXf_SET BCM53262_A0_X1K_ANADVr_FDXf_SET
#define X1K_ANADVr_HDXf_GET BCM53262_A0_X1K_ANADVr_HDXf_GET
#define X1K_ANADVr_HDXf_SET BCM53262_A0_X1K_ANADVr_HDXf_SET
#define X1K_ANADVr_PAUSE_Rf_GET BCM53262_A0_X1K_ANADVr_PAUSE_Rf_GET
#define X1K_ANADVr_PAUSE_Rf_SET BCM53262_A0_X1K_ANADVr_PAUSE_Rf_SET
#define X1K_ANADVr_RESERVED_1Rf_GET BCM53262_A0_X1K_ANADVr_RESERVED_1Rf_GET
#define X1K_ANADVr_RESERVED_1Rf_SET BCM53262_A0_X1K_ANADVr_RESERVED_1Rf_SET
#define X1K_ANADVr_REMOTE_FAULT_Rf_GET BCM53262_A0_X1K_ANADVr_REMOTE_FAULT_Rf_GET
#define X1K_ANADVr_REMOTE_FAULT_Rf_SET BCM53262_A0_X1K_ANADVr_REMOTE_FAULT_Rf_SET
#define X1K_ANADVr_RESERVED_Rf_GET BCM53262_A0_X1K_ANADVr_RESERVED_Rf_GET
#define X1K_ANADVr_RESERVED_Rf_SET BCM53262_A0_X1K_ANADVr_RESERVED_Rf_SET
#define X1K_ANADVr_NEXT_PAGEf_GET BCM53262_A0_X1K_ANADVr_NEXT_PAGEf_GET
#define X1K_ANADVr_NEXT_PAGEf_SET BCM53262_A0_X1K_ANADVr_NEXT_PAGEf_SET
#define READ_X1K_ANADVr BCM53262_A0_READ_X1K_ANADVr
#define WRITE_X1K_ANADVr BCM53262_A0_WRITE_X1K_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_ANADVr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_ANEXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0R      Ignore on read.
 *     PAGE_REC         1 = new link code word has been received.0 = new link code word has not been received.
 *     NEXT_PAGE        1 = local device is next page able0 = local device is not next page able
 *     RESERVED_1R      Reserved
 */
#define BCM53262_A0_X1K_ANEXPr 0x0000b80c

#define BCM53262_A0_X1K_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program X1K_ANEXP.
 */
typedef union BCM53262_A0_X1K_ANEXPr_s {
	uint32_t v[1];
	uint32_t x1k_anexp[1];
	uint32_t _x1k_anexp;
} BCM53262_A0_X1K_ANEXPr_t;

#define BCM53262_A0_X1K_ANEXPr_CLR(r) (r).x1k_anexp[0] = 0
#define BCM53262_A0_X1K_ANEXPr_SET(r,d) (r).x1k_anexp[0] = d
#define BCM53262_A0_X1K_ANEXPr_GET(r) (r).x1k_anexp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_ANEXPr_RESERVED_0Rf_GET(r) (((r).x1k_anexp[0]) & 0x1)
#define BCM53262_A0_X1K_ANEXPr_RESERVED_0Rf_SET(r,f) (r).x1k_anexp[0]=(((r).x1k_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_ANEXPr_PAGE_RECf_GET(r) ((((r).x1k_anexp[0]) >> 1) & 0x1)
#define BCM53262_A0_X1K_ANEXPr_PAGE_RECf_SET(r,f) (r).x1k_anexp[0]=(((r).x1k_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_X1K_ANEXPr_NEXT_PAGEf_GET(r) ((((r).x1k_anexp[0]) >> 2) & 0x1)
#define BCM53262_A0_X1K_ANEXPr_NEXT_PAGEf_SET(r,f) (r).x1k_anexp[0]=(((r).x1k_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_X1K_ANEXPr_RESERVED_1Rf_GET(r) ((((r).x1k_anexp[0]) >> 3) & 0x1fff)
#define BCM53262_A0_X1K_ANEXPr_RESERVED_1Rf_SET(r,f) (r).x1k_anexp[0]=(((r).x1k_anexp[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))

/*
 * These macros can be used to access X1K_ANEXP.
 */
#define BCM53262_A0_READ_X1K_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_ANEXPr,(r._x1k_anexp),2)
#define BCM53262_A0_WRITE_X1K_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_ANEXPr,&(r._x1k_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_ANEXPr BCM53262_A0_X1K_ANEXPr
#define X1K_ANEXPr_SIZE BCM53262_A0_X1K_ANEXPr_SIZE
typedef BCM53262_A0_X1K_ANEXPr_t X1K_ANEXPr_t;
#define X1K_ANEXPr_CLR BCM53262_A0_X1K_ANEXPr_CLR
#define X1K_ANEXPr_SET BCM53262_A0_X1K_ANEXPr_SET
#define X1K_ANEXPr_GET BCM53262_A0_X1K_ANEXPr_GET
#define X1K_ANEXPr_RESERVED_0Rf_GET BCM53262_A0_X1K_ANEXPr_RESERVED_0Rf_GET
#define X1K_ANEXPr_RESERVED_0Rf_SET BCM53262_A0_X1K_ANEXPr_RESERVED_0Rf_SET
#define X1K_ANEXPr_PAGE_RECf_GET BCM53262_A0_X1K_ANEXPr_PAGE_RECf_GET
#define X1K_ANEXPr_PAGE_RECf_SET BCM53262_A0_X1K_ANEXPr_PAGE_RECf_SET
#define X1K_ANEXPr_NEXT_PAGEf_GET BCM53262_A0_X1K_ANEXPr_NEXT_PAGEf_GET
#define X1K_ANEXPr_NEXT_PAGEf_SET BCM53262_A0_X1K_ANEXPr_NEXT_PAGEf_SET
#define X1K_ANEXPr_RESERVED_1Rf_GET BCM53262_A0_X1K_ANEXPr_RESERVED_1Rf_GET
#define X1K_ANEXPr_RESERVED_1Rf_SET BCM53262_A0_X1K_ANEXPr_RESERVED_1Rf_SET
#define READ_X1K_ANEXPr BCM53262_A0_READ_X1K_ANEXPr
#define WRITE_X1K_ANEXPr BCM53262_A0_WRITE_X1K_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_ANEXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_ANLPA
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0R      ignore on read.
 *     LP_FDX           1 = link partner is full duplex capable.0 = link partner is not full duplex capable.
 *     LP_HDX           1 = link partner is half duplex capable0 = link partner is not half duplex capable
 *     LP_PAUSE         00 = no pause.01 = symmetric pause.10 = asymmetric pause toward link partner.11 = both symmetric pause and asymmetric.pause toward local device.
 *     RESERVED_1R      ignore on read.
 *     LP_REMOTE_FAULT  00 = no remote f ault.01 = link failure.10 = of.ine.11 = auto-negotiation error.
 *     LP_ACK           Link Partner acknowledge bit.
 *     LP_NEXT_PAGE     1 = link partner is next page able.0 = link partner is not next page able.
 */
#define BCM53262_A0_X1K_ANLPAr 0x0000b80a

#define BCM53262_A0_X1K_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program X1K_ANLPA.
 */
typedef union BCM53262_A0_X1K_ANLPAr_s {
	uint32_t v[1];
	uint32_t x1k_anlpa[1];
	uint32_t _x1k_anlpa;
} BCM53262_A0_X1K_ANLPAr_t;

#define BCM53262_A0_X1K_ANLPAr_CLR(r) (r).x1k_anlpa[0] = 0
#define BCM53262_A0_X1K_ANLPAr_SET(r,d) (r).x1k_anlpa[0] = d
#define BCM53262_A0_X1K_ANLPAr_GET(r) (r).x1k_anlpa[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_ANLPAr_RESERVED_0Rf_GET(r) (((r).x1k_anlpa[0]) & 0x1f)
#define BCM53262_A0_X1K_ANLPAr_RESERVED_0Rf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_X1K_ANLPAr_LP_FDXf_GET(r) ((((r).x1k_anlpa[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_ANLPAr_LP_FDXf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_ANLPAr_LP_HDXf_GET(r) ((((r).x1k_anlpa[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_ANLPAr_LP_HDXf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_ANLPAr_LP_PAUSEf_GET(r) ((((r).x1k_anlpa[0]) >> 7) & 0x3)
#define BCM53262_A0_X1K_ANLPAr_LP_PAUSEf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53262_A0_X1K_ANLPAr_RESERVED_1Rf_GET(r) ((((r).x1k_anlpa[0]) >> 9) & 0x7)
#define BCM53262_A0_X1K_ANLPAr_RESERVED_1Rf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53262_A0_X1K_ANLPAr_LP_REMOTE_FAULTf_GET(r) ((((r).x1k_anlpa[0]) >> 12) & 0x3)
#define BCM53262_A0_X1K_ANLPAr_LP_REMOTE_FAULTf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53262_A0_X1K_ANLPAr_LP_ACKf_GET(r) ((((r).x1k_anlpa[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_ANLPAr_LP_ACKf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_ANLPAr_LP_NEXT_PAGEf_GET(r) ((((r).x1k_anlpa[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_ANLPAr_LP_NEXT_PAGEf_SET(r,f) (r).x1k_anlpa[0]=(((r).x1k_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_ANLPA.
 */
#define BCM53262_A0_READ_X1K_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_ANLPAr,(r._x1k_anlpa),2)
#define BCM53262_A0_WRITE_X1K_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_ANLPAr,&(r._x1k_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_ANLPAr BCM53262_A0_X1K_ANLPAr
#define X1K_ANLPAr_SIZE BCM53262_A0_X1K_ANLPAr_SIZE
typedef BCM53262_A0_X1K_ANLPAr_t X1K_ANLPAr_t;
#define X1K_ANLPAr_CLR BCM53262_A0_X1K_ANLPAr_CLR
#define X1K_ANLPAr_SET BCM53262_A0_X1K_ANLPAr_SET
#define X1K_ANLPAr_GET BCM53262_A0_X1K_ANLPAr_GET
#define X1K_ANLPAr_RESERVED_0Rf_GET BCM53262_A0_X1K_ANLPAr_RESERVED_0Rf_GET
#define X1K_ANLPAr_RESERVED_0Rf_SET BCM53262_A0_X1K_ANLPAr_RESERVED_0Rf_SET
#define X1K_ANLPAr_LP_FDXf_GET BCM53262_A0_X1K_ANLPAr_LP_FDXf_GET
#define X1K_ANLPAr_LP_FDXf_SET BCM53262_A0_X1K_ANLPAr_LP_FDXf_SET
#define X1K_ANLPAr_LP_HDXf_GET BCM53262_A0_X1K_ANLPAr_LP_HDXf_GET
#define X1K_ANLPAr_LP_HDXf_SET BCM53262_A0_X1K_ANLPAr_LP_HDXf_SET
#define X1K_ANLPAr_LP_PAUSEf_GET BCM53262_A0_X1K_ANLPAr_LP_PAUSEf_GET
#define X1K_ANLPAr_LP_PAUSEf_SET BCM53262_A0_X1K_ANLPAr_LP_PAUSEf_SET
#define X1K_ANLPAr_RESERVED_1Rf_GET BCM53262_A0_X1K_ANLPAr_RESERVED_1Rf_GET
#define X1K_ANLPAr_RESERVED_1Rf_SET BCM53262_A0_X1K_ANLPAr_RESERVED_1Rf_SET
#define X1K_ANLPAr_LP_REMOTE_FAULTf_GET BCM53262_A0_X1K_ANLPAr_LP_REMOTE_FAULTf_GET
#define X1K_ANLPAr_LP_REMOTE_FAULTf_SET BCM53262_A0_X1K_ANLPAr_LP_REMOTE_FAULTf_SET
#define X1K_ANLPAr_LP_ACKf_GET BCM53262_A0_X1K_ANLPAr_LP_ACKf_GET
#define X1K_ANLPAr_LP_ACKf_SET BCM53262_A0_X1K_ANLPAr_LP_ACKf_SET
#define X1K_ANLPAr_LP_NEXT_PAGEf_GET BCM53262_A0_X1K_ANLPAr_LP_NEXT_PAGEf_GET
#define X1K_ANLPAr_LP_NEXT_PAGEf_SET BCM53262_A0_X1K_ANLPAr_LP_NEXT_PAGEf_SET
#define READ_X1K_ANLPAr BCM53262_A0_READ_X1K_ANLPAr
#define WRITE_X1K_ANLPAr BCM53262_A0_WRITE_X1K_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_ANLPAr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_ANNXP
 * BLOCKS:   GPIC0
 * DESC:     1000-X Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       15:0 RESERVED_R RO write as 0, ignore on read
 */
#define BCM53262_A0_X1K_ANNXPr 0x0000b80e

#define BCM53262_A0_X1K_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program X1K_ANNXP.
 */
typedef union BCM53262_A0_X1K_ANNXPr_s {
	uint32_t v[1];
	uint32_t x1k_annxp[1];
	uint32_t _x1k_annxp;
} BCM53262_A0_X1K_ANNXPr_t;

#define BCM53262_A0_X1K_ANNXPr_CLR(r) (r).x1k_annxp[0] = 0
#define BCM53262_A0_X1K_ANNXPr_SET(r,d) (r).x1k_annxp[0] = d
#define BCM53262_A0_X1K_ANNXPr_GET(r) (r).x1k_annxp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_ANNXPr_RESERVED_Rf_GET(r) (((r).x1k_annxp[0]) & 0xffff)
#define BCM53262_A0_X1K_ANNXPr_RESERVED_Rf_SET(r,f) (r).x1k_annxp[0]=(((r).x1k_annxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access X1K_ANNXP.
 */
#define BCM53262_A0_READ_X1K_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_ANNXPr,(r._x1k_annxp),2)
#define BCM53262_A0_WRITE_X1K_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_ANNXPr,&(r._x1k_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_ANNXPr BCM53262_A0_X1K_ANNXPr
#define X1K_ANNXPr_SIZE BCM53262_A0_X1K_ANNXPr_SIZE
typedef BCM53262_A0_X1K_ANNXPr_t X1K_ANNXPr_t;
#define X1K_ANNXPr_CLR BCM53262_A0_X1K_ANNXPr_CLR
#define X1K_ANNXPr_SET BCM53262_A0_X1K_ANNXPr_SET
#define X1K_ANNXPr_GET BCM53262_A0_X1K_ANNXPr_GET
#define X1K_ANNXPr_RESERVED_Rf_GET BCM53262_A0_X1K_ANNXPr_RESERVED_Rf_GET
#define X1K_ANNXPr_RESERVED_Rf_SET BCM53262_A0_X1K_ANNXPr_RESERVED_Rf_SET
#define READ_X1K_ANNXPr BCM53262_A0_READ_X1K_ANNXPr
#define WRITE_X1K_ANNXPr BCM53262_A0_WRITE_X1K_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_ANNXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_BER_CRC_RXCNT
 * BLOCKS:   GPIC0
 * DESC:     BER / CRC Error / Receive Packet Counter Register
 * SIZE:     16
 * FIELDS:
 *     CRC_ERRPKT_RXCNT Number of crc errors detected since last read.Freezes at FFh.When register 0*10h bit 11 is set, then the counterdetects the number of received packets instead of crc errors.
 *     BIT_ERRRATE_CNT  Number of invalid code groups detected whilesync_status = 1.Freezes at FFh.Write register 0*11h bit 14 = 1 in order to clear bits 15:8 of this register.
 */
#define BCM53262_A0_X1K_BER_CRC_RXCNTr 0x0000b82e

#define BCM53262_A0_X1K_BER_CRC_RXCNTr_SIZE 2

/*
 * This structure should be used to declare and program X1K_BER_CRC_RXCNT.
 */
typedef union BCM53262_A0_X1K_BER_CRC_RXCNTr_s {
	uint32_t v[1];
	uint32_t x1k_ber_crc_rxcnt[1];
	uint32_t _x1k_ber_crc_rxcnt;
} BCM53262_A0_X1K_BER_CRC_RXCNTr_t;

#define BCM53262_A0_X1K_BER_CRC_RXCNTr_CLR(r) (r).x1k_ber_crc_rxcnt[0] = 0
#define BCM53262_A0_X1K_BER_CRC_RXCNTr_SET(r,d) (r).x1k_ber_crc_rxcnt[0] = d
#define BCM53262_A0_X1K_BER_CRC_RXCNTr_GET(r) (r).x1k_ber_crc_rxcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_BER_CRC_RXCNTr_CRC_ERRPKT_RXCNTf_GET(r) (((r).x1k_ber_crc_rxcnt[0]) & 0xff)
#define BCM53262_A0_X1K_BER_CRC_RXCNTr_CRC_ERRPKT_RXCNTf_SET(r,f) (r).x1k_ber_crc_rxcnt[0]=(((r).x1k_ber_crc_rxcnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_X1K_BER_CRC_RXCNTr_BIT_ERRRATE_CNTf_GET(r) ((((r).x1k_ber_crc_rxcnt[0]) >> 8) & 0xff)
#define BCM53262_A0_X1K_BER_CRC_RXCNTr_BIT_ERRRATE_CNTf_SET(r,f) (r).x1k_ber_crc_rxcnt[0]=(((r).x1k_ber_crc_rxcnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access X1K_BER_CRC_RXCNT.
 */
#define BCM53262_A0_READ_X1K_BER_CRC_RXCNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_BER_CRC_RXCNTr,(r._x1k_ber_crc_rxcnt),2)
#define BCM53262_A0_WRITE_X1K_BER_CRC_RXCNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_BER_CRC_RXCNTr,&(r._x1k_ber_crc_rxcnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_BER_CRC_RXCNTr BCM53262_A0_X1K_BER_CRC_RXCNTr
#define X1K_BER_CRC_RXCNTr_SIZE BCM53262_A0_X1K_BER_CRC_RXCNTr_SIZE
typedef BCM53262_A0_X1K_BER_CRC_RXCNTr_t X1K_BER_CRC_RXCNTr_t;
#define X1K_BER_CRC_RXCNTr_CLR BCM53262_A0_X1K_BER_CRC_RXCNTr_CLR
#define X1K_BER_CRC_RXCNTr_SET BCM53262_A0_X1K_BER_CRC_RXCNTr_SET
#define X1K_BER_CRC_RXCNTr_GET BCM53262_A0_X1K_BER_CRC_RXCNTr_GET
#define X1K_BER_CRC_RXCNTr_CRC_ERRPKT_RXCNTf_GET BCM53262_A0_X1K_BER_CRC_RXCNTr_CRC_ERRPKT_RXCNTf_GET
#define X1K_BER_CRC_RXCNTr_CRC_ERRPKT_RXCNTf_SET BCM53262_A0_X1K_BER_CRC_RXCNTr_CRC_ERRPKT_RXCNTf_SET
#define X1K_BER_CRC_RXCNTr_BIT_ERRRATE_CNTf_GET BCM53262_A0_X1K_BER_CRC_RXCNTr_BIT_ERRRATE_CNTf_GET
#define X1K_BER_CRC_RXCNTr_BIT_ERRRATE_CNTf_SET BCM53262_A0_X1K_BER_CRC_RXCNTr_BIT_ERRRATE_CNTf_SET
#define READ_X1K_BER_CRC_RXCNTr BCM53262_A0_READ_X1K_BER_CRC_RXCNTr
#define WRITE_X1K_BER_CRC_RXCNTr BCM53262_A0_WRITE_X1K_BER_CRC_RXCNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_BER_CRC_RXCNTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_BRCMTST
 * BLOCKS:   GPIC0
 * DESC:     Indirect Addressing Register
 * SIZE:     16
 * FIELDS:
 *     INDIR_ADDR       all mdio read/write accesses to registers 10-1eh will append the indirect address register in front to allow15 additional banks of registers.Therefore, the notation used in this register spec is: indirect_address * mdio_registerExample: 0*10h, 1*13h, etcRegisters 00-0Fh and 1Fh do not use the indirectaddressing and are .xed.0000 = valid0001 = valid0010 - 1111 = reserved for future implementation                
 *     RESERVED_R       write as 0, ignore on read.
 */
#define BCM53262_A0_X1K_BRCMTSTr 0x0000b83e

#define BCM53262_A0_X1K_BRCMTSTr_SIZE 2

/*
 * This structure should be used to declare and program X1K_BRCMTST.
 */
typedef union BCM53262_A0_X1K_BRCMTSTr_s {
	uint32_t v[1];
	uint32_t x1k_brcmtst[1];
	uint32_t _x1k_brcmtst;
} BCM53262_A0_X1K_BRCMTSTr_t;

#define BCM53262_A0_X1K_BRCMTSTr_CLR(r) (r).x1k_brcmtst[0] = 0
#define BCM53262_A0_X1K_BRCMTSTr_SET(r,d) (r).x1k_brcmtst[0] = d
#define BCM53262_A0_X1K_BRCMTSTr_GET(r) (r).x1k_brcmtst[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_BRCMTSTr_INDIR_ADDRf_GET(r) (((r).x1k_brcmtst[0]) & 0xffff)
#define BCM53262_A0_X1K_BRCMTSTr_INDIR_ADDRf_SET(r,f) (r).x1k_brcmtst[0]=(((r).x1k_brcmtst[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53262_A0_X1K_BRCMTSTr_RESERVED_Rf_GET(r) ((((r).x1k_brcmtst[0]) >> 11) & 0x1f)
#define BCM53262_A0_X1K_BRCMTSTr_RESERVED_Rf_SET(r,f) (r).x1k_brcmtst[0]=(((r).x1k_brcmtst[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access X1K_BRCMTST.
 */
#define BCM53262_A0_READ_X1K_BRCMTSTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_BRCMTSTr,(r._x1k_brcmtst),2)
#define BCM53262_A0_WRITE_X1K_BRCMTSTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_BRCMTSTr,&(r._x1k_brcmtst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_BRCMTSTr BCM53262_A0_X1K_BRCMTSTr
#define X1K_BRCMTSTr_SIZE BCM53262_A0_X1K_BRCMTSTr_SIZE
typedef BCM53262_A0_X1K_BRCMTSTr_t X1K_BRCMTSTr_t;
#define X1K_BRCMTSTr_CLR BCM53262_A0_X1K_BRCMTSTr_CLR
#define X1K_BRCMTSTr_SET BCM53262_A0_X1K_BRCMTSTr_SET
#define X1K_BRCMTSTr_GET BCM53262_A0_X1K_BRCMTSTr_GET
#define X1K_BRCMTSTr_INDIR_ADDRf_GET BCM53262_A0_X1K_BRCMTSTr_INDIR_ADDRf_GET
#define X1K_BRCMTSTr_INDIR_ADDRf_SET BCM53262_A0_X1K_BRCMTSTr_INDIR_ADDRf_SET
#define X1K_BRCMTSTr_RESERVED_Rf_GET BCM53262_A0_X1K_BRCMTSTr_RESERVED_Rf_GET
#define X1K_BRCMTSTr_RESERVED_Rf_SET BCM53262_A0_X1K_BRCMTSTr_RESERVED_Rf_SET
#define READ_X1K_BRCMTSTr BCM53262_A0_READ_X1K_BRCMTSTr
#define WRITE_X1K_BRCMTSTr BCM53262_A0_WRITE_X1K_BRCMTSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_BRCMTSTr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_CTL1
 * BLOCKS:   GPIC0
 * DESC:     1000-X Control Register 1
 * SIZE:     16
 * FIELDS:
 *     FIBER_MODE       1 = Fiber mode (1000X).0 = SGMII mode.
 *     TBI_EN           1 = ten bit interf ace.0 = gmii interface.
 *     EN_SIG_DET       1 = signal detect from pin must be set in order to achieve synchronization.0 = ignore signal detect from pin. The output of the signal detect .lter is internally forced to 1 (active high).
 *     INV_SIG_DET      1 = invert signal detect from pin.0 = use signal detect from pin.
 *     AUTO_DET_EN      1 = enable auto-detection (.ber and sgmii mode will switch each time a auto-negotiation page is received with the wrong selector .eld in bit 0.).0 = disable auto-detection (.ber or sgmii mode is set according to bit 0 of this register).              
 *     SGMII_MST_MODE   1 = sgmii mode operates in íºphy modeí¿. If auto-negotiation is enabled then the local device will send out the following auto-negotiation code word:[15] = 1[14] = ack[13] = 0[12] = register 0.8[11] = register 0.6[10] = register 0.13[9:0] = íº0000000001í¿In order to disable the link set register 0.11 = 1In order to enable the link set register 0.11 = 00 = normal operation.
 *     DIS_PLL_PWRDWN   1 = pll will never be powered down. (use this when the mac/switch uses the pll_clk125 output)0 = pll will be powered down when register 0.12 is setdefault value by clk125_disable_def.
 *     DIS_CRC_CHK      1 = disable crc checker by gating the clock to save power0 = enable crc checker                
 *     EN_COMMA_DET     1 = enable comma detection.0 = disable comma detection.
 *     ZERO_COMMA_DET   1 = force comma detector phase to zero.0 = normal operation.
 *     EN_RM_LPBACK     1 = enable remote loopback (10/100/1000)0 = normal operation
 *     SEL_REC_CNT      1 = select received packets for 0*17h counter0 = select crc errors for 0*17h counter                
 *     TX_AMP_OVERRIDE  1 = override serdes transmit amplitude from register 1*10h bit 140 = normal operation (selected by sgmii or .ber mode).                
 *     MDIO_PHY_SEL     1 = all mdio write accesses to phy address íº00000í¿ will write this phy in addition to its own phy address.0 = normal operation
 *     SIGNAL_DET_DIS   1 = disable .lter for signal detect.0 = .lter signal detect from pin before using for synchronization.
 *     SPARE_R          write as 0, ignore on read
 */
#define BCM53262_A0_X1K_CTL1r 0x0000b820

#define BCM53262_A0_X1K_CTL1r_SIZE 2

/*
 * This structure should be used to declare and program X1K_CTL1.
 */
typedef union BCM53262_A0_X1K_CTL1r_s {
	uint32_t v[1];
	uint32_t x1k_ctl1[1];
	uint32_t _x1k_ctl1;
} BCM53262_A0_X1K_CTL1r_t;

#define BCM53262_A0_X1K_CTL1r_CLR(r) (r).x1k_ctl1[0] = 0
#define BCM53262_A0_X1K_CTL1r_SET(r,d) (r).x1k_ctl1[0] = d
#define BCM53262_A0_X1K_CTL1r_GET(r) (r).x1k_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_CTL1r_FIBER_MODEf_GET(r) (((r).x1k_ctl1[0]) & 0x1)
#define BCM53262_A0_X1K_CTL1r_FIBER_MODEf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_CTL1r_TBI_ENf_GET(r) ((((r).x1k_ctl1[0]) >> 1) & 0x1)
#define BCM53262_A0_X1K_CTL1r_TBI_ENf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_X1K_CTL1r_EN_SIG_DETf_GET(r) ((((r).x1k_ctl1[0]) >> 2) & 0x1)
#define BCM53262_A0_X1K_CTL1r_EN_SIG_DETf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_X1K_CTL1r_INV_SIG_DETf_GET(r) ((((r).x1k_ctl1[0]) >> 3) & 0x1)
#define BCM53262_A0_X1K_CTL1r_INV_SIG_DETf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_X1K_CTL1r_AUTO_DET_ENf_GET(r) ((((r).x1k_ctl1[0]) >> 4) & 0x1)
#define BCM53262_A0_X1K_CTL1r_AUTO_DET_ENf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_X1K_CTL1r_SGMII_MST_MODEf_GET(r) ((((r).x1k_ctl1[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_CTL1r_SGMII_MST_MODEf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_CTL1r_DIS_PLL_PWRDWNf_GET(r) ((((r).x1k_ctl1[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_CTL1r_DIS_PLL_PWRDWNf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_CTL1r_DIS_CRC_CHKf_GET(r) ((((r).x1k_ctl1[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_CTL1r_DIS_CRC_CHKf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_CTL1r_EN_COMMA_DETf_GET(r) ((((r).x1k_ctl1[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_CTL1r_EN_COMMA_DETf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_CTL1r_ZERO_COMMA_DETf_GET(r) ((((r).x1k_ctl1[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_CTL1r_ZERO_COMMA_DETf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_CTL1r_EN_RM_LPBACKf_GET(r) ((((r).x1k_ctl1[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_CTL1r_EN_RM_LPBACKf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_CTL1r_SEL_REC_CNTf_GET(r) ((((r).x1k_ctl1[0]) >> 11) & 0x1)
#define BCM53262_A0_X1K_CTL1r_SEL_REC_CNTf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_X1K_CTL1r_TX_AMP_OVERRIDEf_GET(r) ((((r).x1k_ctl1[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_CTL1r_TX_AMP_OVERRIDEf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_CTL1r_MDIO_PHY_SELf_GET(r) ((((r).x1k_ctl1[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_CTL1r_MDIO_PHY_SELf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_CTL1r_SIGNAL_DET_DISf_GET(r) ((((r).x1k_ctl1[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_CTL1r_SIGNAL_DET_DISf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_CTL1r_SPARE_Rf_GET(r) ((((r).x1k_ctl1[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_CTL1r_SPARE_Rf_SET(r,f) (r).x1k_ctl1[0]=(((r).x1k_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_CTL1.
 */
#define BCM53262_A0_READ_X1K_CTL1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_CTL1r,(r._x1k_ctl1),2)
#define BCM53262_A0_WRITE_X1K_CTL1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_CTL1r,&(r._x1k_ctl1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_CTL1r BCM53262_A0_X1K_CTL1r
#define X1K_CTL1r_SIZE BCM53262_A0_X1K_CTL1r_SIZE
typedef BCM53262_A0_X1K_CTL1r_t X1K_CTL1r_t;
#define X1K_CTL1r_CLR BCM53262_A0_X1K_CTL1r_CLR
#define X1K_CTL1r_SET BCM53262_A0_X1K_CTL1r_SET
#define X1K_CTL1r_GET BCM53262_A0_X1K_CTL1r_GET
#define X1K_CTL1r_FIBER_MODEf_GET BCM53262_A0_X1K_CTL1r_FIBER_MODEf_GET
#define X1K_CTL1r_FIBER_MODEf_SET BCM53262_A0_X1K_CTL1r_FIBER_MODEf_SET
#define X1K_CTL1r_TBI_ENf_GET BCM53262_A0_X1K_CTL1r_TBI_ENf_GET
#define X1K_CTL1r_TBI_ENf_SET BCM53262_A0_X1K_CTL1r_TBI_ENf_SET
#define X1K_CTL1r_EN_SIG_DETf_GET BCM53262_A0_X1K_CTL1r_EN_SIG_DETf_GET
#define X1K_CTL1r_EN_SIG_DETf_SET BCM53262_A0_X1K_CTL1r_EN_SIG_DETf_SET
#define X1K_CTL1r_INV_SIG_DETf_GET BCM53262_A0_X1K_CTL1r_INV_SIG_DETf_GET
#define X1K_CTL1r_INV_SIG_DETf_SET BCM53262_A0_X1K_CTL1r_INV_SIG_DETf_SET
#define X1K_CTL1r_AUTO_DET_ENf_GET BCM53262_A0_X1K_CTL1r_AUTO_DET_ENf_GET
#define X1K_CTL1r_AUTO_DET_ENf_SET BCM53262_A0_X1K_CTL1r_AUTO_DET_ENf_SET
#define X1K_CTL1r_SGMII_MST_MODEf_GET BCM53262_A0_X1K_CTL1r_SGMII_MST_MODEf_GET
#define X1K_CTL1r_SGMII_MST_MODEf_SET BCM53262_A0_X1K_CTL1r_SGMII_MST_MODEf_SET
#define X1K_CTL1r_DIS_PLL_PWRDWNf_GET BCM53262_A0_X1K_CTL1r_DIS_PLL_PWRDWNf_GET
#define X1K_CTL1r_DIS_PLL_PWRDWNf_SET BCM53262_A0_X1K_CTL1r_DIS_PLL_PWRDWNf_SET
#define X1K_CTL1r_DIS_CRC_CHKf_GET BCM53262_A0_X1K_CTL1r_DIS_CRC_CHKf_GET
#define X1K_CTL1r_DIS_CRC_CHKf_SET BCM53262_A0_X1K_CTL1r_DIS_CRC_CHKf_SET
#define X1K_CTL1r_EN_COMMA_DETf_GET BCM53262_A0_X1K_CTL1r_EN_COMMA_DETf_GET
#define X1K_CTL1r_EN_COMMA_DETf_SET BCM53262_A0_X1K_CTL1r_EN_COMMA_DETf_SET
#define X1K_CTL1r_ZERO_COMMA_DETf_GET BCM53262_A0_X1K_CTL1r_ZERO_COMMA_DETf_GET
#define X1K_CTL1r_ZERO_COMMA_DETf_SET BCM53262_A0_X1K_CTL1r_ZERO_COMMA_DETf_SET
#define X1K_CTL1r_EN_RM_LPBACKf_GET BCM53262_A0_X1K_CTL1r_EN_RM_LPBACKf_GET
#define X1K_CTL1r_EN_RM_LPBACKf_SET BCM53262_A0_X1K_CTL1r_EN_RM_LPBACKf_SET
#define X1K_CTL1r_SEL_REC_CNTf_GET BCM53262_A0_X1K_CTL1r_SEL_REC_CNTf_GET
#define X1K_CTL1r_SEL_REC_CNTf_SET BCM53262_A0_X1K_CTL1r_SEL_REC_CNTf_SET
#define X1K_CTL1r_TX_AMP_OVERRIDEf_GET BCM53262_A0_X1K_CTL1r_TX_AMP_OVERRIDEf_GET
#define X1K_CTL1r_TX_AMP_OVERRIDEf_SET BCM53262_A0_X1K_CTL1r_TX_AMP_OVERRIDEf_SET
#define X1K_CTL1r_MDIO_PHY_SELf_GET BCM53262_A0_X1K_CTL1r_MDIO_PHY_SELf_GET
#define X1K_CTL1r_MDIO_PHY_SELf_SET BCM53262_A0_X1K_CTL1r_MDIO_PHY_SELf_SET
#define X1K_CTL1r_SIGNAL_DET_DISf_GET BCM53262_A0_X1K_CTL1r_SIGNAL_DET_DISf_GET
#define X1K_CTL1r_SIGNAL_DET_DISf_SET BCM53262_A0_X1K_CTL1r_SIGNAL_DET_DISf_SET
#define X1K_CTL1r_SPARE_Rf_GET BCM53262_A0_X1K_CTL1r_SPARE_Rf_GET
#define X1K_CTL1r_SPARE_Rf_SET BCM53262_A0_X1K_CTL1r_SPARE_Rf_SET
#define READ_X1K_CTL1r BCM53262_A0_READ_X1K_CTL1r
#define WRITE_X1K_CTL1r BCM53262_A0_WRITE_X1K_CTL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_CTL2
 * BLOCKS:   GPIC0
 * DESC:     1000-X Control Register 2
 * SIZE:     16
 * FIELDS:
 *     EN_PAR_DET       1 = enable parallel detection. (This will turn autonegotiation on and off as needed to properly link up with the link partner. The idles and auto-negotiation code words received from the link partner are used to make this decision).
 *     DIS_FALSE_LNK    1 = do not allo w link to be established when autonegotiation is disabled and receiving auto-negotiation code words. The link will only be established in this case after idles are received. (This bit does not need to be set, if bit 0 below is set.)0 = normal operation.
 *     FILTER_LNK       1 = sync-status must be set for a solid 10ms before a valid link will be established when auto-negotiation is disabled. (This is useful in .ber applications where the user does not have the signal detect pinconnected to the .ber module and auto-negotiation is turned off.)0 = normal operation.
 *     EN_ANERR_TIMER   1 = enable auto-negotiation error timer. Error occurs when timer expires in ability-detect, ack-detect, or idle-detect. When the error occurs, con.g words of all zeros are sent until an ability match occurs, then the autoneg-enable state is entered.0 = normal operation.
 *     BED_ESD_DET      1 = disable automatic sensing of remote faults, such as auto-negotiation error0 = automatically detect remote faults and send remote fault status to link partner via auto-negotiation when .ber mode is selected.(SGMII does not support remote faults).
 *     TMIT_TX          1 = allow packets to be transmitted regardless of the condition of the link or synchronization0 = normal operation.
 *     AN_FAST          1 = speed up timers during auto-negotiation for testing.0 = normal operation.
 *     DIS_CARR_EXT     1 = disable carrier extension in pcs receive.0 = normal operation.
 *     DIS_TRRR_GEN     1 = disable TRRR generation in pcs transmit.0 = normal operation.
 *     BYPASS_PCS_REV   1 = bypass pcs receive operation.0 = normal operation.
 *     TRANS_PKT_TEST   1 = enable 16-stage 10-bit transmit test sequence directly to serdes transmiiter.Stage 1-4, 13-16 = idleStage 5-12 = data packet0 = normal operation.
 *     IDLE_TRANS_TEST  SEQUENCE TEST1 = enable 16-stage 10-bit idle transmit test sequence to serdes transmitter.Register 0*1d[9:0] will override k28.5 for stage 5 (17Ch)Register 0*1e[9:0] will override D16.2 for stage 6 (289h)0 = normal operation
 *     CLR_CNTS         1 = clear bit-error-rate counter (register 0*17h[15:8])0 = normal operation.
 *     SPACE            write as 0, ignore on read
 */
#define BCM53262_A0_X1K_CTL2r 0x0000b822

#define BCM53262_A0_X1K_CTL2r_SIZE 2

/*
 * This structure should be used to declare and program X1K_CTL2.
 */
typedef union BCM53262_A0_X1K_CTL2r_s {
	uint32_t v[1];
	uint32_t x1k_ctl2[1];
	uint32_t _x1k_ctl2;
} BCM53262_A0_X1K_CTL2r_t;

#define BCM53262_A0_X1K_CTL2r_CLR(r) (r).x1k_ctl2[0] = 0
#define BCM53262_A0_X1K_CTL2r_SET(r,d) (r).x1k_ctl2[0] = d
#define BCM53262_A0_X1K_CTL2r_GET(r) (r).x1k_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_CTL2r_EN_PAR_DETf_GET(r) (((r).x1k_ctl2[0]) & 0x1)
#define BCM53262_A0_X1K_CTL2r_EN_PAR_DETf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_CTL2r_DIS_FALSE_LNKf_GET(r) ((((r).x1k_ctl2[0]) >> 1) & 0x1)
#define BCM53262_A0_X1K_CTL2r_DIS_FALSE_LNKf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_X1K_CTL2r_FILTER_LNKf_GET(r) ((((r).x1k_ctl2[0]) >> 2) & 0x1)
#define BCM53262_A0_X1K_CTL2r_FILTER_LNKf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_X1K_CTL2r_EN_ANERR_TIMERf_GET(r) ((((r).x1k_ctl2[0]) >> 3) & 0x1)
#define BCM53262_A0_X1K_CTL2r_EN_ANERR_TIMERf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_X1K_CTL2r_BED_ESD_DETf_GET(r) ((((r).x1k_ctl2[0]) >> 4) & 0x1)
#define BCM53262_A0_X1K_CTL2r_BED_ESD_DETf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_X1K_CTL2r_TMIT_TXf_GET(r) ((((r).x1k_ctl2[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_CTL2r_TMIT_TXf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_CTL2r_AN_FASTf_GET(r) ((((r).x1k_ctl2[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_CTL2r_AN_FASTf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_CTL2r_DIS_CARR_EXTf_GET(r) ((((r).x1k_ctl2[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_CTL2r_DIS_CARR_EXTf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_CTL2r_DIS_TRRR_GENf_GET(r) ((((r).x1k_ctl2[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_CTL2r_DIS_TRRR_GENf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_CTL2r_BYPASS_PCS_REVf_GET(r) ((((r).x1k_ctl2[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_CTL2r_BYPASS_PCS_REVf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_CTL2r_TRANS_PKT_TESTf_GET(r) ((((r).x1k_ctl2[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_CTL2r_TRANS_PKT_TESTf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_CTL2r_IDLE_TRANS_TESTf_GET(r) ((((r).x1k_ctl2[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_CTL2r_IDLE_TRANS_TESTf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_CTL2r_CLR_CNTSf_GET(r) ((((r).x1k_ctl2[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_CTL2r_CLR_CNTSf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_CTL2r_SPACEf_GET(r) ((((r).x1k_ctl2[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_CTL2r_SPACEf_SET(r,f) (r).x1k_ctl2[0]=(((r).x1k_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_CTL2.
 */
#define BCM53262_A0_READ_X1K_CTL2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_CTL2r,(r._x1k_ctl2),2)
#define BCM53262_A0_WRITE_X1K_CTL2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_CTL2r,&(r._x1k_ctl2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_CTL2r BCM53262_A0_X1K_CTL2r
#define X1K_CTL2r_SIZE BCM53262_A0_X1K_CTL2r_SIZE
typedef BCM53262_A0_X1K_CTL2r_t X1K_CTL2r_t;
#define X1K_CTL2r_CLR BCM53262_A0_X1K_CTL2r_CLR
#define X1K_CTL2r_SET BCM53262_A0_X1K_CTL2r_SET
#define X1K_CTL2r_GET BCM53262_A0_X1K_CTL2r_GET
#define X1K_CTL2r_EN_PAR_DETf_GET BCM53262_A0_X1K_CTL2r_EN_PAR_DETf_GET
#define X1K_CTL2r_EN_PAR_DETf_SET BCM53262_A0_X1K_CTL2r_EN_PAR_DETf_SET
#define X1K_CTL2r_DIS_FALSE_LNKf_GET BCM53262_A0_X1K_CTL2r_DIS_FALSE_LNKf_GET
#define X1K_CTL2r_DIS_FALSE_LNKf_SET BCM53262_A0_X1K_CTL2r_DIS_FALSE_LNKf_SET
#define X1K_CTL2r_FILTER_LNKf_GET BCM53262_A0_X1K_CTL2r_FILTER_LNKf_GET
#define X1K_CTL2r_FILTER_LNKf_SET BCM53262_A0_X1K_CTL2r_FILTER_LNKf_SET
#define X1K_CTL2r_EN_ANERR_TIMERf_GET BCM53262_A0_X1K_CTL2r_EN_ANERR_TIMERf_GET
#define X1K_CTL2r_EN_ANERR_TIMERf_SET BCM53262_A0_X1K_CTL2r_EN_ANERR_TIMERf_SET
#define X1K_CTL2r_BED_ESD_DETf_GET BCM53262_A0_X1K_CTL2r_BED_ESD_DETf_GET
#define X1K_CTL2r_BED_ESD_DETf_SET BCM53262_A0_X1K_CTL2r_BED_ESD_DETf_SET
#define X1K_CTL2r_TMIT_TXf_GET BCM53262_A0_X1K_CTL2r_TMIT_TXf_GET
#define X1K_CTL2r_TMIT_TXf_SET BCM53262_A0_X1K_CTL2r_TMIT_TXf_SET
#define X1K_CTL2r_AN_FASTf_GET BCM53262_A0_X1K_CTL2r_AN_FASTf_GET
#define X1K_CTL2r_AN_FASTf_SET BCM53262_A0_X1K_CTL2r_AN_FASTf_SET
#define X1K_CTL2r_DIS_CARR_EXTf_GET BCM53262_A0_X1K_CTL2r_DIS_CARR_EXTf_GET
#define X1K_CTL2r_DIS_CARR_EXTf_SET BCM53262_A0_X1K_CTL2r_DIS_CARR_EXTf_SET
#define X1K_CTL2r_DIS_TRRR_GENf_GET BCM53262_A0_X1K_CTL2r_DIS_TRRR_GENf_GET
#define X1K_CTL2r_DIS_TRRR_GENf_SET BCM53262_A0_X1K_CTL2r_DIS_TRRR_GENf_SET
#define X1K_CTL2r_BYPASS_PCS_REVf_GET BCM53262_A0_X1K_CTL2r_BYPASS_PCS_REVf_GET
#define X1K_CTL2r_BYPASS_PCS_REVf_SET BCM53262_A0_X1K_CTL2r_BYPASS_PCS_REVf_SET
#define X1K_CTL2r_TRANS_PKT_TESTf_GET BCM53262_A0_X1K_CTL2r_TRANS_PKT_TESTf_GET
#define X1K_CTL2r_TRANS_PKT_TESTf_SET BCM53262_A0_X1K_CTL2r_TRANS_PKT_TESTf_SET
#define X1K_CTL2r_IDLE_TRANS_TESTf_GET BCM53262_A0_X1K_CTL2r_IDLE_TRANS_TESTf_GET
#define X1K_CTL2r_IDLE_TRANS_TESTf_SET BCM53262_A0_X1K_CTL2r_IDLE_TRANS_TESTf_SET
#define X1K_CTL2r_CLR_CNTSf_GET BCM53262_A0_X1K_CTL2r_CLR_CNTSf_GET
#define X1K_CTL2r_CLR_CNTSf_SET BCM53262_A0_X1K_CTL2r_CLR_CNTSf_SET
#define X1K_CTL2r_SPACEf_GET BCM53262_A0_X1K_CTL2r_SPACEf_GET
#define X1K_CTL2r_SPACEf_SET BCM53262_A0_X1K_CTL2r_SPACEf_SET
#define READ_X1K_CTL2r BCM53262_A0_READ_X1K_CTL2r
#define WRITE_X1K_CTL2r BCM53262_A0_WRITE_X1K_CTL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_CTL3
 * BLOCKS:   GPIC0
 * DESC:     1000-X Control Register 3
 * SIZE:     16
 * FIELDS:
 *     TX_FIFO_RST      1 = reset transmit .fo. Fifo will remain in reset until this bit is cleared with a software write.0 = normal operation.
 *     FIFO_ELASTIC     00 = supports packets up to 5k bytes01 = supports packets up to 10k bytes1X = supports packets up to 13.5k bytes
 *     FREQLOCK_TX      1 = send extra bytes of preamble to avoid .fo latency. (Used in half-duplex applications to reduce collision domain latency. MAC must send 5 bytes of preamble or less to avoid non-compliant behavior.)0 = normal operation.
 *     EARLY_PREAMBLE_RX 1 = send extra bytes of preamble to avoid .fo latency. (Not necessary if MAC uses crs to determine collision)0 = normal operation.
 *     FREQLOCK_RX      1 = minimum .fo latency to properly handle a clock which is frequency locked, but out of phase.(Not necessary if MAC uses crs to determine collision; overrides bits 2:1of this register)NOTE: MAC and phy must be using the same crystal for this mode to be enabled.0 = normal operation.
 *     BYPASS_TXFIFO_GIGA 1 = bypass transmit .fo in gigabit mode. (Useful for .ber or gigabit only applications where the MAC is using the pll_clk125 as the clk_in port. User must meet timing to the pll_clk125 domain)0 = normal operation.
 *     TX_FIFO_ON       1 = force transmit .fo to free-run in gigabit mode (Requires clk_in and pll_clk125 to be frequency locked.)0 = normal operation.
 *     BLK_TXEN_MODE    1 = block txen when necessary to guarantee an ipg of at least 6.5 bytes in 10/100 mode, 7 bytes in 1000 mode.0 = normal operation.
 *     FAS_CAR_MODE     1 = change false carriers received into packets with preamble only. (Not necessary if MAC uses crs to determine collision)0 = normal operation.
 *     EXTPHY_CRS_MODE  1 = use external pin for the phyíªs íºreceive onlyí¿ crs output. (Useful in sgmii 10/100 half-duplex applications in order to reduce the collision domain latency. Requires a phy which generates a íºreceive onlyí¿ crs output to a pin.)0 = normal operation.
 *     INV_EXTPHY_CRS   CRS1 = invert íºreceive crs from phyí¿ pin0 = use íºreceive crs from phyí¿ pin.
 *     DIS_TX_CRS       1 = disable generating crs from transmitting in halfduplex mode. Only receiving will generate crs.0 = normal operation.
 *     SPARE_R          write as 0, ignore on read
 */
#define BCM53262_A0_X1K_CTL3r 0x0000b824

#define BCM53262_A0_X1K_CTL3r_SIZE 2

/*
 * This structure should be used to declare and program X1K_CTL3.
 */
typedef union BCM53262_A0_X1K_CTL3r_s {
	uint32_t v[1];
	uint32_t x1k_ctl3[1];
	uint32_t _x1k_ctl3;
} BCM53262_A0_X1K_CTL3r_t;

#define BCM53262_A0_X1K_CTL3r_CLR(r) (r).x1k_ctl3[0] = 0
#define BCM53262_A0_X1K_CTL3r_SET(r,d) (r).x1k_ctl3[0] = d
#define BCM53262_A0_X1K_CTL3r_GET(r) (r).x1k_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_CTL3r_TX_FIFO_RSTf_GET(r) (((r).x1k_ctl3[0]) & 0x1)
#define BCM53262_A0_X1K_CTL3r_TX_FIFO_RSTf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_CTL3r_FIFO_ELASTICf_GET(r) ((((r).x1k_ctl3[0]) >> 1) & 0x3)
#define BCM53262_A0_X1K_CTL3r_FIFO_ELASTICf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53262_A0_X1K_CTL3r_FREQLOCK_TXf_GET(r) ((((r).x1k_ctl3[0]) >> 3) & 0x1)
#define BCM53262_A0_X1K_CTL3r_FREQLOCK_TXf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_X1K_CTL3r_EARLY_PREAMBLE_RXf_GET(r) ((((r).x1k_ctl3[0]) >> 4) & 0x1)
#define BCM53262_A0_X1K_CTL3r_EARLY_PREAMBLE_RXf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_X1K_CTL3r_FREQLOCK_RXf_GET(r) ((((r).x1k_ctl3[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_CTL3r_FREQLOCK_RXf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_CTL3r_BYPASS_TXFIFO_GIGAf_GET(r) ((((r).x1k_ctl3[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_CTL3r_BYPASS_TXFIFO_GIGAf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_CTL3r_TX_FIFO_ONf_GET(r) ((((r).x1k_ctl3[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_CTL3r_TX_FIFO_ONf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_CTL3r_BLK_TXEN_MODEf_GET(r) ((((r).x1k_ctl3[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_CTL3r_BLK_TXEN_MODEf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_CTL3r_FAS_CAR_MODEf_GET(r) ((((r).x1k_ctl3[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_CTL3r_FAS_CAR_MODEf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_CTL3r_EXTPHY_CRS_MODEf_GET(r) ((((r).x1k_ctl3[0]) >> 11) & 0x1)
#define BCM53262_A0_X1K_CTL3r_EXTPHY_CRS_MODEf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_X1K_CTL3r_INV_EXTPHY_CRSf_GET(r) ((((r).x1k_ctl3[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_CTL3r_INV_EXTPHY_CRSf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_CTL3r_DIS_TX_CRSf_GET(r) ((((r).x1k_ctl3[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_CTL3r_DIS_TX_CRSf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_CTL3r_SPARE_Rf_GET(r) ((((r).x1k_ctl3[0]) >> 14) & 0x3)
#define BCM53262_A0_X1K_CTL3r_SPARE_Rf_SET(r,f) (r).x1k_ctl3[0]=(((r).x1k_ctl3[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access X1K_CTL3.
 */
#define BCM53262_A0_READ_X1K_CTL3r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_CTL3r,(r._x1k_ctl3),2)
#define BCM53262_A0_WRITE_X1K_CTL3r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_CTL3r,&(r._x1k_ctl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_CTL3r BCM53262_A0_X1K_CTL3r
#define X1K_CTL3r_SIZE BCM53262_A0_X1K_CTL3r_SIZE
typedef BCM53262_A0_X1K_CTL3r_t X1K_CTL3r_t;
#define X1K_CTL3r_CLR BCM53262_A0_X1K_CTL3r_CLR
#define X1K_CTL3r_SET BCM53262_A0_X1K_CTL3r_SET
#define X1K_CTL3r_GET BCM53262_A0_X1K_CTL3r_GET
#define X1K_CTL3r_TX_FIFO_RSTf_GET BCM53262_A0_X1K_CTL3r_TX_FIFO_RSTf_GET
#define X1K_CTL3r_TX_FIFO_RSTf_SET BCM53262_A0_X1K_CTL3r_TX_FIFO_RSTf_SET
#define X1K_CTL3r_FIFO_ELASTICf_GET BCM53262_A0_X1K_CTL3r_FIFO_ELASTICf_GET
#define X1K_CTL3r_FIFO_ELASTICf_SET BCM53262_A0_X1K_CTL3r_FIFO_ELASTICf_SET
#define X1K_CTL3r_FREQLOCK_TXf_GET BCM53262_A0_X1K_CTL3r_FREQLOCK_TXf_GET
#define X1K_CTL3r_FREQLOCK_TXf_SET BCM53262_A0_X1K_CTL3r_FREQLOCK_TXf_SET
#define X1K_CTL3r_EARLY_PREAMBLE_RXf_GET BCM53262_A0_X1K_CTL3r_EARLY_PREAMBLE_RXf_GET
#define X1K_CTL3r_EARLY_PREAMBLE_RXf_SET BCM53262_A0_X1K_CTL3r_EARLY_PREAMBLE_RXf_SET
#define X1K_CTL3r_FREQLOCK_RXf_GET BCM53262_A0_X1K_CTL3r_FREQLOCK_RXf_GET
#define X1K_CTL3r_FREQLOCK_RXf_SET BCM53262_A0_X1K_CTL3r_FREQLOCK_RXf_SET
#define X1K_CTL3r_BYPASS_TXFIFO_GIGAf_GET BCM53262_A0_X1K_CTL3r_BYPASS_TXFIFO_GIGAf_GET
#define X1K_CTL3r_BYPASS_TXFIFO_GIGAf_SET BCM53262_A0_X1K_CTL3r_BYPASS_TXFIFO_GIGAf_SET
#define X1K_CTL3r_TX_FIFO_ONf_GET BCM53262_A0_X1K_CTL3r_TX_FIFO_ONf_GET
#define X1K_CTL3r_TX_FIFO_ONf_SET BCM53262_A0_X1K_CTL3r_TX_FIFO_ONf_SET
#define X1K_CTL3r_BLK_TXEN_MODEf_GET BCM53262_A0_X1K_CTL3r_BLK_TXEN_MODEf_GET
#define X1K_CTL3r_BLK_TXEN_MODEf_SET BCM53262_A0_X1K_CTL3r_BLK_TXEN_MODEf_SET
#define X1K_CTL3r_FAS_CAR_MODEf_GET BCM53262_A0_X1K_CTL3r_FAS_CAR_MODEf_GET
#define X1K_CTL3r_FAS_CAR_MODEf_SET BCM53262_A0_X1K_CTL3r_FAS_CAR_MODEf_SET
#define X1K_CTL3r_EXTPHY_CRS_MODEf_GET BCM53262_A0_X1K_CTL3r_EXTPHY_CRS_MODEf_GET
#define X1K_CTL3r_EXTPHY_CRS_MODEf_SET BCM53262_A0_X1K_CTL3r_EXTPHY_CRS_MODEf_SET
#define X1K_CTL3r_INV_EXTPHY_CRSf_GET BCM53262_A0_X1K_CTL3r_INV_EXTPHY_CRSf_GET
#define X1K_CTL3r_INV_EXTPHY_CRSf_SET BCM53262_A0_X1K_CTL3r_INV_EXTPHY_CRSf_SET
#define X1K_CTL3r_DIS_TX_CRSf_GET BCM53262_A0_X1K_CTL3r_DIS_TX_CRSf_GET
#define X1K_CTL3r_DIS_TX_CRSf_SET BCM53262_A0_X1K_CTL3r_DIS_TX_CRSf_SET
#define X1K_CTL3r_SPARE_Rf_GET BCM53262_A0_X1K_CTL3r_SPARE_Rf_GET
#define X1K_CTL3r_SPARE_Rf_SET BCM53262_A0_X1K_CTL3r_SPARE_Rf_SET
#define READ_X1K_CTL3r BCM53262_A0_READ_X1K_CTL3r
#define WRITE_X1K_CTL3r BCM53262_A0_WRITE_X1K_CTL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_CTL4
 * BLOCKS:   GPIC0
 * DESC:     1000-X Control Register 4
 * SIZE:     16
 * FIELDS:
 *     SPARE_R          write as 0, ignore on read
 */
#define BCM53262_A0_X1K_CTL4r 0x0000b826

#define BCM53262_A0_X1K_CTL4r_SIZE 2

/*
 * This structure should be used to declare and program X1K_CTL4.
 */
typedef union BCM53262_A0_X1K_CTL4r_s {
	uint32_t v[1];
	uint32_t x1k_ctl4[1];
	uint32_t _x1k_ctl4;
} BCM53262_A0_X1K_CTL4r_t;

#define BCM53262_A0_X1K_CTL4r_CLR(r) (r).x1k_ctl4[0] = 0
#define BCM53262_A0_X1K_CTL4r_SET(r,d) (r).x1k_ctl4[0] = d
#define BCM53262_A0_X1K_CTL4r_GET(r) (r).x1k_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_CTL4r_SPARE_Rf_GET(r) (((r).x1k_ctl4[0]) & 0xffff)
#define BCM53262_A0_X1K_CTL4r_SPARE_Rf_SET(r,f) (r).x1k_ctl4[0]=(((r).x1k_ctl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access X1K_CTL4.
 */
#define BCM53262_A0_READ_X1K_CTL4r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_CTL4r,(r._x1k_ctl4),2)
#define BCM53262_A0_WRITE_X1K_CTL4r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_CTL4r,&(r._x1k_ctl4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_CTL4r BCM53262_A0_X1K_CTL4r
#define X1K_CTL4r_SIZE BCM53262_A0_X1K_CTL4r_SIZE
typedef BCM53262_A0_X1K_CTL4r_t X1K_CTL4r_t;
#define X1K_CTL4r_CLR BCM53262_A0_X1K_CTL4r_CLR
#define X1K_CTL4r_SET BCM53262_A0_X1K_CTL4r_SET
#define X1K_CTL4r_GET BCM53262_A0_X1K_CTL4r_GET
#define X1K_CTL4r_SPARE_Rf_GET BCM53262_A0_X1K_CTL4r_SPARE_Rf_GET
#define X1K_CTL4r_SPARE_Rf_SET BCM53262_A0_X1K_CTL4r_SPARE_Rf_SET
#define READ_X1K_CTL4r BCM53262_A0_READ_X1K_CTL4r
#define WRITE_X1K_CTL4r BCM53262_A0_WRITE_X1K_CTL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_EXT_MIISTS
 * BLOCKS:   GPIC0
 * DESC:     1000-X IEEE Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       ignore on read. 
 *     B1000T_HDX       1 = 1000Base-T half duplex capable.0 = not 1000Base-T half duplex capable.   
 *     B1000T_FDX       1 = 1000Base-T full duplex capable.0 = not 1000Base-T full duplex capable. 
 *     B1000X_HDX       1 = 1000Base-X half duplex capable0 = not 1000Base-X half duplex capable.
 *     B1000X_FDX       1 = 1000Base-X full duplex capable.0 = not 1000Base-X full duplex capable.
 */
#define BCM53262_A0_X1K_EXT_MIISTSr 0x0000b81e

#define BCM53262_A0_X1K_EXT_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program X1K_EXT_MIISTS.
 */
typedef union BCM53262_A0_X1K_EXT_MIISTSr_s {
	uint32_t v[1];
	uint32_t x1k_ext_miists[1];
	uint32_t _x1k_ext_miists;
} BCM53262_A0_X1K_EXT_MIISTSr_t;

#define BCM53262_A0_X1K_EXT_MIISTSr_CLR(r) (r).x1k_ext_miists[0] = 0
#define BCM53262_A0_X1K_EXT_MIISTSr_SET(r,d) (r).x1k_ext_miists[0] = d
#define BCM53262_A0_X1K_EXT_MIISTSr_GET(r) (r).x1k_ext_miists[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_EXT_MIISTSr_RESERVED_Rf_GET(r) (((r).x1k_ext_miists[0]) & 0xfff)
#define BCM53262_A0_X1K_EXT_MIISTSr_RESERVED_Rf_SET(r,f) (r).x1k_ext_miists[0]=(((r).x1k_ext_miists[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000T_HDXf_GET(r) ((((r).x1k_ext_miists[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000T_HDXf_SET(r,f) (r).x1k_ext_miists[0]=(((r).x1k_ext_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000T_FDXf_GET(r) ((((r).x1k_ext_miists[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000T_FDXf_SET(r,f) (r).x1k_ext_miists[0]=(((r).x1k_ext_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000X_HDXf_GET(r) ((((r).x1k_ext_miists[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000X_HDXf_SET(r,f) (r).x1k_ext_miists[0]=(((r).x1k_ext_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000X_FDXf_GET(r) ((((r).x1k_ext_miists[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_EXT_MIISTSr_B1000X_FDXf_SET(r,f) (r).x1k_ext_miists[0]=(((r).x1k_ext_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_EXT_MIISTS.
 */
#define BCM53262_A0_READ_X1K_EXT_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_EXT_MIISTSr,(r._x1k_ext_miists),2)
#define BCM53262_A0_WRITE_X1K_EXT_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_EXT_MIISTSr,&(r._x1k_ext_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_EXT_MIISTSr BCM53262_A0_X1K_EXT_MIISTSr
#define X1K_EXT_MIISTSr_SIZE BCM53262_A0_X1K_EXT_MIISTSr_SIZE
typedef BCM53262_A0_X1K_EXT_MIISTSr_t X1K_EXT_MIISTSr_t;
#define X1K_EXT_MIISTSr_CLR BCM53262_A0_X1K_EXT_MIISTSr_CLR
#define X1K_EXT_MIISTSr_SET BCM53262_A0_X1K_EXT_MIISTSr_SET
#define X1K_EXT_MIISTSr_GET BCM53262_A0_X1K_EXT_MIISTSr_GET
#define X1K_EXT_MIISTSr_RESERVED_Rf_GET BCM53262_A0_X1K_EXT_MIISTSr_RESERVED_Rf_GET
#define X1K_EXT_MIISTSr_RESERVED_Rf_SET BCM53262_A0_X1K_EXT_MIISTSr_RESERVED_Rf_SET
#define X1K_EXT_MIISTSr_B1000T_HDXf_GET BCM53262_A0_X1K_EXT_MIISTSr_B1000T_HDXf_GET
#define X1K_EXT_MIISTSr_B1000T_HDXf_SET BCM53262_A0_X1K_EXT_MIISTSr_B1000T_HDXf_SET
#define X1K_EXT_MIISTSr_B1000T_FDXf_GET BCM53262_A0_X1K_EXT_MIISTSr_B1000T_FDXf_GET
#define X1K_EXT_MIISTSr_B1000T_FDXf_SET BCM53262_A0_X1K_EXT_MIISTSr_B1000T_FDXf_SET
#define X1K_EXT_MIISTSr_B1000X_HDXf_GET BCM53262_A0_X1K_EXT_MIISTSr_B1000X_HDXf_GET
#define X1K_EXT_MIISTSr_B1000X_HDXf_SET BCM53262_A0_X1K_EXT_MIISTSr_B1000X_HDXf_SET
#define X1K_EXT_MIISTSr_B1000X_FDXf_GET BCM53262_A0_X1K_EXT_MIISTSr_B1000X_FDXf_GET
#define X1K_EXT_MIISTSr_B1000X_FDXf_SET BCM53262_A0_X1K_EXT_MIISTSr_B1000X_FDXf_SET
#define READ_X1K_EXT_MIISTSr BCM53262_A0_READ_X1K_EXT_MIISTSr
#define WRITE_X1K_EXT_MIISTSr BCM53262_A0_WRITE_X1K_EXT_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_EXT_MIISTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_FORCE_TXD1
 * BLOCKS:   GPIC0
 * DESC:     Force Transmit Data Register 1
 * SIZE:     16
 * FIELDS:
 *     TXDATA_1         Value in this register will be provided to serdes analog transmitter every other clock cycle when bit 10 is set.
 *     EN_DATA2SERDES_TXD 1 = provide alternating 10 bits from this register andregister 0*1eh to serdes analog transmitter0 = normal operation.
 *     RESERVED_R       write as 0, ignore on read
 */
#define BCM53262_A0_X1K_FORCE_TXD1r 0x0000b83a

#define BCM53262_A0_X1K_FORCE_TXD1r_SIZE 2

/*
 * This structure should be used to declare and program X1K_FORCE_TXD1.
 */
typedef union BCM53262_A0_X1K_FORCE_TXD1r_s {
	uint32_t v[1];
	uint32_t x1k_force_txd1[1];
	uint32_t _x1k_force_txd1;
} BCM53262_A0_X1K_FORCE_TXD1r_t;

#define BCM53262_A0_X1K_FORCE_TXD1r_CLR(r) (r).x1k_force_txd1[0] = 0
#define BCM53262_A0_X1K_FORCE_TXD1r_SET(r,d) (r).x1k_force_txd1[0] = d
#define BCM53262_A0_X1K_FORCE_TXD1r_GET(r) (r).x1k_force_txd1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_FORCE_TXD1r_TXDATA_1f_GET(r) (((r).x1k_force_txd1[0]) & 0x3ff)
#define BCM53262_A0_X1K_FORCE_TXD1r_TXDATA_1f_SET(r,f) (r).x1k_force_txd1[0]=(((r).x1k_force_txd1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53262_A0_X1K_FORCE_TXD1r_EN_DATA2SERDES_TXDf_GET(r) ((((r).x1k_force_txd1[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_FORCE_TXD1r_EN_DATA2SERDES_TXDf_SET(r,f) (r).x1k_force_txd1[0]=(((r).x1k_force_txd1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_FORCE_TXD1r_RESERVED_Rf_GET(r) ((((r).x1k_force_txd1[0]) >> 11) & 0x1f)
#define BCM53262_A0_X1K_FORCE_TXD1r_RESERVED_Rf_SET(r,f) (r).x1k_force_txd1[0]=(((r).x1k_force_txd1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access X1K_FORCE_TXD1.
 */
#define BCM53262_A0_READ_X1K_FORCE_TXD1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_FORCE_TXD1r,(r._x1k_force_txd1),2)
#define BCM53262_A0_WRITE_X1K_FORCE_TXD1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_FORCE_TXD1r,&(r._x1k_force_txd1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_FORCE_TXD1r BCM53262_A0_X1K_FORCE_TXD1r
#define X1K_FORCE_TXD1r_SIZE BCM53262_A0_X1K_FORCE_TXD1r_SIZE
typedef BCM53262_A0_X1K_FORCE_TXD1r_t X1K_FORCE_TXD1r_t;
#define X1K_FORCE_TXD1r_CLR BCM53262_A0_X1K_FORCE_TXD1r_CLR
#define X1K_FORCE_TXD1r_SET BCM53262_A0_X1K_FORCE_TXD1r_SET
#define X1K_FORCE_TXD1r_GET BCM53262_A0_X1K_FORCE_TXD1r_GET
#define X1K_FORCE_TXD1r_TXDATA_1f_GET BCM53262_A0_X1K_FORCE_TXD1r_TXDATA_1f_GET
#define X1K_FORCE_TXD1r_TXDATA_1f_SET BCM53262_A0_X1K_FORCE_TXD1r_TXDATA_1f_SET
#define X1K_FORCE_TXD1r_EN_DATA2SERDES_TXDf_GET BCM53262_A0_X1K_FORCE_TXD1r_EN_DATA2SERDES_TXDf_GET
#define X1K_FORCE_TXD1r_EN_DATA2SERDES_TXDf_SET BCM53262_A0_X1K_FORCE_TXD1r_EN_DATA2SERDES_TXDf_SET
#define X1K_FORCE_TXD1r_RESERVED_Rf_GET BCM53262_A0_X1K_FORCE_TXD1r_RESERVED_Rf_GET
#define X1K_FORCE_TXD1r_RESERVED_Rf_SET BCM53262_A0_X1K_FORCE_TXD1r_RESERVED_Rf_SET
#define READ_X1K_FORCE_TXD1r BCM53262_A0_READ_X1K_FORCE_TXD1r
#define WRITE_X1K_FORCE_TXD1r BCM53262_A0_WRITE_X1K_FORCE_TXD1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_FORCE_TXD1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_FORCE_TXD2
 * BLOCKS:   GPIC0
 * DESC:     Force Transmit Data Register 2
 * SIZE:     16
 * FIELDS:
 *     TXDATA_2         Value in this register will be provided to serdes analogtransmitter every other clock cycle whenregister 0*1dh bit 10 is set.
 *     SPARE_R          write as 0, ignore on read.
 *     RESERVED_R       write as 0, ignore on read.
 */
#define BCM53262_A0_X1K_FORCE_TXD2r 0x0000b83c

#define BCM53262_A0_X1K_FORCE_TXD2r_SIZE 2

/*
 * This structure should be used to declare and program X1K_FORCE_TXD2.
 */
typedef union BCM53262_A0_X1K_FORCE_TXD2r_s {
	uint32_t v[1];
	uint32_t x1k_force_txd2[1];
	uint32_t _x1k_force_txd2;
} BCM53262_A0_X1K_FORCE_TXD2r_t;

#define BCM53262_A0_X1K_FORCE_TXD2r_CLR(r) (r).x1k_force_txd2[0] = 0
#define BCM53262_A0_X1K_FORCE_TXD2r_SET(r,d) (r).x1k_force_txd2[0] = d
#define BCM53262_A0_X1K_FORCE_TXD2r_GET(r) (r).x1k_force_txd2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_FORCE_TXD2r_TXDATA_2f_GET(r) (((r).x1k_force_txd2[0]) & 0x3ff)
#define BCM53262_A0_X1K_FORCE_TXD2r_TXDATA_2f_SET(r,f) (r).x1k_force_txd2[0]=(((r).x1k_force_txd2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53262_A0_X1K_FORCE_TXD2r_SPARE_Rf_GET(r) ((((r).x1k_force_txd2[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_FORCE_TXD2r_SPARE_Rf_SET(r,f) (r).x1k_force_txd2[0]=(((r).x1k_force_txd2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_FORCE_TXD2r_RESERVED_Rf_GET(r) ((((r).x1k_force_txd2[0]) >> 11) & 0x1f)
#define BCM53262_A0_X1K_FORCE_TXD2r_RESERVED_Rf_SET(r,f) (r).x1k_force_txd2[0]=(((r).x1k_force_txd2[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access X1K_FORCE_TXD2.
 */
#define BCM53262_A0_READ_X1K_FORCE_TXD2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_FORCE_TXD2r,(r._x1k_force_txd2),2)
#define BCM53262_A0_WRITE_X1K_FORCE_TXD2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_FORCE_TXD2r,&(r._x1k_force_txd2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_FORCE_TXD2r BCM53262_A0_X1K_FORCE_TXD2r
#define X1K_FORCE_TXD2r_SIZE BCM53262_A0_X1K_FORCE_TXD2r_SIZE
typedef BCM53262_A0_X1K_FORCE_TXD2r_t X1K_FORCE_TXD2r_t;
#define X1K_FORCE_TXD2r_CLR BCM53262_A0_X1K_FORCE_TXD2r_CLR
#define X1K_FORCE_TXD2r_SET BCM53262_A0_X1K_FORCE_TXD2r_SET
#define X1K_FORCE_TXD2r_GET BCM53262_A0_X1K_FORCE_TXD2r_GET
#define X1K_FORCE_TXD2r_TXDATA_2f_GET BCM53262_A0_X1K_FORCE_TXD2r_TXDATA_2f_GET
#define X1K_FORCE_TXD2r_TXDATA_2f_SET BCM53262_A0_X1K_FORCE_TXD2r_TXDATA_2f_SET
#define X1K_FORCE_TXD2r_SPARE_Rf_GET BCM53262_A0_X1K_FORCE_TXD2r_SPARE_Rf_GET
#define X1K_FORCE_TXD2r_SPARE_Rf_SET BCM53262_A0_X1K_FORCE_TXD2r_SPARE_Rf_SET
#define X1K_FORCE_TXD2r_RESERVED_Rf_GET BCM53262_A0_X1K_FORCE_TXD2r_RESERVED_Rf_GET
#define X1K_FORCE_TXD2r_RESERVED_Rf_SET BCM53262_A0_X1K_FORCE_TXD2r_RESERVED_Rf_SET
#define READ_X1K_FORCE_TXD2r BCM53262_A0_READ_X1K_FORCE_TXD2r
#define WRITE_X1K_FORCE_TXD2r BCM53262_A0_WRITE_X1K_FORCE_TXD2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_FORCE_TXD2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_LPNXP
 * BLOCKS:   GPIC0
 * DESC:     1000-X Auto-Negotiation Link Partner Ability Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       ignore on read
 */
#define BCM53262_A0_X1K_LPNXPr 0x0000b810

#define BCM53262_A0_X1K_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program X1K_LPNXP.
 */
typedef union BCM53262_A0_X1K_LPNXPr_s {
	uint32_t v[1];
	uint32_t x1k_lpnxp[1];
	uint32_t _x1k_lpnxp;
} BCM53262_A0_X1K_LPNXPr_t;

#define BCM53262_A0_X1K_LPNXPr_CLR(r) (r).x1k_lpnxp[0] = 0
#define BCM53262_A0_X1K_LPNXPr_SET(r,d) (r).x1k_lpnxp[0] = d
#define BCM53262_A0_X1K_LPNXPr_GET(r) (r).x1k_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_LPNXPr_RESERVED_Rf_GET(r) (((r).x1k_lpnxp[0]) & 0xffff)
#define BCM53262_A0_X1K_LPNXPr_RESERVED_Rf_SET(r,f) (r).x1k_lpnxp[0]=(((r).x1k_lpnxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access X1K_LPNXP.
 */
#define BCM53262_A0_READ_X1K_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_LPNXPr,(r._x1k_lpnxp),2)
#define BCM53262_A0_WRITE_X1K_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_LPNXPr,&(r._x1k_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_LPNXPr BCM53262_A0_X1K_LPNXPr
#define X1K_LPNXPr_SIZE BCM53262_A0_X1K_LPNXPr_SIZE
typedef BCM53262_A0_X1K_LPNXPr_t X1K_LPNXPr_t;
#define X1K_LPNXPr_CLR BCM53262_A0_X1K_LPNXPr_CLR
#define X1K_LPNXPr_SET BCM53262_A0_X1K_LPNXPr_SET
#define X1K_LPNXPr_GET BCM53262_A0_X1K_LPNXPr_GET
#define X1K_LPNXPr_RESERVED_Rf_GET BCM53262_A0_X1K_LPNXPr_RESERVED_Rf_GET
#define X1K_LPNXPr_RESERVED_Rf_SET BCM53262_A0_X1K_LPNXPr_RESERVED_Rf_SET
#define READ_X1K_LPNXPr BCM53262_A0_READ_X1K_LPNXPr
#define WRITE_X1K_LPNXPr BCM53262_A0_WRITE_X1K_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_LPNXPr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_MIICTL
 * BLOCKS:   GPIC0
 * DESC:     1000-X MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Ignore when read.
 *     MANUAL_SPD_1     (SGMII only)manual speed[1:0]:1X = sgmii 100001 = sgmii 10000 = sgmii 10NOTE: register ignored for 1000-X operation
 *     COL_TEST         1 = collision test mode enabled0 = collision test mode disabled
 *     DUPLEX_MOD       (SGMII/1000-X)                1b'b1: Full Duplex.1b'b0: Half Duplex.
 *     RE_AN            1b'b1: Restart Auto-Negotiation process.1b'b0: Normal operation.
 *     PWR_DOWN         1 = low power mode0 = normal operation
 *     AN_EN            1b'b1: Auto-Negotiation Enable.1b'b0: Auto-Negotiation disable.
 *     MANUAL_SPD_0     (SGMII only)manual speed[1:0]:1X = sgmii 100001 = sgmii 10000 = sgmii 10NOTE: register ignored for 1000-X operation
 *     LOOPBACK         1b'b1: Loopback mode.1b'b0: Normal operation.
 *     RESET_R          1b'b1: PHY reset.1b'b0: Normal operation.
 */
#define BCM53262_A0_X1K_MIICTLr 0x0000b800

#define BCM53262_A0_X1K_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program X1K_MIICTL.
 */
typedef union BCM53262_A0_X1K_MIICTLr_s {
	uint32_t v[1];
	uint32_t x1k_miictl[1];
	uint32_t _x1k_miictl;
} BCM53262_A0_X1K_MIICTLr_t;

#define BCM53262_A0_X1K_MIICTLr_CLR(r) (r).x1k_miictl[0] = 0
#define BCM53262_A0_X1K_MIICTLr_SET(r,d) (r).x1k_miictl[0] = d
#define BCM53262_A0_X1K_MIICTLr_GET(r) (r).x1k_miictl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_MIICTLr_RESERVED_Rf_GET(r) (((r).x1k_miictl[0]) & 0x3f)
#define BCM53262_A0_X1K_MIICTLr_RESERVED_Rf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_1f_GET(r) ((((r).x1k_miictl[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_1f_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_MIICTLr_COL_TESTf_GET(r) ((((r).x1k_miictl[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_COL_TESTf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_MIICTLr_DUPLEX_MODf_GET(r) ((((r).x1k_miictl[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_DUPLEX_MODf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_MIICTLr_RE_ANf_GET(r) ((((r).x1k_miictl[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_RE_ANf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_MIICTLr_PWR_DOWNf_GET(r) ((((r).x1k_miictl[0]) >> 11) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_PWR_DOWNf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_X1K_MIICTLr_AN_ENf_GET(r) ((((r).x1k_miictl[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_AN_ENf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_0f_GET(r) ((((r).x1k_miictl[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_0f_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_MIICTLr_LOOPBACKf_GET(r) ((((r).x1k_miictl[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_LOOPBACKf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_MIICTLr_RESET_Rf_GET(r) ((((r).x1k_miictl[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_MIICTLr_RESET_Rf_SET(r,f) (r).x1k_miictl[0]=(((r).x1k_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_MIICTL.
 */
#define BCM53262_A0_READ_X1K_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_MIICTLr,(r._x1k_miictl),2)
#define BCM53262_A0_WRITE_X1K_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_MIICTLr,&(r._x1k_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_MIICTLr BCM53262_A0_X1K_MIICTLr
#define X1K_MIICTLr_SIZE BCM53262_A0_X1K_MIICTLr_SIZE
typedef BCM53262_A0_X1K_MIICTLr_t X1K_MIICTLr_t;
#define X1K_MIICTLr_CLR BCM53262_A0_X1K_MIICTLr_CLR
#define X1K_MIICTLr_SET BCM53262_A0_X1K_MIICTLr_SET
#define X1K_MIICTLr_GET BCM53262_A0_X1K_MIICTLr_GET
#define X1K_MIICTLr_RESERVED_Rf_GET BCM53262_A0_X1K_MIICTLr_RESERVED_Rf_GET
#define X1K_MIICTLr_RESERVED_Rf_SET BCM53262_A0_X1K_MIICTLr_RESERVED_Rf_SET
#define X1K_MIICTLr_MANUAL_SPD_1f_GET BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_1f_GET
#define X1K_MIICTLr_MANUAL_SPD_1f_SET BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_1f_SET
#define X1K_MIICTLr_COL_TESTf_GET BCM53262_A0_X1K_MIICTLr_COL_TESTf_GET
#define X1K_MIICTLr_COL_TESTf_SET BCM53262_A0_X1K_MIICTLr_COL_TESTf_SET
#define X1K_MIICTLr_DUPLEX_MODf_GET BCM53262_A0_X1K_MIICTLr_DUPLEX_MODf_GET
#define X1K_MIICTLr_DUPLEX_MODf_SET BCM53262_A0_X1K_MIICTLr_DUPLEX_MODf_SET
#define X1K_MIICTLr_RE_ANf_GET BCM53262_A0_X1K_MIICTLr_RE_ANf_GET
#define X1K_MIICTLr_RE_ANf_SET BCM53262_A0_X1K_MIICTLr_RE_ANf_SET
#define X1K_MIICTLr_PWR_DOWNf_GET BCM53262_A0_X1K_MIICTLr_PWR_DOWNf_GET
#define X1K_MIICTLr_PWR_DOWNf_SET BCM53262_A0_X1K_MIICTLr_PWR_DOWNf_SET
#define X1K_MIICTLr_AN_ENf_GET BCM53262_A0_X1K_MIICTLr_AN_ENf_GET
#define X1K_MIICTLr_AN_ENf_SET BCM53262_A0_X1K_MIICTLr_AN_ENf_SET
#define X1K_MIICTLr_MANUAL_SPD_0f_GET BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_0f_GET
#define X1K_MIICTLr_MANUAL_SPD_0f_SET BCM53262_A0_X1K_MIICTLr_MANUAL_SPD_0f_SET
#define X1K_MIICTLr_LOOPBACKf_GET BCM53262_A0_X1K_MIICTLr_LOOPBACKf_GET
#define X1K_MIICTLr_LOOPBACKf_SET BCM53262_A0_X1K_MIICTLr_LOOPBACKf_SET
#define X1K_MIICTLr_RESET_Rf_GET BCM53262_A0_X1K_MIICTLr_RESET_Rf_GET
#define X1K_MIICTLr_RESET_Rf_SET BCM53262_A0_X1K_MIICTLr_RESET_Rf_SET
#define READ_X1K_MIICTLr BCM53262_A0_READ_X1K_MIICTLr
#define WRITE_X1K_MIICTLr BCM53262_A0_WRITE_X1K_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_MIICTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_MIISTS
 * BLOCKS:   GPIC0
 * DESC:     1000-X MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = Extended register capable.
 *     JABBER_DET       1 = Jabber condition detected;0 = No jabber condition detected.Latched High.
 *     LINK_STA         1 = Link is up (Link Pass state);0 = Link is down (Link Fail state).Latched Low.
 *     AUTO_NEGO_CAP    1 = Auto-Negotiation capable;0 = Not auto-negotiation capable.
 *     REMOTE_FAULT_R   1 = Remote/far-end fault condition detected ; 0 = No remote/far-end fault condition detected.Latched High.
 *     AUTO_NEGO_COMP   1 = Auto-Negotiation process completed ; 0 = Auto-Negotiation process not completed.
 *     MF_PRE_SUP       1 = Preamble may be suppressed 0 = Preamble always required.
 *     RESERVED_R       Ignore when read.
 *     EXT_STATUS       1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HDX_CAP   1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FDX_CAP   1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_HDX_CAP     1 = 10BASE-T half duplex capable.0 = Not 10Base-T half duplex capable.
 *     B10T_FDX_CAP     1 = 10BASE-T full duplex capable.0 = Not 10Base-T full duplex capable.
 *     B100TX_CAP       1 = 100BASE-TX half duplex capable.0 = Not 100Base-X half duplex capable.
 *     B100TX_FDX_CAP   1 = 100BASE-TX full duplex capable.0 = Not 100Base-X full duplex capable.
 *     B100T4_CAP       1 = 100Base-T4 capable.                0 = Not 100BASE-T4 capable.
 */
#define BCM53262_A0_X1K_MIISTSr 0x0000b802

#define BCM53262_A0_X1K_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program X1K_MIISTS.
 */
typedef union BCM53262_A0_X1K_MIISTSr_s {
	uint32_t v[1];
	uint32_t x1k_miists[1];
	uint32_t _x1k_miists;
} BCM53262_A0_X1K_MIISTSr_t;

#define BCM53262_A0_X1K_MIISTSr_CLR(r) (r).x1k_miists[0] = 0
#define BCM53262_A0_X1K_MIISTSr_SET(r,d) (r).x1k_miists[0] = d
#define BCM53262_A0_X1K_MIISTSr_GET(r) (r).x1k_miists[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_MIISTSr_EXT_CAPf_GET(r) (((r).x1k_miists[0]) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_EXT_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_MIISTSr_JABBER_DETf_GET(r) ((((r).x1k_miists[0]) >> 1) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_JABBER_DETf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_X1K_MIISTSr_LINK_STAf_GET(r) ((((r).x1k_miists[0]) >> 2) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_LINK_STAf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).x1k_miists[0]) >> 3) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_X1K_MIISTSr_REMOTE_FAULT_Rf_GET(r) ((((r).x1k_miists[0]) >> 4) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_REMOTE_FAULT_Rf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).x1k_miists[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).x1k_miists[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_MIISTSr_RESERVED_Rf_GET(r) ((((r).x1k_miists[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_RESERVED_Rf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_MIISTSr_EXT_STATUSf_GET(r) ((((r).x1k_miists[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_EXT_STATUSf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_MIISTSr_B100T2_HDX_CAPf_GET(r) ((((r).x1k_miists[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_B100T2_HDX_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_MIISTSr_B100T2_FDX_CAPf_GET(r) ((((r).x1k_miists[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_B100T2_FDX_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_MIISTSr_B10T_HDX_CAPf_GET(r) ((((r).x1k_miists[0]) >> 11) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_B10T_HDX_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_X1K_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).x1k_miists[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_MIISTSr_B100TX_CAPf_GET(r) ((((r).x1k_miists[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_B100TX_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).x1k_miists[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_MIISTSr_B100T4_CAPf_GET(r) ((((r).x1k_miists[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_MIISTSr_B100T4_CAPf_SET(r,f) (r).x1k_miists[0]=(((r).x1k_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_MIISTS.
 */
#define BCM53262_A0_READ_X1K_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_MIISTSr,(r._x1k_miists),2)
#define BCM53262_A0_WRITE_X1K_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_MIISTSr,&(r._x1k_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_MIISTSr BCM53262_A0_X1K_MIISTSr
#define X1K_MIISTSr_SIZE BCM53262_A0_X1K_MIISTSr_SIZE
typedef BCM53262_A0_X1K_MIISTSr_t X1K_MIISTSr_t;
#define X1K_MIISTSr_CLR BCM53262_A0_X1K_MIISTSr_CLR
#define X1K_MIISTSr_SET BCM53262_A0_X1K_MIISTSr_SET
#define X1K_MIISTSr_GET BCM53262_A0_X1K_MIISTSr_GET
#define X1K_MIISTSr_EXT_CAPf_GET BCM53262_A0_X1K_MIISTSr_EXT_CAPf_GET
#define X1K_MIISTSr_EXT_CAPf_SET BCM53262_A0_X1K_MIISTSr_EXT_CAPf_SET
#define X1K_MIISTSr_JABBER_DETf_GET BCM53262_A0_X1K_MIISTSr_JABBER_DETf_GET
#define X1K_MIISTSr_JABBER_DETf_SET BCM53262_A0_X1K_MIISTSr_JABBER_DETf_SET
#define X1K_MIISTSr_LINK_STAf_GET BCM53262_A0_X1K_MIISTSr_LINK_STAf_GET
#define X1K_MIISTSr_LINK_STAf_SET BCM53262_A0_X1K_MIISTSr_LINK_STAf_SET
#define X1K_MIISTSr_AUTO_NEGO_CAPf_GET BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_CAPf_GET
#define X1K_MIISTSr_AUTO_NEGO_CAPf_SET BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_CAPf_SET
#define X1K_MIISTSr_REMOTE_FAULT_Rf_GET BCM53262_A0_X1K_MIISTSr_REMOTE_FAULT_Rf_GET
#define X1K_MIISTSr_REMOTE_FAULT_Rf_SET BCM53262_A0_X1K_MIISTSr_REMOTE_FAULT_Rf_SET
#define X1K_MIISTSr_AUTO_NEGO_COMPf_GET BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_COMPf_GET
#define X1K_MIISTSr_AUTO_NEGO_COMPf_SET BCM53262_A0_X1K_MIISTSr_AUTO_NEGO_COMPf_SET
#define X1K_MIISTSr_MF_PRE_SUPf_GET BCM53262_A0_X1K_MIISTSr_MF_PRE_SUPf_GET
#define X1K_MIISTSr_MF_PRE_SUPf_SET BCM53262_A0_X1K_MIISTSr_MF_PRE_SUPf_SET
#define X1K_MIISTSr_RESERVED_Rf_GET BCM53262_A0_X1K_MIISTSr_RESERVED_Rf_GET
#define X1K_MIISTSr_RESERVED_Rf_SET BCM53262_A0_X1K_MIISTSr_RESERVED_Rf_SET
#define X1K_MIISTSr_EXT_STATUSf_GET BCM53262_A0_X1K_MIISTSr_EXT_STATUSf_GET
#define X1K_MIISTSr_EXT_STATUSf_SET BCM53262_A0_X1K_MIISTSr_EXT_STATUSf_SET
#define X1K_MIISTSr_B100T2_HDX_CAPf_GET BCM53262_A0_X1K_MIISTSr_B100T2_HDX_CAPf_GET
#define X1K_MIISTSr_B100T2_HDX_CAPf_SET BCM53262_A0_X1K_MIISTSr_B100T2_HDX_CAPf_SET
#define X1K_MIISTSr_B100T2_FDX_CAPf_GET BCM53262_A0_X1K_MIISTSr_B100T2_FDX_CAPf_GET
#define X1K_MIISTSr_B100T2_FDX_CAPf_SET BCM53262_A0_X1K_MIISTSr_B100T2_FDX_CAPf_SET
#define X1K_MIISTSr_B10T_HDX_CAPf_GET BCM53262_A0_X1K_MIISTSr_B10T_HDX_CAPf_GET
#define X1K_MIISTSr_B10T_HDX_CAPf_SET BCM53262_A0_X1K_MIISTSr_B10T_HDX_CAPf_SET
#define X1K_MIISTSr_B10T_FDX_CAPf_GET BCM53262_A0_X1K_MIISTSr_B10T_FDX_CAPf_GET
#define X1K_MIISTSr_B10T_FDX_CAPf_SET BCM53262_A0_X1K_MIISTSr_B10T_FDX_CAPf_SET
#define X1K_MIISTSr_B100TX_CAPf_GET BCM53262_A0_X1K_MIISTSr_B100TX_CAPf_GET
#define X1K_MIISTSr_B100TX_CAPf_SET BCM53262_A0_X1K_MIISTSr_B100TX_CAPf_SET
#define X1K_MIISTSr_B100TX_FDX_CAPf_GET BCM53262_A0_X1K_MIISTSr_B100TX_FDX_CAPf_GET
#define X1K_MIISTSr_B100TX_FDX_CAPf_SET BCM53262_A0_X1K_MIISTSr_B100TX_FDX_CAPf_SET
#define X1K_MIISTSr_B100T4_CAPf_GET BCM53262_A0_X1K_MIISTSr_B100T4_CAPf_GET
#define X1K_MIISTSr_B100T4_CAPf_SET BCM53262_A0_X1K_MIISTSr_B100T4_CAPf_SET
#define READ_X1K_MIISTSr BCM53262_A0_READ_X1K_MIISTSr
#define WRITE_X1K_MIISTSr BCM53262_A0_WRITE_X1K_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_MIISTSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_PATT_GEN_CTL
 * BLOCKS:   GPIC0
 * DESC:     Pattern Generator Control Register
 * SIZE:     16
 * FIELDS:
 *     SEL_PATT_DATE    1 = send idles or pattern generator data into transmit .fo (ignore MAC transmit data)0 = normal operation.
 *     RUN_PATT_GEN     1 = A rising edge on this bit while the pattern generator is in the idle state will start sending packets. If the single pass mode is set, then a single packet will be sent and the idle state will be entered. If the single pass mode is not set, then packets will be sent until this bit is cleared. At this point the currentpacket will .nish transmitting and then enter the idle state.NOTE: A valid link must be established prior to sending packets.0 = do not send packets.
 *     SING_BYPASS      1 = only send 1 packet and stop.0 = send packets while bit 1 of this register is set.
 *     PKT_SIZE         000000 = invalid000001 = 256 bytes000010 = 512 bytes000011 = 768 bytes000100 = 1024 bytes...111111 = 16,128 bytes.
 *     IGP_SEL          000 = invalid001 = ipg of 6 bytes010 = ipg of 10 bytes011 = ipg of 14 bytes100 = ipg of 18 bytes101 = ipg of 22 bytes110 = ipg of 26 bytes111 = ipg of 30 bytes.
 *     EN_CRC_CHK       1 = enable crc checker to detect crc errors on packets of any size (1 byte or more)0 = normal operation (crc checker only detects crc errors on packets of at least 72 bytes).
 *     SKIP_CRC         1 = do not append 32 bit crc to end of packet0 = normal operation.
 *     TX_ERR           1 = set txer=1 during crc portion of packet0 = normal operation.
 *     SPARE_R          write as 0, ignore on read.
 */
#define BCM53262_A0_X1K_PATT_GEN_CTLr 0x0000b834

#define BCM53262_A0_X1K_PATT_GEN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program X1K_PATT_GEN_CTL.
 */
typedef union BCM53262_A0_X1K_PATT_GEN_CTLr_s {
	uint32_t v[1];
	uint32_t x1k_patt_gen_ctl[1];
	uint32_t _x1k_patt_gen_ctl;
} BCM53262_A0_X1K_PATT_GEN_CTLr_t;

#define BCM53262_A0_X1K_PATT_GEN_CTLr_CLR(r) (r).x1k_patt_gen_ctl[0] = 0
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SET(r,d) (r).x1k_patt_gen_ctl[0] = d
#define BCM53262_A0_X1K_PATT_GEN_CTLr_GET(r) (r).x1k_patt_gen_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SEL_PATT_DATEf_GET(r) (((r).x1k_patt_gen_ctl[0]) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SEL_PATT_DATEf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_RUN_PATT_GENf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 1) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_RUN_PATT_GENf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SING_BYPASSf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 2) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SING_BYPASSf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_PKT_SIZEf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 3) & 0x3f)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_PKT_SIZEf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_IGP_SELf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 9) & 0x7)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_IGP_SELf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_EN_CRC_CHKf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_EN_CRC_CHKf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SKIP_CRCf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SKIP_CRCf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_TX_ERRf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_TX_ERRf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SPARE_Rf_GET(r) ((((r).x1k_patt_gen_ctl[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_CTLr_SPARE_Rf_SET(r,f) (r).x1k_patt_gen_ctl[0]=(((r).x1k_patt_gen_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_PATT_GEN_CTL.
 */
#define BCM53262_A0_READ_X1K_PATT_GEN_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_PATT_GEN_CTLr,(r._x1k_patt_gen_ctl),2)
#define BCM53262_A0_WRITE_X1K_PATT_GEN_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_PATT_GEN_CTLr,&(r._x1k_patt_gen_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_PATT_GEN_CTLr BCM53262_A0_X1K_PATT_GEN_CTLr
#define X1K_PATT_GEN_CTLr_SIZE BCM53262_A0_X1K_PATT_GEN_CTLr_SIZE
typedef BCM53262_A0_X1K_PATT_GEN_CTLr_t X1K_PATT_GEN_CTLr_t;
#define X1K_PATT_GEN_CTLr_CLR BCM53262_A0_X1K_PATT_GEN_CTLr_CLR
#define X1K_PATT_GEN_CTLr_SET BCM53262_A0_X1K_PATT_GEN_CTLr_SET
#define X1K_PATT_GEN_CTLr_GET BCM53262_A0_X1K_PATT_GEN_CTLr_GET
#define X1K_PATT_GEN_CTLr_SEL_PATT_DATEf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_SEL_PATT_DATEf_GET
#define X1K_PATT_GEN_CTLr_SEL_PATT_DATEf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_SEL_PATT_DATEf_SET
#define X1K_PATT_GEN_CTLr_RUN_PATT_GENf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_RUN_PATT_GENf_GET
#define X1K_PATT_GEN_CTLr_RUN_PATT_GENf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_RUN_PATT_GENf_SET
#define X1K_PATT_GEN_CTLr_SING_BYPASSf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_SING_BYPASSf_GET
#define X1K_PATT_GEN_CTLr_SING_BYPASSf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_SING_BYPASSf_SET
#define X1K_PATT_GEN_CTLr_PKT_SIZEf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_PKT_SIZEf_GET
#define X1K_PATT_GEN_CTLr_PKT_SIZEf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_PKT_SIZEf_SET
#define X1K_PATT_GEN_CTLr_IGP_SELf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_IGP_SELf_GET
#define X1K_PATT_GEN_CTLr_IGP_SELf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_IGP_SELf_SET
#define X1K_PATT_GEN_CTLr_EN_CRC_CHKf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_EN_CRC_CHKf_GET
#define X1K_PATT_GEN_CTLr_EN_CRC_CHKf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_EN_CRC_CHKf_SET
#define X1K_PATT_GEN_CTLr_SKIP_CRCf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_SKIP_CRCf_GET
#define X1K_PATT_GEN_CTLr_SKIP_CRCf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_SKIP_CRCf_SET
#define X1K_PATT_GEN_CTLr_TX_ERRf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_TX_ERRf_GET
#define X1K_PATT_GEN_CTLr_TX_ERRf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_TX_ERRf_SET
#define X1K_PATT_GEN_CTLr_SPARE_Rf_GET BCM53262_A0_X1K_PATT_GEN_CTLr_SPARE_Rf_GET
#define X1K_PATT_GEN_CTLr_SPARE_Rf_SET BCM53262_A0_X1K_PATT_GEN_CTLr_SPARE_Rf_SET
#define READ_X1K_PATT_GEN_CTLr BCM53262_A0_READ_X1K_PATT_GEN_CTLr
#define WRITE_X1K_PATT_GEN_CTLr BCM53262_A0_WRITE_X1K_PATT_GEN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_PATT_GEN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_PATT_GEN_STS
 * BLOCKS:   GPIC0
 * DESC:     Pattern Generator Status Register
 * SIZE:     16
 * FIELDS:
 *     PATT_GEN_FSM     000 = idle001 = transmit preamble011 = transmit sfd010 = transmit data110 = transmit crc100 = ipg101 = ipg 2 (allows fsm to be grey-coded).
 *     PATT_GEN_ACT     1 = pattern generator is still sending packets.0 = pattern generator is idle.
 *     RESERVED_R       Reserved
 */
#define BCM53262_A0_X1K_PATT_GEN_STSr 0x0000b836

#define BCM53262_A0_X1K_PATT_GEN_STSr_SIZE 2

/*
 * This structure should be used to declare and program X1K_PATT_GEN_STS.
 */
typedef union BCM53262_A0_X1K_PATT_GEN_STSr_s {
	uint32_t v[1];
	uint32_t x1k_patt_gen_sts[1];
	uint32_t _x1k_patt_gen_sts;
} BCM53262_A0_X1K_PATT_GEN_STSr_t;

#define BCM53262_A0_X1K_PATT_GEN_STSr_CLR(r) (r).x1k_patt_gen_sts[0] = 0
#define BCM53262_A0_X1K_PATT_GEN_STSr_SET(r,d) (r).x1k_patt_gen_sts[0] = d
#define BCM53262_A0_X1K_PATT_GEN_STSr_GET(r) (r).x1k_patt_gen_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_FSMf_GET(r) (((r).x1k_patt_gen_sts[0]) & 0x7)
#define BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_FSMf_SET(r,f) (r).x1k_patt_gen_sts[0]=(((r).x1k_patt_gen_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_ACTf_GET(r) ((((r).x1k_patt_gen_sts[0]) >> 3) & 0x1)
#define BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_ACTf_SET(r,f) (r).x1k_patt_gen_sts[0]=(((r).x1k_patt_gen_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_X1K_PATT_GEN_STSr_RESERVED_Rf_GET(r) ((((r).x1k_patt_gen_sts[0]) >> 4) & 0xfff)
#define BCM53262_A0_X1K_PATT_GEN_STSr_RESERVED_Rf_SET(r,f) (r).x1k_patt_gen_sts[0]=(((r).x1k_patt_gen_sts[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access X1K_PATT_GEN_STS.
 */
#define BCM53262_A0_READ_X1K_PATT_GEN_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_PATT_GEN_STSr,(r._x1k_patt_gen_sts),2)
#define BCM53262_A0_WRITE_X1K_PATT_GEN_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_PATT_GEN_STSr,&(r._x1k_patt_gen_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_PATT_GEN_STSr BCM53262_A0_X1K_PATT_GEN_STSr
#define X1K_PATT_GEN_STSr_SIZE BCM53262_A0_X1K_PATT_GEN_STSr_SIZE
typedef BCM53262_A0_X1K_PATT_GEN_STSr_t X1K_PATT_GEN_STSr_t;
#define X1K_PATT_GEN_STSr_CLR BCM53262_A0_X1K_PATT_GEN_STSr_CLR
#define X1K_PATT_GEN_STSr_SET BCM53262_A0_X1K_PATT_GEN_STSr_SET
#define X1K_PATT_GEN_STSr_GET BCM53262_A0_X1K_PATT_GEN_STSr_GET
#define X1K_PATT_GEN_STSr_PATT_GEN_FSMf_GET BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_FSMf_GET
#define X1K_PATT_GEN_STSr_PATT_GEN_FSMf_SET BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_FSMf_SET
#define X1K_PATT_GEN_STSr_PATT_GEN_ACTf_GET BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_ACTf_GET
#define X1K_PATT_GEN_STSr_PATT_GEN_ACTf_SET BCM53262_A0_X1K_PATT_GEN_STSr_PATT_GEN_ACTf_SET
#define X1K_PATT_GEN_STSr_RESERVED_Rf_GET BCM53262_A0_X1K_PATT_GEN_STSr_RESERVED_Rf_GET
#define X1K_PATT_GEN_STSr_RESERVED_Rf_SET BCM53262_A0_X1K_PATT_GEN_STSr_RESERVED_Rf_SET
#define READ_X1K_PATT_GEN_STSr BCM53262_A0_READ_X1K_PATT_GEN_STSr
#define WRITE_X1K_PATT_GEN_STSr BCM53262_A0_WRITE_X1K_PATT_GEN_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_PATT_GEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_PHYIDH
 * BLOCKS:   GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI_HI           PHYID HIGH.
 */
#define BCM53262_A0_X1K_PHYIDHr 0x0000b804

#define BCM53262_A0_X1K_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program X1K_PHYIDH.
 */
typedef union BCM53262_A0_X1K_PHYIDHr_s {
	uint32_t v[1];
	uint32_t x1k_phyidh[1];
	uint32_t _x1k_phyidh;
} BCM53262_A0_X1K_PHYIDHr_t;

#define BCM53262_A0_X1K_PHYIDHr_CLR(r) (r).x1k_phyidh[0] = 0
#define BCM53262_A0_X1K_PHYIDHr_SET(r,d) (r).x1k_phyidh[0] = d
#define BCM53262_A0_X1K_PHYIDHr_GET(r) (r).x1k_phyidh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_PHYIDHr_OUI_HIf_GET(r) (((r).x1k_phyidh[0]) & 0xffff)
#define BCM53262_A0_X1K_PHYIDHr_OUI_HIf_SET(r,f) (r).x1k_phyidh[0]=(((r).x1k_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access X1K_PHYIDH.
 */
#define BCM53262_A0_READ_X1K_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_PHYIDHr,(r._x1k_phyidh),2)
#define BCM53262_A0_WRITE_X1K_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_PHYIDHr,&(r._x1k_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_PHYIDHr BCM53262_A0_X1K_PHYIDHr
#define X1K_PHYIDHr_SIZE BCM53262_A0_X1K_PHYIDHr_SIZE
typedef BCM53262_A0_X1K_PHYIDHr_t X1K_PHYIDHr_t;
#define X1K_PHYIDHr_CLR BCM53262_A0_X1K_PHYIDHr_CLR
#define X1K_PHYIDHr_SET BCM53262_A0_X1K_PHYIDHr_SET
#define X1K_PHYIDHr_GET BCM53262_A0_X1K_PHYIDHr_GET
#define X1K_PHYIDHr_OUI_HIf_GET BCM53262_A0_X1K_PHYIDHr_OUI_HIf_GET
#define X1K_PHYIDHr_OUI_HIf_SET BCM53262_A0_X1K_PHYIDHr_OUI_HIf_SET
#define READ_X1K_PHYIDHr BCM53262_A0_READ_X1K_PHYIDHr
#define WRITE_X1K_PHYIDHr BCM53262_A0_WRITE_X1K_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_PHYIDHr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_PHYIDL
 * BLOCKS:   GPIC0
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         PHYID LOW.
 *     MODEL            PHYID LOW.
 *     OUI_LOW          PHYID LOW.
 */
#define BCM53262_A0_X1K_PHYIDLr 0x0000b806

#define BCM53262_A0_X1K_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program X1K_PHYIDL.
 */
typedef union BCM53262_A0_X1K_PHYIDLr_s {
	uint32_t v[1];
	uint32_t x1k_phyidl[1];
	uint32_t _x1k_phyidl;
} BCM53262_A0_X1K_PHYIDLr_t;

#define BCM53262_A0_X1K_PHYIDLr_CLR(r) (r).x1k_phyidl[0] = 0
#define BCM53262_A0_X1K_PHYIDLr_SET(r,d) (r).x1k_phyidl[0] = d
#define BCM53262_A0_X1K_PHYIDLr_GET(r) (r).x1k_phyidl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_PHYIDLr_REVISIONf_GET(r) (((r).x1k_phyidl[0]) & 0xf)
#define BCM53262_A0_X1K_PHYIDLr_REVISIONf_SET(r,f) (r).x1k_phyidl[0]=(((r).x1k_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53262_A0_X1K_PHYIDLr_MODELf_GET(r) ((((r).x1k_phyidl[0]) >> 4) & 0x3f)
#define BCM53262_A0_X1K_PHYIDLr_MODELf_SET(r,f) (r).x1k_phyidl[0]=(((r).x1k_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53262_A0_X1K_PHYIDLr_OUI_LOWf_GET(r) ((((r).x1k_phyidl[0]) >> 10) & 0x3f)
#define BCM53262_A0_X1K_PHYIDLr_OUI_LOWf_SET(r,f) (r).x1k_phyidl[0]=(((r).x1k_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access X1K_PHYIDL.
 */
#define BCM53262_A0_READ_X1K_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_PHYIDLr,(r._x1k_phyidl),2)
#define BCM53262_A0_WRITE_X1K_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_PHYIDLr,&(r._x1k_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_PHYIDLr BCM53262_A0_X1K_PHYIDLr
#define X1K_PHYIDLr_SIZE BCM53262_A0_X1K_PHYIDLr_SIZE
typedef BCM53262_A0_X1K_PHYIDLr_t X1K_PHYIDLr_t;
#define X1K_PHYIDLr_CLR BCM53262_A0_X1K_PHYIDLr_CLR
#define X1K_PHYIDLr_SET BCM53262_A0_X1K_PHYIDLr_SET
#define X1K_PHYIDLr_GET BCM53262_A0_X1K_PHYIDLr_GET
#define X1K_PHYIDLr_REVISIONf_GET BCM53262_A0_X1K_PHYIDLr_REVISIONf_GET
#define X1K_PHYIDLr_REVISIONf_SET BCM53262_A0_X1K_PHYIDLr_REVISIONf_SET
#define X1K_PHYIDLr_MODELf_GET BCM53262_A0_X1K_PHYIDLr_MODELf_GET
#define X1K_PHYIDLr_MODELf_SET BCM53262_A0_X1K_PHYIDLr_MODELf_SET
#define X1K_PHYIDLr_OUI_LOWf_GET BCM53262_A0_X1K_PHYIDLr_OUI_LOWf_GET
#define X1K_PHYIDLr_OUI_LOWf_SET BCM53262_A0_X1K_PHYIDLr_OUI_LOWf_SET
#define READ_X1K_PHYIDLr BCM53262_A0_READ_X1K_PHYIDLr
#define WRITE_X1K_PHYIDLr BCM53262_A0_WRITE_X1K_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_PHYIDLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_PRBS_CTL
 * BLOCKS:   GPIC0
 * DESC:     PRBS Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_PRBS          1 = enable PRBS.0 = disable PRBS.
 *     INV_PRBS_POLYNOMIAL 1 = invert polynomial sequence0 = normal operation.
 *     PRBS_POLYNOMIAL  11 = x(n) = 1 + x(28) + x(31).10 = x(n) = 1 + x(18) + x(23).01 = x(n) = 1 + x(14) + x(15).00 = x(n) = 1 + x(6) + x(7).
 *     SPARE_R          write as 0, ignore on read.
 *     RESERVED_R       write as 0, ignore on read.
 */
#define BCM53262_A0_X1K_PRBS_CTLr 0x0000b830

#define BCM53262_A0_X1K_PRBS_CTLr_SIZE 2

/*
 * This structure should be used to declare and program X1K_PRBS_CTL.
 */
typedef union BCM53262_A0_X1K_PRBS_CTLr_s {
	uint32_t v[1];
	uint32_t x1k_prbs_ctl[1];
	uint32_t _x1k_prbs_ctl;
} BCM53262_A0_X1K_PRBS_CTLr_t;

#define BCM53262_A0_X1K_PRBS_CTLr_CLR(r) (r).x1k_prbs_ctl[0] = 0
#define BCM53262_A0_X1K_PRBS_CTLr_SET(r,d) (r).x1k_prbs_ctl[0] = d
#define BCM53262_A0_X1K_PRBS_CTLr_GET(r) (r).x1k_prbs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_PRBS_CTLr_EN_PRBSf_GET(r) (((r).x1k_prbs_ctl[0]) & 0xff)
#define BCM53262_A0_X1K_PRBS_CTLr_EN_PRBSf_SET(r,f) (r).x1k_prbs_ctl[0]=(((r).x1k_prbs_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_X1K_PRBS_CTLr_INV_PRBS_POLYNOMIALf_GET(r) (((r).x1k_prbs_ctl[0]) & 0xff)
#define BCM53262_A0_X1K_PRBS_CTLr_INV_PRBS_POLYNOMIALf_SET(r,f) (r).x1k_prbs_ctl[0]=(((r).x1k_prbs_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53262_A0_X1K_PRBS_CTLr_PRBS_POLYNOMIALf_GET(r) ((((r).x1k_prbs_ctl[0]) >> 2) & 0x3)
#define BCM53262_A0_X1K_PRBS_CTLr_PRBS_POLYNOMIALf_SET(r,f) (r).x1k_prbs_ctl[0]=(((r).x1k_prbs_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53262_A0_X1K_PRBS_CTLr_SPARE_Rf_GET(r) ((((r).x1k_prbs_ctl[0]) >> 4) & 0x3)
#define BCM53262_A0_X1K_PRBS_CTLr_SPARE_Rf_SET(r,f) (r).x1k_prbs_ctl[0]=(((r).x1k_prbs_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53262_A0_X1K_PRBS_CTLr_RESERVED_Rf_GET(r) ((((r).x1k_prbs_ctl[0]) >> 8) & 0xff)
#define BCM53262_A0_X1K_PRBS_CTLr_RESERVED_Rf_SET(r,f) (r).x1k_prbs_ctl[0]=(((r).x1k_prbs_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access X1K_PRBS_CTL.
 */
#define BCM53262_A0_READ_X1K_PRBS_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_PRBS_CTLr,(r._x1k_prbs_ctl),2)
#define BCM53262_A0_WRITE_X1K_PRBS_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_PRBS_CTLr,&(r._x1k_prbs_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_PRBS_CTLr BCM53262_A0_X1K_PRBS_CTLr
#define X1K_PRBS_CTLr_SIZE BCM53262_A0_X1K_PRBS_CTLr_SIZE
typedef BCM53262_A0_X1K_PRBS_CTLr_t X1K_PRBS_CTLr_t;
#define X1K_PRBS_CTLr_CLR BCM53262_A0_X1K_PRBS_CTLr_CLR
#define X1K_PRBS_CTLr_SET BCM53262_A0_X1K_PRBS_CTLr_SET
#define X1K_PRBS_CTLr_GET BCM53262_A0_X1K_PRBS_CTLr_GET
#define X1K_PRBS_CTLr_EN_PRBSf_GET BCM53262_A0_X1K_PRBS_CTLr_EN_PRBSf_GET
#define X1K_PRBS_CTLr_EN_PRBSf_SET BCM53262_A0_X1K_PRBS_CTLr_EN_PRBSf_SET
#define X1K_PRBS_CTLr_INV_PRBS_POLYNOMIALf_GET BCM53262_A0_X1K_PRBS_CTLr_INV_PRBS_POLYNOMIALf_GET
#define X1K_PRBS_CTLr_INV_PRBS_POLYNOMIALf_SET BCM53262_A0_X1K_PRBS_CTLr_INV_PRBS_POLYNOMIALf_SET
#define X1K_PRBS_CTLr_PRBS_POLYNOMIALf_GET BCM53262_A0_X1K_PRBS_CTLr_PRBS_POLYNOMIALf_GET
#define X1K_PRBS_CTLr_PRBS_POLYNOMIALf_SET BCM53262_A0_X1K_PRBS_CTLr_PRBS_POLYNOMIALf_SET
#define X1K_PRBS_CTLr_SPARE_Rf_GET BCM53262_A0_X1K_PRBS_CTLr_SPARE_Rf_GET
#define X1K_PRBS_CTLr_SPARE_Rf_SET BCM53262_A0_X1K_PRBS_CTLr_SPARE_Rf_SET
#define X1K_PRBS_CTLr_RESERVED_Rf_GET BCM53262_A0_X1K_PRBS_CTLr_RESERVED_Rf_GET
#define X1K_PRBS_CTLr_RESERVED_Rf_SET BCM53262_A0_X1K_PRBS_CTLr_RESERVED_Rf_SET
#define READ_X1K_PRBS_CTLr BCM53262_A0_READ_X1K_PRBS_CTLr
#define WRITE_X1K_PRBS_CTLr BCM53262_A0_WRITE_X1K_PRBS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_PRBS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_PRBS_STS
 * BLOCKS:   GPIC0
 * DESC:     PRBS Status Register
 * SIZE:     16
 * FIELDS:
 *     PRBS_ERR         Number of PRBS errors detected while locked.Freezes at 7ffh.NOTE: counter is not synchronized to read statusclock. The counter might increment while reading,causing inaccurate results. The PRBS should bedisabled before reading the 11 bit error counter.
 *     AN_ACK_DET       1 = PRBS monitor is locked.0 = PRBS monitor is not locked.
 *     PRBS_LOST_LCK    1 = PRBS has lost lock since last read0 = PRBS has not lost lock since last read.
 *     PRBS_ERR_STS     Grey coded FSM:100 = 1024 or more errors101 = 512-1023 errors111 = 256-511 errors110 = 128-255 errors010 = 64-127 errors011 = 32-63 errors001 = 1-31 errors000 = no errors.
 */
#define BCM53262_A0_X1K_PRBS_STSr 0x0000b832

#define BCM53262_A0_X1K_PRBS_STSr_SIZE 2

/*
 * This structure should be used to declare and program X1K_PRBS_STS.
 */
typedef union BCM53262_A0_X1K_PRBS_STSr_s {
	uint32_t v[1];
	uint32_t x1k_prbs_sts[1];
	uint32_t _x1k_prbs_sts;
} BCM53262_A0_X1K_PRBS_STSr_t;

#define BCM53262_A0_X1K_PRBS_STSr_CLR(r) (r).x1k_prbs_sts[0] = 0
#define BCM53262_A0_X1K_PRBS_STSr_SET(r,d) (r).x1k_prbs_sts[0] = d
#define BCM53262_A0_X1K_PRBS_STSr_GET(r) (r).x1k_prbs_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_PRBS_STSr_PRBS_ERRf_GET(r) (((r).x1k_prbs_sts[0]) & 0x7ff)
#define BCM53262_A0_X1K_PRBS_STSr_PRBS_ERRf_SET(r,f) (r).x1k_prbs_sts[0]=(((r).x1k_prbs_sts[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53262_A0_X1K_PRBS_STSr_AN_ACK_DETf_GET(r) ((((r).x1k_prbs_sts[0]) >> 11) & 0x1)
#define BCM53262_A0_X1K_PRBS_STSr_AN_ACK_DETf_SET(r,f) (r).x1k_prbs_sts[0]=(((r).x1k_prbs_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_X1K_PRBS_STSr_PRBS_LOST_LCKf_GET(r) ((((r).x1k_prbs_sts[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_PRBS_STSr_PRBS_LOST_LCKf_SET(r,f) (r).x1k_prbs_sts[0]=(((r).x1k_prbs_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_PRBS_STSr_PRBS_ERR_STSf_GET(r) ((((r).x1k_prbs_sts[0]) >> 13) & 0x7)
#define BCM53262_A0_X1K_PRBS_STSr_PRBS_ERR_STSf_SET(r,f) (r).x1k_prbs_sts[0]=(((r).x1k_prbs_sts[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access X1K_PRBS_STS.
 */
#define BCM53262_A0_READ_X1K_PRBS_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_PRBS_STSr,(r._x1k_prbs_sts),2)
#define BCM53262_A0_WRITE_X1K_PRBS_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_PRBS_STSr,&(r._x1k_prbs_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_PRBS_STSr BCM53262_A0_X1K_PRBS_STSr
#define X1K_PRBS_STSr_SIZE BCM53262_A0_X1K_PRBS_STSr_SIZE
typedef BCM53262_A0_X1K_PRBS_STSr_t X1K_PRBS_STSr_t;
#define X1K_PRBS_STSr_CLR BCM53262_A0_X1K_PRBS_STSr_CLR
#define X1K_PRBS_STSr_SET BCM53262_A0_X1K_PRBS_STSr_SET
#define X1K_PRBS_STSr_GET BCM53262_A0_X1K_PRBS_STSr_GET
#define X1K_PRBS_STSr_PRBS_ERRf_GET BCM53262_A0_X1K_PRBS_STSr_PRBS_ERRf_GET
#define X1K_PRBS_STSr_PRBS_ERRf_SET BCM53262_A0_X1K_PRBS_STSr_PRBS_ERRf_SET
#define X1K_PRBS_STSr_AN_ACK_DETf_GET BCM53262_A0_X1K_PRBS_STSr_AN_ACK_DETf_GET
#define X1K_PRBS_STSr_AN_ACK_DETf_SET BCM53262_A0_X1K_PRBS_STSr_AN_ACK_DETf_SET
#define X1K_PRBS_STSr_PRBS_LOST_LCKf_GET BCM53262_A0_X1K_PRBS_STSr_PRBS_LOST_LCKf_GET
#define X1K_PRBS_STSr_PRBS_LOST_LCKf_SET BCM53262_A0_X1K_PRBS_STSr_PRBS_LOST_LCKf_SET
#define X1K_PRBS_STSr_PRBS_ERR_STSf_GET BCM53262_A0_X1K_PRBS_STSr_PRBS_ERR_STSf_GET
#define X1K_PRBS_STSr_PRBS_ERR_STSf_SET BCM53262_A0_X1K_PRBS_STSr_PRBS_ERR_STSf_SET
#define READ_X1K_PRBS_STSr BCM53262_A0_READ_X1K_PRBS_STSr
#define WRITE_X1K_PRBS_STSr BCM53262_A0_WRITE_X1K_PRBS_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_PRBS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_STS1
 * BLOCKS:   GPIC0
 * DESC:     1000-X Status Register 1
 * SIZE:     16
 * FIELDS:
 *     SGMII_MODE       1 = sgmii mode0 = .ber mode (1000-X).
 *     LNK_STS          1 = link is up0 = link is downNOTE: When the ten bit interface is selected with .ber mode (1000-X), then link will always be down.
 *     DUPLEX_STS       1 = full-duplex0 = half-duplexNOTE: When the ten bit interface is selected with .ber mode (1000-X), then half-duplex will always be reported.
 *     SPEED_STS        1X = gigabit01 = 100 mbps00 = 10 mbps.
 *     EN_PAUSE_TX      1 = enable pause transmit.0 = disable pause transmit.
 *     EN_PAUSE_RX      1 = enable pause receive.0 = disable pause receive.
 *     LNK_STS_CH       1 = link status has changed since last read0 = link status has not changed since last read.
 *     EARLYEND_EXT_DET 1 = early end extension since last read(early_end_ext in pcs receive fsm)0 = no early end extension since last read.
 *     CARR_EXT_ERR_DET 1 = carrier extend error since last read(extend_err in pcs receive fsm)0 = no carrier extend error since last read
 *     RX_ERR_DET       1 = transmit error code detected since last read(rx_data_error state in pcs receive fsm)0 = no transmit error code detected since last read.
 *     TX_ERR_DET       1 = transmit error code detected since last read (rx_data_error state in pcs receive fsm)0 = no transmit error code detected since last read.
 *     CRC_ERR_DET      LH1 = crc error detected since last read.0 = no crc error detected since last read or detection is disabled via register 0*10h bit 7.
 *     FASLSE_CARR_DET  1 = false carrier detected since last read0 = no false carrier detected since last read
 *     RXFIFO_ERR_DET   1 = receive .fo error detected since last read.0 = no receive .fo error detected since last read.
 *     TXFIFO_ERR_DET   1 = transmit .fo error detected since last read0 = no transmit .fo error detected since last read.
 */
#define BCM53262_A0_X1K_STS1r 0x0000b828

#define BCM53262_A0_X1K_STS1r_SIZE 2

/*
 * This structure should be used to declare and program X1K_STS1.
 */
typedef union BCM53262_A0_X1K_STS1r_s {
	uint32_t v[1];
	uint32_t x1k_sts1[1];
	uint32_t _x1k_sts1;
} BCM53262_A0_X1K_STS1r_t;

#define BCM53262_A0_X1K_STS1r_CLR(r) (r).x1k_sts1[0] = 0
#define BCM53262_A0_X1K_STS1r_SET(r,d) (r).x1k_sts1[0] = d
#define BCM53262_A0_X1K_STS1r_GET(r) (r).x1k_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_STS1r_SGMII_MODEf_GET(r) (((r).x1k_sts1[0]) & 0x1)
#define BCM53262_A0_X1K_STS1r_SGMII_MODEf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_STS1r_LNK_STSf_GET(r) ((((r).x1k_sts1[0]) >> 1) & 0x1)
#define BCM53262_A0_X1K_STS1r_LNK_STSf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_X1K_STS1r_DUPLEX_STSf_GET(r) ((((r).x1k_sts1[0]) >> 2) & 0x1)
#define BCM53262_A0_X1K_STS1r_DUPLEX_STSf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_X1K_STS1r_SPEED_STSf_GET(r) ((((r).x1k_sts1[0]) >> 3) & 0x3)
#define BCM53262_A0_X1K_STS1r_SPEED_STSf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53262_A0_X1K_STS1r_EN_PAUSE_TXf_GET(r) ((((r).x1k_sts1[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_STS1r_EN_PAUSE_TXf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_STS1r_EN_PAUSE_RXf_GET(r) ((((r).x1k_sts1[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_STS1r_EN_PAUSE_RXf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_STS1r_LNK_STS_CHf_GET(r) ((((r).x1k_sts1[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_STS1r_LNK_STS_CHf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_STS1r_EARLYEND_EXT_DETf_GET(r) ((((r).x1k_sts1[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_STS1r_EARLYEND_EXT_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_STS1r_CARR_EXT_ERR_DETf_GET(r) ((((r).x1k_sts1[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_STS1r_CARR_EXT_ERR_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_STS1r_RX_ERR_DETf_GET(r) ((((r).x1k_sts1[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_STS1r_RX_ERR_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_STS1r_TX_ERR_DETf_GET(r) ((((r).x1k_sts1[0]) >> 11) & 0x1)
#define BCM53262_A0_X1K_STS1r_TX_ERR_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_X1K_STS1r_CRC_ERR_DETf_GET(r) ((((r).x1k_sts1[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_STS1r_CRC_ERR_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_STS1r_FASLSE_CARR_DETf_GET(r) ((((r).x1k_sts1[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_STS1r_FASLSE_CARR_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_STS1r_RXFIFO_ERR_DETf_GET(r) ((((r).x1k_sts1[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_STS1r_RXFIFO_ERR_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_STS1r_TXFIFO_ERR_DETf_GET(r) ((((r).x1k_sts1[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_STS1r_TXFIFO_ERR_DETf_SET(r,f) (r).x1k_sts1[0]=(((r).x1k_sts1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_STS1.
 */
#define BCM53262_A0_READ_X1K_STS1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_STS1r,(r._x1k_sts1),2)
#define BCM53262_A0_WRITE_X1K_STS1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_STS1r,&(r._x1k_sts1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_STS1r BCM53262_A0_X1K_STS1r
#define X1K_STS1r_SIZE BCM53262_A0_X1K_STS1r_SIZE
typedef BCM53262_A0_X1K_STS1r_t X1K_STS1r_t;
#define X1K_STS1r_CLR BCM53262_A0_X1K_STS1r_CLR
#define X1K_STS1r_SET BCM53262_A0_X1K_STS1r_SET
#define X1K_STS1r_GET BCM53262_A0_X1K_STS1r_GET
#define X1K_STS1r_SGMII_MODEf_GET BCM53262_A0_X1K_STS1r_SGMII_MODEf_GET
#define X1K_STS1r_SGMII_MODEf_SET BCM53262_A0_X1K_STS1r_SGMII_MODEf_SET
#define X1K_STS1r_LNK_STSf_GET BCM53262_A0_X1K_STS1r_LNK_STSf_GET
#define X1K_STS1r_LNK_STSf_SET BCM53262_A0_X1K_STS1r_LNK_STSf_SET
#define X1K_STS1r_DUPLEX_STSf_GET BCM53262_A0_X1K_STS1r_DUPLEX_STSf_GET
#define X1K_STS1r_DUPLEX_STSf_SET BCM53262_A0_X1K_STS1r_DUPLEX_STSf_SET
#define X1K_STS1r_SPEED_STSf_GET BCM53262_A0_X1K_STS1r_SPEED_STSf_GET
#define X1K_STS1r_SPEED_STSf_SET BCM53262_A0_X1K_STS1r_SPEED_STSf_SET
#define X1K_STS1r_EN_PAUSE_TXf_GET BCM53262_A0_X1K_STS1r_EN_PAUSE_TXf_GET
#define X1K_STS1r_EN_PAUSE_TXf_SET BCM53262_A0_X1K_STS1r_EN_PAUSE_TXf_SET
#define X1K_STS1r_EN_PAUSE_RXf_GET BCM53262_A0_X1K_STS1r_EN_PAUSE_RXf_GET
#define X1K_STS1r_EN_PAUSE_RXf_SET BCM53262_A0_X1K_STS1r_EN_PAUSE_RXf_SET
#define X1K_STS1r_LNK_STS_CHf_GET BCM53262_A0_X1K_STS1r_LNK_STS_CHf_GET
#define X1K_STS1r_LNK_STS_CHf_SET BCM53262_A0_X1K_STS1r_LNK_STS_CHf_SET
#define X1K_STS1r_EARLYEND_EXT_DETf_GET BCM53262_A0_X1K_STS1r_EARLYEND_EXT_DETf_GET
#define X1K_STS1r_EARLYEND_EXT_DETf_SET BCM53262_A0_X1K_STS1r_EARLYEND_EXT_DETf_SET
#define X1K_STS1r_CARR_EXT_ERR_DETf_GET BCM53262_A0_X1K_STS1r_CARR_EXT_ERR_DETf_GET
#define X1K_STS1r_CARR_EXT_ERR_DETf_SET BCM53262_A0_X1K_STS1r_CARR_EXT_ERR_DETf_SET
#define X1K_STS1r_RX_ERR_DETf_GET BCM53262_A0_X1K_STS1r_RX_ERR_DETf_GET
#define X1K_STS1r_RX_ERR_DETf_SET BCM53262_A0_X1K_STS1r_RX_ERR_DETf_SET
#define X1K_STS1r_TX_ERR_DETf_GET BCM53262_A0_X1K_STS1r_TX_ERR_DETf_GET
#define X1K_STS1r_TX_ERR_DETf_SET BCM53262_A0_X1K_STS1r_TX_ERR_DETf_SET
#define X1K_STS1r_CRC_ERR_DETf_GET BCM53262_A0_X1K_STS1r_CRC_ERR_DETf_GET
#define X1K_STS1r_CRC_ERR_DETf_SET BCM53262_A0_X1K_STS1r_CRC_ERR_DETf_SET
#define X1K_STS1r_FASLSE_CARR_DETf_GET BCM53262_A0_X1K_STS1r_FASLSE_CARR_DETf_GET
#define X1K_STS1r_FASLSE_CARR_DETf_SET BCM53262_A0_X1K_STS1r_FASLSE_CARR_DETf_SET
#define X1K_STS1r_RXFIFO_ERR_DETf_GET BCM53262_A0_X1K_STS1r_RXFIFO_ERR_DETf_GET
#define X1K_STS1r_RXFIFO_ERR_DETf_SET BCM53262_A0_X1K_STS1r_RXFIFO_ERR_DETf_SET
#define X1K_STS1r_TXFIFO_ERR_DETf_GET BCM53262_A0_X1K_STS1r_TXFIFO_ERR_DETf_GET
#define X1K_STS1r_TXFIFO_ERR_DETf_SET BCM53262_A0_X1K_STS1r_TXFIFO_ERR_DETf_SET
#define READ_X1K_STS1r BCM53262_A0_READ_X1K_STS1r
#define WRITE_X1K_STS1r BCM53262_A0_WRITE_X1K_STS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_STS2
 * BLOCKS:   GPIC0
 * DESC:     1000-X Status Register 2
 * SIZE:     16
 * FIELDS:
 *     AN_EN_STA        1 = an_enable state in auto-negotiation fsm entered since last read0 = an_enable state has not been entered since last read.
 *     AN_ERR_LNK_STA   If register 0*11h bit 3 is set:1 = an_error state entered since last read0 = an_error state not entered since last read.If register 0*11h bit 3 is cleared:1 = an_disable_link_ok state in auto-negotiation fsm entered since last read0 = an_disable_link_ok not entered since last read.
 *     ABI_DET_STS      1 = ability detect state in auto-negotiation fsm entered since last read0 = ability detect state not entered since last read.
 *     AC_DET_STA       1 = acknowledge detect state in auto-negotiation fsm entered since last read0 = acknowledge detect state not entered since last read.
 *     COMP_AC_STA      1 = complete acknowledge state in auto-negotiation fsm entered since last read0 = complete acknowledge state not entered since last read.
 *     IDLE_STS_DET     LH1 = idle detect state in auto-negotiation fsm entered since last read0 = idle detect state not entered since last read.
 *     LNK_DWN_LOSSSYNC 1 = a valid link went down due to a loss of synchronization for over 10 ms0 = failure condition has not been detected since last read.
 *     RUDI_INVALID     1 = rudi_invalid detected since last read.0 = rudi_invalid has not been detected since last read.
 *     RUDI_I           1 = rudi_i detected since last read.0 = rudi_i has not been detected since last read.
 *     RUDI_C           1 = rudi_c detected since last read0 = rudi_c has not been detected since last read.
 *     SYNC_STS_OK      1 = sync_status ok detected since last read(synchronization has been achieved)0 = sync_status ok has not been detected since last read.
 *     SYNC_STS_FAIL    1 = sync_status has failed since last read(synchronization has been lost)0 = sync_status has not failed since last read.
 *     SGMII_SEL_MIS    1 = sgmii selector mismatch detected since last read(auto-negotiation page received from link partnerwith bit 0 = 0 while local device is in sgmii mode)0 = sgmii selector mismatch not detected since last read.
 *     AN_RES_ERR       1 = auto-negotiation hcd error detected since last read (hcd is none in .ber mode)0 = auto-negotiation hcd error has not been detected since last read.
 *     CONSIST_MIS      1 = consistency mismatch detected since last read0 = consistency mismatch has not been detected since last read.
 *     SGMII_MODE_CH    1 = sgmii mode has changed since last read(sgmii mode enabled or disabled)NOTE: This bit is useful when the auto-detection is enabled in register 0*10h bit 4.0 = sgmii mode has not changed since last read(.xed in sgmii or .ber mode).
 */
#define BCM53262_A0_X1K_STS2r 0x0000b82a

#define BCM53262_A0_X1K_STS2r_SIZE 2

/*
 * This structure should be used to declare and program X1K_STS2.
 */
typedef union BCM53262_A0_X1K_STS2r_s {
	uint32_t v[1];
	uint32_t x1k_sts2[1];
	uint32_t _x1k_sts2;
} BCM53262_A0_X1K_STS2r_t;

#define BCM53262_A0_X1K_STS2r_CLR(r) (r).x1k_sts2[0] = 0
#define BCM53262_A0_X1K_STS2r_SET(r,d) (r).x1k_sts2[0] = d
#define BCM53262_A0_X1K_STS2r_GET(r) (r).x1k_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_STS2r_AN_EN_STAf_GET(r) (((r).x1k_sts2[0]) & 0x1)
#define BCM53262_A0_X1K_STS2r_AN_EN_STAf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53262_A0_X1K_STS2r_AN_ERR_LNK_STAf_GET(r) ((((r).x1k_sts2[0]) >> 1) & 0x1)
#define BCM53262_A0_X1K_STS2r_AN_ERR_LNK_STAf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53262_A0_X1K_STS2r_ABI_DET_STSf_GET(r) ((((r).x1k_sts2[0]) >> 2) & 0x1)
#define BCM53262_A0_X1K_STS2r_ABI_DET_STSf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53262_A0_X1K_STS2r_AC_DET_STAf_GET(r) ((((r).x1k_sts2[0]) >> 3) & 0x1)
#define BCM53262_A0_X1K_STS2r_AC_DET_STAf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53262_A0_X1K_STS2r_COMP_AC_STAf_GET(r) ((((r).x1k_sts2[0]) >> 4) & 0x1)
#define BCM53262_A0_X1K_STS2r_COMP_AC_STAf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53262_A0_X1K_STS2r_IDLE_STS_DETf_GET(r) ((((r).x1k_sts2[0]) >> 5) & 0x1)
#define BCM53262_A0_X1K_STS2r_IDLE_STS_DETf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53262_A0_X1K_STS2r_LNK_DWN_LOSSSYNCf_GET(r) ((((r).x1k_sts2[0]) >> 6) & 0x1)
#define BCM53262_A0_X1K_STS2r_LNK_DWN_LOSSSYNCf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53262_A0_X1K_STS2r_RUDI_INVALIDf_GET(r) ((((r).x1k_sts2[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_STS2r_RUDI_INVALIDf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_STS2r_RUDI_If_GET(r) ((((r).x1k_sts2[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_STS2r_RUDI_If_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_STS2r_RUDI_Cf_GET(r) ((((r).x1k_sts2[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_STS2r_RUDI_Cf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_STS2r_SYNC_STS_OKf_GET(r) ((((r).x1k_sts2[0]) >> 10) & 0x1)
#define BCM53262_A0_X1K_STS2r_SYNC_STS_OKf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53262_A0_X1K_STS2r_SYNC_STS_FAILf_GET(r) ((((r).x1k_sts2[0]) >> 11) & 0x1)
#define BCM53262_A0_X1K_STS2r_SYNC_STS_FAILf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53262_A0_X1K_STS2r_SGMII_SEL_MISf_GET(r) ((((r).x1k_sts2[0]) >> 12) & 0x1)
#define BCM53262_A0_X1K_STS2r_SGMII_SEL_MISf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53262_A0_X1K_STS2r_AN_RES_ERRf_GET(r) ((((r).x1k_sts2[0]) >> 13) & 0x1)
#define BCM53262_A0_X1K_STS2r_AN_RES_ERRf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53262_A0_X1K_STS2r_CONSIST_MISf_GET(r) ((((r).x1k_sts2[0]) >> 14) & 0x1)
#define BCM53262_A0_X1K_STS2r_CONSIST_MISf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53262_A0_X1K_STS2r_SGMII_MODE_CHf_GET(r) ((((r).x1k_sts2[0]) >> 15) & 0x1)
#define BCM53262_A0_X1K_STS2r_SGMII_MODE_CHf_SET(r,f) (r).x1k_sts2[0]=(((r).x1k_sts2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access X1K_STS2.
 */
#define BCM53262_A0_READ_X1K_STS2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_STS2r,(r._x1k_sts2),2)
#define BCM53262_A0_WRITE_X1K_STS2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_STS2r,&(r._x1k_sts2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_STS2r BCM53262_A0_X1K_STS2r
#define X1K_STS2r_SIZE BCM53262_A0_X1K_STS2r_SIZE
typedef BCM53262_A0_X1K_STS2r_t X1K_STS2r_t;
#define X1K_STS2r_CLR BCM53262_A0_X1K_STS2r_CLR
#define X1K_STS2r_SET BCM53262_A0_X1K_STS2r_SET
#define X1K_STS2r_GET BCM53262_A0_X1K_STS2r_GET
#define X1K_STS2r_AN_EN_STAf_GET BCM53262_A0_X1K_STS2r_AN_EN_STAf_GET
#define X1K_STS2r_AN_EN_STAf_SET BCM53262_A0_X1K_STS2r_AN_EN_STAf_SET
#define X1K_STS2r_AN_ERR_LNK_STAf_GET BCM53262_A0_X1K_STS2r_AN_ERR_LNK_STAf_GET
#define X1K_STS2r_AN_ERR_LNK_STAf_SET BCM53262_A0_X1K_STS2r_AN_ERR_LNK_STAf_SET
#define X1K_STS2r_ABI_DET_STSf_GET BCM53262_A0_X1K_STS2r_ABI_DET_STSf_GET
#define X1K_STS2r_ABI_DET_STSf_SET BCM53262_A0_X1K_STS2r_ABI_DET_STSf_SET
#define X1K_STS2r_AC_DET_STAf_GET BCM53262_A0_X1K_STS2r_AC_DET_STAf_GET
#define X1K_STS2r_AC_DET_STAf_SET BCM53262_A0_X1K_STS2r_AC_DET_STAf_SET
#define X1K_STS2r_COMP_AC_STAf_GET BCM53262_A0_X1K_STS2r_COMP_AC_STAf_GET
#define X1K_STS2r_COMP_AC_STAf_SET BCM53262_A0_X1K_STS2r_COMP_AC_STAf_SET
#define X1K_STS2r_IDLE_STS_DETf_GET BCM53262_A0_X1K_STS2r_IDLE_STS_DETf_GET
#define X1K_STS2r_IDLE_STS_DETf_SET BCM53262_A0_X1K_STS2r_IDLE_STS_DETf_SET
#define X1K_STS2r_LNK_DWN_LOSSSYNCf_GET BCM53262_A0_X1K_STS2r_LNK_DWN_LOSSSYNCf_GET
#define X1K_STS2r_LNK_DWN_LOSSSYNCf_SET BCM53262_A0_X1K_STS2r_LNK_DWN_LOSSSYNCf_SET
#define X1K_STS2r_RUDI_INVALIDf_GET BCM53262_A0_X1K_STS2r_RUDI_INVALIDf_GET
#define X1K_STS2r_RUDI_INVALIDf_SET BCM53262_A0_X1K_STS2r_RUDI_INVALIDf_SET
#define X1K_STS2r_RUDI_If_GET BCM53262_A0_X1K_STS2r_RUDI_If_GET
#define X1K_STS2r_RUDI_If_SET BCM53262_A0_X1K_STS2r_RUDI_If_SET
#define X1K_STS2r_RUDI_Cf_GET BCM53262_A0_X1K_STS2r_RUDI_Cf_GET
#define X1K_STS2r_RUDI_Cf_SET BCM53262_A0_X1K_STS2r_RUDI_Cf_SET
#define X1K_STS2r_SYNC_STS_OKf_GET BCM53262_A0_X1K_STS2r_SYNC_STS_OKf_GET
#define X1K_STS2r_SYNC_STS_OKf_SET BCM53262_A0_X1K_STS2r_SYNC_STS_OKf_SET
#define X1K_STS2r_SYNC_STS_FAILf_GET BCM53262_A0_X1K_STS2r_SYNC_STS_FAILf_GET
#define X1K_STS2r_SYNC_STS_FAILf_SET BCM53262_A0_X1K_STS2r_SYNC_STS_FAILf_SET
#define X1K_STS2r_SGMII_SEL_MISf_GET BCM53262_A0_X1K_STS2r_SGMII_SEL_MISf_GET
#define X1K_STS2r_SGMII_SEL_MISf_SET BCM53262_A0_X1K_STS2r_SGMII_SEL_MISf_SET
#define X1K_STS2r_AN_RES_ERRf_GET BCM53262_A0_X1K_STS2r_AN_RES_ERRf_GET
#define X1K_STS2r_AN_RES_ERRf_SET BCM53262_A0_X1K_STS2r_AN_RES_ERRf_SET
#define X1K_STS2r_CONSIST_MISf_GET BCM53262_A0_X1K_STS2r_CONSIST_MISf_GET
#define X1K_STS2r_CONSIST_MISf_SET BCM53262_A0_X1K_STS2r_CONSIST_MISf_SET
#define X1K_STS2r_SGMII_MODE_CHf_GET BCM53262_A0_X1K_STS2r_SGMII_MODE_CHf_GET
#define X1K_STS2r_SGMII_MODE_CHf_SET BCM53262_A0_X1K_STS2r_SGMII_MODE_CHf_SET
#define READ_X1K_STS2r BCM53262_A0_READ_X1K_STS2r
#define WRITE_X1K_STS2r BCM53262_A0_WRITE_X1K_STS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_STS3
 * BLOCKS:   GPIC0
 * DESC:     1000-X Status Register 3
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       ignore on read.
 *     SIGN_DET_CH      1 = signal detect has changed since last read0 = signal detect has not changed since last readNOTE: The signal detect change is based on a change in bit 9 of this register.
 *     SIGN_DET_IN      1 = input of signal detect .lter is set0 = input of signal detect .lter is not setNOTE: This is the only SD status bit that will be valid when the serdes is powered down from register 0.11This status signal is the "signal detect" input port when register 0*10h bit 3 is 0, otherwise it is the ignal detect?input port inverted.
 *     SIGN_DET_OUT     1 = output of signal detect .lter is set0 = output of signal detect .lter is not setNOTE: This signal is used for the PCS synchronization. When register 0*10h bit 2 is 0,then the output of the .lter will be forced high.This status signal is still valid when register 0*10h bit 14 is 1. Noise pulses less than 16 ns wide are still removed when even the .lter is disabled.
 *     SPARE_R          ignore on read.
 */
#define BCM53262_A0_X1K_STS3r 0x0000b82c

#define BCM53262_A0_X1K_STS3r_SIZE 2

/*
 * This structure should be used to declare and program X1K_STS3.
 */
typedef union BCM53262_A0_X1K_STS3r_s {
	uint32_t v[1];
	uint32_t x1k_sts3[1];
	uint32_t _x1k_sts3;
} BCM53262_A0_X1K_STS3r_t;

#define BCM53262_A0_X1K_STS3r_CLR(r) (r).x1k_sts3[0] = 0
#define BCM53262_A0_X1K_STS3r_SET(r,d) (r).x1k_sts3[0] = d
#define BCM53262_A0_X1K_STS3r_GET(r) (r).x1k_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_STS3r_RESERVED_Rf_GET(r) (((r).x1k_sts3[0]) & 0x7f)
#define BCM53262_A0_X1K_STS3r_RESERVED_Rf_SET(r,f) (r).x1k_sts3[0]=(((r).x1k_sts3[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53262_A0_X1K_STS3r_SIGN_DET_CHf_GET(r) ((((r).x1k_sts3[0]) >> 7) & 0x1)
#define BCM53262_A0_X1K_STS3r_SIGN_DET_CHf_SET(r,f) (r).x1k_sts3[0]=(((r).x1k_sts3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53262_A0_X1K_STS3r_SIGN_DET_INf_GET(r) ((((r).x1k_sts3[0]) >> 8) & 0x1)
#define BCM53262_A0_X1K_STS3r_SIGN_DET_INf_SET(r,f) (r).x1k_sts3[0]=(((r).x1k_sts3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53262_A0_X1K_STS3r_SIGN_DET_OUTf_GET(r) ((((r).x1k_sts3[0]) >> 9) & 0x1)
#define BCM53262_A0_X1K_STS3r_SIGN_DET_OUTf_SET(r,f) (r).x1k_sts3[0]=(((r).x1k_sts3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53262_A0_X1K_STS3r_SPARE_Rf_GET(r) ((((r).x1k_sts3[0]) >> 10) & 0x3f)
#define BCM53262_A0_X1K_STS3r_SPARE_Rf_SET(r,f) (r).x1k_sts3[0]=(((r).x1k_sts3[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access X1K_STS3.
 */
#define BCM53262_A0_READ_X1K_STS3r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_STS3r,(r._x1k_sts3),2)
#define BCM53262_A0_WRITE_X1K_STS3r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_STS3r,&(r._x1k_sts3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_STS3r BCM53262_A0_X1K_STS3r
#define X1K_STS3r_SIZE BCM53262_A0_X1K_STS3r_SIZE
typedef BCM53262_A0_X1K_STS3r_t X1K_STS3r_t;
#define X1K_STS3r_CLR BCM53262_A0_X1K_STS3r_CLR
#define X1K_STS3r_SET BCM53262_A0_X1K_STS3r_SET
#define X1K_STS3r_GET BCM53262_A0_X1K_STS3r_GET
#define X1K_STS3r_RESERVED_Rf_GET BCM53262_A0_X1K_STS3r_RESERVED_Rf_GET
#define X1K_STS3r_RESERVED_Rf_SET BCM53262_A0_X1K_STS3r_RESERVED_Rf_SET
#define X1K_STS3r_SIGN_DET_CHf_GET BCM53262_A0_X1K_STS3r_SIGN_DET_CHf_GET
#define X1K_STS3r_SIGN_DET_CHf_SET BCM53262_A0_X1K_STS3r_SIGN_DET_CHf_SET
#define X1K_STS3r_SIGN_DET_INf_GET BCM53262_A0_X1K_STS3r_SIGN_DET_INf_GET
#define X1K_STS3r_SIGN_DET_INf_SET BCM53262_A0_X1K_STS3r_SIGN_DET_INf_SET
#define X1K_STS3r_SIGN_DET_OUTf_GET BCM53262_A0_X1K_STS3r_SIGN_DET_OUTf_GET
#define X1K_STS3r_SIGN_DET_OUTf_SET BCM53262_A0_X1K_STS3r_SIGN_DET_OUTf_SET
#define X1K_STS3r_SPARE_Rf_GET BCM53262_A0_X1K_STS3r_SPARE_Rf_GET
#define X1K_STS3r_SPARE_Rf_SET BCM53262_A0_X1K_STS3r_SPARE_Rf_SET
#define READ_X1K_STS3r BCM53262_A0_READ_X1K_STS3r
#define WRITE_X1K_STS3r BCM53262_A0_WRITE_X1K_STS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCM53262_A0
 * REGISTER:  X1K_TST_MOD
 * BLOCKS:   GPIC0
 * DESC:     Test Mode Register
 * SIZE:     16
 * FIELDS:
 *     TST_MON_MOD1     select test mode for tpout[11:0];see testability document for details.
 *     TST_MON_MOD2     select test mode for tpout[23:12];see testability document for details.
 *     SPARE_R          write as 0, ignore on read.
 *     RESERVED_R       write as 0, ignore on read
 */
#define BCM53262_A0_X1K_TST_MODr 0x0000b838

#define BCM53262_A0_X1K_TST_MODr_SIZE 2

/*
 * This structure should be used to declare and program X1K_TST_MOD.
 */
typedef union BCM53262_A0_X1K_TST_MODr_s {
	uint32_t v[1];
	uint32_t x1k_tst_mod[1];
	uint32_t _x1k_tst_mod;
} BCM53262_A0_X1K_TST_MODr_t;

#define BCM53262_A0_X1K_TST_MODr_CLR(r) (r).x1k_tst_mod[0] = 0
#define BCM53262_A0_X1K_TST_MODr_SET(r,d) (r).x1k_tst_mod[0] = d
#define BCM53262_A0_X1K_TST_MODr_GET(r) (r).x1k_tst_mod[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM53262_A0_X1K_TST_MODr_TST_MON_MOD1f_GET(r) (((r).x1k_tst_mod[0]) & 0x1f)
#define BCM53262_A0_X1K_TST_MODr_TST_MON_MOD1f_SET(r,f) (r).x1k_tst_mod[0]=(((r).x1k_tst_mod[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53262_A0_X1K_TST_MODr_TST_MON_MOD2f_GET(r) ((((r).x1k_tst_mod[0]) >> 5) & 0x1f)
#define BCM53262_A0_X1K_TST_MODr_TST_MON_MOD2f_SET(r,f) (r).x1k_tst_mod[0]=(((r).x1k_tst_mod[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM53262_A0_X1K_TST_MODr_SPARE_Rf_GET(r) ((((r).x1k_tst_mod[0]) >> 10) & 0x3)
#define BCM53262_A0_X1K_TST_MODr_SPARE_Rf_SET(r,f) (r).x1k_tst_mod[0]=(((r).x1k_tst_mod[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53262_A0_X1K_TST_MODr_RESERVED_Rf_GET(r) ((((r).x1k_tst_mod[0]) >> 12) & 0xf)
#define BCM53262_A0_X1K_TST_MODr_RESERVED_Rf_SET(r,f) (r).x1k_tst_mod[0]=(((r).x1k_tst_mod[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access X1K_TST_MOD.
 */
#define BCM53262_A0_READ_X1K_TST_MODr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53262_A0_X1K_TST_MODr,(r._x1k_tst_mod),2)
#define BCM53262_A0_WRITE_X1K_TST_MODr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53262_A0_X1K_TST_MODr,&(r._x1k_tst_mod),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define X1K_TST_MODr BCM53262_A0_X1K_TST_MODr
#define X1K_TST_MODr_SIZE BCM53262_A0_X1K_TST_MODr_SIZE
typedef BCM53262_A0_X1K_TST_MODr_t X1K_TST_MODr_t;
#define X1K_TST_MODr_CLR BCM53262_A0_X1K_TST_MODr_CLR
#define X1K_TST_MODr_SET BCM53262_A0_X1K_TST_MODr_SET
#define X1K_TST_MODr_GET BCM53262_A0_X1K_TST_MODr_GET
#define X1K_TST_MODr_TST_MON_MOD1f_GET BCM53262_A0_X1K_TST_MODr_TST_MON_MOD1f_GET
#define X1K_TST_MODr_TST_MON_MOD1f_SET BCM53262_A0_X1K_TST_MODr_TST_MON_MOD1f_SET
#define X1K_TST_MODr_TST_MON_MOD2f_GET BCM53262_A0_X1K_TST_MODr_TST_MON_MOD2f_GET
#define X1K_TST_MODr_TST_MON_MOD2f_SET BCM53262_A0_X1K_TST_MODr_TST_MON_MOD2f_SET
#define X1K_TST_MODr_SPARE_Rf_GET BCM53262_A0_X1K_TST_MODr_SPARE_Rf_GET
#define X1K_TST_MODr_SPARE_Rf_SET BCM53262_A0_X1K_TST_MODr_SPARE_Rf_SET
#define X1K_TST_MODr_RESERVED_Rf_GET BCM53262_A0_X1K_TST_MODr_RESERVED_Rf_GET
#define X1K_TST_MODr_RESERVED_Rf_SET BCM53262_A0_X1K_TST_MODr_RESERVED_Rf_SET
#define READ_X1K_TST_MODr BCM53262_A0_READ_X1K_TST_MODr
#define WRITE_X1K_TST_MODr BCM53262_A0_WRITE_X1K_TST_MODr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53262_A0_X1K_TST_MODr'
 */




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM53262_A0_DEFS_H__ */
