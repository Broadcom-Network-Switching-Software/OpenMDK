#ifndef __BCMI_QTC_XGXS_DEFS_H__
#define __BCMI_QTC_XGXS_DEFS_H__
/*******************************************************************************
 *
 * This software is governed by the Broadcom Switch APIs license.
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenMDK/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_QTC_XGXS.
 * This file provides all basic definitions required to program the BCMI_QTC_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 */

#include <phymod/acc/phymod_tsc_iblk.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PHYID2
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0002
 * DESC:     IEEE phyID2 Register
 * SIZE:     32
 * FIELDS:
 *     REGID1           PHYID2 register
 */
#define BCMI_QTC_XGXS_PHYID2r (0x00000002 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PHYID2r_SIZE 4

/*
 * This structure should be used to declare and program PHYID2.
 */
typedef union BCMI_QTC_XGXS_PHYID2r_s {
	uint32_t v[1];
	uint32_t phyid2[1];
	uint32_t _phyid2;
} BCMI_QTC_XGXS_PHYID2r_t;

#define BCMI_QTC_XGXS_PHYID2r_CLR(r) (r).phyid2[0] = 0
#define BCMI_QTC_XGXS_PHYID2r_SET(r,d) (r).phyid2[0] = d
#define BCMI_QTC_XGXS_PHYID2r_GET(r) (r).phyid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PHYID2r_REGID1f_GET(r) (((r).phyid2[0]) & 0xffff)
#define BCMI_QTC_XGXS_PHYID2r_REGID1f_SET(r,f) (r).phyid2[0]=(((r).phyid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PHYID2.
 */
#define BCMI_QTC_XGXS_READ_PHYID2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_QTC_XGXS_WRITE_PHYID2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID2r,(_r._phyid2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PHYID2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_QTC_XGXS_READLN_PHYID2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_QTC_XGXS_WRITELN_PHYID2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_QTC_XGXS_WRITEALL_PHYID2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHYID2r BCMI_QTC_XGXS_PHYID2r
#define PHYID2r_SIZE BCMI_QTC_XGXS_PHYID2r_SIZE
typedef BCMI_QTC_XGXS_PHYID2r_t PHYID2r_t;
#define PHYID2r_CLR BCMI_QTC_XGXS_PHYID2r_CLR
#define PHYID2r_SET BCMI_QTC_XGXS_PHYID2r_SET
#define PHYID2r_GET BCMI_QTC_XGXS_PHYID2r_GET
#define PHYID2r_REGID1f_GET BCMI_QTC_XGXS_PHYID2r_REGID1f_GET
#define PHYID2r_REGID1f_SET BCMI_QTC_XGXS_PHYID2r_REGID1f_SET
#define READ_PHYID2r BCMI_QTC_XGXS_READ_PHYID2r
#define WRITE_PHYID2r BCMI_QTC_XGXS_WRITE_PHYID2r
#define MODIFY_PHYID2r BCMI_QTC_XGXS_MODIFY_PHYID2r
#define READLN_PHYID2r BCMI_QTC_XGXS_READLN_PHYID2r
#define WRITELN_PHYID2r BCMI_QTC_XGXS_WRITELN_PHYID2r
#define WRITEALL_PHYID2r BCMI_QTC_XGXS_WRITEALL_PHYID2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PHYID2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PHYID3
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0003
 * DESC:     IEEE phyID3 Register
 * SIZE:     32
 * FIELDS:
 *     REGID2           PHYID3 register
 */
#define BCMI_QTC_XGXS_PHYID3r (0x00000003 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PHYID3r_SIZE 4

/*
 * This structure should be used to declare and program PHYID3.
 */
typedef union BCMI_QTC_XGXS_PHYID3r_s {
	uint32_t v[1];
	uint32_t phyid3[1];
	uint32_t _phyid3;
} BCMI_QTC_XGXS_PHYID3r_t;

#define BCMI_QTC_XGXS_PHYID3r_CLR(r) (r).phyid3[0] = 0
#define BCMI_QTC_XGXS_PHYID3r_SET(r,d) (r).phyid3[0] = d
#define BCMI_QTC_XGXS_PHYID3r_GET(r) (r).phyid3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PHYID3r_REGID2f_GET(r) (((r).phyid3[0]) & 0xffff)
#define BCMI_QTC_XGXS_PHYID3r_REGID2f_SET(r,f) (r).phyid3[0]=(((r).phyid3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PHYID3.
 */
#define BCMI_QTC_XGXS_READ_PHYID3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_QTC_XGXS_WRITE_PHYID3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID3r,(_r._phyid3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PHYID3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_QTC_XGXS_READLN_PHYID3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_QTC_XGXS_WRITELN_PHYID3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_QTC_XGXS_WRITEALL_PHYID3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHYID3r BCMI_QTC_XGXS_PHYID3r
#define PHYID3r_SIZE BCMI_QTC_XGXS_PHYID3r_SIZE
typedef BCMI_QTC_XGXS_PHYID3r_t PHYID3r_t;
#define PHYID3r_CLR BCMI_QTC_XGXS_PHYID3r_CLR
#define PHYID3r_SET BCMI_QTC_XGXS_PHYID3r_SET
#define PHYID3r_GET BCMI_QTC_XGXS_PHYID3r_GET
#define PHYID3r_REGID2f_GET BCMI_QTC_XGXS_PHYID3r_REGID2f_GET
#define PHYID3r_REGID2f_SET BCMI_QTC_XGXS_PHYID3r_REGID2f_SET
#define READ_PHYID3r BCMI_QTC_XGXS_READ_PHYID3r
#define WRITE_PHYID3r BCMI_QTC_XGXS_WRITE_PHYID3r
#define MODIFY_PHYID3r BCMI_QTC_XGXS_MODIFY_PHYID3r
#define READLN_PHYID3r BCMI_QTC_XGXS_READLN_PHYID3r
#define WRITELN_PHYID3r BCMI_QTC_XGXS_WRITELN_PHYID3r
#define WRITEALL_PHYID3r BCMI_QTC_XGXS_WRITEALL_PHYID3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PHYID3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SETUP
 * BLOCKS:   MAIN
 * REGADDR:  0x9000
 * DESC:     main control register
 * SIZE:     32
 * FIELDS:
 *     MASTER_PORT_NUM  Port that will control PMD core logic and PLL reset:0 : port 0 is master1 : port 1 is master2 : port 2 is master3 : port 3 is master
 *     PLL_RESET_EN     Enable reseting PMD core logic and PLL by Speed control. The port that will reset the pll is selected by master_port_number
 *     SINGLE_PORT_MODE Indicates QTC is in single port mode.  Used by AN logic to determine whether to reset the PLL after AN completes.If set, when AN completes, the PLL will be reset to operate consistent with the resolved AN speed.If not set, the PLL will not change once AN completes.
 *     CL37_HIGH_VCO    Use 10G/12.5G VCO based speed for CL37 AN. By default 6.25G VCO based speed is used.This bit will also make the resolved speeds to use 10G/12.5G VCO when possible.00 - 6.25G VCO01 - 10G VCO10 - 12.5G VCO11 - reserved
 *     REFCLK_SEL       Specifies refclk frequency
 */
#define BCMI_QTC_XGXS_MAIN_SETUPr (0x00109000 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SETUP.
 */
typedef union BCMI_QTC_XGXS_MAIN_SETUPr_s {
	uint32_t v[1];
	uint32_t main_setup[1];
	uint32_t _main_setup;
} BCMI_QTC_XGXS_MAIN_SETUPr_t;

#define BCMI_QTC_XGXS_MAIN_SETUPr_CLR(r) (r).main_setup[0] = 0
#define BCMI_QTC_XGXS_MAIN_SETUPr_SET(r,d) (r).main_setup[0] = d
#define BCMI_QTC_XGXS_MAIN_SETUPr_GET(r) (r).main_setup[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SETUPr_REFCLK_SELf_GET(r) ((((r).main_setup[0]) >> 13) & 0x7)
#define BCMI_QTC_XGXS_MAIN_SETUPr_REFCLK_SELf_SET(r,f) (r).main_setup[0]=(((r).main_setup[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_QTC_XGXS_MAIN_SETUPr_CL37_HIGH_VCOf_GET(r) ((((r).main_setup[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SETUPr_CL37_HIGH_VCOf_SET(r,f) (r).main_setup[0]=(((r).main_setup[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_MAIN_SETUPr_SINGLE_PORT_MODEf_GET(r) ((((r).main_setup[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_MAIN_SETUPr_SINGLE_PORT_MODEf_SET(r,f) (r).main_setup[0]=(((r).main_setup[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_MAIN_SETUPr_PLL_RESET_ENf_GET(r) ((((r).main_setup[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_MAIN_SETUPr_PLL_RESET_ENf_SET(r,f) (r).main_setup[0]=(((r).main_setup[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_MAIN_SETUPr_MASTER_PORT_NUMf_GET(r) (((r).main_setup[0]) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SETUPr_MASTER_PORT_NUMf_SET(r,f) (r).main_setup[0]=(((r).main_setup[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access MAIN_SETUP.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SETUPr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SETUPr,(_r._main_setup))
#define BCMI_QTC_XGXS_WRITE_MAIN_SETUPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SETUPr,(_r._main_setup)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SETUPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SETUPr,(_r._main_setup))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SETUPr BCMI_QTC_XGXS_MAIN_SETUPr
#define MAIN_SETUPr_SIZE BCMI_QTC_XGXS_MAIN_SETUPr_SIZE
typedef BCMI_QTC_XGXS_MAIN_SETUPr_t MAIN_SETUPr_t;
#define MAIN_SETUPr_CLR BCMI_QTC_XGXS_MAIN_SETUPr_CLR
#define MAIN_SETUPr_SET BCMI_QTC_XGXS_MAIN_SETUPr_SET
#define MAIN_SETUPr_GET BCMI_QTC_XGXS_MAIN_SETUPr_GET
#define MAIN_SETUPr_REFCLK_SELf_GET BCMI_QTC_XGXS_MAIN_SETUPr_REFCLK_SELf_GET
#define MAIN_SETUPr_REFCLK_SELf_SET BCMI_QTC_XGXS_MAIN_SETUPr_REFCLK_SELf_SET
#define MAIN_SETUPr_CL37_HIGH_VCOf_GET BCMI_QTC_XGXS_MAIN_SETUPr_CL37_HIGH_VCOf_GET
#define MAIN_SETUPr_CL37_HIGH_VCOf_SET BCMI_QTC_XGXS_MAIN_SETUPr_CL37_HIGH_VCOf_SET
#define MAIN_SETUPr_SINGLE_PORT_MODEf_GET BCMI_QTC_XGXS_MAIN_SETUPr_SINGLE_PORT_MODEf_GET
#define MAIN_SETUPr_SINGLE_PORT_MODEf_SET BCMI_QTC_XGXS_MAIN_SETUPr_SINGLE_PORT_MODEf_SET
#define MAIN_SETUPr_PLL_RESET_ENf_GET BCMI_QTC_XGXS_MAIN_SETUPr_PLL_RESET_ENf_GET
#define MAIN_SETUPr_PLL_RESET_ENf_SET BCMI_QTC_XGXS_MAIN_SETUPr_PLL_RESET_ENf_SET
#define MAIN_SETUPr_MASTER_PORT_NUMf_GET BCMI_QTC_XGXS_MAIN_SETUPr_MASTER_PORT_NUMf_GET
#define MAIN_SETUPr_MASTER_PORT_NUMf_SET BCMI_QTC_XGXS_MAIN_SETUPr_MASTER_PORT_NUMf_SET
#define READ_MAIN_SETUPr BCMI_QTC_XGXS_READ_MAIN_SETUPr
#define WRITE_MAIN_SETUPr BCMI_QTC_XGXS_WRITE_MAIN_SETUPr
#define MODIFY_MAIN_SETUPr BCMI_QTC_XGXS_MODIFY_MAIN_SETUPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SETUPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_LN_SWP
 * BLOCKS:   MAIN
 * REGADDR:  0x9001
 * DESC:     Lane Swap Control Register
 * SIZE:     32
 * FIELDS:
 *     LOG0_TO_PHY_LNSWAP_SEL Lane0 logical to physical swap selectLOGICAL to PHYSICAL lane mapping controlIndicates for LOGICAL lane 3 which PHYSICAL lane to send data to
 *     LOG1_TO_PHY_LNSWAP_SEL Lane1 logical to physical swap selectLOGICAL to PHYSICAL lane mapping controlIndicates for LOGICAL lane 3 which PHYSICAL lane to send data to
 *     LOG2_TO_PHY_LNSWAP_SEL Lane2 logical to physical swap selectLOGICAL to PHYSICAL lane mapping controlIndicates for LOGICAL lane 3 which PHYSICAL lane to send data to
 *     LOG3_TO_PHY_LNSWAP_SEL Lane3 logical to physical swap selectLOGICAL to PHYSICAL lane mapping controlIndicates for LOGICAL lane 3 which PHYSICAL lane to send data to
 *     MAC_TO_PCS_LANE_MAP_SEL_SGMII smgii mode: mac to pcs lane mapping in sgmii modein sgmii mode: QTC lane0/1/2/3 will be mapped to mac0/4/8/12 if this bit is 0, will be mapped to  mac0/1/2/3 if this bit is 1
 */
#define BCMI_QTC_XGXS_MAIN_LN_SWPr (0x00109001 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_LN_SWPr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_LN_SWP.
 */
typedef union BCMI_QTC_XGXS_MAIN_LN_SWPr_s {
	uint32_t v[1];
	uint32_t main_ln_swp[1];
	uint32_t _main_ln_swp;
} BCMI_QTC_XGXS_MAIN_LN_SWPr_t;

#define BCMI_QTC_XGXS_MAIN_LN_SWPr_CLR(r) (r).main_ln_swp[0] = 0
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_SET(r,d) (r).main_ln_swp[0] = d
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_GET(r) (r).main_ln_swp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_MAC_TO_PCS_LANE_MAP_SEL_SGMIIf_GET(r) ((((r).main_ln_swp[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_MAC_TO_PCS_LANE_MAP_SEL_SGMIIf_SET(r,f) (r).main_ln_swp[0]=(((r).main_ln_swp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG3_TO_PHY_LNSWAP_SELf_GET(r) ((((r).main_ln_swp[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG3_TO_PHY_LNSWAP_SELf_SET(r,f) (r).main_ln_swp[0]=(((r).main_ln_swp[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG2_TO_PHY_LNSWAP_SELf_GET(r) ((((r).main_ln_swp[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG2_TO_PHY_LNSWAP_SELf_SET(r,f) (r).main_ln_swp[0]=(((r).main_ln_swp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG1_TO_PHY_LNSWAP_SELf_GET(r) ((((r).main_ln_swp[0]) >> 2) & 0x3)
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG1_TO_PHY_LNSWAP_SELf_SET(r,f) (r).main_ln_swp[0]=(((r).main_ln_swp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG0_TO_PHY_LNSWAP_SELf_GET(r) (((r).main_ln_swp[0]) & 0x3)
#define BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG0_TO_PHY_LNSWAP_SELf_SET(r,f) (r).main_ln_swp[0]=(((r).main_ln_swp[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access MAIN_LN_SWP.
 */
#define BCMI_QTC_XGXS_READ_MAIN_LN_SWPr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_LN_SWPr,(_r._main_ln_swp))
#define BCMI_QTC_XGXS_WRITE_MAIN_LN_SWPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_LN_SWPr,(_r._main_ln_swp)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_LN_SWPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_LN_SWPr,(_r._main_ln_swp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_LN_SWPr BCMI_QTC_XGXS_MAIN_LN_SWPr
#define MAIN_LN_SWPr_SIZE BCMI_QTC_XGXS_MAIN_LN_SWPr_SIZE
typedef BCMI_QTC_XGXS_MAIN_LN_SWPr_t MAIN_LN_SWPr_t;
#define MAIN_LN_SWPr_CLR BCMI_QTC_XGXS_MAIN_LN_SWPr_CLR
#define MAIN_LN_SWPr_SET BCMI_QTC_XGXS_MAIN_LN_SWPr_SET
#define MAIN_LN_SWPr_GET BCMI_QTC_XGXS_MAIN_LN_SWPr_GET
#define MAIN_LN_SWPr_MAC_TO_PCS_LANE_MAP_SEL_SGMIIf_GET BCMI_QTC_XGXS_MAIN_LN_SWPr_MAC_TO_PCS_LANE_MAP_SEL_SGMIIf_GET
#define MAIN_LN_SWPr_MAC_TO_PCS_LANE_MAP_SEL_SGMIIf_SET BCMI_QTC_XGXS_MAIN_LN_SWPr_MAC_TO_PCS_LANE_MAP_SEL_SGMIIf_SET
#define MAIN_LN_SWPr_LOG3_TO_PHY_LNSWAP_SELf_GET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG3_TO_PHY_LNSWAP_SELf_GET
#define MAIN_LN_SWPr_LOG3_TO_PHY_LNSWAP_SELf_SET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG3_TO_PHY_LNSWAP_SELf_SET
#define MAIN_LN_SWPr_LOG2_TO_PHY_LNSWAP_SELf_GET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG2_TO_PHY_LNSWAP_SELf_GET
#define MAIN_LN_SWPr_LOG2_TO_PHY_LNSWAP_SELf_SET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG2_TO_PHY_LNSWAP_SELf_SET
#define MAIN_LN_SWPr_LOG1_TO_PHY_LNSWAP_SELf_GET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG1_TO_PHY_LNSWAP_SELf_GET
#define MAIN_LN_SWPr_LOG1_TO_PHY_LNSWAP_SELf_SET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG1_TO_PHY_LNSWAP_SELf_SET
#define MAIN_LN_SWPr_LOG0_TO_PHY_LNSWAP_SELf_GET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG0_TO_PHY_LNSWAP_SELf_GET
#define MAIN_LN_SWPr_LOG0_TO_PHY_LNSWAP_SELf_SET BCMI_QTC_XGXS_MAIN_LN_SWPr_LOG0_TO_PHY_LNSWAP_SELf_SET
#define READ_MAIN_LN_SWPr BCMI_QTC_XGXS_READ_MAIN_LN_SWPr
#define WRITE_MAIN_LN_SWPr BCMI_QTC_XGXS_WRITE_MAIN_LN_SWPr
#define MODIFY_MAIN_LN_SWPr BCMI_QTC_XGXS_MODIFY_MAIN_LN_SWPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_LN_SWPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_DEVINPKG5
 * BLOCKS:   MAIN
 * REGADDR:  0x9002
 * DESC:     Devices in Package5
 * SIZE:     32
 * FIELDS:
 *     CLAUSE22         1 = Clause 22 registers present in package0 = Clause 22 registers not present in package
 *     PMA_PMD          1 = PMA/PMD present in package0 = PMA/PMD not present in package
 *     WIS              1 = WIS present in package0 = WIS not present in package
 *     PCS_XS           1 = PCS present in package0 = PCS not present in package
 *     PHY_XS           1 = PHY XS present in package0 = PHY XS not present in package
 *     DTE_XS           1 = DTE XS present in package0 = DTE XS not present in package
 *     TC               1 = TC present in package0 = TC not present in package
 *     AN               1 = Auto-Negotiation present in package0 = Auto-Negotiation not present in package
 */
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r (0x00109002 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_SIZE 4

/*
 * This structure should be used to declare and program MAIN_DEVINPKG5.
 */
typedef union BCMI_QTC_XGXS_MAIN_DEVINPKG5r_s {
	uint32_t v[1];
	uint32_t main_devinpkg5[1];
	uint32_t _main_devinpkg5;
} BCMI_QTC_XGXS_MAIN_DEVINPKG5r_t;

#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_CLR(r) (r).main_devinpkg5[0] = 0
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_SET(r,d) (r).main_devinpkg5[0] = d
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_GET(r) (r).main_devinpkg5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_ANf_GET(r) ((((r).main_devinpkg5[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_ANf_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_TCf_GET(r) ((((r).main_devinpkg5[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_TCf_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_DTE_XSf_GET(r) ((((r).main_devinpkg5[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_DTE_XSf_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PHY_XSf_GET(r) ((((r).main_devinpkg5[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PHY_XSf_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PCS_XSf_GET(r) ((((r).main_devinpkg5[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PCS_XSf_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_WISf_GET(r) ((((r).main_devinpkg5[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_WISf_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PMA_PMDf_GET(r) ((((r).main_devinpkg5[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PMA_PMDf_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_CLAUSE22f_GET(r) (((r).main_devinpkg5[0]) & 0x1)
#define BCMI_QTC_XGXS_MAIN_DEVINPKG5r_CLAUSE22f_SET(r,f) (r).main_devinpkg5[0]=(((r).main_devinpkg5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access MAIN_DEVINPKG5.
 */
#define BCMI_QTC_XGXS_READ_MAIN_DEVINPKG5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_DEVINPKG5r,(_r._main_devinpkg5))
#define BCMI_QTC_XGXS_WRITE_MAIN_DEVINPKG5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_DEVINPKG5r,(_r._main_devinpkg5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_DEVINPKG5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_DEVINPKG5r,(_r._main_devinpkg5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_DEVINPKG5r BCMI_QTC_XGXS_MAIN_DEVINPKG5r
#define MAIN_DEVINPKG5r_SIZE BCMI_QTC_XGXS_MAIN_DEVINPKG5r_SIZE
typedef BCMI_QTC_XGXS_MAIN_DEVINPKG5r_t MAIN_DEVINPKG5r_t;
#define MAIN_DEVINPKG5r_CLR BCMI_QTC_XGXS_MAIN_DEVINPKG5r_CLR
#define MAIN_DEVINPKG5r_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_SET
#define MAIN_DEVINPKG5r_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_GET
#define MAIN_DEVINPKG5r_ANf_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_ANf_GET
#define MAIN_DEVINPKG5r_ANf_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_ANf_SET
#define MAIN_DEVINPKG5r_TCf_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_TCf_GET
#define MAIN_DEVINPKG5r_TCf_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_TCf_SET
#define MAIN_DEVINPKG5r_DTE_XSf_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_DTE_XSf_GET
#define MAIN_DEVINPKG5r_DTE_XSf_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_DTE_XSf_SET
#define MAIN_DEVINPKG5r_PHY_XSf_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PHY_XSf_GET
#define MAIN_DEVINPKG5r_PHY_XSf_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PHY_XSf_SET
#define MAIN_DEVINPKG5r_PCS_XSf_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PCS_XSf_GET
#define MAIN_DEVINPKG5r_PCS_XSf_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PCS_XSf_SET
#define MAIN_DEVINPKG5r_WISf_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_WISf_GET
#define MAIN_DEVINPKG5r_WISf_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_WISf_SET
#define MAIN_DEVINPKG5r_PMA_PMDf_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PMA_PMDf_GET
#define MAIN_DEVINPKG5r_PMA_PMDf_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_PMA_PMDf_SET
#define MAIN_DEVINPKG5r_CLAUSE22f_GET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_CLAUSE22f_GET
#define MAIN_DEVINPKG5r_CLAUSE22f_SET BCMI_QTC_XGXS_MAIN_DEVINPKG5r_CLAUSE22f_SET
#define READ_MAIN_DEVINPKG5r BCMI_QTC_XGXS_READ_MAIN_DEVINPKG5r
#define WRITE_MAIN_DEVINPKG5r BCMI_QTC_XGXS_WRITE_MAIN_DEVINPKG5r
#define MODIFY_MAIN_DEVINPKG5r BCMI_QTC_XGXS_MODIFY_MAIN_DEVINPKG5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_DEVINPKG5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_TICK_CTL1
 * BLOCKS:   MAIN
 * REGADDR:  0x9003
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * SIZE:     32
 * FIELDS:
 *     TICK_NUMERATOR_UPPER Bits [18:4] of the tick numerator.  Used when tick_override is true
 *     TICK_OVERRIDE    Enables override of tick counts instead of using refclk_sel
 */
#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r (0x00109003 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program MAIN_TICK_CTL1.
 */
typedef union BCMI_QTC_XGXS_MAIN_TICK_CTL1r_s {
	uint32_t v[1];
	uint32_t main_tick_ctl1[1];
	uint32_t _main_tick_ctl1;
} BCMI_QTC_XGXS_MAIN_TICK_CTL1r_t;

#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_CLR(r) (r).main_tick_ctl1[0] = 0
#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_SET(r,d) (r).main_tick_ctl1[0] = d
#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_GET(r) (r).main_tick_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_OVERRIDEf_GET(r) ((((r).main_tick_ctl1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_OVERRIDEf_SET(r,f) (r).main_tick_ctl1[0]=(((r).main_tick_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET(r) (((r).main_tick_ctl1[0]) & 0x7fff)
#define BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET(r,f) (r).main_tick_ctl1[0]=(((r).main_tick_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (32767 << 16)

/*
 * These macros can be used to access MAIN_TICK_CTL1.
 */
#define BCMI_QTC_XGXS_READ_MAIN_TICK_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_TICK_CTL1r,(_r._main_tick_ctl1))
#define BCMI_QTC_XGXS_WRITE_MAIN_TICK_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_TICK_CTL1r,(_r._main_tick_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_TICK_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_TICK_CTL1r,(_r._main_tick_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_TICK_CTL1r BCMI_QTC_XGXS_MAIN_TICK_CTL1r
#define MAIN_TICK_CTL1r_SIZE BCMI_QTC_XGXS_MAIN_TICK_CTL1r_SIZE
typedef BCMI_QTC_XGXS_MAIN_TICK_CTL1r_t MAIN_TICK_CTL1r_t;
#define MAIN_TICK_CTL1r_CLR BCMI_QTC_XGXS_MAIN_TICK_CTL1r_CLR
#define MAIN_TICK_CTL1r_SET BCMI_QTC_XGXS_MAIN_TICK_CTL1r_SET
#define MAIN_TICK_CTL1r_GET BCMI_QTC_XGXS_MAIN_TICK_CTL1r_GET
#define MAIN_TICK_CTL1r_TICK_OVERRIDEf_GET BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_OVERRIDEf_GET
#define MAIN_TICK_CTL1r_TICK_OVERRIDEf_SET BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_OVERRIDEf_SET
#define MAIN_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET
#define MAIN_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET BCMI_QTC_XGXS_MAIN_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET
#define READ_MAIN_TICK_CTL1r BCMI_QTC_XGXS_READ_MAIN_TICK_CTL1r
#define WRITE_MAIN_TICK_CTL1r BCMI_QTC_XGXS_WRITE_MAIN_TICK_CTL1r
#define MODIFY_MAIN_TICK_CTL1r BCMI_QTC_XGXS_MODIFY_MAIN_TICK_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_TICK_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_TICK_CTL0
 * BLOCKS:   MAIN
 * REGADDR:  0x9004
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * SIZE:     32
 * FIELDS:
 *     TICK_DENOMINATOR Tick denominator.  Used when tick_override is true
 *     TICK_NUMERATOR_LOWER Bits [3:0] of the tick numerator.  Used when tick_override is true
 */
#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r (0x00109004 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN_TICK_CTL0.
 */
typedef union BCMI_QTC_XGXS_MAIN_TICK_CTL0r_s {
	uint32_t v[1];
	uint32_t main_tick_ctl0[1];
	uint32_t _main_tick_ctl0;
} BCMI_QTC_XGXS_MAIN_TICK_CTL0r_t;

#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_CLR(r) (r).main_tick_ctl0[0] = 0
#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_SET(r,d) (r).main_tick_ctl0[0] = d
#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_GET(r) (r).main_tick_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET(r) ((((r).main_tick_ctl0[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET(r,f) (r).main_tick_ctl0[0]=(((r).main_tick_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_DENOMINATORf_GET(r) ((((r).main_tick_ctl0[0]) >> 2) & 0x3ff)
#define BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_DENOMINATORf_SET(r,f) (r).main_tick_ctl0[0]=(((r).main_tick_ctl0[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2)) | (1023 << (16 + 2))

/*
 * These macros can be used to access MAIN_TICK_CTL0.
 */
#define BCMI_QTC_XGXS_READ_MAIN_TICK_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_TICK_CTL0r,(_r._main_tick_ctl0))
#define BCMI_QTC_XGXS_WRITE_MAIN_TICK_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_TICK_CTL0r,(_r._main_tick_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_TICK_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_TICK_CTL0r,(_r._main_tick_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_TICK_CTL0r BCMI_QTC_XGXS_MAIN_TICK_CTL0r
#define MAIN_TICK_CTL0r_SIZE BCMI_QTC_XGXS_MAIN_TICK_CTL0r_SIZE
typedef BCMI_QTC_XGXS_MAIN_TICK_CTL0r_t MAIN_TICK_CTL0r_t;
#define MAIN_TICK_CTL0r_CLR BCMI_QTC_XGXS_MAIN_TICK_CTL0r_CLR
#define MAIN_TICK_CTL0r_SET BCMI_QTC_XGXS_MAIN_TICK_CTL0r_SET
#define MAIN_TICK_CTL0r_GET BCMI_QTC_XGXS_MAIN_TICK_CTL0r_GET
#define MAIN_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET
#define MAIN_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET
#define MAIN_TICK_CTL0r_TICK_DENOMINATORf_GET BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_DENOMINATORf_GET
#define MAIN_TICK_CTL0r_TICK_DENOMINATORf_SET BCMI_QTC_XGXS_MAIN_TICK_CTL0r_TICK_DENOMINATORf_SET
#define READ_MAIN_TICK_CTL0r BCMI_QTC_XGXS_READ_MAIN_TICK_CTL0r
#define WRITE_MAIN_TICK_CTL0r BCMI_QTC_XGXS_WRITE_MAIN_TICK_CTL0r
#define MODIFY_MAIN_TICK_CTL0r BCMI_QTC_XGXS_MODIFY_MAIN_TICK_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_TICK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_LPBK_CTL
 * BLOCKS:   MAIN
 * REGADDR:  0x9005
 * DESC:     LOOPBACK CONTROL REGISTER
 * SIZE:     32
 * FIELDS:
 *     LOCAL_PCS_LOOPBACK_ENABLE Per LOGICAL LANE control to enable PCS based local (TX to RX) loopback
 *     REMOTE_PCS_LOOPBACK_ENABLE Per LOGICAL LANE control to enable PCS based remote (RX to TX) loopback
 */
#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr (0x00109005 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_LPBK_CTL.
 */
typedef union BCMI_QTC_XGXS_MAIN_LPBK_CTLr_s {
	uint32_t v[1];
	uint32_t main_lpbk_ctl[1];
	uint32_t _main_lpbk_ctl;
} BCMI_QTC_XGXS_MAIN_LPBK_CTLr_t;

#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_CLR(r) (r).main_lpbk_ctl[0] = 0
#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_SET(r,d) (r).main_lpbk_ctl[0] = d
#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_GET(r) (r).main_lpbk_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET(r) ((((r).main_lpbk_ctl[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).main_lpbk_ctl[0]=(((r).main_lpbk_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET(r) (((r).main_lpbk_ctl[0]) & 0xf)
#define BCMI_QTC_XGXS_MAIN_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).main_lpbk_ctl[0]=(((r).main_lpbk_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access MAIN_LPBK_CTL.
 */
#define BCMI_QTC_XGXS_READ_MAIN_LPBK_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_LPBK_CTLr,(_r._main_lpbk_ctl))
#define BCMI_QTC_XGXS_WRITE_MAIN_LPBK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_LPBK_CTLr,(_r._main_lpbk_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_LPBK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_LPBK_CTLr,(_r._main_lpbk_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_LPBK_CTLr BCMI_QTC_XGXS_MAIN_LPBK_CTLr
#define MAIN_LPBK_CTLr_SIZE BCMI_QTC_XGXS_MAIN_LPBK_CTLr_SIZE
typedef BCMI_QTC_XGXS_MAIN_LPBK_CTLr_t MAIN_LPBK_CTLr_t;
#define MAIN_LPBK_CTLr_CLR BCMI_QTC_XGXS_MAIN_LPBK_CTLr_CLR
#define MAIN_LPBK_CTLr_SET BCMI_QTC_XGXS_MAIN_LPBK_CTLr_SET
#define MAIN_LPBK_CTLr_GET BCMI_QTC_XGXS_MAIN_LPBK_CTLr_GET
#define MAIN_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET BCMI_QTC_XGXS_MAIN_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET
#define MAIN_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET BCMI_QTC_XGXS_MAIN_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET
#define MAIN_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET BCMI_QTC_XGXS_MAIN_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET
#define MAIN_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET BCMI_QTC_XGXS_MAIN_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET
#define READ_MAIN_LPBK_CTLr BCMI_QTC_XGXS_READ_MAIN_LPBK_CTLr
#define WRITE_MAIN_LPBK_CTLr BCMI_QTC_XGXS_WRITE_MAIN_LPBK_CTLr
#define MODIFY_MAIN_LPBK_CTLr BCMI_QTC_XGXS_MODIFY_MAIN_LPBK_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_LPBK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_MDIO_BCST
 * BLOCKS:   MAIN
 * REGADDR:  0x9006
 * DESC:     PRTAD Broadcast Values
 * SIZE:     32
 * FIELDS:
 *     MULTIPRTS_EN     per port Broadcast enable
 *     PRTAD_BCST       PORT VALUE FOR BROADCASTING TO MULTIPLE PORTS
 */
#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr (0x00109006 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_MDIO_BCST.
 */
typedef union BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_s {
	uint32_t v[1];
	uint32_t main_mdio_bcst[1];
	uint32_t _main_mdio_bcst;
} BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_t;

#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_CLR(r) (r).main_mdio_bcst[0] = 0
#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_SET(r,d) (r).main_mdio_bcst[0] = d
#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_GET(r) (r).main_mdio_bcst[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_PRTAD_BCSTf_GET(r) ((((r).main_mdio_bcst[0]) >> 11) & 0x1f)
#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_PRTAD_BCSTf_SET(r,f) (r).main_mdio_bcst[0]=(((r).main_mdio_bcst[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_MULTIPRTS_ENf_GET(r) ((((r).main_mdio_bcst[0]) >> 7) & 0xf)
#define BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_MULTIPRTS_ENf_SET(r,f) (r).main_mdio_bcst[0]=(((r).main_mdio_bcst[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7)) | (15 << (16 + 7))

/*
 * These macros can be used to access MAIN_MDIO_BCST.
 */
#define BCMI_QTC_XGXS_READ_MAIN_MDIO_BCSTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_MDIO_BCSTr,(_r._main_mdio_bcst))
#define BCMI_QTC_XGXS_WRITE_MAIN_MDIO_BCSTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_MDIO_BCSTr,(_r._main_mdio_bcst)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_MDIO_BCSTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_MDIO_BCSTr,(_r._main_mdio_bcst))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_MDIO_BCSTr BCMI_QTC_XGXS_MAIN_MDIO_BCSTr
#define MAIN_MDIO_BCSTr_SIZE BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_SIZE
typedef BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_t MAIN_MDIO_BCSTr_t;
#define MAIN_MDIO_BCSTr_CLR BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_CLR
#define MAIN_MDIO_BCSTr_SET BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_SET
#define MAIN_MDIO_BCSTr_GET BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_GET
#define MAIN_MDIO_BCSTr_PRTAD_BCSTf_GET BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_PRTAD_BCSTf_GET
#define MAIN_MDIO_BCSTr_PRTAD_BCSTf_SET BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_PRTAD_BCSTf_SET
#define MAIN_MDIO_BCSTr_MULTIPRTS_ENf_GET BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_MULTIPRTS_ENf_GET
#define MAIN_MDIO_BCSTr_MULTIPRTS_ENf_SET BCMI_QTC_XGXS_MAIN_MDIO_BCSTr_MULTIPRTS_ENf_SET
#define READ_MAIN_MDIO_BCSTr BCMI_QTC_XGXS_READ_MAIN_MDIO_BCSTr
#define WRITE_MAIN_MDIO_BCSTr BCMI_QTC_XGXS_WRITE_MAIN_MDIO_BCSTr
#define MODIFY_MAIN_MDIO_BCSTr BCMI_QTC_XGXS_MODIFY_MAIN_MDIO_BCSTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_MDIO_BCSTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SERDESID
 * BLOCKS:   MAIN
 * REGADDR:  0x9007
 * DESC:     Serdes ID Register
 * SIZE:     32
 * FIELDS:
 *     MODEL_NUMBER     Same as phyID model number00 = SERDES_CL73 (ComboCore, 65nm)01 = XGXS_16G02 = Hypercore03 = Hyperlite04 = PCIE_G2_PIPE05 = 1.25GBd Serdes06 = SATA207 = QSGMII08 = XGXS10G09 = WarpCore0A = XFICore0B = RXFI, Reduced XFI0C = WarpLite0D = PentaCore0E = ESM0F = Quad_SGMII10 = WarpCore 311 = TSC12 = TSCE413 = TSCE1214 = TSCF415 = QTC1D = XGXS_CL73, 90nm1E = SERDES_CL73, 90nm20 = WarpCore321 = WarpCore4 TSC22 = RXAUI
 *     TECH_PROC        0 = 90nm1 = 65nm2 = 40nm3 = 28nm4-7 = reserved
 *     BONDING          0 = wire bond1 = flip chip2-3 = reserved
 *     REV_NUMBER       0 = rev 01 = rev 1...7 = rev 7
 *     REV_LETTER       0 = rev A1 = rev B2 = rev C3 = rev D
 */
#define BCMI_QTC_XGXS_MAIN_SERDESIDr (0x00109007 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SERDESIDr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SERDESID.
 */
typedef union BCMI_QTC_XGXS_MAIN_SERDESIDr_s {
	uint32_t v[1];
	uint32_t main_serdesid[1];
	uint32_t _main_serdesid;
} BCMI_QTC_XGXS_MAIN_SERDESIDr_t;

#define BCMI_QTC_XGXS_MAIN_SERDESIDr_CLR(r) (r).main_serdesid[0] = 0
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_SET(r,d) (r).main_serdesid[0] = d
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_GET(r) (r).main_serdesid[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_LETTERf_GET(r) ((((r).main_serdesid[0]) >> 14) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_LETTERf_SET(r,f) (r).main_serdesid[0]=(((r).main_serdesid[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_NUMBERf_GET(r) ((((r).main_serdesid[0]) >> 11) & 0x7)
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_NUMBERf_SET(r,f) (r).main_serdesid[0]=(((r).main_serdesid[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_BONDINGf_GET(r) ((((r).main_serdesid[0]) >> 9) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_BONDINGf_SET(r,f) (r).main_serdesid[0]=(((r).main_serdesid[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_TECH_PROCf_GET(r) ((((r).main_serdesid[0]) >> 6) & 0x7)
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_TECH_PROCf_SET(r,f) (r).main_serdesid[0]=(((r).main_serdesid[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_MODEL_NUMBERf_GET(r) (((r).main_serdesid[0]) & 0x3f)
#define BCMI_QTC_XGXS_MAIN_SERDESIDr_MODEL_NUMBERf_SET(r,f) (r).main_serdesid[0]=(((r).main_serdesid[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access MAIN_SERDESID.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SERDESIDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SERDESIDr,(_r._main_serdesid))
#define BCMI_QTC_XGXS_WRITE_MAIN_SERDESIDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SERDESIDr,(_r._main_serdesid)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SERDESIDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SERDESIDr,(_r._main_serdesid))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SERDESIDr BCMI_QTC_XGXS_MAIN_SERDESIDr
#define MAIN_SERDESIDr_SIZE BCMI_QTC_XGXS_MAIN_SERDESIDr_SIZE
typedef BCMI_QTC_XGXS_MAIN_SERDESIDr_t MAIN_SERDESIDr_t;
#define MAIN_SERDESIDr_CLR BCMI_QTC_XGXS_MAIN_SERDESIDr_CLR
#define MAIN_SERDESIDr_SET BCMI_QTC_XGXS_MAIN_SERDESIDr_SET
#define MAIN_SERDESIDr_GET BCMI_QTC_XGXS_MAIN_SERDESIDr_GET
#define MAIN_SERDESIDr_REV_LETTERf_GET BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_LETTERf_GET
#define MAIN_SERDESIDr_REV_LETTERf_SET BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_LETTERf_SET
#define MAIN_SERDESIDr_REV_NUMBERf_GET BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_NUMBERf_GET
#define MAIN_SERDESIDr_REV_NUMBERf_SET BCMI_QTC_XGXS_MAIN_SERDESIDr_REV_NUMBERf_SET
#define MAIN_SERDESIDr_BONDINGf_GET BCMI_QTC_XGXS_MAIN_SERDESIDr_BONDINGf_GET
#define MAIN_SERDESIDr_BONDINGf_SET BCMI_QTC_XGXS_MAIN_SERDESIDr_BONDINGf_SET
#define MAIN_SERDESIDr_TECH_PROCf_GET BCMI_QTC_XGXS_MAIN_SERDESIDr_TECH_PROCf_GET
#define MAIN_SERDESIDr_TECH_PROCf_SET BCMI_QTC_XGXS_MAIN_SERDESIDr_TECH_PROCf_SET
#define MAIN_SERDESIDr_MODEL_NUMBERf_GET BCMI_QTC_XGXS_MAIN_SERDESIDr_MODEL_NUMBERf_GET
#define MAIN_SERDESIDr_MODEL_NUMBERf_SET BCMI_QTC_XGXS_MAIN_SERDESIDr_MODEL_NUMBERf_SET
#define READ_MAIN_SERDESIDr BCMI_QTC_XGXS_READ_MAIN_SERDESIDr
#define WRITE_MAIN_SERDESIDr BCMI_QTC_XGXS_WRITE_MAIN_SERDESIDr
#define MODIFY_MAIN_SERDESIDr BCMI_QTC_XGXS_MODIFY_MAIN_SERDESIDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SERDESIDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SYNCE_CTL
 * BLOCKS:   MAIN
 * REGADDR:  0x9008
 * DESC:     SyncE mode register
 * SIZE:     32
 * FIELDS:
 *     SYNCE_MODE0_PHY_LN0 clock divider for synce clock generation
 *     SYNCE_MODE1_PHY_LN0 clock divider for synce clock generation
 *     SYNCE_MODE0_PHY_LN1 clock divider for synce clock generation
 *     SYNCE_MODE1_PHY_LN1 clock divider for synce clock generation
 *     SYNCE_MODE0_PHY_LN2 clock divider for synce clock generation
 *     SYNCE_MODE1_PHY_LN2 clock divider for synce clock generation
 *     SYNCE_MODE0_PHY_LN3 clock divider for synce clock generationThere are 3 divider options in stage 0 divider.1. f*4/5: this option drops the 5th clock in each 5-clock period2. SDM_frac_div: this option uses SDM (Sigma-delta Modulator) to enable fractional divider.syncE_SDM_divisor[15:0] should be programmed with appropriate value to achieve desired fractional divider.3. By Pass (div 1): no divider applied.
 *     SYNCE_MODE1_PHY_LN3 clock divider for synce clock generationDiv 7: this option divides its incoming clock by 7Div 11: this option divides its incoming clock by 11Div 1: this options divides its incoming clock by 1 or by pass
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr (0x00109008 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SYNCE_CTL.
 */
typedef union BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_s {
	uint32_t v[1];
	uint32_t main_synce_ctl[1];
	uint32_t _main_synce_ctl;
} BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_t;

#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_CLR(r) (r).main_synce_ctl[0] = 0
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SET(r,d) (r).main_synce_ctl[0] = d
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_GET(r) (r).main_synce_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN3f_GET(r) ((((r).main_synce_ctl[0]) >> 14) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN3f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN3f_GET(r) ((((r).main_synce_ctl[0]) >> 12) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN3f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN2f_GET(r) ((((r).main_synce_ctl[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN2f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN2f_GET(r) ((((r).main_synce_ctl[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN2f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN1f_GET(r) ((((r).main_synce_ctl[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN1f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN1f_GET(r) ((((r).main_synce_ctl[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN1f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN0f_GET(r) ((((r).main_synce_ctl[0]) >> 2) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN0f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN0f_GET(r) (((r).main_synce_ctl[0]) & 0x3)
#define BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN0f_SET(r,f) (r).main_synce_ctl[0]=(((r).main_synce_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access MAIN_SYNCE_CTL.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SYNCE_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_CTLr,(_r._main_synce_ctl))
#define BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_CTLr,(_r._main_synce_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_CTLr,(_r._main_synce_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SYNCE_CTLr BCMI_QTC_XGXS_MAIN_SYNCE_CTLr
#define MAIN_SYNCE_CTLr_SIZE BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SIZE
typedef BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_t MAIN_SYNCE_CTLr_t;
#define MAIN_SYNCE_CTLr_CLR BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_CLR
#define MAIN_SYNCE_CTLr_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SET
#define MAIN_SYNCE_CTLr_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN3f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN3f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN3f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN3f_SET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN3f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN3f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN3f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN3f_SET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN2f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN2f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN2f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN2f_SET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN2f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN2f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN2f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN2f_SET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN1f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN1f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN1f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN1f_SET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN1f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN1f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN1f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN1f_SET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN0f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN0f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN0f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE1_PHY_LN0f_SET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN0f_GET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN0f_GET
#define MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN0f_SET BCMI_QTC_XGXS_MAIN_SYNCE_CTLr_SYNCE_MODE0_PHY_LN0f_SET
#define READ_MAIN_SYNCE_CTLr BCMI_QTC_XGXS_READ_MAIN_SYNCE_CTLr
#define WRITE_MAIN_SYNCE_CTLr BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_CTLr
#define MODIFY_MAIN_SYNCE_CTLr BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SYNCE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SYNCE_DIVISOR0_PHY_LN0
 * BLOCKS:   MAIN
 * REGADDR:  0x9009
 * DESC:     SyncE fractional divisor
 * SIZE:     32
 * FIELDS:
 *     SYNCE_DIVISOR0   fractional divisorPer physical lane:Program this register for different divider as the following table:f_cdr(Hz)      config divisor[15:0]  resulted fractional divider :Eagle         515,625,000     5280                  20.625546,875,000     5600                  21.875Falcon        644,531,250     6600                  25.78125683,593,750     7000                  27.34375515,625,000     5280                  20.625257,812,500     2640                  10.3125156,250,000     1600                  6.25515,625,000     5280                  20.625resulted fractional divider  =       config division[15:0]/256
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r (0x00109009 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SYNCE_DIVISOR0_PHY_LN0.
 */
typedef union BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_s {
	uint32_t v[1];
	uint32_t main_synce_divisor0_phy_ln0[1];
	uint32_t _main_synce_divisor0_phy_ln0;
} BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_t;

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_CLR(r) (r).main_synce_divisor0_phy_ln0[0] = 0
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SET(r,d) (r).main_synce_divisor0_phy_ln0[0] = d
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_GET(r) (r).main_synce_divisor0_phy_ln0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SYNCE_DIVISOR0f_GET(r) (((r).main_synce_divisor0_phy_ln0[0]) & 0xffff)
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SYNCE_DIVISOR0f_SET(r,f) (r).main_synce_divisor0_phy_ln0[0]=(((r).main_synce_divisor0_phy_ln0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access MAIN_SYNCE_DIVISOR0_PHY_LN0.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR0_PHY_LN0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r,(_r._main_synce_divisor0_phy_ln0))
#define BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR0_PHY_LN0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r,(_r._main_synce_divisor0_phy_ln0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR0_PHY_LN0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r,(_r._main_synce_divisor0_phy_ln0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SYNCE_DIVISOR0_PHY_LN0r BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r
#define MAIN_SYNCE_DIVISOR0_PHY_LN0r_SIZE BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SIZE
typedef BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_t MAIN_SYNCE_DIVISOR0_PHY_LN0r_t;
#define MAIN_SYNCE_DIVISOR0_PHY_LN0r_CLR BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_CLR
#define MAIN_SYNCE_DIVISOR0_PHY_LN0r_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SET
#define MAIN_SYNCE_DIVISOR0_PHY_LN0r_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_GET
#define MAIN_SYNCE_DIVISOR0_PHY_LN0r_SYNCE_DIVISOR0f_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SYNCE_DIVISOR0f_GET
#define MAIN_SYNCE_DIVISOR0_PHY_LN0r_SYNCE_DIVISOR0f_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r_SYNCE_DIVISOR0f_SET
#define READ_MAIN_SYNCE_DIVISOR0_PHY_LN0r BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR0_PHY_LN0r
#define WRITE_MAIN_SYNCE_DIVISOR0_PHY_LN0r BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR0_PHY_LN0r
#define MODIFY_MAIN_SYNCE_DIVISOR0_PHY_LN0r BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR0_PHY_LN0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR0_PHY_LN0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SYNCE_DIVISOR1_PHY_LN1
 * BLOCKS:   MAIN
 * REGADDR:  0x900a
 * DESC:     SyncE fractional divisor
 * SIZE:     32
 * FIELDS:
 *     SYNCE_DIVISOR1   fractional divisor
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r (0x0010900a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SYNCE_DIVISOR1_PHY_LN1.
 */
typedef union BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_s {
	uint32_t v[1];
	uint32_t main_synce_divisor1_phy_ln1[1];
	uint32_t _main_synce_divisor1_phy_ln1;
} BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_t;

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_CLR(r) (r).main_synce_divisor1_phy_ln1[0] = 0
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SET(r,d) (r).main_synce_divisor1_phy_ln1[0] = d
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_GET(r) (r).main_synce_divisor1_phy_ln1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SYNCE_DIVISOR1f_GET(r) (((r).main_synce_divisor1_phy_ln1[0]) & 0xffff)
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SYNCE_DIVISOR1f_SET(r,f) (r).main_synce_divisor1_phy_ln1[0]=(((r).main_synce_divisor1_phy_ln1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access MAIN_SYNCE_DIVISOR1_PHY_LN1.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR1_PHY_LN1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r,(_r._main_synce_divisor1_phy_ln1))
#define BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR1_PHY_LN1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r,(_r._main_synce_divisor1_phy_ln1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR1_PHY_LN1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r,(_r._main_synce_divisor1_phy_ln1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SYNCE_DIVISOR1_PHY_LN1r BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r
#define MAIN_SYNCE_DIVISOR1_PHY_LN1r_SIZE BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SIZE
typedef BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_t MAIN_SYNCE_DIVISOR1_PHY_LN1r_t;
#define MAIN_SYNCE_DIVISOR1_PHY_LN1r_CLR BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_CLR
#define MAIN_SYNCE_DIVISOR1_PHY_LN1r_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SET
#define MAIN_SYNCE_DIVISOR1_PHY_LN1r_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_GET
#define MAIN_SYNCE_DIVISOR1_PHY_LN1r_SYNCE_DIVISOR1f_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SYNCE_DIVISOR1f_GET
#define MAIN_SYNCE_DIVISOR1_PHY_LN1r_SYNCE_DIVISOR1f_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r_SYNCE_DIVISOR1f_SET
#define READ_MAIN_SYNCE_DIVISOR1_PHY_LN1r BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR1_PHY_LN1r
#define WRITE_MAIN_SYNCE_DIVISOR1_PHY_LN1r BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR1_PHY_LN1r
#define MODIFY_MAIN_SYNCE_DIVISOR1_PHY_LN1r BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR1_PHY_LN1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR1_PHY_LN1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SYNCE_DIVISOR2_PHY_LN2
 * BLOCKS:   MAIN
 * REGADDR:  0x900b
 * DESC:     SyncE fractional divisor
 * SIZE:     32
 * FIELDS:
 *     SYNCE_DIVISOR2   fractional divisor
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r (0x0010900b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SYNCE_DIVISOR2_PHY_LN2.
 */
typedef union BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_s {
	uint32_t v[1];
	uint32_t main_synce_divisor2_phy_ln2[1];
	uint32_t _main_synce_divisor2_phy_ln2;
} BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_t;

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_CLR(r) (r).main_synce_divisor2_phy_ln2[0] = 0
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SET(r,d) (r).main_synce_divisor2_phy_ln2[0] = d
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_GET(r) (r).main_synce_divisor2_phy_ln2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SYNCE_DIVISOR2f_GET(r) (((r).main_synce_divisor2_phy_ln2[0]) & 0xffff)
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SYNCE_DIVISOR2f_SET(r,f) (r).main_synce_divisor2_phy_ln2[0]=(((r).main_synce_divisor2_phy_ln2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access MAIN_SYNCE_DIVISOR2_PHY_LN2.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR2_PHY_LN2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r,(_r._main_synce_divisor2_phy_ln2))
#define BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR2_PHY_LN2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r,(_r._main_synce_divisor2_phy_ln2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR2_PHY_LN2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r,(_r._main_synce_divisor2_phy_ln2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SYNCE_DIVISOR2_PHY_LN2r BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r
#define MAIN_SYNCE_DIVISOR2_PHY_LN2r_SIZE BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SIZE
typedef BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_t MAIN_SYNCE_DIVISOR2_PHY_LN2r_t;
#define MAIN_SYNCE_DIVISOR2_PHY_LN2r_CLR BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_CLR
#define MAIN_SYNCE_DIVISOR2_PHY_LN2r_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SET
#define MAIN_SYNCE_DIVISOR2_PHY_LN2r_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_GET
#define MAIN_SYNCE_DIVISOR2_PHY_LN2r_SYNCE_DIVISOR2f_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SYNCE_DIVISOR2f_GET
#define MAIN_SYNCE_DIVISOR2_PHY_LN2r_SYNCE_DIVISOR2f_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r_SYNCE_DIVISOR2f_SET
#define READ_MAIN_SYNCE_DIVISOR2_PHY_LN2r BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR2_PHY_LN2r
#define WRITE_MAIN_SYNCE_DIVISOR2_PHY_LN2r BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR2_PHY_LN2r
#define MODIFY_MAIN_SYNCE_DIVISOR2_PHY_LN2r BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR2_PHY_LN2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR2_PHY_LN2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SYNCE_DIVISOR3_PHY_LN3
 * BLOCKS:   MAIN
 * REGADDR:  0x900c
 * DESC:     SyncE fractional divisor
 * SIZE:     32
 * FIELDS:
 *     SYNCE_DIVISOR3   fractional divisor
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r (0x0010900c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SYNCE_DIVISOR3_PHY_LN3.
 */
typedef union BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_s {
	uint32_t v[1];
	uint32_t main_synce_divisor3_phy_ln3[1];
	uint32_t _main_synce_divisor3_phy_ln3;
} BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_t;

#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_CLR(r) (r).main_synce_divisor3_phy_ln3[0] = 0
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SET(r,d) (r).main_synce_divisor3_phy_ln3[0] = d
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_GET(r) (r).main_synce_divisor3_phy_ln3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SYNCE_DIVISOR3f_GET(r) (((r).main_synce_divisor3_phy_ln3[0]) & 0xffff)
#define BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SYNCE_DIVISOR3f_SET(r,f) (r).main_synce_divisor3_phy_ln3[0]=(((r).main_synce_divisor3_phy_ln3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access MAIN_SYNCE_DIVISOR3_PHY_LN3.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR3_PHY_LN3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r,(_r._main_synce_divisor3_phy_ln3))
#define BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR3_PHY_LN3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r,(_r._main_synce_divisor3_phy_ln3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR3_PHY_LN3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r,(_r._main_synce_divisor3_phy_ln3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SYNCE_DIVISOR3_PHY_LN3r BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r
#define MAIN_SYNCE_DIVISOR3_PHY_LN3r_SIZE BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SIZE
typedef BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_t MAIN_SYNCE_DIVISOR3_PHY_LN3r_t;
#define MAIN_SYNCE_DIVISOR3_PHY_LN3r_CLR BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_CLR
#define MAIN_SYNCE_DIVISOR3_PHY_LN3r_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SET
#define MAIN_SYNCE_DIVISOR3_PHY_LN3r_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_GET
#define MAIN_SYNCE_DIVISOR3_PHY_LN3r_SYNCE_DIVISOR3f_GET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SYNCE_DIVISOR3f_GET
#define MAIN_SYNCE_DIVISOR3_PHY_LN3r_SYNCE_DIVISOR3f_SET BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r_SYNCE_DIVISOR3f_SET
#define READ_MAIN_SYNCE_DIVISOR3_PHY_LN3r BCMI_QTC_XGXS_READ_MAIN_SYNCE_DIVISOR3_PHY_LN3r
#define WRITE_MAIN_SYNCE_DIVISOR3_PHY_LN3r BCMI_QTC_XGXS_WRITE_MAIN_SYNCE_DIVISOR3_PHY_LN3r
#define MODIFY_MAIN_SYNCE_DIVISOR3_PHY_LN3r BCMI_QTC_XGXS_MODIFY_MAIN_SYNCE_DIVISOR3_PHY_LN3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SYNCE_DIVISOR3_PHY_LN3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_UNIMAC_SHIM_CLK
 * BLOCKS:   MAIN
 * REGADDR:  0x900d
 * DESC:     unimac shim clock gating  control
 * SIZE:     32
 * FIELDS:
 *     SHIM_TX_CLK_GATE_DISABLE 1: disable tx clk gating on unimac shim
 *     SHIM_RX_CLK_GATE_DISABLE 1: disable rx clk gating on unimac shim
 */
#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr (0x0010900d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_UNIMAC_SHIM_CLK.
 */
typedef union BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_s {
	uint32_t v[1];
	uint32_t main_unimac_shim_clk[1];
	uint32_t _main_unimac_shim_clk;
} BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_t;

#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_CLR(r) (r).main_unimac_shim_clk[0] = 0
#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SET(r,d) (r).main_unimac_shim_clk[0] = d
#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_GET(r) (r).main_unimac_shim_clk[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_RX_CLK_GATE_DISABLEf_GET(r) ((((r).main_unimac_shim_clk[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_RX_CLK_GATE_DISABLEf_SET(r,f) (r).main_unimac_shim_clk[0]=(((r).main_unimac_shim_clk[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_TX_CLK_GATE_DISABLEf_GET(r) (((r).main_unimac_shim_clk[0]) & 0xf)
#define BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_TX_CLK_GATE_DISABLEf_SET(r,f) (r).main_unimac_shim_clk[0]=(((r).main_unimac_shim_clk[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access MAIN_UNIMAC_SHIM_CLK.
 */
#define BCMI_QTC_XGXS_READ_MAIN_UNIMAC_SHIM_CLKr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr,(_r._main_unimac_shim_clk))
#define BCMI_QTC_XGXS_WRITE_MAIN_UNIMAC_SHIM_CLKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr,(_r._main_unimac_shim_clk)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_UNIMAC_SHIM_CLKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr,(_r._main_unimac_shim_clk))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_UNIMAC_SHIM_CLKr BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr
#define MAIN_UNIMAC_SHIM_CLKr_SIZE BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SIZE
typedef BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_t MAIN_UNIMAC_SHIM_CLKr_t;
#define MAIN_UNIMAC_SHIM_CLKr_CLR BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_CLR
#define MAIN_UNIMAC_SHIM_CLKr_SET BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SET
#define MAIN_UNIMAC_SHIM_CLKr_GET BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_GET
#define MAIN_UNIMAC_SHIM_CLKr_SHIM_RX_CLK_GATE_DISABLEf_GET BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_RX_CLK_GATE_DISABLEf_GET
#define MAIN_UNIMAC_SHIM_CLKr_SHIM_RX_CLK_GATE_DISABLEf_SET BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_RX_CLK_GATE_DISABLEf_SET
#define MAIN_UNIMAC_SHIM_CLKr_SHIM_TX_CLK_GATE_DISABLEf_GET BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_TX_CLK_GATE_DISABLEf_GET
#define MAIN_UNIMAC_SHIM_CLKr_SHIM_TX_CLK_GATE_DISABLEf_SET BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr_SHIM_TX_CLK_GATE_DISABLEf_SET
#define READ_MAIN_UNIMAC_SHIM_CLKr BCMI_QTC_XGXS_READ_MAIN_UNIMAC_SHIM_CLKr
#define WRITE_MAIN_UNIMAC_SHIM_CLKr BCMI_QTC_XGXS_WRITE_MAIN_UNIMAC_SHIM_CLKr
#define MODIFY_MAIN_UNIMAC_SHIM_CLKr BCMI_QTC_XGXS_MODIFY_MAIN_UNIMAC_SHIM_CLKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_UNIMAC_SHIM_CLKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MAIN_SHIM_FF_THR
 * BLOCKS:   MAIN
 * REGADDR:  0x900e
 * DESC:     shim fifo threshold control
 * SIZE:     32
 * FIELDS:
 *     SHIM_FF_THRESHOLD_10M threshold for 10M Unimac interface
 *     SHIM_FF_THRESHOLD_100M threshold for 100M Unimac interface
 *     SHIM_FF_THRESHOLD_1G threshold for 1G Unimac interface
 *     SHIM_FF_THRESHOLD_2P5G threshold for 2.5G Unimac interface
 */
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr (0x0010900e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SIZE 4

/*
 * This structure should be used to declare and program MAIN_SHIM_FF_THR.
 */
typedef union BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_s {
	uint32_t v[1];
	uint32_t main_shim_ff_thr[1];
	uint32_t _main_shim_ff_thr;
} BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_t;

#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_CLR(r) (r).main_shim_ff_thr[0] = 0
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SET(r,d) (r).main_shim_ff_thr[0] = d
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_GET(r) (r).main_shim_ff_thr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_2P5Gf_GET(r) ((((r).main_shim_ff_thr[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_2P5Gf_SET(r,f) (r).main_shim_ff_thr[0]=(((r).main_shim_ff_thr[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_1Gf_GET(r) ((((r).main_shim_ff_thr[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_1Gf_SET(r,f) (r).main_shim_ff_thr[0]=(((r).main_shim_ff_thr[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_100Mf_GET(r) ((((r).main_shim_ff_thr[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_100Mf_SET(r,f) (r).main_shim_ff_thr[0]=(((r).main_shim_ff_thr[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_10Mf_GET(r) (((r).main_shim_ff_thr[0]) & 0xf)
#define BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_10Mf_SET(r,f) (r).main_shim_ff_thr[0]=(((r).main_shim_ff_thr[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access MAIN_SHIM_FF_THR.
 */
#define BCMI_QTC_XGXS_READ_MAIN_SHIM_FF_THRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr,(_r._main_shim_ff_thr))
#define BCMI_QTC_XGXS_WRITE_MAIN_SHIM_FF_THRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr,(_r._main_shim_ff_thr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MAIN_SHIM_FF_THRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr,(_r._main_shim_ff_thr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MAIN_SHIM_FF_THRr BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr
#define MAIN_SHIM_FF_THRr_SIZE BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SIZE
typedef BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_t MAIN_SHIM_FF_THRr_t;
#define MAIN_SHIM_FF_THRr_CLR BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_CLR
#define MAIN_SHIM_FF_THRr_SET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SET
#define MAIN_SHIM_FF_THRr_GET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_GET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_2P5Gf_GET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_2P5Gf_GET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_2P5Gf_SET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_2P5Gf_SET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_1Gf_GET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_1Gf_GET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_1Gf_SET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_1Gf_SET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_100Mf_GET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_100Mf_GET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_100Mf_SET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_100Mf_SET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_10Mf_GET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_10Mf_GET
#define MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_10Mf_SET BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr_SHIM_FF_THRESHOLD_10Mf_SET
#define READ_MAIN_SHIM_FF_THRr BCMI_QTC_XGXS_READ_MAIN_SHIM_FF_THRr
#define WRITE_MAIN_SHIM_FF_THRr BCMI_QTC_XGXS_WRITE_MAIN_SHIM_FF_THRr
#define MODIFY_MAIN_SHIM_FF_THRr BCMI_QTC_XGXS_MODIFY_MAIN_SHIM_FF_THRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MAIN_SHIM_FF_THRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X1_CTL
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9010
 * DESC:     Global PMD reset controls
 * SIZE:     32
 * FIELDS:
 *     CORE_DP_H_RSTB   PMD Core data path reset override valueOnly used for Speed Control bypass operationby default is zero too keep PMD in reset till enabled
 *     POR_H_RSTB       PMD Core power on resetby default is zero too keep PMD in reset till enabled
 *     PRAM_ABILITY     enable direct pram interface writes
 */
#define BCMI_QTC_XGXS_PMD_X1_CTLr (0x00109010 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_CTL.
 */
typedef union BCMI_QTC_XGXS_PMD_X1_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x1_ctl[1];
	uint32_t _pmd_x1_ctl;
} BCMI_QTC_XGXS_PMD_X1_CTLr_t;

#define BCMI_QTC_XGXS_PMD_X1_CTLr_CLR(r) (r).pmd_x1_ctl[0] = 0
#define BCMI_QTC_XGXS_PMD_X1_CTLr_SET(r,d) (r).pmd_x1_ctl[0] = d
#define BCMI_QTC_XGXS_PMD_X1_CTLr_GET(r) (r).pmd_x1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_GET(r) ((((r).pmd_x1_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET(r) ((((r).pmd_x1_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET(r) (((r).pmd_x1_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X1_CTL.
 */
#define BCMI_QTC_XGXS_READ_PMD_X1_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))
#define BCMI_QTC_XGXS_WRITE_PMD_X1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_CTLr BCMI_QTC_XGXS_PMD_X1_CTLr
#define PMD_X1_CTLr_SIZE BCMI_QTC_XGXS_PMD_X1_CTLr_SIZE
typedef BCMI_QTC_XGXS_PMD_X1_CTLr_t PMD_X1_CTLr_t;
#define PMD_X1_CTLr_CLR BCMI_QTC_XGXS_PMD_X1_CTLr_CLR
#define PMD_X1_CTLr_SET BCMI_QTC_XGXS_PMD_X1_CTLr_SET
#define PMD_X1_CTLr_GET BCMI_QTC_XGXS_PMD_X1_CTLr_GET
#define PMD_X1_CTLr_PRAM_ABILITYf_GET BCMI_QTC_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_GET
#define PMD_X1_CTLr_PRAM_ABILITYf_SET BCMI_QTC_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_SET
#define PMD_X1_CTLr_POR_H_RSTBf_GET BCMI_QTC_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET
#define PMD_X1_CTLr_POR_H_RSTBf_SET BCMI_QTC_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_GET BCMI_QTC_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_SET BCMI_QTC_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET
#define READ_PMD_X1_CTLr BCMI_QTC_XGXS_READ_PMD_X1_CTLr
#define WRITE_PMD_X1_CTLr BCMI_QTC_XGXS_WRITE_PMD_X1_CTLr
#define MODIFY_PMD_X1_CTLr BCMI_QTC_XGXS_MODIFY_PMD_X1_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X1_MODE
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9011
 * DESC:     Global PMD mode configuration
 * SIZE:     32
 * FIELDS:
 *     CORE_MODE        PMD code modeUse the following format: {reserved[3:0], otp_options[3:0], speed_id[7:0]}Only used when Speed Control logic is bypassed
 */
#define BCMI_QTC_XGXS_PMD_X1_MODEr (0x00109011 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X1_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_MODE.
 */
typedef union BCMI_QTC_XGXS_PMD_X1_MODEr_s {
	uint32_t v[1];
	uint32_t pmd_x1_mode[1];
	uint32_t _pmd_x1_mode;
} BCMI_QTC_XGXS_PMD_X1_MODEr_t;

#define BCMI_QTC_XGXS_PMD_X1_MODEr_CLR(r) (r).pmd_x1_mode[0] = 0
#define BCMI_QTC_XGXS_PMD_X1_MODEr_SET(r,d) (r).pmd_x1_mode[0] = d
#define BCMI_QTC_XGXS_PMD_X1_MODEr_GET(r) (r).pmd_x1_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X1_MODEr_CORE_MODEf_GET(r) (((r).pmd_x1_mode[0]) & 0xffff)
#define BCMI_QTC_XGXS_PMD_X1_MODEr_CORE_MODEf_SET(r,f) (r).pmd_x1_mode[0]=(((r).pmd_x1_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PMD_X1_MODE.
 */
#define BCMI_QTC_XGXS_READ_PMD_X1_MODEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode))
#define BCMI_QTC_XGXS_WRITE_PMD_X1_MODEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X1_MODEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_MODEr BCMI_QTC_XGXS_PMD_X1_MODEr
#define PMD_X1_MODEr_SIZE BCMI_QTC_XGXS_PMD_X1_MODEr_SIZE
typedef BCMI_QTC_XGXS_PMD_X1_MODEr_t PMD_X1_MODEr_t;
#define PMD_X1_MODEr_CLR BCMI_QTC_XGXS_PMD_X1_MODEr_CLR
#define PMD_X1_MODEr_SET BCMI_QTC_XGXS_PMD_X1_MODEr_SET
#define PMD_X1_MODEr_GET BCMI_QTC_XGXS_PMD_X1_MODEr_GET
#define PMD_X1_MODEr_CORE_MODEf_GET BCMI_QTC_XGXS_PMD_X1_MODEr_CORE_MODEf_GET
#define PMD_X1_MODEr_CORE_MODEf_SET BCMI_QTC_XGXS_PMD_X1_MODEr_CORE_MODEf_SET
#define READ_PMD_X1_MODEr BCMI_QTC_XGXS_READ_PMD_X1_MODEr
#define WRITE_PMD_X1_MODEr BCMI_QTC_XGXS_WRITE_PMD_X1_MODEr
#define MODIFY_PMD_X1_MODEr BCMI_QTC_XGXS_MODIFY_PMD_X1_MODEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X1_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X1_STS
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9012
 * DESC:     Global PMD live status
 * SIZE:     32
 * FIELDS:
 *     PLL_LOCK_STS     PMD PLL lock indication
 *     TX_CLK_VLD_STS   tx_clk_vld indication from PMD
 */
#define BCMI_QTC_XGXS_PMD_X1_STSr (0x00109012 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X1_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_STS.
 */
typedef union BCMI_QTC_XGXS_PMD_X1_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x1_sts[1];
	uint32_t _pmd_x1_sts;
} BCMI_QTC_XGXS_PMD_X1_STSr_t;

#define BCMI_QTC_XGXS_PMD_X1_STSr_CLR(r) (r).pmd_x1_sts[0] = 0
#define BCMI_QTC_XGXS_PMD_X1_STSr_SET(r,d) (r).pmd_x1_sts[0] = d
#define BCMI_QTC_XGXS_PMD_X1_STSr_GET(r) (r).pmd_x1_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X1_STSr_TX_CLK_VLD_STSf_GET(r) ((((r).pmd_x1_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_STSr_TX_CLK_VLD_STSf_SET(r,f) (r).pmd_x1_sts[0]=(((r).pmd_x1_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_GET(r) (((r).pmd_x1_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_SET(r,f) (r).pmd_x1_sts[0]=(((r).pmd_x1_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X1_STS.
 */
#define BCMI_QTC_XGXS_READ_PMD_X1_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts))
#define BCMI_QTC_XGXS_WRITE_PMD_X1_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X1_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_STSr BCMI_QTC_XGXS_PMD_X1_STSr
#define PMD_X1_STSr_SIZE BCMI_QTC_XGXS_PMD_X1_STSr_SIZE
typedef BCMI_QTC_XGXS_PMD_X1_STSr_t PMD_X1_STSr_t;
#define PMD_X1_STSr_CLR BCMI_QTC_XGXS_PMD_X1_STSr_CLR
#define PMD_X1_STSr_SET BCMI_QTC_XGXS_PMD_X1_STSr_SET
#define PMD_X1_STSr_GET BCMI_QTC_XGXS_PMD_X1_STSr_GET
#define PMD_X1_STSr_TX_CLK_VLD_STSf_GET BCMI_QTC_XGXS_PMD_X1_STSr_TX_CLK_VLD_STSf_GET
#define PMD_X1_STSr_TX_CLK_VLD_STSf_SET BCMI_QTC_XGXS_PMD_X1_STSr_TX_CLK_VLD_STSf_SET
#define PMD_X1_STSr_PLL_LOCK_STSf_GET BCMI_QTC_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_GET
#define PMD_X1_STSr_PLL_LOCK_STSf_SET BCMI_QTC_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_SET
#define READ_PMD_X1_STSr BCMI_QTC_XGXS_READ_PMD_X1_STSr
#define WRITE_PMD_X1_STSr BCMI_QTC_XGXS_WRITE_PMD_X1_STSr
#define MODIFY_PMD_X1_STSr BCMI_QTC_XGXS_MODIFY_PMD_X1_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X1_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X1_LATCH_STS
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9013
 * DESC:     Global PMD latched status
 * SIZE:     32
 * FIELDS:
 *     PLL_LOCK_LL      PMD PLL lock indication negedge detected
 *     PLL_LOCK_LH      PMD PLL lock indication posedge detected
 *     TX_CLK_VLD_LL    tx_clk_vld indication from PMD negedge detected
 *     TX_CLK_VLD_LH    tx_clk_vld indication from PMD posedge detected
 */
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr (0x00109013 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_LATCH_STS.
 */
typedef union BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x1_latch_sts[1];
	uint32_t _pmd_x1_latch_sts;
} BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_t;

#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_CLR(r) (r).pmd_x1_latch_sts[0] = 0
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_SET(r,d) (r).pmd_x1_latch_sts[0] = d
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_GET(r) (r).pmd_x1_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LHf_GET(r) ((((r).pmd_x1_latch_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LHf_SET(r,f) (r).pmd_x1_latch_sts[0]=(((r).pmd_x1_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LLf_GET(r) ((((r).pmd_x1_latch_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LLf_SET(r,f) (r).pmd_x1_latch_sts[0]=(((r).pmd_x1_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_GET(r) ((((r).pmd_x1_latch_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_SET(r,f) (r).pmd_x1_latch_sts[0]=(((r).pmd_x1_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_GET(r) (((r).pmd_x1_latch_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_SET(r,f) (r).pmd_x1_latch_sts[0]=(((r).pmd_x1_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X1_LATCH_STS.
 */
#define BCMI_QTC_XGXS_READ_PMD_X1_LATCH_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X1_LATCH_STSr,(_r._pmd_x1_latch_sts))
#define BCMI_QTC_XGXS_WRITE_PMD_X1_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_LATCH_STSr,(_r._pmd_x1_latch_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X1_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_LATCH_STSr,(_r._pmd_x1_latch_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_LATCH_STSr BCMI_QTC_XGXS_PMD_X1_LATCH_STSr
#define PMD_X1_LATCH_STSr_SIZE BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_SIZE
typedef BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_t PMD_X1_LATCH_STSr_t;
#define PMD_X1_LATCH_STSr_CLR BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_CLR
#define PMD_X1_LATCH_STSr_SET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_SET
#define PMD_X1_LATCH_STSr_GET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_GET
#define PMD_X1_LATCH_STSr_TX_CLK_VLD_LHf_GET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LHf_GET
#define PMD_X1_LATCH_STSr_TX_CLK_VLD_LHf_SET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LHf_SET
#define PMD_X1_LATCH_STSr_TX_CLK_VLD_LLf_GET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LLf_GET
#define PMD_X1_LATCH_STSr_TX_CLK_VLD_LLf_SET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_TX_CLK_VLD_LLf_SET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LHf_GET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_GET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LHf_SET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_SET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LLf_GET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_GET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LLf_SET BCMI_QTC_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_SET
#define READ_PMD_X1_LATCH_STSr BCMI_QTC_XGXS_READ_PMD_X1_LATCH_STSr
#define WRITE_PMD_X1_LATCH_STSr BCMI_QTC_XGXS_WRITE_PMD_X1_LATCH_STSr
#define MODIFY_PMD_X1_LATCH_STSr BCMI_QTC_XGXS_MODIFY_PMD_X1_LATCH_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X1_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X1_OVRR
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9014
 * DESC:     Global PMD override
 * SIZE:     32
 * FIELDS:
 *     PLL_LOCK_OVRD    PMD PLL lock indicationOnly used for Speed Control bypass operation
 *     TX_CLK_VLD_OVRD  Override tx_clk_vld indication from PMDOnly used for Speed Control bypass operation
 *     CORE_MODE_OEN    Override enable for core modeOnly used for Speed Control bypass operation
 *     CORE_DP_H_RSTB_OEN Override enable for PMD Core data path resetOnly used for Speed Control bypass operation
 */
#define BCMI_QTC_XGXS_PMD_X1_OVRRr (0x00109014 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X1_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_OVRR.
 */
typedef union BCMI_QTC_XGXS_PMD_X1_OVRRr_s {
	uint32_t v[1];
	uint32_t pmd_x1_ovrr[1];
	uint32_t _pmd_x1_ovrr;
} BCMI_QTC_XGXS_PMD_X1_OVRRr_t;

#define BCMI_QTC_XGXS_PMD_X1_OVRRr_CLR(r) (r).pmd_x1_ovrr[0] = 0
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_SET(r,d) (r).pmd_x1_ovrr[0] = d
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_GET(r) (r).pmd_x1_ovrr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_TX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_TX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_GET(r) (((r).pmd_x1_ovrr[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X1_OVRR.
 */
#define BCMI_QTC_XGXS_READ_PMD_X1_OVRRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr))
#define BCMI_QTC_XGXS_WRITE_PMD_X1_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X1_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_OVRRr BCMI_QTC_XGXS_PMD_X1_OVRRr
#define PMD_X1_OVRRr_SIZE BCMI_QTC_XGXS_PMD_X1_OVRRr_SIZE
typedef BCMI_QTC_XGXS_PMD_X1_OVRRr_t PMD_X1_OVRRr_t;
#define PMD_X1_OVRRr_CLR BCMI_QTC_XGXS_PMD_X1_OVRRr_CLR
#define PMD_X1_OVRRr_SET BCMI_QTC_XGXS_PMD_X1_OVRRr_SET
#define PMD_X1_OVRRr_GET BCMI_QTC_XGXS_PMD_X1_OVRRr_GET
#define PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET
#define PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET
#define PMD_X1_OVRRr_CORE_MODE_OENf_GET BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_GET
#define PMD_X1_OVRRr_CORE_MODE_OENf_SET BCMI_QTC_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_SET
#define PMD_X1_OVRRr_TX_CLK_VLD_OVRDf_GET BCMI_QTC_XGXS_PMD_X1_OVRRr_TX_CLK_VLD_OVRDf_GET
#define PMD_X1_OVRRr_TX_CLK_VLD_OVRDf_SET BCMI_QTC_XGXS_PMD_X1_OVRRr_TX_CLK_VLD_OVRDf_SET
#define PMD_X1_OVRRr_PLL_LOCK_OVRDf_GET BCMI_QTC_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_GET
#define PMD_X1_OVRRr_PLL_LOCK_OVRDf_SET BCMI_QTC_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_SET
#define READ_PMD_X1_OVRRr BCMI_QTC_XGXS_READ_PMD_X1_OVRRr
#define WRITE_PMD_X1_OVRRr BCMI_QTC_XGXS_WRITE_PMD_X1_OVRRr
#define MODIFY_PMD_X1_OVRRr BCMI_QTC_XGXS_MODIFY_PMD_X1_OVRRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X1_OVRRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKTGENCTL1
 * BLOCKS:   PACKET_GEN
 * REGADDR:  0x9030
 * DESC:     Number of Packets
 * SIZE:     32
 * FIELDS:
 *     TX_PORT_SEL      Port for which crpat tx packet generator should be enabledPacket generator is shared across all ports, so only one port can have it enabledLower 2 bits are dont-care because QSGMII is not supported for tx crpat generator
 *     RX_PORT_SEL      Port for which crpat rx packet checker should be enabledPacket checker is shared across all ports, so only one port can have it enabledLower 2 bits are dont-care because QSGMII is not supported for rx crpat checker
 *     LPI_EN           n/a for qtc : replace idles with lpi (eee)
 *     CLR_CRCCNT       Clear crpat rx error count in Packet Checker
 *     RX_BUS_TYPE      0: MII/GMII type octet, 1: QSGMII type octetMust be set to 0 for cl36 crpat generation and checking
 *     RX_PKT_CHECK_EN  Enable Rx Packet checker for cl36 crpat
 *     NUMBER_PKT       0-15 (RESERVED) Not supported for QTC
 */
#define BCMI_QTC_XGXS_PKTGENCTL1r (0x00109030 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKTGENCTL1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGENCTL1.
 */
typedef union BCMI_QTC_XGXS_PKTGENCTL1r_s {
	uint32_t v[1];
	uint32_t pktgenctl1[1];
	uint32_t _pktgenctl1;
} BCMI_QTC_XGXS_PKTGENCTL1r_t;

#define BCMI_QTC_XGXS_PKTGENCTL1r_CLR(r) (r).pktgenctl1[0] = 0
#define BCMI_QTC_XGXS_PKTGENCTL1r_SET(r,d) (r).pktgenctl1[0] = d
#define BCMI_QTC_XGXS_PKTGENCTL1r_GET(r) (r).pktgenctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKTGENCTL1r_NUMBER_PKTf_GET(r) ((((r).pktgenctl1[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_PKTGENCTL1r_NUMBER_PKTf_SET(r,f) (r).pktgenctl1[0]=(((r).pktgenctl1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_PKTGENCTL1r_RX_PKT_CHECK_ENf_GET(r) ((((r).pktgenctl1[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_PKTGENCTL1r_RX_PKT_CHECK_ENf_SET(r,f) (r).pktgenctl1[0]=(((r).pktgenctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_PKTGENCTL1r_RX_BUS_TYPEf_GET(r) ((((r).pktgenctl1[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_PKTGENCTL1r_RX_BUS_TYPEf_SET(r,f) (r).pktgenctl1[0]=(((r).pktgenctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_PKTGENCTL1r_CLR_CRCCNTf_GET(r) ((((r).pktgenctl1[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_PKTGENCTL1r_CLR_CRCCNTf_SET(r,f) (r).pktgenctl1[0]=(((r).pktgenctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_PKTGENCTL1r_LPI_ENf_GET(r) ((((r).pktgenctl1[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_PKTGENCTL1r_LPI_ENf_SET(r,f) (r).pktgenctl1[0]=(((r).pktgenctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_PKTGENCTL1r_RX_PORT_SELf_GET(r) ((((r).pktgenctl1[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_PKTGENCTL1r_RX_PORT_SELf_SET(r,f) (r).pktgenctl1[0]=(((r).pktgenctl1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_PKTGENCTL1r_TX_PORT_SELf_GET(r) (((r).pktgenctl1[0]) & 0xf)
#define BCMI_QTC_XGXS_PKTGENCTL1r_TX_PORT_SELf_SET(r,f) (r).pktgenctl1[0]=(((r).pktgenctl1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access PKTGENCTL1.
 */
#define BCMI_QTC_XGXS_READ_PKTGENCTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKTGENCTL1r,(_r._pktgenctl1))
#define BCMI_QTC_XGXS_WRITE_PKTGENCTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKTGENCTL1r,(_r._pktgenctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKTGENCTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKTGENCTL1r,(_r._pktgenctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKTGENCTL1r BCMI_QTC_XGXS_PKTGENCTL1r
#define PKTGENCTL1r_SIZE BCMI_QTC_XGXS_PKTGENCTL1r_SIZE
typedef BCMI_QTC_XGXS_PKTGENCTL1r_t PKTGENCTL1r_t;
#define PKTGENCTL1r_CLR BCMI_QTC_XGXS_PKTGENCTL1r_CLR
#define PKTGENCTL1r_SET BCMI_QTC_XGXS_PKTGENCTL1r_SET
#define PKTGENCTL1r_GET BCMI_QTC_XGXS_PKTGENCTL1r_GET
#define PKTGENCTL1r_NUMBER_PKTf_GET BCMI_QTC_XGXS_PKTGENCTL1r_NUMBER_PKTf_GET
#define PKTGENCTL1r_NUMBER_PKTf_SET BCMI_QTC_XGXS_PKTGENCTL1r_NUMBER_PKTf_SET
#define PKTGENCTL1r_RX_PKT_CHECK_ENf_GET BCMI_QTC_XGXS_PKTGENCTL1r_RX_PKT_CHECK_ENf_GET
#define PKTGENCTL1r_RX_PKT_CHECK_ENf_SET BCMI_QTC_XGXS_PKTGENCTL1r_RX_PKT_CHECK_ENf_SET
#define PKTGENCTL1r_RX_BUS_TYPEf_GET BCMI_QTC_XGXS_PKTGENCTL1r_RX_BUS_TYPEf_GET
#define PKTGENCTL1r_RX_BUS_TYPEf_SET BCMI_QTC_XGXS_PKTGENCTL1r_RX_BUS_TYPEf_SET
#define PKTGENCTL1r_CLR_CRCCNTf_GET BCMI_QTC_XGXS_PKTGENCTL1r_CLR_CRCCNTf_GET
#define PKTGENCTL1r_CLR_CRCCNTf_SET BCMI_QTC_XGXS_PKTGENCTL1r_CLR_CRCCNTf_SET
#define PKTGENCTL1r_LPI_ENf_GET BCMI_QTC_XGXS_PKTGENCTL1r_LPI_ENf_GET
#define PKTGENCTL1r_LPI_ENf_SET BCMI_QTC_XGXS_PKTGENCTL1r_LPI_ENf_SET
#define PKTGENCTL1r_RX_PORT_SELf_GET BCMI_QTC_XGXS_PKTGENCTL1r_RX_PORT_SELf_GET
#define PKTGENCTL1r_RX_PORT_SELf_SET BCMI_QTC_XGXS_PKTGENCTL1r_RX_PORT_SELf_SET
#define PKTGENCTL1r_TX_PORT_SELf_GET BCMI_QTC_XGXS_PKTGENCTL1r_TX_PORT_SELf_GET
#define PKTGENCTL1r_TX_PORT_SELf_SET BCMI_QTC_XGXS_PKTGENCTL1r_TX_PORT_SELf_SET
#define READ_PKTGENCTL1r BCMI_QTC_XGXS_READ_PKTGENCTL1r
#define WRITE_PKTGENCTL1r BCMI_QTC_XGXS_WRITE_PKTGENCTL1r
#define MODIFY_PKTGENCTL1r BCMI_QTC_XGXS_MODIFY_PKTGENCTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKTGENCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKTGENCTL2
 * BLOCKS:   PACKET_GEN
 * REGADDR:  0x9031
 * DESC:     Packet and IPG Size
 * SIZE:     32
 * FIELDS:
 *     IPG_SIZE         IPG inserted by tx crpat generator between packets. Minimum is 12range is 12 to 31
 *     PKT_SIZE         Reserved - Not supported for QTC
 *     PAYLOAD_TYPE     payload type - Controls both TX and RX crpat. i.e. Single selection for TX and RX is enforced.0..3 Reserved - Not supported for QTC4 CL36 Long CRPAT - Annex 36A.4 (can be used with GMII/MII)5 CL36 Short CRPAT - Annex 36A.5 (can be used with GMII/MII)
 *     TX_BUS_TYPE      0: MII/GMII type octet, 1: QSGMII type octetMust be set to 0 for cl36 crpat generation and checking
 *     PKTGEN_EN        cl36 crpat tx enable
 */
#define BCMI_QTC_XGXS_PKTGENCTL2r (0x00109031 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKTGENCTL2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGENCTL2.
 */
typedef union BCMI_QTC_XGXS_PKTGENCTL2r_s {
	uint32_t v[1];
	uint32_t pktgenctl2[1];
	uint32_t _pktgenctl2;
} BCMI_QTC_XGXS_PKTGENCTL2r_t;

#define BCMI_QTC_XGXS_PKTGENCTL2r_CLR(r) (r).pktgenctl2[0] = 0
#define BCMI_QTC_XGXS_PKTGENCTL2r_SET(r,d) (r).pktgenctl2[0] = d
#define BCMI_QTC_XGXS_PKTGENCTL2r_GET(r) (r).pktgenctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKTGENCTL2r_PKTGEN_ENf_GET(r) ((((r).pktgenctl2[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_PKTGENCTL2r_PKTGEN_ENf_SET(r,f) (r).pktgenctl2[0]=(((r).pktgenctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_PKTGENCTL2r_TX_BUS_TYPEf_GET(r) ((((r).pktgenctl2[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_PKTGENCTL2r_TX_BUS_TYPEf_SET(r,f) (r).pktgenctl2[0]=(((r).pktgenctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_PKTGENCTL2r_PAYLOAD_TYPEf_GET(r) ((((r).pktgenctl2[0]) >> 11) & 0x7)
#define BCMI_QTC_XGXS_PKTGENCTL2r_PAYLOAD_TYPEf_SET(r,f) (r).pktgenctl2[0]=(((r).pktgenctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_QTC_XGXS_PKTGENCTL2r_PKT_SIZEf_GET(r) ((((r).pktgenctl2[0]) >> 5) & 0x3f)
#define BCMI_QTC_XGXS_PKTGENCTL2r_PKT_SIZEf_SET(r,f) (r).pktgenctl2[0]=(((r).pktgenctl2[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_QTC_XGXS_PKTGENCTL2r_IPG_SIZEf_GET(r) (((r).pktgenctl2[0]) & 0x1f)
#define BCMI_QTC_XGXS_PKTGENCTL2r_IPG_SIZEf_SET(r,f) (r).pktgenctl2[0]=(((r).pktgenctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access PKTGENCTL2.
 */
#define BCMI_QTC_XGXS_READ_PKTGENCTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKTGENCTL2r,(_r._pktgenctl2))
#define BCMI_QTC_XGXS_WRITE_PKTGENCTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKTGENCTL2r,(_r._pktgenctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKTGENCTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKTGENCTL2r,(_r._pktgenctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKTGENCTL2r BCMI_QTC_XGXS_PKTGENCTL2r
#define PKTGENCTL2r_SIZE BCMI_QTC_XGXS_PKTGENCTL2r_SIZE
typedef BCMI_QTC_XGXS_PKTGENCTL2r_t PKTGENCTL2r_t;
#define PKTGENCTL2r_CLR BCMI_QTC_XGXS_PKTGENCTL2r_CLR
#define PKTGENCTL2r_SET BCMI_QTC_XGXS_PKTGENCTL2r_SET
#define PKTGENCTL2r_GET BCMI_QTC_XGXS_PKTGENCTL2r_GET
#define PKTGENCTL2r_PKTGEN_ENf_GET BCMI_QTC_XGXS_PKTGENCTL2r_PKTGEN_ENf_GET
#define PKTGENCTL2r_PKTGEN_ENf_SET BCMI_QTC_XGXS_PKTGENCTL2r_PKTGEN_ENf_SET
#define PKTGENCTL2r_TX_BUS_TYPEf_GET BCMI_QTC_XGXS_PKTGENCTL2r_TX_BUS_TYPEf_GET
#define PKTGENCTL2r_TX_BUS_TYPEf_SET BCMI_QTC_XGXS_PKTGENCTL2r_TX_BUS_TYPEf_SET
#define PKTGENCTL2r_PAYLOAD_TYPEf_GET BCMI_QTC_XGXS_PKTGENCTL2r_PAYLOAD_TYPEf_GET
#define PKTGENCTL2r_PAYLOAD_TYPEf_SET BCMI_QTC_XGXS_PKTGENCTL2r_PAYLOAD_TYPEf_SET
#define PKTGENCTL2r_PKT_SIZEf_GET BCMI_QTC_XGXS_PKTGENCTL2r_PKT_SIZEf_GET
#define PKTGENCTL2r_PKT_SIZEf_SET BCMI_QTC_XGXS_PKTGENCTL2r_PKT_SIZEf_SET
#define PKTGENCTL2r_IPG_SIZEf_GET BCMI_QTC_XGXS_PKTGENCTL2r_IPG_SIZEf_GET
#define PKTGENCTL2r_IPG_SIZEf_SET BCMI_QTC_XGXS_PKTGENCTL2r_IPG_SIZEf_SET
#define READ_PKTGENCTL2r BCMI_QTC_XGXS_READ_PKTGENCTL2r
#define WRITE_PKTGENCTL2r BCMI_QTC_XGXS_WRITE_PKTGENCTL2r
#define MODIFY_PKTGENCTL2r BCMI_QTC_XGXS_MODIFY_PKTGENCTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKTGENCTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PAYLOADBYTES
 * BLOCKS:   PACKET_GEN
 * REGADDR:  0x9032
 * DESC:     Repeated Payload Bytes
 * SIZE:     32
 * FIELDS:
 *     BYTE0            Not supported
 *     BYTE1            Not supported
 */
#define BCMI_QTC_XGXS_PAYLOADBYTESr (0x00109032 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PAYLOADBYTESr_SIZE 4

/*
 * This structure should be used to declare and program PAYLOADBYTES.
 */
typedef union BCMI_QTC_XGXS_PAYLOADBYTESr_s {
	uint32_t v[1];
	uint32_t payloadbytes[1];
	uint32_t _payloadbytes;
} BCMI_QTC_XGXS_PAYLOADBYTESr_t;

#define BCMI_QTC_XGXS_PAYLOADBYTESr_CLR(r) (r).payloadbytes[0] = 0
#define BCMI_QTC_XGXS_PAYLOADBYTESr_SET(r,d) (r).payloadbytes[0] = d
#define BCMI_QTC_XGXS_PAYLOADBYTESr_GET(r) (r).payloadbytes[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE1f_GET(r) ((((r).payloadbytes[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE1f_SET(r,f) (r).payloadbytes[0]=(((r).payloadbytes[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE0f_GET(r) (((r).payloadbytes[0]) & 0xff)
#define BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE0f_SET(r,f) (r).payloadbytes[0]=(((r).payloadbytes[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access PAYLOADBYTES.
 */
#define BCMI_QTC_XGXS_READ_PAYLOADBYTESr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PAYLOADBYTESr,(_r._payloadbytes))
#define BCMI_QTC_XGXS_WRITE_PAYLOADBYTESr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PAYLOADBYTESr,(_r._payloadbytes)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PAYLOADBYTESr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PAYLOADBYTESr,(_r._payloadbytes))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PAYLOADBYTESr BCMI_QTC_XGXS_PAYLOADBYTESr
#define PAYLOADBYTESr_SIZE BCMI_QTC_XGXS_PAYLOADBYTESr_SIZE
typedef BCMI_QTC_XGXS_PAYLOADBYTESr_t PAYLOADBYTESr_t;
#define PAYLOADBYTESr_CLR BCMI_QTC_XGXS_PAYLOADBYTESr_CLR
#define PAYLOADBYTESr_SET BCMI_QTC_XGXS_PAYLOADBYTESr_SET
#define PAYLOADBYTESr_GET BCMI_QTC_XGXS_PAYLOADBYTESr_GET
#define PAYLOADBYTESr_BYTE1f_GET BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE1f_GET
#define PAYLOADBYTESr_BYTE1f_SET BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE1f_SET
#define PAYLOADBYTESr_BYTE0f_GET BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE0f_GET
#define PAYLOADBYTESr_BYTE0f_SET BCMI_QTC_XGXS_PAYLOADBYTESr_BYTE0f_SET
#define READ_PAYLOADBYTESr BCMI_QTC_XGXS_READ_PAYLOADBYTESr
#define WRITE_PAYLOADBYTESr BCMI_QTC_XGXS_WRITE_PAYLOADBYTESr
#define MODIFY_PAYLOADBYTESr BCMI_QTC_XGXS_MODIFY_PAYLOADBYTESr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PAYLOADBYTESr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  ERR_GEN
 * BLOCKS:   PACKET_GEN
 * REGADDR:  0x9033
 * DESC:     Error Generation Control register
 * SIZE:     32
 * FIELDS:
 *     ERRGEN_EN        Not supported for QTC
 */
#define BCMI_QTC_XGXS_ERR_GENr (0x00109033 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_ERR_GENr_SIZE 4

/*
 * This structure should be used to declare and program ERR_GEN.
 */
typedef union BCMI_QTC_XGXS_ERR_GENr_s {
	uint32_t v[1];
	uint32_t err_gen[1];
	uint32_t _err_gen;
} BCMI_QTC_XGXS_ERR_GENr_t;

#define BCMI_QTC_XGXS_ERR_GENr_CLR(r) (r).err_gen[0] = 0
#define BCMI_QTC_XGXS_ERR_GENr_SET(r,d) (r).err_gen[0] = d
#define BCMI_QTC_XGXS_ERR_GENr_GET(r) (r).err_gen[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_ERR_GENr_ERRGEN_ENf_GET(r) (((r).err_gen[0]) & 0xf)
#define BCMI_QTC_XGXS_ERR_GENr_ERRGEN_ENf_SET(r,f) (r).err_gen[0]=(((r).err_gen[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access ERR_GEN.
 */
#define BCMI_QTC_XGXS_READ_ERR_GENr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_ERR_GENr,(_r._err_gen))
#define BCMI_QTC_XGXS_WRITE_ERR_GENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ERR_GENr,(_r._err_gen)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_ERR_GENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ERR_GENr,(_r._err_gen))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ERR_GENr BCMI_QTC_XGXS_ERR_GENr
#define ERR_GENr_SIZE BCMI_QTC_XGXS_ERR_GENr_SIZE
typedef BCMI_QTC_XGXS_ERR_GENr_t ERR_GENr_t;
#define ERR_GENr_CLR BCMI_QTC_XGXS_ERR_GENr_CLR
#define ERR_GENr_SET BCMI_QTC_XGXS_ERR_GENr_SET
#define ERR_GENr_GET BCMI_QTC_XGXS_ERR_GENr_GET
#define ERR_GENr_ERRGEN_ENf_GET BCMI_QTC_XGXS_ERR_GENr_ERRGEN_ENf_GET
#define ERR_GENr_ERRGEN_ENf_SET BCMI_QTC_XGXS_ERR_GENr_ERRGEN_ENf_SET
#define READ_ERR_GENr BCMI_QTC_XGXS_READ_ERR_GENr
#define WRITE_ERR_GENr BCMI_QTC_XGXS_WRITE_ERR_GENr
#define MODIFY_ERR_GENr BCMI_QTC_XGXS_MODIFY_ERR_GENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_ERR_GENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  ERRMASK
 * BLOCKS:   PACKET_GEN
 * REGADDR:  0x9034
 * DESC:     Error mask bits 7:0
 * SIZE:     32
 * FIELDS:
 *     ERROR_MASK       Not supported for QTC
 */
#define BCMI_QTC_XGXS_ERRMASKr (0x00109034 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_ERRMASKr_SIZE 4

/*
 * This structure should be used to declare and program ERRMASK.
 */
typedef union BCMI_QTC_XGXS_ERRMASKr_s {
	uint32_t v[1];
	uint32_t errmask[1];
	uint32_t _errmask;
} BCMI_QTC_XGXS_ERRMASKr_t;

#define BCMI_QTC_XGXS_ERRMASKr_CLR(r) (r).errmask[0] = 0
#define BCMI_QTC_XGXS_ERRMASKr_SET(r,d) (r).errmask[0] = d
#define BCMI_QTC_XGXS_ERRMASKr_GET(r) (r).errmask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_ERRMASKr_ERROR_MASKf_GET(r) (((r).errmask[0]) & 0xff)
#define BCMI_QTC_XGXS_ERRMASKr_ERROR_MASKf_SET(r,f) (r).errmask[0]=(((r).errmask[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access ERRMASK.
 */
#define BCMI_QTC_XGXS_READ_ERRMASKr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_ERRMASKr,(_r._errmask))
#define BCMI_QTC_XGXS_WRITE_ERRMASKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ERRMASKr,(_r._errmask)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_ERRMASKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ERRMASKr,(_r._errmask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ERRMASKr BCMI_QTC_XGXS_ERRMASKr
#define ERRMASKr_SIZE BCMI_QTC_XGXS_ERRMASKr_SIZE
typedef BCMI_QTC_XGXS_ERRMASKr_t ERRMASKr_t;
#define ERRMASKr_CLR BCMI_QTC_XGXS_ERRMASKr_CLR
#define ERRMASKr_SET BCMI_QTC_XGXS_ERRMASKr_SET
#define ERRMASKr_GET BCMI_QTC_XGXS_ERRMASKr_GET
#define ERRMASKr_ERROR_MASKf_GET BCMI_QTC_XGXS_ERRMASKr_ERROR_MASKf_GET
#define ERRMASKr_ERROR_MASKf_SET BCMI_QTC_XGXS_ERRMASKr_ERROR_MASKf_SET
#define READ_ERRMASKr BCMI_QTC_XGXS_READ_ERRMASKr
#define WRITE_ERRMASKr BCMI_QTC_XGXS_WRITE_ERRMASKr
#define MODIFY_ERRMASKr BCMI_QTC_XGXS_MODIFY_ERRMASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_ERRMASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CRCERRCNT
 * BLOCKS:   PACKET_GEN
 * REGADDR:  0x9035
 * DESC:     CRC Error Count Register
 * SIZE:     32
 * FIELDS:
 *     CRCERRCNT        Count of received cl36 crpat packets with one of the following errors.Less than 2 bytes of preambleUnexpected data byte in crpat pattern based on long or short selection
 */
#define BCMI_QTC_XGXS_CRCERRCNTr (0x00109035 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CRCERRCNTr_SIZE 4

/*
 * This structure should be used to declare and program CRCERRCNT.
 */
typedef union BCMI_QTC_XGXS_CRCERRCNTr_s {
	uint32_t v[1];
	uint32_t crcerrcnt[1];
	uint32_t _crcerrcnt;
} BCMI_QTC_XGXS_CRCERRCNTr_t;

#define BCMI_QTC_XGXS_CRCERRCNTr_CLR(r) (r).crcerrcnt[0] = 0
#define BCMI_QTC_XGXS_CRCERRCNTr_SET(r,d) (r).crcerrcnt[0] = d
#define BCMI_QTC_XGXS_CRCERRCNTr_GET(r) (r).crcerrcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CRCERRCNTr_CRCERRCNTf_GET(r) (((r).crcerrcnt[0]) & 0xffff)
#define BCMI_QTC_XGXS_CRCERRCNTr_CRCERRCNTf_SET(r,f) (r).crcerrcnt[0]=(((r).crcerrcnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CRCERRCNT.
 */
#define BCMI_QTC_XGXS_READ_CRCERRCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CRCERRCNTr,(_r._crcerrcnt))
#define BCMI_QTC_XGXS_WRITE_CRCERRCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CRCERRCNTr,(_r._crcerrcnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CRCERRCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CRCERRCNTr,(_r._crcerrcnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CRCERRCNTr BCMI_QTC_XGXS_CRCERRCNTr
#define CRCERRCNTr_SIZE BCMI_QTC_XGXS_CRCERRCNTr_SIZE
typedef BCMI_QTC_XGXS_CRCERRCNTr_t CRCERRCNTr_t;
#define CRCERRCNTr_CLR BCMI_QTC_XGXS_CRCERRCNTr_CLR
#define CRCERRCNTr_SET BCMI_QTC_XGXS_CRCERRCNTr_SET
#define CRCERRCNTr_GET BCMI_QTC_XGXS_CRCERRCNTr_GET
#define CRCERRCNTr_CRCERRCNTf_GET BCMI_QTC_XGXS_CRCERRCNTr_CRCERRCNTf_GET
#define CRCERRCNTr_CRCERRCNTf_SET BCMI_QTC_XGXS_CRCERRCNTr_CRCERRCNTf_SET
#define READ_CRCERRCNTr BCMI_QTC_XGXS_READ_CRCERRCNTr
#define WRITE_CRCERRCNTr BCMI_QTC_XGXS_WRITE_CRCERRCNTr
#define MODIFY_CRCERRCNTr BCMI_QTC_XGXS_MODIFY_CRCERRCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CRCERRCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  OUI_UPR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9240
 * DESC:     OUI upper bits register
 * SIZE:     32
 * FIELDS:
 *     OUI_UPPER_DATA   UPPER 8 BITS OF OUI FIELD
 */
#define BCMI_QTC_XGXS_OUI_UPRr (0x00109240 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_OUI_UPRr_SIZE 4

/*
 * This structure should be used to declare and program OUI_UPR.
 */
typedef union BCMI_QTC_XGXS_OUI_UPRr_s {
	uint32_t v[1];
	uint32_t oui_upr[1];
	uint32_t _oui_upr;
} BCMI_QTC_XGXS_OUI_UPRr_t;

#define BCMI_QTC_XGXS_OUI_UPRr_CLR(r) (r).oui_upr[0] = 0
#define BCMI_QTC_XGXS_OUI_UPRr_SET(r,d) (r).oui_upr[0] = d
#define BCMI_QTC_XGXS_OUI_UPRr_GET(r) (r).oui_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_OUI_UPRr_OUI_UPPER_DATAf_GET(r) (((r).oui_upr[0]) & 0xff)
#define BCMI_QTC_XGXS_OUI_UPRr_OUI_UPPER_DATAf_SET(r,f) (r).oui_upr[0]=(((r).oui_upr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access OUI_UPR.
 */
#define BCMI_QTC_XGXS_READ_OUI_UPRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_OUI_UPRr,(_r._oui_upr))
#define BCMI_QTC_XGXS_WRITE_OUI_UPRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_OUI_UPRr,(_r._oui_upr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_OUI_UPRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_OUI_UPRr,(_r._oui_upr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define OUI_UPRr BCMI_QTC_XGXS_OUI_UPRr
#define OUI_UPRr_SIZE BCMI_QTC_XGXS_OUI_UPRr_SIZE
typedef BCMI_QTC_XGXS_OUI_UPRr_t OUI_UPRr_t;
#define OUI_UPRr_CLR BCMI_QTC_XGXS_OUI_UPRr_CLR
#define OUI_UPRr_SET BCMI_QTC_XGXS_OUI_UPRr_SET
#define OUI_UPRr_GET BCMI_QTC_XGXS_OUI_UPRr_GET
#define OUI_UPRr_OUI_UPPER_DATAf_GET BCMI_QTC_XGXS_OUI_UPRr_OUI_UPPER_DATAf_GET
#define OUI_UPRr_OUI_UPPER_DATAf_SET BCMI_QTC_XGXS_OUI_UPRr_OUI_UPPER_DATAf_SET
#define READ_OUI_UPRr BCMI_QTC_XGXS_READ_OUI_UPRr
#define WRITE_OUI_UPRr BCMI_QTC_XGXS_WRITE_OUI_UPRr
#define MODIFY_OUI_UPRr BCMI_QTC_XGXS_MODIFY_OUI_UPRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_OUI_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  OUI_LWR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9241
 * DESC:     OUI lower bits register
 * SIZE:     32
 * FIELDS:
 *     OUI_LOWER_DATA   LOWER 16 BITS OF OUI FIELD
 */
#define BCMI_QTC_XGXS_OUI_LWRr (0x00109241 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_OUI_LWRr_SIZE 4

/*
 * This structure should be used to declare and program OUI_LWR.
 */
typedef union BCMI_QTC_XGXS_OUI_LWRr_s {
	uint32_t v[1];
	uint32_t oui_lwr[1];
	uint32_t _oui_lwr;
} BCMI_QTC_XGXS_OUI_LWRr_t;

#define BCMI_QTC_XGXS_OUI_LWRr_CLR(r) (r).oui_lwr[0] = 0
#define BCMI_QTC_XGXS_OUI_LWRr_SET(r,d) (r).oui_lwr[0] = d
#define BCMI_QTC_XGXS_OUI_LWRr_GET(r) (r).oui_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_OUI_LWRr_OUI_LOWER_DATAf_GET(r) (((r).oui_lwr[0]) & 0xffff)
#define BCMI_QTC_XGXS_OUI_LWRr_OUI_LOWER_DATAf_SET(r,f) (r).oui_lwr[0]=(((r).oui_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access OUI_LWR.
 */
#define BCMI_QTC_XGXS_READ_OUI_LWRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_OUI_LWRr,(_r._oui_lwr))
#define BCMI_QTC_XGXS_WRITE_OUI_LWRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_OUI_LWRr,(_r._oui_lwr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_OUI_LWRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_OUI_LWRr,(_r._oui_lwr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define OUI_LWRr BCMI_QTC_XGXS_OUI_LWRr
#define OUI_LWRr_SIZE BCMI_QTC_XGXS_OUI_LWRr_SIZE
typedef BCMI_QTC_XGXS_OUI_LWRr_t OUI_LWRr_t;
#define OUI_LWRr_CLR BCMI_QTC_XGXS_OUI_LWRr_CLR
#define OUI_LWRr_SET BCMI_QTC_XGXS_OUI_LWRr_SET
#define OUI_LWRr_GET BCMI_QTC_XGXS_OUI_LWRr_GET
#define OUI_LWRr_OUI_LOWER_DATAf_GET BCMI_QTC_XGXS_OUI_LWRr_OUI_LOWER_DATAf_GET
#define OUI_LWRr_OUI_LOWER_DATAf_SET BCMI_QTC_XGXS_OUI_LWRr_OUI_LOWER_DATAf_SET
#define READ_OUI_LWRr BCMI_QTC_XGXS_READ_OUI_LWRr
#define WRITE_OUI_LWRr BCMI_QTC_XGXS_WRITE_OUI_LWRr
#define MODIFY_OUI_LWRr BCMI_QTC_XGXS_MODIFY_OUI_LWRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_OUI_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  BAM_SPD_PRI_5_0
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9242
 * DESC:     Remap Priority Register
 * SIZE:     32
 * FIELDS:
 *     AN_PRIORITY_1000M HCD PRIORITY OVERRIDE FOR PRIORITY 1000M SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_100M HCD PRIORITY OVERRIDE FOR PRIORITY 100M SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10M  HCD PRIORITY OVERRIDE FOR PRIORITY 10M SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_2P5GX1 HCD PRIORITY OVERRIDE FOR PRIORITY 2p5GX1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_1GKX HCD PRIORITY OVERRIDE FOR PRIORITY 1GKX SPEED.  ZERO MEANS USE HW PRIORITY
 */
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r (0x00109242 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_SIZE 4

/*
 * This structure should be used to declare and program BAM_SPD_PRI_5_0.
 */
typedef union BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_s {
	uint32_t v[1];
	uint32_t bam_spd_pri_5_0[1];
	uint32_t _bam_spd_pri_5_0;
} BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_t;

#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_CLR(r) (r).bam_spd_pri_5_0[0] = 0
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_SET(r,d) (r).bam_spd_pri_5_0[0] = d
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_GET(r) (r).bam_spd_pri_5_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_GET(r) ((((r).bam_spd_pri_5_0[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_SET(r,f) (r).bam_spd_pri_5_0[0]=(((r).bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET(r) ((((r).bam_spd_pri_5_0[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET(r,f) (r).bam_spd_pri_5_0[0]=(((r).bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_GET(r) ((((r).bam_spd_pri_5_0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_SET(r,f) (r).bam_spd_pri_5_0[0]=(((r).bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_GET(r) ((((r).bam_spd_pri_5_0[0]) >> 2) & 0x3)
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_SET(r,f) (r).bam_spd_pri_5_0[0]=(((r).bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_GET(r) (((r).bam_spd_pri_5_0[0]) & 0x3)
#define BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_SET(r,f) (r).bam_spd_pri_5_0[0]=(((r).bam_spd_pri_5_0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access BAM_SPD_PRI_5_0.
 */
#define BCMI_QTC_XGXS_READ_BAM_SPD_PRI_5_0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r,(_r._bam_spd_pri_5_0))
#define BCMI_QTC_XGXS_WRITE_BAM_SPD_PRI_5_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r,(_r._bam_spd_pri_5_0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_BAM_SPD_PRI_5_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r,(_r._bam_spd_pri_5_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BAM_SPD_PRI_5_0r BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r
#define BAM_SPD_PRI_5_0r_SIZE BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_SIZE
typedef BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_t BAM_SPD_PRI_5_0r_t;
#define BAM_SPD_PRI_5_0r_CLR BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_CLR
#define BAM_SPD_PRI_5_0r_SET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_SET
#define BAM_SPD_PRI_5_0r_GET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_GET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_GET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_GET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_SET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_SET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_GET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_GET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_SET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_SET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_GET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_GET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_SET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_SET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_GET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_GET
#define BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_SET BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_SET
#define READ_BAM_SPD_PRI_5_0r BCMI_QTC_XGXS_READ_BAM_SPD_PRI_5_0r
#define WRITE_BAM_SPD_PRI_5_0r BCMI_QTC_XGXS_WRITE_BAM_SPD_PRI_5_0r
#define MODIFY_BAM_SPD_PRI_5_0r BCMI_QTC_XGXS_MODIFY_BAM_SPD_PRI_5_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_BAM_SPD_PRI_5_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL37_RESTART
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9250
 * DESC:     CL37 AUTO-NEG RESTART TIMER
 * SIZE:     32
 * FIELDS:
 *     CL37_RESTART_TIMER_PERIOD Period/range is 10 mssingle copyCL37 auto-neg restart timer. Timer for the amout of time to send restart pages.
 */
#define BCMI_QTC_XGXS_CL37_RESTARTr (0x00109250 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL37_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program CL37_RESTART.
 */
typedef union BCMI_QTC_XGXS_CL37_RESTARTr_s {
	uint32_t v[1];
	uint32_t cl37_restart[1];
	uint32_t _cl37_restart;
} BCMI_QTC_XGXS_CL37_RESTARTr_t;

#define BCMI_QTC_XGXS_CL37_RESTARTr_CLR(r) (r).cl37_restart[0] = 0
#define BCMI_QTC_XGXS_CL37_RESTARTr_SET(r,d) (r).cl37_restart[0] = d
#define BCMI_QTC_XGXS_CL37_RESTARTr_GET(r) (r).cl37_restart[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET(r) (((r).cl37_restart[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET(r,f) (r).cl37_restart[0]=(((r).cl37_restart[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL37_RESTART.
 */
#define BCMI_QTC_XGXS_READ_CL37_RESTARTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL37_RESTARTr,(_r._cl37_restart))
#define BCMI_QTC_XGXS_WRITE_CL37_RESTARTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_RESTARTr,(_r._cl37_restart)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL37_RESTARTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_RESTARTr,(_r._cl37_restart))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_RESTARTr BCMI_QTC_XGXS_CL37_RESTARTr
#define CL37_RESTARTr_SIZE BCMI_QTC_XGXS_CL37_RESTARTr_SIZE
typedef BCMI_QTC_XGXS_CL37_RESTARTr_t CL37_RESTARTr_t;
#define CL37_RESTARTr_CLR BCMI_QTC_XGXS_CL37_RESTARTr_CLR
#define CL37_RESTARTr_SET BCMI_QTC_XGXS_CL37_RESTARTr_SET
#define CL37_RESTARTr_GET BCMI_QTC_XGXS_CL37_RESTARTr_GET
#define CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET BCMI_QTC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET
#define CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET BCMI_QTC_XGXS_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET
#define READ_CL37_RESTARTr BCMI_QTC_XGXS_READ_CL37_RESTARTr
#define WRITE_CL37_RESTARTr BCMI_QTC_XGXS_WRITE_CL37_RESTARTr
#define MODIFY_CL37_RESTARTr BCMI_QTC_XGXS_MODIFY_CL37_RESTARTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL37_RESTARTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL37_ACK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9251
 * DESC:     CL37 AUTO-NEG COMPLETE-ACKNOWLEDGE TIMER
 * SIZE:     32
 * FIELDS:
 *     CL37_ACK_TIMER_PERIOD Period/range is 10 mssingle copyCL37 auto-neg complete-acknowledge timer.  Timer for the amount of time to sent CL37 acknowledges.
 */
#define BCMI_QTC_XGXS_CL37_ACKr (0x00109251 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL37_ACKr_SIZE 4

/*
 * This structure should be used to declare and program CL37_ACK.
 */
typedef union BCMI_QTC_XGXS_CL37_ACKr_s {
	uint32_t v[1];
	uint32_t cl37_ack[1];
	uint32_t _cl37_ack;
} BCMI_QTC_XGXS_CL37_ACKr_t;

#define BCMI_QTC_XGXS_CL37_ACKr_CLR(r) (r).cl37_ack[0] = 0
#define BCMI_QTC_XGXS_CL37_ACKr_SET(r,d) (r).cl37_ack[0] = d
#define BCMI_QTC_XGXS_CL37_ACKr_GET(r) (r).cl37_ack[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET(r) (((r).cl37_ack[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET(r,f) (r).cl37_ack[0]=(((r).cl37_ack[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL37_ACK.
 */
#define BCMI_QTC_XGXS_READ_CL37_ACKr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL37_ACKr,(_r._cl37_ack))
#define BCMI_QTC_XGXS_WRITE_CL37_ACKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_ACKr,(_r._cl37_ack)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL37_ACKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_ACKr,(_r._cl37_ack))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_ACKr BCMI_QTC_XGXS_CL37_ACKr
#define CL37_ACKr_SIZE BCMI_QTC_XGXS_CL37_ACKr_SIZE
typedef BCMI_QTC_XGXS_CL37_ACKr_t CL37_ACKr_t;
#define CL37_ACKr_CLR BCMI_QTC_XGXS_CL37_ACKr_CLR
#define CL37_ACKr_SET BCMI_QTC_XGXS_CL37_ACKr_SET
#define CL37_ACKr_GET BCMI_QTC_XGXS_CL37_ACKr_GET
#define CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET BCMI_QTC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET
#define CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET BCMI_QTC_XGXS_CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET
#define READ_CL37_ACKr BCMI_QTC_XGXS_READ_CL37_ACKr
#define WRITE_CL37_ACKr BCMI_QTC_XGXS_WRITE_CL37_ACKr
#define MODIFY_CL37_ACKr BCMI_QTC_XGXS_MODIFY_CL37_ACKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL37_ACKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL37_ERR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9252
 * DESC:     CL37 AUTO-NEG TIMEOUT-ERROR TIMER
 * SIZE:     32
 * FIELDS:
 *     CL37_ERROR_TIMER_PERIOD Period/range is 20.6 mssingle copyCL37 auto-neg timeout-error timer Timer for the amout ot time to receive a page from the link partner.
 */
#define BCMI_QTC_XGXS_CL37_ERRr (0x00109252 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL37_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CL37_ERR.
 */
typedef union BCMI_QTC_XGXS_CL37_ERRr_s {
	uint32_t v[1];
	uint32_t cl37_err[1];
	uint32_t _cl37_err;
} BCMI_QTC_XGXS_CL37_ERRr_t;

#define BCMI_QTC_XGXS_CL37_ERRr_CLR(r) (r).cl37_err[0] = 0
#define BCMI_QTC_XGXS_CL37_ERRr_SET(r,d) (r).cl37_err[0] = d
#define BCMI_QTC_XGXS_CL37_ERRr_GET(r) (r).cl37_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_GET(r) (((r).cl37_err[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_SET(r,f) (r).cl37_err[0]=(((r).cl37_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL37_ERR.
 */
#define BCMI_QTC_XGXS_READ_CL37_ERRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL37_ERRr,(_r._cl37_err))
#define BCMI_QTC_XGXS_WRITE_CL37_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_ERRr,(_r._cl37_err)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL37_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_ERRr,(_r._cl37_err))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_ERRr BCMI_QTC_XGXS_CL37_ERRr
#define CL37_ERRr_SIZE BCMI_QTC_XGXS_CL37_ERRr_SIZE
typedef BCMI_QTC_XGXS_CL37_ERRr_t CL37_ERRr_t;
#define CL37_ERRr_CLR BCMI_QTC_XGXS_CL37_ERRr_CLR
#define CL37_ERRr_SET BCMI_QTC_XGXS_CL37_ERRr_SET
#define CL37_ERRr_GET BCMI_QTC_XGXS_CL37_ERRr_GET
#define CL37_ERRr_CL37_ERROR_TIMER_PERIODf_GET BCMI_QTC_XGXS_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_GET
#define CL37_ERRr_CL37_ERROR_TIMER_PERIODf_SET BCMI_QTC_XGXS_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_SET
#define READ_CL37_ERRr BCMI_QTC_XGXS_READ_CL37_ERRr
#define WRITE_CL37_ERRr BCMI_QTC_XGXS_WRITE_CL37_ERRr
#define MODIFY_CL37_ERRr BCMI_QTC_XGXS_MODIFY_CL37_ERRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL37_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL37_SYNC_STS_FILTER_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9253
 * DESC:     PERIOD TO IGNORE CL37 SYNC_STATUS DOWN INDICATION
 * SIZE:     32
 * FIELDS:
 *     CL37_SYNC_STATUS_FILTER_TIMER_PERIOD Period is in tickssingle copyPeriod to ignore the cl37 sync_status down indication if it is less than 10ms
 */
#define BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr (0x00109253 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_SIZE 4

/*
 * This structure should be used to declare and program CL37_SYNC_STS_FILTER_TMR.
 */
typedef union BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_s {
	uint32_t v[1];
	uint32_t cl37_sync_sts_filter_tmr[1];
	uint32_t _cl37_sync_sts_filter_tmr;
} BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_t;

#define BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_CLR(r) (r).cl37_sync_sts_filter_tmr[0] = 0
#define BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_SET(r,d) (r).cl37_sync_sts_filter_tmr[0] = d
#define BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_GET(r) (r).cl37_sync_sts_filter_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_GET(r) (((r).cl37_sync_sts_filter_tmr[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_SET(r,f) (r).cl37_sync_sts_filter_tmr[0]=(((r).cl37_sync_sts_filter_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL37_SYNC_STS_FILTER_TMR.
 */
#define BCMI_QTC_XGXS_READ_CL37_SYNC_STS_FILTER_TMRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr,(_r._cl37_sync_sts_filter_tmr))
#define BCMI_QTC_XGXS_WRITE_CL37_SYNC_STS_FILTER_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr,(_r._cl37_sync_sts_filter_tmr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL37_SYNC_STS_FILTER_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr,(_r._cl37_sync_sts_filter_tmr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL37_SYNC_STS_FILTER_TMRr BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr
#define CL37_SYNC_STS_FILTER_TMRr_SIZE BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_SIZE
typedef BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_t CL37_SYNC_STS_FILTER_TMRr_t;
#define CL37_SYNC_STS_FILTER_TMRr_CLR BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_CLR
#define CL37_SYNC_STS_FILTER_TMRr_SET BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_SET
#define CL37_SYNC_STS_FILTER_TMRr_GET BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_GET
#define CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_GET BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_GET
#define CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_SET BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_SET
#define READ_CL37_SYNC_STS_FILTER_TMRr BCMI_QTC_XGXS_READ_CL37_SYNC_STS_FILTER_TMRr
#define WRITE_CL37_SYNC_STS_FILTER_TMRr BCMI_QTC_XGXS_WRITE_CL37_SYNC_STS_FILTER_TMRr
#define MODIFY_CL37_SYNC_STS_FILTER_TMRr BCMI_QTC_XGXS_MODIFY_CL37_SYNC_STS_FILTER_TMRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL37_SYNC_STS_FILTER_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SGMII_CL37_TMR_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9254
 * DESC:     CL37 SGMII TIMER
 * SIZE:     32
 * FIELDS:
 *     SGMII_TIMER      This timer is used in CL37 for all SGMII time related functions such as link timer, send timer, ...
 */
#define BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr (0x00109254 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SGMII_CL37_TMR_TYPE.
 */
typedef union BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_s {
	uint32_t v[1];
	uint32_t sgmii_cl37_tmr_type[1];
	uint32_t _sgmii_cl37_tmr_type;
} BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_t;

#define BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_CLR(r) (r).sgmii_cl37_tmr_type[0] = 0
#define BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SET(r,d) (r).sgmii_cl37_tmr_type[0] = d
#define BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_GET(r) (r).sgmii_cl37_tmr_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SGMII_TIMERf_GET(r) (((r).sgmii_cl37_tmr_type[0]) & 0xffff)
#define BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SGMII_TIMERf_SET(r,f) (r).sgmii_cl37_tmr_type[0]=(((r).sgmii_cl37_tmr_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access SGMII_CL37_TMR_TYPE.
 */
#define BCMI_QTC_XGXS_READ_SGMII_CL37_TMR_TYPEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr,(_r._sgmii_cl37_tmr_type))
#define BCMI_QTC_XGXS_WRITE_SGMII_CL37_TMR_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr,(_r._sgmii_cl37_tmr_type)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SGMII_CL37_TMR_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr,(_r._sgmii_cl37_tmr_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SGMII_CL37_TMR_TYPEr BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr
#define SGMII_CL37_TMR_TYPEr_SIZE BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SIZE
typedef BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_t SGMII_CL37_TMR_TYPEr_t;
#define SGMII_CL37_TMR_TYPEr_CLR BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_CLR
#define SGMII_CL37_TMR_TYPEr_SET BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SET
#define SGMII_CL37_TMR_TYPEr_GET BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_GET
#define SGMII_CL37_TMR_TYPEr_SGMII_TIMERf_GET BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SGMII_TIMERf_GET
#define SGMII_CL37_TMR_TYPEr_SGMII_TIMERf_SET BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr_SGMII_TIMERf_SET
#define READ_SGMII_CL37_TMR_TYPEr BCMI_QTC_XGXS_READ_SGMII_CL37_TMR_TYPEr
#define WRITE_SGMII_CL37_TMR_TYPEr BCMI_QTC_XGXS_WRITE_SGMII_CL37_TMR_TYPEr
#define MODIFY_SGMII_CL37_TMR_TYPEr BCMI_QTC_XGXS_MODIFY_SGMII_CL37_TMR_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SGMII_CL37_TMR_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  LNK_UP_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9255
 * DESC:     CL37 Link up timer
 * SIZE:     32
 * FIELDS:
 *     LINK_UP_TIMER_PERIOD Period/range is 100 tosingle copyCL37 link-up timer.  Timer for the amount of time for the link to come up (after page exchange is done).
 */
#define BCMI_QTC_XGXS_LNK_UP_TYPEr (0x00109255 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_LNK_UP_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program LNK_UP_TYPE.
 */
typedef union BCMI_QTC_XGXS_LNK_UP_TYPEr_s {
	uint32_t v[1];
	uint32_t lnk_up_type[1];
	uint32_t _lnk_up_type;
} BCMI_QTC_XGXS_LNK_UP_TYPEr_t;

#define BCMI_QTC_XGXS_LNK_UP_TYPEr_CLR(r) (r).lnk_up_type[0] = 0
#define BCMI_QTC_XGXS_LNK_UP_TYPEr_SET(r,d) (r).lnk_up_type[0] = d
#define BCMI_QTC_XGXS_LNK_UP_TYPEr_GET(r) (r).lnk_up_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_LNK_UP_TYPEr_LINK_UP_TIMER_PERIODf_GET(r) (((r).lnk_up_type[0]) & 0xffff)
#define BCMI_QTC_XGXS_LNK_UP_TYPEr_LINK_UP_TIMER_PERIODf_SET(r,f) (r).lnk_up_type[0]=(((r).lnk_up_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access LNK_UP_TYPE.
 */
#define BCMI_QTC_XGXS_READ_LNK_UP_TYPEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_LNK_UP_TYPEr,(_r._lnk_up_type))
#define BCMI_QTC_XGXS_WRITE_LNK_UP_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_UP_TYPEr,(_r._lnk_up_type)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_LNK_UP_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_UP_TYPEr,(_r._lnk_up_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LNK_UP_TYPEr BCMI_QTC_XGXS_LNK_UP_TYPEr
#define LNK_UP_TYPEr_SIZE BCMI_QTC_XGXS_LNK_UP_TYPEr_SIZE
typedef BCMI_QTC_XGXS_LNK_UP_TYPEr_t LNK_UP_TYPEr_t;
#define LNK_UP_TYPEr_CLR BCMI_QTC_XGXS_LNK_UP_TYPEr_CLR
#define LNK_UP_TYPEr_SET BCMI_QTC_XGXS_LNK_UP_TYPEr_SET
#define LNK_UP_TYPEr_GET BCMI_QTC_XGXS_LNK_UP_TYPEr_GET
#define LNK_UP_TYPEr_LINK_UP_TIMER_PERIODf_GET BCMI_QTC_XGXS_LNK_UP_TYPEr_LINK_UP_TIMER_PERIODf_GET
#define LNK_UP_TYPEr_LINK_UP_TIMER_PERIODf_SET BCMI_QTC_XGXS_LNK_UP_TYPEr_LINK_UP_TIMER_PERIODf_SET
#define READ_LNK_UP_TYPEr BCMI_QTC_XGXS_READ_LNK_UP_TYPEr
#define WRITE_LNK_UP_TYPEr BCMI_QTC_XGXS_WRITE_LNK_UP_TYPEr
#define MODIFY_LNK_UP_TYPEr BCMI_QTC_XGXS_MODIFY_LNK_UP_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_LNK_UP_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  IGNORE_LNK_TMR_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9256
 * DESC:     CL37 Ignore Link timer
 * SIZE:     32
 * FIELDS:
 *     IGNORE_LINK_TIMER_PERIOD Period/range is 100 tosingle copyThis is Not USED IN CL37 but good to have it for debugging purpose (if Link up takes time)
 */
#define BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr (0x00109256 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program IGNORE_LNK_TMR_TYPE.
 */
typedef union BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_s {
	uint32_t v[1];
	uint32_t ignore_lnk_tmr_type[1];
	uint32_t _ignore_lnk_tmr_type;
} BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_t;

#define BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_CLR(r) (r).ignore_lnk_tmr_type[0] = 0
#define BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_SET(r,d) (r).ignore_lnk_tmr_type[0] = d
#define BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_GET(r) (r).ignore_lnk_tmr_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_IGNORE_LINK_TIMER_PERIODf_GET(r) (((r).ignore_lnk_tmr_type[0]) & 0xffff)
#define BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_IGNORE_LINK_TIMER_PERIODf_SET(r,f) (r).ignore_lnk_tmr_type[0]=(((r).ignore_lnk_tmr_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access IGNORE_LNK_TMR_TYPE.
 */
#define BCMI_QTC_XGXS_READ_IGNORE_LNK_TMR_TYPEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr,(_r._ignore_lnk_tmr_type))
#define BCMI_QTC_XGXS_WRITE_IGNORE_LNK_TMR_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr,(_r._ignore_lnk_tmr_type)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_IGNORE_LNK_TMR_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr,(_r._ignore_lnk_tmr_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define IGNORE_LNK_TMR_TYPEr BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr
#define IGNORE_LNK_TMR_TYPEr_SIZE BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_SIZE
typedef BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_t IGNORE_LNK_TMR_TYPEr_t;
#define IGNORE_LNK_TMR_TYPEr_CLR BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_CLR
#define IGNORE_LNK_TMR_TYPEr_SET BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_SET
#define IGNORE_LNK_TMR_TYPEr_GET BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_GET
#define IGNORE_LNK_TMR_TYPEr_IGNORE_LINK_TIMER_PERIODf_GET BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_IGNORE_LINK_TIMER_PERIODf_GET
#define IGNORE_LNK_TMR_TYPEr_IGNORE_LINK_TIMER_PERIODf_SET BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr_IGNORE_LINK_TIMER_PERIODf_SET
#define READ_IGNORE_LNK_TMR_TYPEr BCMI_QTC_XGXS_READ_IGNORE_LNK_TMR_TYPEr
#define WRITE_IGNORE_LNK_TMR_TYPEr BCMI_QTC_XGXS_WRITE_IGNORE_LNK_TMR_TYPEr
#define MODIFY_IGNORE_LNK_TMR_TYPEr BCMI_QTC_XGXS_MODIFY_IGNORE_LNK_TMR_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_IGNORE_LNK_TMR_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  LNK_FAIL_INHBT_TMR_NOT_CL72_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9257
 * DESC:     CL37 nCL72 timer
 * SIZE:     32
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD Period/range is 100 tosingle copyTimer for qualifying a link_status==FAIL indication or a link_status==OK indication. This is Not USED IN CL37 but good to have it for debugging purpose (if Link up takes time)
 */
#define BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr (0x00109257 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program LNK_FAIL_INHBT_TMR_NOT_CL72_TYPE.
 */
typedef union BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_s {
	uint32_t v[1];
	uint32_t lnk_fail_inhbt_tmr_not_cl72_type[1];
	uint32_t _lnk_fail_inhbt_tmr_not_cl72_type;
} BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_t;

#define BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_CLR(r) (r).lnk_fail_inhbt_tmr_not_cl72_type[0] = 0
#define BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_SET(r,d) (r).lnk_fail_inhbt_tmr_not_cl72_type[0] = d
#define BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_GET(r) (r).lnk_fail_inhbt_tmr_not_cl72_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET(r) (((r).lnk_fail_inhbt_tmr_not_cl72_type[0]) & 0xffff)
#define BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET(r,f) (r).lnk_fail_inhbt_tmr_not_cl72_type[0]=(((r).lnk_fail_inhbt_tmr_not_cl72_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access LNK_FAIL_INHBT_TMR_NOT_CL72_TYPE.
 */
#define BCMI_QTC_XGXS_READ_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr,(_r._lnk_fail_inhbt_tmr_not_cl72_type))
#define BCMI_QTC_XGXS_WRITE_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr,(_r._lnk_fail_inhbt_tmr_not_cl72_type)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr,(_r._lnk_fail_inhbt_tmr_not_cl72_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr
#define LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_SIZE BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_SIZE
typedef BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_t LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_t;
#define LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_CLR BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_CLR
#define LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_SET BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_SET
#define LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_GET BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_GET
#define LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET
#define LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET
#define READ_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr BCMI_QTC_XGXS_READ_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr
#define WRITE_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr BCMI_QTC_XGXS_WRITE_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr
#define MODIFY_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr BCMI_QTC_XGXS_MODIFY_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_LNK_FAIL_INHBT_TMR_NOT_CL72_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_PLL_LOCK_TMR
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9260
 * DESC:     PLL lock timeout period
 * SIZE:     32
 * FIELDS:
 *     PLL_LOCK_TIMER_PERIOD Period/range is XXX msTimer for the maximin amount of time required for PLL to lockIf PLL is not locked during this period of time,the Speed Control logic will report an error and go to Initial state.The Speed Control logic can we restarted after that by SW or AN.
 */
#define BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr (0x00109260 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PLL_LOCK_TMR.
 */
typedef union BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_s {
	uint32_t v[1];
	uint32_t sc_x1_pll_lock_tmr[1];
	uint32_t _sc_x1_pll_lock_tmr;
} BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_t;

#define BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_CLR(r) (r).sc_x1_pll_lock_tmr[0] = 0
#define BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_SET(r,d) (r).sc_x1_pll_lock_tmr[0] = d
#define BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_GET(r) (r).sc_x1_pll_lock_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET(r) (((r).sc_x1_pll_lock_tmr[0]) & 0xffff)
#define BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET(r,f) (r).sc_x1_pll_lock_tmr[0]=(((r).sc_x1_pll_lock_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access SC_X1_PLL_LOCK_TMR.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_PLL_LOCK_TMRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr))
#define BCMI_QTC_XGXS_WRITE_SC_X1_PLL_LOCK_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_PLL_LOCK_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PLL_LOCK_TMRr BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr
#define SC_X1_PLL_LOCK_TMRr_SIZE BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_t SC_X1_PLL_LOCK_TMRr_t;
#define SC_X1_PLL_LOCK_TMRr_CLR BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_CLR
#define SC_X1_PLL_LOCK_TMRr_SET BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_SET
#define SC_X1_PLL_LOCK_TMRr_GET BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_GET
#define SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET
#define SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET
#define READ_SC_X1_PLL_LOCK_TMRr BCMI_QTC_XGXS_READ_SC_X1_PLL_LOCK_TMRr
#define WRITE_SC_X1_PLL_LOCK_TMRr BCMI_QTC_XGXS_WRITE_SC_X1_PLL_LOCK_TMRr
#define MODIFY_SC_X1_PLL_LOCK_TMRr BCMI_QTC_XGXS_MODIFY_SC_X1_PLL_LOCK_TMRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_PLL_LOCK_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_PMD_LOCK_TMR
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9261
 * DESC:     PMD lock timeout period
 * SIZE:     32
 * FIELDS:
 *     PMD_LOCK_TIMER_PERIOD Period/range is XXX msTimer for the maximin amount of time required for PMD RX to lockIf PMD RX is not locked during this period of time,the Speed Control logic will report an error and go to Initial state.The Speed Control logic can we restarted after that by SW or AN.
 */
#define BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr (0x00109261 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PMD_LOCK_TMR.
 */
typedef union BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_s {
	uint32_t v[1];
	uint32_t sc_x1_pmd_lock_tmr[1];
	uint32_t _sc_x1_pmd_lock_tmr;
} BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_t;

#define BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_CLR(r) (r).sc_x1_pmd_lock_tmr[0] = 0
#define BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_SET(r,d) (r).sc_x1_pmd_lock_tmr[0] = d
#define BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_GET(r) (r).sc_x1_pmd_lock_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET(r) (((r).sc_x1_pmd_lock_tmr[0]) & 0xffff)
#define BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET(r,f) (r).sc_x1_pmd_lock_tmr[0]=(((r).sc_x1_pmd_lock_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access SC_X1_PMD_LOCK_TMR.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_PMD_LOCK_TMRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr))
#define BCMI_QTC_XGXS_WRITE_SC_X1_PMD_LOCK_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_PMD_LOCK_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PMD_LOCK_TMRr BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr
#define SC_X1_PMD_LOCK_TMRr_SIZE BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_t SC_X1_PMD_LOCK_TMRr_t;
#define SC_X1_PMD_LOCK_TMRr_CLR BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_CLR
#define SC_X1_PMD_LOCK_TMRr_SET BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_SET
#define SC_X1_PMD_LOCK_TMRr_GET BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_GET
#define SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET
#define SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET
#define READ_SC_X1_PMD_LOCK_TMRr BCMI_QTC_XGXS_READ_SC_X1_PMD_LOCK_TMRr
#define WRITE_SC_X1_PMD_LOCK_TMRr BCMI_QTC_XGXS_WRITE_SC_X1_PMD_LOCK_TMRr
#define MODIFY_SC_X1_PMD_LOCK_TMRr BCMI_QTC_XGXS_MODIFY_SC_X1_PMD_LOCK_TMRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_PMD_LOCK_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_PIPE_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9262
 * DESC:     Pipeline reset count
 * SIZE:     32
 * FIELDS:
 *     PIPELINE_RESET_COUNT period in clock cyclesshould be set to 0xffCounter for amount of time to keep pipeline in resetduring speed change process
 */
#define BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr (0x00109262 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PIPE_RST_CNT.
 */
typedef union BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_pipe_rst_cnt[1];
	uint32_t _sc_x1_pipe_rst_cnt;
} BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_t;

#define BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_CLR(r) (r).sc_x1_pipe_rst_cnt[0] = 0
#define BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_SET(r,d) (r).sc_x1_pipe_rst_cnt[0] = d
#define BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_GET(r) (r).sc_x1_pipe_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET(r) (((r).sc_x1_pipe_rst_cnt[0]) & 0xffff)
#define BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET(r,f) (r).sc_x1_pipe_rst_cnt[0]=(((r).sc_x1_pipe_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access SC_X1_PIPE_RST_CNT.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_PIPE_RST_CNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))
#define BCMI_QTC_XGXS_WRITE_SC_X1_PIPE_RST_CNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PIPE_RST_CNTr BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr
#define SC_X1_PIPE_RST_CNTr_SIZE BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_t SC_X1_PIPE_RST_CNTr_t;
#define SC_X1_PIPE_RST_CNTr_CLR BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_CLR
#define SC_X1_PIPE_RST_CNTr_SET BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_SET
#define SC_X1_PIPE_RST_CNTr_GET BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET
#define READ_SC_X1_PIPE_RST_CNTr BCMI_QTC_XGXS_READ_SC_X1_PIPE_RST_CNTr
#define WRITE_SC_X1_PIPE_RST_CNTr BCMI_QTC_XGXS_WRITE_SC_X1_PIPE_RST_CNTr
#define MODIFY_SC_X1_PIPE_RST_CNTr BCMI_QTC_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_PIPE_RST_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_TX_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9263
 * DESC:     tx pipeline reset count
 * SIZE:     32
 * FIELDS:
 *     TX_RESET_COUNT   period in clock cyclesCounter for amount of time to keep after pll is lockedduring speed change process
 */
#define BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr (0x00109263 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_TX_RST_CNT.
 */
typedef union BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_tx_rst_cnt[1];
	uint32_t _sc_x1_tx_rst_cnt;
} BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_t;

#define BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_CLR(r) (r).sc_x1_tx_rst_cnt[0] = 0
#define BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_SET(r,d) (r).sc_x1_tx_rst_cnt[0] = d
#define BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_GET(r) (r).sc_x1_tx_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET(r) (((r).sc_x1_tx_rst_cnt[0]) & 0xffff)
#define BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET(r,f) (r).sc_x1_tx_rst_cnt[0]=(((r).sc_x1_tx_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access SC_X1_TX_RST_CNT.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_TX_RST_CNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))
#define BCMI_QTC_XGXS_WRITE_SC_X1_TX_RST_CNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_TX_RST_CNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_TX_RST_CNTr BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr
#define SC_X1_TX_RST_CNTr_SIZE BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_t SC_X1_TX_RST_CNTr_t;
#define SC_X1_TX_RST_CNTr_CLR BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_CLR
#define SC_X1_TX_RST_CNTr_SET BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_SET
#define SC_X1_TX_RST_CNTr_GET BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET
#define READ_SC_X1_TX_RST_CNTr BCMI_QTC_XGXS_READ_SC_X1_TX_RST_CNTr
#define WRITE_SC_X1_TX_RST_CNTr BCMI_QTC_XGXS_WRITE_SC_X1_TX_RST_CNTr
#define MODIFY_SC_X1_TX_RST_CNTr BCMI_QTC_XGXS_MODIFY_SC_X1_TX_RST_CNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_TX_RST_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9270
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr (0x00109270 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_spd[1];
	uint32_t _sc_x1_spd_ovrr0_spd;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_CLR(r) (r).sc_x1_spd_ovrr0_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SET(r,d) (r).sc_x1_spd_ovrr0_spd[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_GET(r) (r).sc_x1_spd_ovrr0_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET(r) (((r).sc_x1_spd_ovrr0_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_SPDr BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr
#define SC_X1_SPD_OVRR0_SPDr_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_t SC_X1_SPD_OVRR0_SPDr_t;
#define SC_X1_SPD_OVRR0_SPDr_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_CLR
#define SC_X1_SPD_OVRR0_SPDr_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SET
#define SC_X1_SPD_OVRR0_SPDr_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_GET
#define SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET
#define READ_SC_X1_SPD_OVRR0_SPDr BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_SPDr
#define WRITE_SC_X1_SPD_OVRR0_SPDr BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_SPDr
#define MODIFY_SC_X1_SPD_OVRR0_SPDr BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9271
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r (0x00109271 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_0.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_0[1];
	uint32_t _sc_x1_spd_ovrr0_0;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_CLR(r) (r).sc_x1_spd_ovrr0_0[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_SET(r,d) (r).sc_x1_spd_ovrr0_0[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_GET(r) (r).sc_x1_spd_ovrr0_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_QSGMII_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_QSGMII_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_GET(r) (((r).sc_x1_spd_ovrr0_0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_0.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_0r BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r
#define SC_X1_SPD_OVRR0_0r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_t SC_X1_SPD_OVRR0_0r_t;
#define SC_X1_SPD_OVRR0_0r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_CLR
#define SC_X1_SPD_OVRR0_0r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_SET
#define SC_X1_SPD_OVRR0_0r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_GET
#define SC_X1_SPD_OVRR0_0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_QSGMII_ENf_GET
#define SC_X1_SPD_OVRR0_0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_QSGMII_ENf_SET
#define SC_X1_SPD_OVRR0_0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR0_0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR0_0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_SET
#define READ_SC_X1_SPD_OVRR0_0r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_0r
#define WRITE_SC_X1_SPD_OVRR0_0r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_0r
#define MODIFY_SC_X1_SPD_OVRR0_0r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9272
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r (0x00109272 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_1.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_1[1];
	uint32_t _sc_x1_spd_ovrr0_1;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_CLR(r) (r).sc_x1_spd_ovrr0_1[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SET(r,d) (r).sc_x1_spd_ovrr0_1[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_GET(r) (r).sc_x1_spd_ovrr0_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr0_1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_1.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_1r BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r
#define SC_X1_SPD_OVRR0_1r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_t SC_X1_SPD_OVRR0_1r_t;
#define SC_X1_SPD_OVRR0_1r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_CLR
#define SC_X1_SPD_OVRR0_1r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SET
#define SC_X1_SPD_OVRR0_1r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_GET
#define SC_X1_SPD_OVRR0_1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR0_1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR0_1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR0_1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR0_1r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_1r
#define WRITE_SC_X1_SPD_OVRR0_1r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_1r
#define MODIFY_SC_X1_SPD_OVRR0_1r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9273
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r (0x00109273 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_2.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_2[1];
	uint32_t _sc_x1_spd_ovrr0_2;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_CLR(r) (r).sc_x1_spd_ovrr0_2[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_SET(r,d) (r).sc_x1_spd_ovrr0_2[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_GET(r) (r).sc_x1_spd_ovrr0_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr0_2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr0_2[0]=(((r).sc_x1_spd_ovrr0_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_2.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_2r BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r
#define SC_X1_SPD_OVRR0_2r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_t SC_X1_SPD_OVRR0_2r_t;
#define SC_X1_SPD_OVRR0_2r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_CLR
#define SC_X1_SPD_OVRR0_2r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_SET
#define SC_X1_SPD_OVRR0_2r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_GET
#define SC_X1_SPD_OVRR0_2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR0_2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR0_2r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_2r
#define WRITE_SC_X1_SPD_OVRR0_2r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_2r
#define MODIFY_SC_X1_SPD_OVRR0_2r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9274
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r (0x00109274 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_3.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_3[1];
	uint32_t _sc_x1_spd_ovrr0_3;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_CLR(r) (r).sc_x1_spd_ovrr0_3[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_SET(r,d) (r).sc_x1_spd_ovrr0_3[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_GET(r) (r).sc_x1_spd_ovrr0_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr0_3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_3[0]=(((r).sc_x1_spd_ovrr0_3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr0_3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr0_3[0]=(((r).sc_x1_spd_ovrr0_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_3.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_3r BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r
#define SC_X1_SPD_OVRR0_3r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_t SC_X1_SPD_OVRR0_3r_t;
#define SC_X1_SPD_OVRR0_3r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_CLR
#define SC_X1_SPD_OVRR0_3r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_SET
#define SC_X1_SPD_OVRR0_3r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_GET
#define SC_X1_SPD_OVRR0_3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR0_3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR0_3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR0_3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR0_3r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_3r
#define WRITE_SC_X1_SPD_OVRR0_3r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_3r
#define MODIFY_SC_X1_SPD_OVRR0_3r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9275
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r (0x00109275 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_4.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_4[1];
	uint32_t _sc_x1_spd_ovrr0_4;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_CLR(r) (r).sc_x1_spd_ovrr0_4[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_SET(r,d) (r).sc_x1_spd_ovrr0_4[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_GET(r) (r).sc_x1_spd_ovrr0_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr0_4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr0_4[0]=(((r).sc_x1_spd_ovrr0_4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_4.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_4r BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r
#define SC_X1_SPD_OVRR0_4r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_t SC_X1_SPD_OVRR0_4r_t;
#define SC_X1_SPD_OVRR0_4r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_CLR
#define SC_X1_SPD_OVRR0_4r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_SET
#define SC_X1_SPD_OVRR0_4r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_GET
#define SC_X1_SPD_OVRR0_4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR0_4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR0_4r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_4r
#define WRITE_SC_X1_SPD_OVRR0_4r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_4r
#define MODIFY_SC_X1_SPD_OVRR0_4r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9276
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r (0x00109276 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_5.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_5[1];
	uint32_t _sc_x1_spd_ovrr0_5;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_CLR(r) (r).sc_x1_spd_ovrr0_5[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_SET(r,d) (r).sc_x1_spd_ovrr0_5[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_GET(r) (r).sc_x1_spd_ovrr0_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr0_5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr0_5[0]=(((r).sc_x1_spd_ovrr0_5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr0_5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr0_5[0]=(((r).sc_x1_spd_ovrr0_5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr0_5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_5[0]=(((r).sc_x1_spd_ovrr0_5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_5.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_5r BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r
#define SC_X1_SPD_OVRR0_5r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_t SC_X1_SPD_OVRR0_5r_t;
#define SC_X1_SPD_OVRR0_5r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_CLR
#define SC_X1_SPD_OVRR0_5r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_SET
#define SC_X1_SPD_OVRR0_5r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_GET
#define SC_X1_SPD_OVRR0_5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR0_5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR0_5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR0_5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR0_5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR0_5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR0_5r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_5r
#define WRITE_SC_X1_SPD_OVRR0_5r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_5r
#define MODIFY_SC_X1_SPD_OVRR0_5r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9277
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r (0x00109277 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_6.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_6[1];
	uint32_t _sc_x1_spd_ovrr0_6;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_CLR(r) (r).sc_x1_spd_ovrr0_6[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_SET(r,d) (r).sc_x1_spd_ovrr0_6[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_GET(r) (r).sc_x1_spd_ovrr0_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr0_6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_6.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_6r BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r
#define SC_X1_SPD_OVRR0_6r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_t SC_X1_SPD_OVRR0_6r_t;
#define SC_X1_SPD_OVRR0_6r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_CLR
#define SC_X1_SPD_OVRR0_6r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_SET
#define SC_X1_SPD_OVRR0_6r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_GET
#define SC_X1_SPD_OVRR0_6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR0_6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR0_6r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR0_6r
#define WRITE_SC_X1_SPD_OVRR0_6r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR0_6r
#define MODIFY_SC_X1_SPD_OVRR0_6r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR0_6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR0_6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9280
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr (0x00109280 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_spd[1];
	uint32_t _sc_x1_spd_ovrr1_spd;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_CLR(r) (r).sc_x1_spd_ovrr1_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SET(r,d) (r).sc_x1_spd_ovrr1_spd[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_GET(r) (r).sc_x1_spd_ovrr1_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET(r) (((r).sc_x1_spd_ovrr1_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_SPDr BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr
#define SC_X1_SPD_OVRR1_SPDr_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_t SC_X1_SPD_OVRR1_SPDr_t;
#define SC_X1_SPD_OVRR1_SPDr_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_CLR
#define SC_X1_SPD_OVRR1_SPDr_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SET
#define SC_X1_SPD_OVRR1_SPDr_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_GET
#define SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET
#define READ_SC_X1_SPD_OVRR1_SPDr BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_SPDr
#define WRITE_SC_X1_SPD_OVRR1_SPDr BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_SPDr
#define MODIFY_SC_X1_SPD_OVRR1_SPDr BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9281
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r (0x00109281 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_0.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_0[1];
	uint32_t _sc_x1_spd_ovrr1_0;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_CLR(r) (r).sc_x1_spd_ovrr1_0[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_SET(r,d) (r).sc_x1_spd_ovrr1_0[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_GET(r) (r).sc_x1_spd_ovrr1_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_QSGMII_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_QSGMII_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_GET(r) (((r).sc_x1_spd_ovrr1_0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_0.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_0r BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r
#define SC_X1_SPD_OVRR1_0r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_t SC_X1_SPD_OVRR1_0r_t;
#define SC_X1_SPD_OVRR1_0r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_CLR
#define SC_X1_SPD_OVRR1_0r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_SET
#define SC_X1_SPD_OVRR1_0r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_GET
#define SC_X1_SPD_OVRR1_0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_QSGMII_ENf_GET
#define SC_X1_SPD_OVRR1_0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_QSGMII_ENf_SET
#define SC_X1_SPD_OVRR1_0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR1_0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR1_0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_SET
#define READ_SC_X1_SPD_OVRR1_0r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_0r
#define WRITE_SC_X1_SPD_OVRR1_0r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_0r
#define MODIFY_SC_X1_SPD_OVRR1_0r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9282
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r (0x00109282 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_1.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_1[1];
	uint32_t _sc_x1_spd_ovrr1_1;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_CLR(r) (r).sc_x1_spd_ovrr1_1[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SET(r,d) (r).sc_x1_spd_ovrr1_1[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_GET(r) (r).sc_x1_spd_ovrr1_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr1_1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_1.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_1r BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r
#define SC_X1_SPD_OVRR1_1r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_t SC_X1_SPD_OVRR1_1r_t;
#define SC_X1_SPD_OVRR1_1r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_CLR
#define SC_X1_SPD_OVRR1_1r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SET
#define SC_X1_SPD_OVRR1_1r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_GET
#define SC_X1_SPD_OVRR1_1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR1_1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR1_1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR1_1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR1_1r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_1r
#define WRITE_SC_X1_SPD_OVRR1_1r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_1r
#define MODIFY_SC_X1_SPD_OVRR1_1r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9283
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r (0x00109283 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_2.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_2[1];
	uint32_t _sc_x1_spd_ovrr1_2;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_CLR(r) (r).sc_x1_spd_ovrr1_2[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_SET(r,d) (r).sc_x1_spd_ovrr1_2[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_GET(r) (r).sc_x1_spd_ovrr1_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr1_2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr1_2[0]=(((r).sc_x1_spd_ovrr1_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_2.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_2r BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r
#define SC_X1_SPD_OVRR1_2r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_t SC_X1_SPD_OVRR1_2r_t;
#define SC_X1_SPD_OVRR1_2r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_CLR
#define SC_X1_SPD_OVRR1_2r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_SET
#define SC_X1_SPD_OVRR1_2r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_GET
#define SC_X1_SPD_OVRR1_2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR1_2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR1_2r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_2r
#define WRITE_SC_X1_SPD_OVRR1_2r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_2r
#define MODIFY_SC_X1_SPD_OVRR1_2r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9284
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r (0x00109284 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_3.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_3[1];
	uint32_t _sc_x1_spd_ovrr1_3;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_CLR(r) (r).sc_x1_spd_ovrr1_3[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_SET(r,d) (r).sc_x1_spd_ovrr1_3[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_GET(r) (r).sc_x1_spd_ovrr1_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr1_3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_3[0]=(((r).sc_x1_spd_ovrr1_3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr1_3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr1_3[0]=(((r).sc_x1_spd_ovrr1_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_3.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_3r BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r
#define SC_X1_SPD_OVRR1_3r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_t SC_X1_SPD_OVRR1_3r_t;
#define SC_X1_SPD_OVRR1_3r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_CLR
#define SC_X1_SPD_OVRR1_3r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_SET
#define SC_X1_SPD_OVRR1_3r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_GET
#define SC_X1_SPD_OVRR1_3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR1_3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR1_3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR1_3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR1_3r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_3r
#define WRITE_SC_X1_SPD_OVRR1_3r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_3r
#define MODIFY_SC_X1_SPD_OVRR1_3r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9285
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r (0x00109285 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_4.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_4[1];
	uint32_t _sc_x1_spd_ovrr1_4;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_CLR(r) (r).sc_x1_spd_ovrr1_4[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_SET(r,d) (r).sc_x1_spd_ovrr1_4[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_GET(r) (r).sc_x1_spd_ovrr1_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr1_4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr1_4[0]=(((r).sc_x1_spd_ovrr1_4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_4.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_4r BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r
#define SC_X1_SPD_OVRR1_4r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_t SC_X1_SPD_OVRR1_4r_t;
#define SC_X1_SPD_OVRR1_4r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_CLR
#define SC_X1_SPD_OVRR1_4r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_SET
#define SC_X1_SPD_OVRR1_4r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_GET
#define SC_X1_SPD_OVRR1_4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR1_4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR1_4r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_4r
#define WRITE_SC_X1_SPD_OVRR1_4r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_4r
#define MODIFY_SC_X1_SPD_OVRR1_4r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9286
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r (0x00109286 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_5.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_5[1];
	uint32_t _sc_x1_spd_ovrr1_5;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_CLR(r) (r).sc_x1_spd_ovrr1_5[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_SET(r,d) (r).sc_x1_spd_ovrr1_5[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_GET(r) (r).sc_x1_spd_ovrr1_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr1_5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr1_5[0]=(((r).sc_x1_spd_ovrr1_5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr1_5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr1_5[0]=(((r).sc_x1_spd_ovrr1_5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr1_5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_5[0]=(((r).sc_x1_spd_ovrr1_5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_5.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_5r BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r
#define SC_X1_SPD_OVRR1_5r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_t SC_X1_SPD_OVRR1_5r_t;
#define SC_X1_SPD_OVRR1_5r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_CLR
#define SC_X1_SPD_OVRR1_5r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_SET
#define SC_X1_SPD_OVRR1_5r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_GET
#define SC_X1_SPD_OVRR1_5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR1_5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR1_5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR1_5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR1_5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR1_5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR1_5r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_5r
#define WRITE_SC_X1_SPD_OVRR1_5r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_5r
#define MODIFY_SC_X1_SPD_OVRR1_5r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9287
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r (0x00109287 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_6.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_6[1];
	uint32_t _sc_x1_spd_ovrr1_6;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_CLR(r) (r).sc_x1_spd_ovrr1_6[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_SET(r,d) (r).sc_x1_spd_ovrr1_6[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_GET(r) (r).sc_x1_spd_ovrr1_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr1_6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_6.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_6r BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r
#define SC_X1_SPD_OVRR1_6r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_t SC_X1_SPD_OVRR1_6r_t;
#define SC_X1_SPD_OVRR1_6r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_CLR
#define SC_X1_SPD_OVRR1_6r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_SET
#define SC_X1_SPD_OVRR1_6r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_GET
#define SC_X1_SPD_OVRR1_6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR1_6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR1_6r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR1_6r
#define WRITE_SC_X1_SPD_OVRR1_6r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR1_6r
#define MODIFY_SC_X1_SPD_OVRR1_6r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR1_6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR1_6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9290
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr (0x00109290 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_spd[1];
	uint32_t _sc_x1_spd_ovrr2_spd;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_CLR(r) (r).sc_x1_spd_ovrr2_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SET(r,d) (r).sc_x1_spd_ovrr2_spd[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_GET(r) (r).sc_x1_spd_ovrr2_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET(r) (((r).sc_x1_spd_ovrr2_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_SPDr BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr
#define SC_X1_SPD_OVRR2_SPDr_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_t SC_X1_SPD_OVRR2_SPDr_t;
#define SC_X1_SPD_OVRR2_SPDr_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_CLR
#define SC_X1_SPD_OVRR2_SPDr_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SET
#define SC_X1_SPD_OVRR2_SPDr_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_GET
#define SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET
#define READ_SC_X1_SPD_OVRR2_SPDr BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_SPDr
#define WRITE_SC_X1_SPD_OVRR2_SPDr BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_SPDr
#define MODIFY_SC_X1_SPD_OVRR2_SPDr BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9291
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r (0x00109291 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_0.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_0[1];
	uint32_t _sc_x1_spd_ovrr2_0;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_CLR(r) (r).sc_x1_spd_ovrr2_0[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_SET(r,d) (r).sc_x1_spd_ovrr2_0[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_GET(r) (r).sc_x1_spd_ovrr2_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_QSGMII_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_QSGMII_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_GET(r) (((r).sc_x1_spd_ovrr2_0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_0.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_0r BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r
#define SC_X1_SPD_OVRR2_0r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_t SC_X1_SPD_OVRR2_0r_t;
#define SC_X1_SPD_OVRR2_0r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_CLR
#define SC_X1_SPD_OVRR2_0r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_SET
#define SC_X1_SPD_OVRR2_0r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_GET
#define SC_X1_SPD_OVRR2_0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_QSGMII_ENf_GET
#define SC_X1_SPD_OVRR2_0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_QSGMII_ENf_SET
#define SC_X1_SPD_OVRR2_0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR2_0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR2_0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_SET
#define READ_SC_X1_SPD_OVRR2_0r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_0r
#define WRITE_SC_X1_SPD_OVRR2_0r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_0r
#define MODIFY_SC_X1_SPD_OVRR2_0r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9292
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r (0x00109292 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_1.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_1[1];
	uint32_t _sc_x1_spd_ovrr2_1;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_CLR(r) (r).sc_x1_spd_ovrr2_1[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SET(r,d) (r).sc_x1_spd_ovrr2_1[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_GET(r) (r).sc_x1_spd_ovrr2_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr2_1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_1.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_1r BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r
#define SC_X1_SPD_OVRR2_1r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_t SC_X1_SPD_OVRR2_1r_t;
#define SC_X1_SPD_OVRR2_1r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_CLR
#define SC_X1_SPD_OVRR2_1r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SET
#define SC_X1_SPD_OVRR2_1r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_GET
#define SC_X1_SPD_OVRR2_1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR2_1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR2_1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR2_1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR2_1r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_1r
#define WRITE_SC_X1_SPD_OVRR2_1r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_1r
#define MODIFY_SC_X1_SPD_OVRR2_1r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9293
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r (0x00109293 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_2.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_2[1];
	uint32_t _sc_x1_spd_ovrr2_2;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_CLR(r) (r).sc_x1_spd_ovrr2_2[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_SET(r,d) (r).sc_x1_spd_ovrr2_2[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_GET(r) (r).sc_x1_spd_ovrr2_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr2_2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr2_2[0]=(((r).sc_x1_spd_ovrr2_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_2.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_2r BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r
#define SC_X1_SPD_OVRR2_2r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_t SC_X1_SPD_OVRR2_2r_t;
#define SC_X1_SPD_OVRR2_2r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_CLR
#define SC_X1_SPD_OVRR2_2r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_SET
#define SC_X1_SPD_OVRR2_2r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_GET
#define SC_X1_SPD_OVRR2_2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR2_2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR2_2r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_2r
#define WRITE_SC_X1_SPD_OVRR2_2r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_2r
#define MODIFY_SC_X1_SPD_OVRR2_2r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9294
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r (0x00109294 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_3.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_3[1];
	uint32_t _sc_x1_spd_ovrr2_3;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_CLR(r) (r).sc_x1_spd_ovrr2_3[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_SET(r,d) (r).sc_x1_spd_ovrr2_3[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_GET(r) (r).sc_x1_spd_ovrr2_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr2_3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_3[0]=(((r).sc_x1_spd_ovrr2_3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr2_3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr2_3[0]=(((r).sc_x1_spd_ovrr2_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_3.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_3r BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r
#define SC_X1_SPD_OVRR2_3r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_t SC_X1_SPD_OVRR2_3r_t;
#define SC_X1_SPD_OVRR2_3r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_CLR
#define SC_X1_SPD_OVRR2_3r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_SET
#define SC_X1_SPD_OVRR2_3r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_GET
#define SC_X1_SPD_OVRR2_3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR2_3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR2_3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR2_3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR2_3r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_3r
#define WRITE_SC_X1_SPD_OVRR2_3r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_3r
#define MODIFY_SC_X1_SPD_OVRR2_3r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9295
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r (0x00109295 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_4.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_4[1];
	uint32_t _sc_x1_spd_ovrr2_4;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_CLR(r) (r).sc_x1_spd_ovrr2_4[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_SET(r,d) (r).sc_x1_spd_ovrr2_4[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_GET(r) (r).sc_x1_spd_ovrr2_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr2_4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr2_4[0]=(((r).sc_x1_spd_ovrr2_4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_4.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_4r BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r
#define SC_X1_SPD_OVRR2_4r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_t SC_X1_SPD_OVRR2_4r_t;
#define SC_X1_SPD_OVRR2_4r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_CLR
#define SC_X1_SPD_OVRR2_4r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_SET
#define SC_X1_SPD_OVRR2_4r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_GET
#define SC_X1_SPD_OVRR2_4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR2_4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR2_4r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_4r
#define WRITE_SC_X1_SPD_OVRR2_4r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_4r
#define MODIFY_SC_X1_SPD_OVRR2_4r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9296
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r (0x00109296 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_5.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_5[1];
	uint32_t _sc_x1_spd_ovrr2_5;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_CLR(r) (r).sc_x1_spd_ovrr2_5[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_SET(r,d) (r).sc_x1_spd_ovrr2_5[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_GET(r) (r).sc_x1_spd_ovrr2_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr2_5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr2_5[0]=(((r).sc_x1_spd_ovrr2_5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr2_5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr2_5[0]=(((r).sc_x1_spd_ovrr2_5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr2_5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_5[0]=(((r).sc_x1_spd_ovrr2_5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_5.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_5r BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r
#define SC_X1_SPD_OVRR2_5r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_t SC_X1_SPD_OVRR2_5r_t;
#define SC_X1_SPD_OVRR2_5r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_CLR
#define SC_X1_SPD_OVRR2_5r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_SET
#define SC_X1_SPD_OVRR2_5r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_GET
#define SC_X1_SPD_OVRR2_5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR2_5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR2_5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR2_5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR2_5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR2_5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR2_5r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_5r
#define WRITE_SC_X1_SPD_OVRR2_5r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_5r
#define MODIFY_SC_X1_SPD_OVRR2_5r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9297
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r (0x00109297 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_6.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_6[1];
	uint32_t _sc_x1_spd_ovrr2_6;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_CLR(r) (r).sc_x1_spd_ovrr2_6[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_SET(r,d) (r).sc_x1_spd_ovrr2_6[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_GET(r) (r).sc_x1_spd_ovrr2_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr2_6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_6.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_6r BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r
#define SC_X1_SPD_OVRR2_6r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_t SC_X1_SPD_OVRR2_6r_t;
#define SC_X1_SPD_OVRR2_6r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_CLR
#define SC_X1_SPD_OVRR2_6r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_SET
#define SC_X1_SPD_OVRR2_6r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_GET
#define SC_X1_SPD_OVRR2_6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR2_6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR2_6r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR2_6r
#define WRITE_SC_X1_SPD_OVRR2_6r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR2_6r
#define MODIFY_SC_X1_SPD_OVRR2_6r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR2_6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR2_6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a0
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr (0x001092a0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_spd[1];
	uint32_t _sc_x1_spd_ovrr3_spd;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_CLR(r) (r).sc_x1_spd_ovrr3_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SET(r,d) (r).sc_x1_spd_ovrr3_spd[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_GET(r) (r).sc_x1_spd_ovrr3_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET(r) (((r).sc_x1_spd_ovrr3_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_SPDr BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr
#define SC_X1_SPD_OVRR3_SPDr_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_t SC_X1_SPD_OVRR3_SPDr_t;
#define SC_X1_SPD_OVRR3_SPDr_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_CLR
#define SC_X1_SPD_OVRR3_SPDr_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SET
#define SC_X1_SPD_OVRR3_SPDr_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_GET
#define SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET
#define READ_SC_X1_SPD_OVRR3_SPDr BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_SPDr
#define WRITE_SC_X1_SPD_OVRR3_SPDr BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_SPDr
#define MODIFY_SC_X1_SPD_OVRR3_SPDr BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a1
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r (0x001092a1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_0.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_0[1];
	uint32_t _sc_x1_spd_ovrr3_0;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_CLR(r) (r).sc_x1_spd_ovrr3_0[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_SET(r,d) (r).sc_x1_spd_ovrr3_0[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_GET(r) (r).sc_x1_spd_ovrr3_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_QSGMII_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_QSGMII_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_GET(r) (((r).sc_x1_spd_ovrr3_0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_0.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_0r BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r
#define SC_X1_SPD_OVRR3_0r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_t SC_X1_SPD_OVRR3_0r_t;
#define SC_X1_SPD_OVRR3_0r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_CLR
#define SC_X1_SPD_OVRR3_0r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_SET
#define SC_X1_SPD_OVRR3_0r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_GET
#define SC_X1_SPD_OVRR3_0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_QSGMII_ENf_GET
#define SC_X1_SPD_OVRR3_0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_QSGMII_ENf_SET
#define SC_X1_SPD_OVRR3_0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR3_0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR3_0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_SET
#define READ_SC_X1_SPD_OVRR3_0r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_0r
#define WRITE_SC_X1_SPD_OVRR3_0r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_0r
#define MODIFY_SC_X1_SPD_OVRR3_0r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a2
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r (0x001092a2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_1.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_1[1];
	uint32_t _sc_x1_spd_ovrr3_1;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_CLR(r) (r).sc_x1_spd_ovrr3_1[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SET(r,d) (r).sc_x1_spd_ovrr3_1[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_GET(r) (r).sc_x1_spd_ovrr3_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr3_1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_1.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_1r BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r
#define SC_X1_SPD_OVRR3_1r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_t SC_X1_SPD_OVRR3_1r_t;
#define SC_X1_SPD_OVRR3_1r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_CLR
#define SC_X1_SPD_OVRR3_1r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SET
#define SC_X1_SPD_OVRR3_1r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_GET
#define SC_X1_SPD_OVRR3_1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR3_1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR3_1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR3_1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR3_1r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_1r
#define WRITE_SC_X1_SPD_OVRR3_1r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_1r
#define MODIFY_SC_X1_SPD_OVRR3_1r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a3
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r (0x001092a3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_2.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_2[1];
	uint32_t _sc_x1_spd_ovrr3_2;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_CLR(r) (r).sc_x1_spd_ovrr3_2[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_SET(r,d) (r).sc_x1_spd_ovrr3_2[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_GET(r) (r).sc_x1_spd_ovrr3_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr3_2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr3_2[0]=(((r).sc_x1_spd_ovrr3_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_2.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_2r BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r
#define SC_X1_SPD_OVRR3_2r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_t SC_X1_SPD_OVRR3_2r_t;
#define SC_X1_SPD_OVRR3_2r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_CLR
#define SC_X1_SPD_OVRR3_2r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_SET
#define SC_X1_SPD_OVRR3_2r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_GET
#define SC_X1_SPD_OVRR3_2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR3_2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR3_2r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_2r
#define WRITE_SC_X1_SPD_OVRR3_2r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_2r
#define MODIFY_SC_X1_SPD_OVRR3_2r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a4
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r (0x001092a4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_3.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_3[1];
	uint32_t _sc_x1_spd_ovrr3_3;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_CLR(r) (r).sc_x1_spd_ovrr3_3[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_SET(r,d) (r).sc_x1_spd_ovrr3_3[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_GET(r) (r).sc_x1_spd_ovrr3_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr3_3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_3[0]=(((r).sc_x1_spd_ovrr3_3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr3_3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr3_3[0]=(((r).sc_x1_spd_ovrr3_3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_3.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_3r BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r
#define SC_X1_SPD_OVRR3_3r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_t SC_X1_SPD_OVRR3_3r_t;
#define SC_X1_SPD_OVRR3_3r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_CLR
#define SC_X1_SPD_OVRR3_3r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_SET
#define SC_X1_SPD_OVRR3_3r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_GET
#define SC_X1_SPD_OVRR3_3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR3_3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR3_3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR3_3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR3_3r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_3r
#define WRITE_SC_X1_SPD_OVRR3_3r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_3r
#define MODIFY_SC_X1_SPD_OVRR3_3r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a5
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r (0x001092a5 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_4.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_4[1];
	uint32_t _sc_x1_spd_ovrr3_4;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_CLR(r) (r).sc_x1_spd_ovrr3_4[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_SET(r,d) (r).sc_x1_spd_ovrr3_4[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_GET(r) (r).sc_x1_spd_ovrr3_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr3_4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr3_4[0]=(((r).sc_x1_spd_ovrr3_4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_4.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_4r BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r
#define SC_X1_SPD_OVRR3_4r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_t SC_X1_SPD_OVRR3_4r_t;
#define SC_X1_SPD_OVRR3_4r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_CLR
#define SC_X1_SPD_OVRR3_4r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_SET
#define SC_X1_SPD_OVRR3_4r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_GET
#define SC_X1_SPD_OVRR3_4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR3_4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR3_4r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_4r
#define WRITE_SC_X1_SPD_OVRR3_4r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_4r
#define MODIFY_SC_X1_SPD_OVRR3_4r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a6
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r (0x001092a6 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_5.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_5[1];
	uint32_t _sc_x1_spd_ovrr3_5;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_CLR(r) (r).sc_x1_spd_ovrr3_5[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_SET(r,d) (r).sc_x1_spd_ovrr3_5[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_GET(r) (r).sc_x1_spd_ovrr3_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr3_5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr3_5[0]=(((r).sc_x1_spd_ovrr3_5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr3_5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr3_5[0]=(((r).sc_x1_spd_ovrr3_5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr3_5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_5[0]=(((r).sc_x1_spd_ovrr3_5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_5.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_5r BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r
#define SC_X1_SPD_OVRR3_5r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_t SC_X1_SPD_OVRR3_5r_t;
#define SC_X1_SPD_OVRR3_5r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_CLR
#define SC_X1_SPD_OVRR3_5r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_SET
#define SC_X1_SPD_OVRR3_5r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_GET
#define SC_X1_SPD_OVRR3_5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR3_5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR3_5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR3_5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR3_5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR3_5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR3_5r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_5r
#define WRITE_SC_X1_SPD_OVRR3_5r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_5r
#define MODIFY_SC_X1_SPD_OVRR3_5r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a7
 * DESC:     Override speed specification for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r (0x001092a7 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_6.
 */
typedef union BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_6[1];
	uint32_t _sc_x1_spd_ovrr3_6;
} BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_t;

#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_CLR(r) (r).sc_x1_spd_ovrr3_6[0] = 0
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_SET(r,d) (r).sc_x1_spd_ovrr3_6[0] = d
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_GET(r) (r).sc_x1_spd_ovrr3_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr3_6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_6.
 */
#define BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6))
#define BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_6r BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r
#define SC_X1_SPD_OVRR3_6r_SIZE BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_SIZE
typedef BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_t SC_X1_SPD_OVRR3_6r_t;
#define SC_X1_SPD_OVRR3_6r_CLR BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_CLR
#define SC_X1_SPD_OVRR3_6r_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_SET
#define SC_X1_SPD_OVRR3_6r_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_GET
#define SC_X1_SPD_OVRR3_6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR3_6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR3_6r BCMI_QTC_XGXS_READ_SC_X1_SPD_OVRR3_6r
#define WRITE_SC_X1_SPD_OVRR3_6r BCMI_QTC_XGXS_WRITE_SC_X1_SPD_OVRR3_6r
#define MODIFY_SC_X1_SPD_OVRR3_6r BCMI_QTC_XGXS_MODIFY_SC_X1_SPD_OVRR3_6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X1_SPD_OVRR3_6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X4_CTL
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc010
 * DESC:     PMD lane reset controls
 * SIZE:     32
 * FIELDS:
 *     LN_DP_H_RSTB     PMD lane datapath reset override valueOnly used for Speed Control bypass operation
 *     LN_H_RSTB        Reset all lane logic: data path and registers
 *     LN_TX_H_PWRDN    Lane power down, TX direction
 *     LN_RX_H_PWRDN    Lane power down, RX direction
 *     TX_DISABLE       Set to squelch the transmit signal for laneOnly used for Speed Control bypass operation
 *     OSR_MODE         OSR mode. In current implementation only OSR mode 1 is usedOnly used for Speed Control bypass operation
 *     RX_DME_EN        DME is enabled, for CL73 faster sample modeOnly used for Speed Control bypass operation
 */
#define BCMI_QTC_XGXS_PMD_X4_CTLr (0x0000c010 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_CTL.
 */
typedef union BCMI_QTC_XGXS_PMD_X4_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ctl[1];
	uint32_t _pmd_x4_ctl;
} BCMI_QTC_XGXS_PMD_X4_CTLr_t;

#define BCMI_QTC_XGXS_PMD_X4_CTLr_CLR(r) (r).pmd_x4_ctl[0] = 0
#define BCMI_QTC_XGXS_PMD_X4_CTLr_SET(r,d) (r).pmd_x4_ctl[0] = d
#define BCMI_QTC_XGXS_PMD_X4_CTLr_GET(r) (r).pmd_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X4_CTLr_RX_DME_ENf_GET(r) ((((r).pmd_x4_ctl[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_CTLr_RX_DME_ENf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_PMD_X4_CTLr_OSR_MODEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 9) & 0xf)
#define BCMI_QTC_XGXS_PMD_X4_CTLr_OSR_MODEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9)) | (15 << (16 + 9))
#define BCMI_QTC_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_H_RSTBf_GET(r) ((((r).pmd_x4_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_GET(r) (((r).pmd_x4_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X4_CTL.
 */
#define BCMI_QTC_XGXS_READ_PMD_X4_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_QTC_XGXS_WRITE_PMD_X4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_QTC_XGXS_READLN_PMD_X4_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_QTC_XGXS_WRITELN_PMD_X4_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_QTC_XGXS_WRITEALL_PMD_X4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_CTLr BCMI_QTC_XGXS_PMD_X4_CTLr
#define PMD_X4_CTLr_SIZE BCMI_QTC_XGXS_PMD_X4_CTLr_SIZE
typedef BCMI_QTC_XGXS_PMD_X4_CTLr_t PMD_X4_CTLr_t;
#define PMD_X4_CTLr_CLR BCMI_QTC_XGXS_PMD_X4_CTLr_CLR
#define PMD_X4_CTLr_SET BCMI_QTC_XGXS_PMD_X4_CTLr_SET
#define PMD_X4_CTLr_GET BCMI_QTC_XGXS_PMD_X4_CTLr_GET
#define PMD_X4_CTLr_RX_DME_ENf_GET BCMI_QTC_XGXS_PMD_X4_CTLr_RX_DME_ENf_GET
#define PMD_X4_CTLr_RX_DME_ENf_SET BCMI_QTC_XGXS_PMD_X4_CTLr_RX_DME_ENf_SET
#define PMD_X4_CTLr_OSR_MODEf_GET BCMI_QTC_XGXS_PMD_X4_CTLr_OSR_MODEf_GET
#define PMD_X4_CTLr_OSR_MODEf_SET BCMI_QTC_XGXS_PMD_X4_CTLr_OSR_MODEf_SET
#define PMD_X4_CTLr_TX_DISABLEf_GET BCMI_QTC_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET
#define PMD_X4_CTLr_TX_DISABLEf_SET BCMI_QTC_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_GET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_SET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_GET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_SET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_H_RSTBf_GET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_H_RSTBf_GET
#define PMD_X4_CTLr_LN_H_RSTBf_SET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_H_RSTBf_SET
#define PMD_X4_CTLr_LN_DP_H_RSTBf_GET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_GET
#define PMD_X4_CTLr_LN_DP_H_RSTBf_SET BCMI_QTC_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_SET
#define READ_PMD_X4_CTLr BCMI_QTC_XGXS_READ_PMD_X4_CTLr
#define WRITE_PMD_X4_CTLr BCMI_QTC_XGXS_WRITE_PMD_X4_CTLr
#define MODIFY_PMD_X4_CTLr BCMI_QTC_XGXS_MODIFY_PMD_X4_CTLr
#define READLN_PMD_X4_CTLr BCMI_QTC_XGXS_READLN_PMD_X4_CTLr
#define WRITELN_PMD_X4_CTLr BCMI_QTC_XGXS_WRITELN_PMD_X4_CTLr
#define WRITEALL_PMD_X4_CTLr BCMI_QTC_XGXS_WRITEALL_PMD_X4_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X4_MODE
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc011
 * DESC:     PMD lane mode configuration
 * SIZE:     32
 * FIELDS:
 *     LANE_MODE        Lane modeUse the following format: {reserved[4:0], cl72_en, scrambler_dis, eee_mode_en, speed_id[7:0]}Only used for Speed Control bypass operation
 */
#define BCMI_QTC_XGXS_PMD_X4_MODEr (0x0000c011 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X4_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_MODE.
 */
typedef union BCMI_QTC_XGXS_PMD_X4_MODEr_s {
	uint32_t v[1];
	uint32_t pmd_x4_mode[1];
	uint32_t _pmd_x4_mode;
} BCMI_QTC_XGXS_PMD_X4_MODEr_t;

#define BCMI_QTC_XGXS_PMD_X4_MODEr_CLR(r) (r).pmd_x4_mode[0] = 0
#define BCMI_QTC_XGXS_PMD_X4_MODEr_SET(r,d) (r).pmd_x4_mode[0] = d
#define BCMI_QTC_XGXS_PMD_X4_MODEr_GET(r) (r).pmd_x4_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X4_MODEr_LANE_MODEf_GET(r) (((r).pmd_x4_mode[0]) & 0xffff)
#define BCMI_QTC_XGXS_PMD_X4_MODEr_LANE_MODEf_SET(r,f) (r).pmd_x4_mode[0]=(((r).pmd_x4_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PMD_X4_MODE.
 */
#define BCMI_QTC_XGXS_READ_PMD_X4_MODEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_QTC_XGXS_WRITE_PMD_X4_MODEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X4_MODEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_QTC_XGXS_READLN_PMD_X4_MODEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_QTC_XGXS_WRITELN_PMD_X4_MODEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_QTC_XGXS_WRITEALL_PMD_X4_MODEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_mode))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_MODEr BCMI_QTC_XGXS_PMD_X4_MODEr
#define PMD_X4_MODEr_SIZE BCMI_QTC_XGXS_PMD_X4_MODEr_SIZE
typedef BCMI_QTC_XGXS_PMD_X4_MODEr_t PMD_X4_MODEr_t;
#define PMD_X4_MODEr_CLR BCMI_QTC_XGXS_PMD_X4_MODEr_CLR
#define PMD_X4_MODEr_SET BCMI_QTC_XGXS_PMD_X4_MODEr_SET
#define PMD_X4_MODEr_GET BCMI_QTC_XGXS_PMD_X4_MODEr_GET
#define PMD_X4_MODEr_LANE_MODEf_GET BCMI_QTC_XGXS_PMD_X4_MODEr_LANE_MODEf_GET
#define PMD_X4_MODEr_LANE_MODEf_SET BCMI_QTC_XGXS_PMD_X4_MODEr_LANE_MODEf_SET
#define READ_PMD_X4_MODEr BCMI_QTC_XGXS_READ_PMD_X4_MODEr
#define WRITE_PMD_X4_MODEr BCMI_QTC_XGXS_WRITE_PMD_X4_MODEr
#define MODIFY_PMD_X4_MODEr BCMI_QTC_XGXS_MODIFY_PMD_X4_MODEr
#define READLN_PMD_X4_MODEr BCMI_QTC_XGXS_READLN_PMD_X4_MODEr
#define WRITELN_PMD_X4_MODEr BCMI_QTC_XGXS_WRITELN_PMD_X4_MODEr
#define WRITEALL_PMD_X4_MODEr BCMI_QTC_XGXS_WRITEALL_PMD_X4_MODEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X4_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X4_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc012
 * DESC:     PMD lane live status
 * SIZE:     32
 * FIELDS:
 *     RX_LOCK_STS      DSC RX lock indication from PMD
 *     SIGNAL_DETECT_STS Signal Detect indication from PMD
 *     RX_CLK_VLD_STS   rx_clk_vld indication from PMD
 */
#define BCMI_QTC_XGXS_PMD_X4_STSr (0x0000c012 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_STS.
 */
typedef union BCMI_QTC_XGXS_PMD_X4_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_sts[1];
	uint32_t _pmd_x4_sts;
} BCMI_QTC_XGXS_PMD_X4_STSr_t;

#define BCMI_QTC_XGXS_PMD_X4_STSr_CLR(r) (r).pmd_x4_sts[0] = 0
#define BCMI_QTC_XGXS_PMD_X4_STSr_SET(r,d) (r).pmd_x4_sts[0] = d
#define BCMI_QTC_XGXS_PMD_X4_STSr_GET(r) (r).pmd_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET(r) (((r).pmd_x4_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X4_STS.
 */
#define BCMI_QTC_XGXS_READ_PMD_X4_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_QTC_XGXS_WRITE_PMD_X4_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X4_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_QTC_XGXS_READLN_PMD_X4_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_QTC_XGXS_WRITELN_PMD_X4_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_QTC_XGXS_WRITEALL_PMD_X4_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_STSr BCMI_QTC_XGXS_PMD_X4_STSr
#define PMD_X4_STSr_SIZE BCMI_QTC_XGXS_PMD_X4_STSr_SIZE
typedef BCMI_QTC_XGXS_PMD_X4_STSr_t PMD_X4_STSr_t;
#define PMD_X4_STSr_CLR BCMI_QTC_XGXS_PMD_X4_STSr_CLR
#define PMD_X4_STSr_SET BCMI_QTC_XGXS_PMD_X4_STSr_SET
#define PMD_X4_STSr_GET BCMI_QTC_XGXS_PMD_X4_STSr_GET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_GET BCMI_QTC_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_SET BCMI_QTC_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_GET BCMI_QTC_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_SET BCMI_QTC_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET
#define PMD_X4_STSr_RX_LOCK_STSf_GET BCMI_QTC_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET
#define PMD_X4_STSr_RX_LOCK_STSf_SET BCMI_QTC_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET
#define READ_PMD_X4_STSr BCMI_QTC_XGXS_READ_PMD_X4_STSr
#define WRITE_PMD_X4_STSr BCMI_QTC_XGXS_WRITE_PMD_X4_STSr
#define MODIFY_PMD_X4_STSr BCMI_QTC_XGXS_MODIFY_PMD_X4_STSr
#define READLN_PMD_X4_STSr BCMI_QTC_XGXS_READLN_PMD_X4_STSr
#define WRITELN_PMD_X4_STSr BCMI_QTC_XGXS_WRITELN_PMD_X4_STSr
#define WRITEALL_PMD_X4_STSr BCMI_QTC_XGXS_WRITEALL_PMD_X4_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X4_LATCH_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc013
 * DESC:     PMD lane latched status
 * SIZE:     32
 * FIELDS:
 *     RX_LOCK_LL       DSC RX lock indication from PMD negedge detected
 *     RX_LOCK_LH       DSC RX lock indication from PMD posedge detected
 *     SIGNAL_DETECT_LL Signal Detect indication from PMD negedge detected
 *     SIGNAL_DETECT_LH Signal Detect indication from PMD posedge detected
 *     RX_CLK_VLD_LL    rx_clk_vld indication from PMD negedge detected
 *     RX_CLK_VLD_LH    rx_clk_vld indication from PMD posedge detected
 */
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr (0x0000c013 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_LATCH_STS.
 */
typedef union BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_latch_sts[1];
	uint32_t _pmd_x4_latch_sts;
} BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_t;

#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_CLR(r) (r).pmd_x4_latch_sts[0] = 0
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SET(r,d) (r).pmd_x4_latch_sts[0] = d
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_GET(r) (r).pmd_x4_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET(r) (((r).pmd_x4_latch_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X4_LATCH_STS.
 */
#define BCMI_QTC_XGXS_READ_PMD_X4_LATCH_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_QTC_XGXS_WRITE_PMD_X4_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X4_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_QTC_XGXS_READLN_PMD_X4_LATCH_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_QTC_XGXS_WRITELN_PMD_X4_LATCH_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_QTC_XGXS_WRITEALL_PMD_X4_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_latch_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_LATCH_STSr BCMI_QTC_XGXS_PMD_X4_LATCH_STSr
#define PMD_X4_LATCH_STSr_SIZE BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIZE
typedef BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_t PMD_X4_LATCH_STSr_t;
#define PMD_X4_LATCH_STSr_CLR BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_CLR
#define PMD_X4_LATCH_STSr_SET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SET
#define PMD_X4_LATCH_STSr_GET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET BCMI_QTC_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET
#define READ_PMD_X4_LATCH_STSr BCMI_QTC_XGXS_READ_PMD_X4_LATCH_STSr
#define WRITE_PMD_X4_LATCH_STSr BCMI_QTC_XGXS_WRITE_PMD_X4_LATCH_STSr
#define MODIFY_PMD_X4_LATCH_STSr BCMI_QTC_XGXS_MODIFY_PMD_X4_LATCH_STSr
#define READLN_PMD_X4_LATCH_STSr BCMI_QTC_XGXS_READLN_PMD_X4_LATCH_STSr
#define WRITELN_PMD_X4_LATCH_STSr BCMI_QTC_XGXS_WRITELN_PMD_X4_LATCH_STSr
#define WRITEALL_PMD_X4_LATCH_STSr BCMI_QTC_XGXS_WRITEALL_PMD_X4_LATCH_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X4_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X4_OVRR
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc014
 * DESC:     PMD lane override
 * SIZE:     32
 * FIELDS:
 *     RX_LOCK_OVRD     Override for DSC RX lock indication from PMD
 *     SIGNAL_DETECT_OVRD Override for Signal Detect indication from PMD
 *     RX_CLK_VLD_OVRD  Override rx_clk_vld indication from PMD
 *     LANE_MODE_OEN    Lane mode override enable
 *     OSR_MODE_OEN     OSR mode, overrideOnly used for Speed Control bypass operation
 *     RX_DME_EN_OEN    DME is enabled, overrideOnly used for Speed Control bypass operation
 *     TX_DISABLE_OEN   tx_disable override enableOnly used for Speed Control bypass operation
 *     LN_DP_H_RSTB_OEN PMD Lane Data path reset override enableOnly used for Speed Control bypass operation
 */
#define BCMI_QTC_XGXS_PMD_X4_OVRRr (0x0000c014 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X4_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_OVRR.
 */
typedef union BCMI_QTC_XGXS_PMD_X4_OVRRr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ovrr[1];
	uint32_t _pmd_x4_ovrr;
} BCMI_QTC_XGXS_PMD_X4_OVRRr_t;

#define BCMI_QTC_XGXS_PMD_X4_OVRRr_CLR(r) (r).pmd_x4_ovrr[0] = 0
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_SET(r,d) (r).pmd_x4_ovrr[0] = d
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_GET(r) (r).pmd_x4_ovrr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET(r) (((r).pmd_x4_ovrr[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X4_OVRR.
 */
#define BCMI_QTC_XGXS_READ_PMD_X4_OVRRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_QTC_XGXS_WRITE_PMD_X4_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X4_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_QTC_XGXS_READLN_PMD_X4_OVRRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_QTC_XGXS_WRITELN_PMD_X4_OVRRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_QTC_XGXS_WRITEALL_PMD_X4_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ovrr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_OVRRr BCMI_QTC_XGXS_PMD_X4_OVRRr
#define PMD_X4_OVRRr_SIZE BCMI_QTC_XGXS_PMD_X4_OVRRr_SIZE
typedef BCMI_QTC_XGXS_PMD_X4_OVRRr_t PMD_X4_OVRRr_t;
#define PMD_X4_OVRRr_CLR BCMI_QTC_XGXS_PMD_X4_OVRRr_CLR
#define PMD_X4_OVRRr_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_SET
#define PMD_X4_OVRRr_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_GET
#define PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET
#define PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET
#define PMD_X4_OVRRr_RX_DME_EN_OENf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_GET
#define PMD_X4_OVRRr_RX_DME_EN_OENf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_SET
#define PMD_X4_OVRRr_OSR_MODE_OENf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_GET
#define PMD_X4_OVRRr_OSR_MODE_OENf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_SET
#define PMD_X4_OVRRr_LANE_MODE_OENf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET
#define PMD_X4_OVRRr_LANE_MODE_OENf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_GET BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_SET BCMI_QTC_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET
#define READ_PMD_X4_OVRRr BCMI_QTC_XGXS_READ_PMD_X4_OVRRr
#define WRITE_PMD_X4_OVRRr BCMI_QTC_XGXS_WRITE_PMD_X4_OVRRr
#define MODIFY_PMD_X4_OVRRr BCMI_QTC_XGXS_MODIFY_PMD_X4_OVRRr
#define READLN_PMD_X4_OVRRr BCMI_QTC_XGXS_READLN_PMD_X4_OVRRr
#define WRITELN_PMD_X4_OVRRr BCMI_QTC_XGXS_WRITELN_PMD_X4_OVRRr
#define WRITEALL_PMD_X4_OVRRr BCMI_QTC_XGXS_WRITEALL_PMD_X4_OVRRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X4_OVRRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X4_EEE_CTL
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc018
 * DESC:     PMD lane eee controls
 * SIZE:     32
 * FIELDS:
 *     TX_MODE          EEE tx low power modeEEE low power operation is not supported by TSC
 *     RX_MODE          EEE rx low power modeEEE low power operation is not supported by TSC
 */
#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr (0x0000c018 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_EEE_CTL.
 */
typedef union BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x4_eee_ctl[1];
	uint32_t _pmd_x4_eee_ctl;
} BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_t;

#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_CLR(r) (r).pmd_x4_eee_ctl[0] = 0
#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_SET(r,d) (r).pmd_x4_eee_ctl[0] = d
#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_GET(r) (r).pmd_x4_eee_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_GET(r) ((((r).pmd_x4_eee_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_SET(r,f) (r).pmd_x4_eee_ctl[0]=(((r).pmd_x4_eee_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_GET(r) (((r).pmd_x4_eee_ctl[0]) & 0x3)
#define BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_SET(r,f) (r).pmd_x4_eee_ctl[0]=(((r).pmd_x4_eee_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access PMD_X4_EEE_CTL.
 */
#define BCMI_QTC_XGXS_READ_PMD_X4_EEE_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl))
#define BCMI_QTC_XGXS_WRITE_PMD_X4_EEE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X4_EEE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl))
#define BCMI_QTC_XGXS_READLN_PMD_X4_EEE_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_ctl))
#define BCMI_QTC_XGXS_WRITELN_PMD_X4_EEE_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_ctl))
#define BCMI_QTC_XGXS_WRITEALL_PMD_X4_EEE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_eee_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_EEE_CTLr BCMI_QTC_XGXS_PMD_X4_EEE_CTLr
#define PMD_X4_EEE_CTLr_SIZE BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_SIZE
typedef BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_t PMD_X4_EEE_CTLr_t;
#define PMD_X4_EEE_CTLr_CLR BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_CLR
#define PMD_X4_EEE_CTLr_SET BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_SET
#define PMD_X4_EEE_CTLr_GET BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_GET
#define PMD_X4_EEE_CTLr_RX_MODEf_GET BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_GET
#define PMD_X4_EEE_CTLr_RX_MODEf_SET BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_SET
#define PMD_X4_EEE_CTLr_TX_MODEf_GET BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_GET
#define PMD_X4_EEE_CTLr_TX_MODEf_SET BCMI_QTC_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_SET
#define READ_PMD_X4_EEE_CTLr BCMI_QTC_XGXS_READ_PMD_X4_EEE_CTLr
#define WRITE_PMD_X4_EEE_CTLr BCMI_QTC_XGXS_WRITE_PMD_X4_EEE_CTLr
#define MODIFY_PMD_X4_EEE_CTLr BCMI_QTC_XGXS_MODIFY_PMD_X4_EEE_CTLr
#define READLN_PMD_X4_EEE_CTLr BCMI_QTC_XGXS_READLN_PMD_X4_EEE_CTLr
#define WRITELN_PMD_X4_EEE_CTLr BCMI_QTC_XGXS_WRITELN_PMD_X4_EEE_CTLr
#define WRITEALL_PMD_X4_EEE_CTLr BCMI_QTC_XGXS_WRITEALL_PMD_X4_EEE_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X4_EEE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMD_X4_EEE_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc019
 * DESC:     PMD lane eee status
 * SIZE:     32
 * FIELDS:
 *     ENERGY_DETECT    EEE Energy detection indication from PMDEEE low power operation is not supported by TSC
 */
#define BCMI_QTC_XGXS_PMD_X4_EEE_STSr (0x0000c019 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMD_X4_EEE_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_EEE_STS.
 */
typedef union BCMI_QTC_XGXS_PMD_X4_EEE_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_eee_sts[1];
	uint32_t _pmd_x4_eee_sts;
} BCMI_QTC_XGXS_PMD_X4_EEE_STSr_t;

#define BCMI_QTC_XGXS_PMD_X4_EEE_STSr_CLR(r) (r).pmd_x4_eee_sts[0] = 0
#define BCMI_QTC_XGXS_PMD_X4_EEE_STSr_SET(r,d) (r).pmd_x4_eee_sts[0] = d
#define BCMI_QTC_XGXS_PMD_X4_EEE_STSr_GET(r) (r).pmd_x4_eee_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_GET(r) (((r).pmd_x4_eee_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_SET(r,f) (r).pmd_x4_eee_sts[0]=(((r).pmd_x4_eee_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMD_X4_EEE_STS.
 */
#define BCMI_QTC_XGXS_READ_PMD_X4_EEE_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts))
#define BCMI_QTC_XGXS_WRITE_PMD_X4_EEE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMD_X4_EEE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts))
#define BCMI_QTC_XGXS_READLN_PMD_X4_EEE_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_sts))
#define BCMI_QTC_XGXS_WRITELN_PMD_X4_EEE_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_sts))
#define BCMI_QTC_XGXS_WRITEALL_PMD_X4_EEE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_eee_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_EEE_STSr BCMI_QTC_XGXS_PMD_X4_EEE_STSr
#define PMD_X4_EEE_STSr_SIZE BCMI_QTC_XGXS_PMD_X4_EEE_STSr_SIZE
typedef BCMI_QTC_XGXS_PMD_X4_EEE_STSr_t PMD_X4_EEE_STSr_t;
#define PMD_X4_EEE_STSr_CLR BCMI_QTC_XGXS_PMD_X4_EEE_STSr_CLR
#define PMD_X4_EEE_STSr_SET BCMI_QTC_XGXS_PMD_X4_EEE_STSr_SET
#define PMD_X4_EEE_STSr_GET BCMI_QTC_XGXS_PMD_X4_EEE_STSr_GET
#define PMD_X4_EEE_STSr_ENERGY_DETECTf_GET BCMI_QTC_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_GET
#define PMD_X4_EEE_STSr_ENERGY_DETECTf_SET BCMI_QTC_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_SET
#define READ_PMD_X4_EEE_STSr BCMI_QTC_XGXS_READ_PMD_X4_EEE_STSr
#define WRITE_PMD_X4_EEE_STSr BCMI_QTC_XGXS_WRITE_PMD_X4_EEE_STSr
#define MODIFY_PMD_X4_EEE_STSr BCMI_QTC_XGXS_MODIFY_PMD_X4_EEE_STSr
#define READLN_PMD_X4_EEE_STSr BCMI_QTC_XGXS_READLN_PMD_X4_EEE_STSr
#define WRITELN_PMD_X4_EEE_STSr BCMI_QTC_XGXS_WRITELN_PMD_X4_EEE_STSr
#define WRITEALL_PMD_X4_EEE_STSr BCMI_QTC_XGXS_WRITEALL_PMD_X4_EEE_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMD_X4_EEE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_CTL
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc020
 * DESC:     SW speed change control
 * SIZE:     32
 * FIELDS:
 *     SW_SPEED         Speed to be set
 *     SW_SPEED_CHANGE  Start SW speed change.HW will detect possedge of this field and start or restart the speed change logic.To restart speed change logic SW must write 0 to this bit and then write 1.
 */
#define BCMI_QTC_XGXS_SC_X4_CTLr (0x0000c020 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_CTL.
 */
typedef union BCMI_QTC_XGXS_SC_X4_CTLr_s {
	uint32_t v[1];
	uint32_t sc_x4_ctl[1];
	uint32_t _sc_x4_ctl;
} BCMI_QTC_XGXS_SC_X4_CTLr_t;

#define BCMI_QTC_XGXS_SC_X4_CTLr_CLR(r) (r).sc_x4_ctl[0] = 0
#define BCMI_QTC_XGXS_SC_X4_CTLr_SET(r,d) (r).sc_x4_ctl[0] = d
#define BCMI_QTC_XGXS_SC_X4_CTLr_GET(r) (r).sc_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET(r) ((((r).sc_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEEDf_GET(r) (((r).sc_x4_ctl[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEEDf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_CTL.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_QTC_XGXS_WRITE_SC_X4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_QTC_XGXS_READLN_SC_X4_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_CTLr BCMI_QTC_XGXS_SC_X4_CTLr
#define SC_X4_CTLr_SIZE BCMI_QTC_XGXS_SC_X4_CTLr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_CTLr_t SC_X4_CTLr_t;
#define SC_X4_CTLr_CLR BCMI_QTC_XGXS_SC_X4_CTLr_CLR
#define SC_X4_CTLr_SET BCMI_QTC_XGXS_SC_X4_CTLr_SET
#define SC_X4_CTLr_GET BCMI_QTC_XGXS_SC_X4_CTLr_GET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_GET BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_SET BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET
#define SC_X4_CTLr_SW_SPEEDf_GET BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEEDf_GET
#define SC_X4_CTLr_SW_SPEEDf_SET BCMI_QTC_XGXS_SC_X4_CTLr_SW_SPEEDf_SET
#define READ_SC_X4_CTLr BCMI_QTC_XGXS_READ_SC_X4_CTLr
#define WRITE_SC_X4_CTLr BCMI_QTC_XGXS_WRITE_SC_X4_CTLr
#define MODIFY_SC_X4_CTLr BCMI_QTC_XGXS_MODIFY_SC_X4_CTLr
#define READLN_SC_X4_CTLr BCMI_QTC_XGXS_READLN_SC_X4_CTLr
#define WRITELN_SC_X4_CTLr BCMI_QTC_XGXS_WRITELN_SC_X4_CTLr
#define WRITEALL_SC_X4_CTLr BCMI_QTC_XGXS_WRITEALL_SC_X4_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_QSGMII_SPD
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc021
 * DESC:     SW subport speed control
 * SIZE:     32
 * FIELDS:
 *     SPEED_SP0        QSGMII Subport speed0   : 1G speed1   : 100M speed2   : 10M speed3   : Reserved
 *     SPEED_SP1        QSGMII Subport speed0   : 1G speed1   : 100M speed2   : 10M speed3   : Reserved
 *     SPEED_SP2        QSGMII Subport speed0   : 1G speed1   : 100M speed2   : 10M speed3   : Reserved
 *     SPEED_SP3        QSGMII Subport speed0   : 1G speed1   : 100M speed2   : 10M speed3   : Reserved
 */
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr (0x0000c021 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_QSGMII_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_qsgmii_spd[1];
	uint32_t _sc_x4_qsgmii_spd;
} BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_t;

#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_CLR(r) (r).sc_x4_qsgmii_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SET(r,d) (r).sc_x4_qsgmii_spd[0] = d
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_GET(r) (r).sc_x4_qsgmii_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP3f_GET(r) ((((r).sc_x4_qsgmii_spd[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP3f_SET(r,f) (r).sc_x4_qsgmii_spd[0]=(((r).sc_x4_qsgmii_spd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP2f_GET(r) ((((r).sc_x4_qsgmii_spd[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP2f_SET(r,f) (r).sc_x4_qsgmii_spd[0]=(((r).sc_x4_qsgmii_spd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP1f_GET(r) ((((r).sc_x4_qsgmii_spd[0]) >> 2) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP1f_SET(r,f) (r).sc_x4_qsgmii_spd[0]=(((r).sc_x4_qsgmii_spd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP0f_GET(r) (((r).sc_x4_qsgmii_spd[0]) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP0f_SET(r,f) (r).sc_x4_qsgmii_spd[0]=(((r).sc_x4_qsgmii_spd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access SC_X4_QSGMII_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_QSGMII_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr,(_r._sc_x4_qsgmii_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X4_QSGMII_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr,(_r._sc_x4_qsgmii_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_QSGMII_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr,(_r._sc_x4_qsgmii_spd))
#define BCMI_QTC_XGXS_READLN_SC_X4_QSGMII_SPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_qsgmii_spd))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_QSGMII_SPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_qsgmii_spd))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_QSGMII_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_qsgmii_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_QSGMII_SPDr BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr
#define SC_X4_QSGMII_SPDr_SIZE BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_t SC_X4_QSGMII_SPDr_t;
#define SC_X4_QSGMII_SPDr_CLR BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_CLR
#define SC_X4_QSGMII_SPDr_SET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SET
#define SC_X4_QSGMII_SPDr_GET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_GET
#define SC_X4_QSGMII_SPDr_SPEED_SP3f_GET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP3f_GET
#define SC_X4_QSGMII_SPDr_SPEED_SP3f_SET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP3f_SET
#define SC_X4_QSGMII_SPDr_SPEED_SP2f_GET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP2f_GET
#define SC_X4_QSGMII_SPDr_SPEED_SP2f_SET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP2f_SET
#define SC_X4_QSGMII_SPDr_SPEED_SP1f_GET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP1f_GET
#define SC_X4_QSGMII_SPDr_SPEED_SP1f_SET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP1f_SET
#define SC_X4_QSGMII_SPDr_SPEED_SP0f_GET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP0f_GET
#define SC_X4_QSGMII_SPDr_SPEED_SP0f_SET BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr_SPEED_SP0f_SET
#define READ_SC_X4_QSGMII_SPDr BCMI_QTC_XGXS_READ_SC_X4_QSGMII_SPDr
#define WRITE_SC_X4_QSGMII_SPDr BCMI_QTC_XGXS_WRITE_SC_X4_QSGMII_SPDr
#define MODIFY_SC_X4_QSGMII_SPDr BCMI_QTC_XGXS_MODIFY_SC_X4_QSGMII_SPDr
#define READLN_SC_X4_QSGMII_SPDr BCMI_QTC_XGXS_READLN_SC_X4_QSGMII_SPDr
#define WRITELN_SC_X4_QSGMII_SPDr BCMI_QTC_XGXS_WRITELN_SC_X4_QSGMII_SPDr
#define WRITEALL_SC_X4_QSGMII_SPDr BCMI_QTC_XGXS_WRITEALL_SC_X4_QSGMII_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_QSGMII_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_STS
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc022
 * DESC:     SW speed change status
 * SIZE:     32
 * FIELDS:
 *     SW_SPEED_CHANGE_DONE Read clear bit indicating that SW initiated speed change completed
 *     SW_SPEED_CONFIG_VLD Read clear bit indicating that resolved speed configuration in stutus registers can be read
 */
#define BCMI_QTC_XGXS_SC_X4_STSr (0x0000c022 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_STS.
 */
typedef union BCMI_QTC_XGXS_SC_X4_STSr_s {
	uint32_t v[1];
	uint32_t sc_x4_sts[1];
	uint32_t _sc_x4_sts;
} BCMI_QTC_XGXS_SC_X4_STSr_t;

#define BCMI_QTC_XGXS_SC_X4_STSr_CLR(r) (r).sc_x4_sts[0] = 0
#define BCMI_QTC_XGXS_SC_X4_STSr_SET(r,d) (r).sc_x4_sts[0] = d
#define BCMI_QTC_XGXS_SC_X4_STSr_GET(r) (r).sc_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET(r) ((((r).sc_x4_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET(r) (((r).sc_x4_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access SC_X4_STS.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_QTC_XGXS_WRITE_SC_X4_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_STSr,(_r._sc_x4_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_QTC_XGXS_READLN_SC_X4_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_STSr BCMI_QTC_XGXS_SC_X4_STSr
#define SC_X4_STSr_SIZE BCMI_QTC_XGXS_SC_X4_STSr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_STSr_t SC_X4_STSr_t;
#define SC_X4_STSr_CLR BCMI_QTC_XGXS_SC_X4_STSr_CLR
#define SC_X4_STSr_SET BCMI_QTC_XGXS_SC_X4_STSr_SET
#define SC_X4_STSr_GET BCMI_QTC_XGXS_SC_X4_STSr_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET BCMI_QTC_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET
#define READ_SC_X4_STSr BCMI_QTC_XGXS_READ_SC_X4_STSr
#define WRITE_SC_X4_STSr BCMI_QTC_XGXS_WRITE_SC_X4_STSr
#define MODIFY_SC_X4_STSr BCMI_QTC_XGXS_MODIFY_SC_X4_STSr
#define READLN_SC_X4_STSr BCMI_QTC_XGXS_READLN_SC_X4_STSr
#define WRITELN_SC_X4_STSr BCMI_QTC_XGXS_WRITELN_SC_X4_STSr
#define WRITEALL_SC_X4_STSr BCMI_QTC_XGXS_WRITEALL_SC_X4_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_ERR
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc023
 * DESC:     Speed control error indication
 * SIZE:     32
 * FIELDS:
 *     PLL_LOCK_TIMED_OUT Indication of timeout during PLL lock
 *     PMD_LOCK_TIMED_OUT Indication of timeout during PMD RX lock
 */
#define BCMI_QTC_XGXS_SC_X4_ERRr (0x0000c023 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_ERRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_ERR.
 */
typedef union BCMI_QTC_XGXS_SC_X4_ERRr_s {
	uint32_t v[1];
	uint32_t sc_x4_err[1];
	uint32_t _sc_x4_err;
} BCMI_QTC_XGXS_SC_X4_ERRr_t;

#define BCMI_QTC_XGXS_SC_X4_ERRr_CLR(r) (r).sc_x4_err[0] = 0
#define BCMI_QTC_XGXS_SC_X4_ERRr_SET(r,d) (r).sc_x4_err[0] = d
#define BCMI_QTC_XGXS_SC_X4_ERRr_GET(r) (r).sc_x4_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET(r) ((((r).sc_x4_err[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET(r,f) (r).sc_x4_err[0]=(((r).sc_x4_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET(r) (((r).sc_x4_err[0]) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET(r,f) (r).sc_x4_err[0]=(((r).sc_x4_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access SC_X4_ERR.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_ERRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_ERRr,(_r._sc_x4_err))
#define BCMI_QTC_XGXS_WRITE_SC_X4_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_ERRr,(_r._sc_x4_err)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_ERRr,(_r._sc_x4_err))
#define BCMI_QTC_XGXS_READLN_SC_X4_ERRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_err))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_ERRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_err))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_err))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_ERRr BCMI_QTC_XGXS_SC_X4_ERRr
#define SC_X4_ERRr_SIZE BCMI_QTC_XGXS_SC_X4_ERRr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_ERRr_t SC_X4_ERRr_t;
#define SC_X4_ERRr_CLR BCMI_QTC_XGXS_SC_X4_ERRr_CLR
#define SC_X4_ERRr_SET BCMI_QTC_XGXS_SC_X4_ERRr_SET
#define SC_X4_ERRr_GET BCMI_QTC_XGXS_SC_X4_ERRr_GET
#define SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET BCMI_QTC_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET
#define SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET BCMI_QTC_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET
#define SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET BCMI_QTC_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET
#define SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET BCMI_QTC_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET
#define READ_SC_X4_ERRr BCMI_QTC_XGXS_READ_SC_X4_ERRr
#define WRITE_SC_X4_ERRr BCMI_QTC_XGXS_WRITE_SC_X4_ERRr
#define MODIFY_SC_X4_ERRr BCMI_QTC_XGXS_MODIFY_SC_X4_ERRr
#define READLN_SC_X4_ERRr BCMI_QTC_XGXS_READLN_SC_X4_ERRr
#define WRITELN_SC_X4_ERRr BCMI_QTC_XGXS_WRITELN_SC_X4_ERRr
#define WRITEALL_SC_X4_ERRr BCMI_QTC_XGXS_WRITEALL_SC_X4_ERRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_DBG
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc024
 * DESC:     Speed control debug information
 * SIZE:     32
 * FIELDS:
 *     SC_FSM_STATUS    Speed Control logic FSM debug information
 */
#define BCMI_QTC_XGXS_SC_X4_DBGr (0x0000c024 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_DBGr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_DBG.
 */
typedef union BCMI_QTC_XGXS_SC_X4_DBGr_s {
	uint32_t v[1];
	uint32_t sc_x4_dbg[1];
	uint32_t _sc_x4_dbg;
} BCMI_QTC_XGXS_SC_X4_DBGr_t;

#define BCMI_QTC_XGXS_SC_X4_DBGr_CLR(r) (r).sc_x4_dbg[0] = 0
#define BCMI_QTC_XGXS_SC_X4_DBGr_SET(r,d) (r).sc_x4_dbg[0] = d
#define BCMI_QTC_XGXS_SC_X4_DBGr_GET(r) (r).sc_x4_dbg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET(r) (((r).sc_x4_dbg[0]) & 0xffff)
#define BCMI_QTC_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET(r,f) (r).sc_x4_dbg[0]=(((r).sc_x4_dbg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access SC_X4_DBG.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_DBGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_QTC_XGXS_WRITE_SC_X4_DBGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_DBGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_QTC_XGXS_READLN_SC_X4_DBGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_DBGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_DBGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_dbg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_DBGr BCMI_QTC_XGXS_SC_X4_DBGr
#define SC_X4_DBGr_SIZE BCMI_QTC_XGXS_SC_X4_DBGr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_DBGr_t SC_X4_DBGr_t;
#define SC_X4_DBGr_CLR BCMI_QTC_XGXS_SC_X4_DBGr_CLR
#define SC_X4_DBGr_SET BCMI_QTC_XGXS_SC_X4_DBGr_SET
#define SC_X4_DBGr_GET BCMI_QTC_XGXS_SC_X4_DBGr_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_GET BCMI_QTC_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_SET BCMI_QTC_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET
#define READ_SC_X4_DBGr BCMI_QTC_XGXS_READ_SC_X4_DBGr
#define WRITE_SC_X4_DBGr BCMI_QTC_XGXS_WRITE_SC_X4_DBGr
#define MODIFY_SC_X4_DBGr BCMI_QTC_XGXS_MODIFY_SC_X4_DBGr
#define READLN_SC_X4_DBGr BCMI_QTC_XGXS_READLN_SC_X4_DBGr
#define WRITELN_SC_X4_DBGr BCMI_QTC_XGXS_WRITELN_SC_X4_DBGr
#define WRITEALL_SC_X4_DBGr BCMI_QTC_XGXS_WRITEALL_SC_X4_DBGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_DBGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_BYPASS
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc028
 * DESC:     Speed control bypass enable
 * SIZE:     32
 * FIELDS:
 *     SC_BYPASS        Disable speed control logic
 *     SC_IGNORE_TX_DATA_VLD Do not wait for tx_data_vld indication from PMD before taking TX pipe out of reset
 */
#define BCMI_QTC_XGXS_SC_X4_BYPASSr (0x0000c028 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_BYPASSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_BYPASS.
 */
typedef union BCMI_QTC_XGXS_SC_X4_BYPASSr_s {
	uint32_t v[1];
	uint32_t sc_x4_bypass[1];
	uint32_t _sc_x4_bypass;
} BCMI_QTC_XGXS_SC_X4_BYPASSr_t;

#define BCMI_QTC_XGXS_SC_X4_BYPASSr_CLR(r) (r).sc_x4_bypass[0] = 0
#define BCMI_QTC_XGXS_SC_X4_BYPASSr_SET(r,d) (r).sc_x4_bypass[0] = d
#define BCMI_QTC_XGXS_SC_X4_BYPASSr_GET(r) (r).sc_x4_bypass[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET(r) ((((r).sc_x4_bypass[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET(r,f) (r).sc_x4_bypass[0]=(((r).sc_x4_bypass[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_BYPASSf_GET(r) (((r).sc_x4_bypass[0]) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_BYPASSf_SET(r,f) (r).sc_x4_bypass[0]=(((r).sc_x4_bypass[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access SC_X4_BYPASS.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_BYPASSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass))
#define BCMI_QTC_XGXS_WRITE_SC_X4_BYPASSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_BYPASSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass))
#define BCMI_QTC_XGXS_READLN_SC_X4_BYPASSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_bypass))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_BYPASSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_bypass))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_BYPASSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_bypass))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_BYPASSr BCMI_QTC_XGXS_SC_X4_BYPASSr
#define SC_X4_BYPASSr_SIZE BCMI_QTC_XGXS_SC_X4_BYPASSr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_BYPASSr_t SC_X4_BYPASSr_t;
#define SC_X4_BYPASSr_CLR BCMI_QTC_XGXS_SC_X4_BYPASSr_CLR
#define SC_X4_BYPASSr_SET BCMI_QTC_XGXS_SC_X4_BYPASSr_SET
#define SC_X4_BYPASSr_GET BCMI_QTC_XGXS_SC_X4_BYPASSr_GET
#define SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET
#define SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET
#define SC_X4_BYPASSr_SC_BYPASSf_GET BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_BYPASSf_GET
#define SC_X4_BYPASSr_SC_BYPASSf_SET BCMI_QTC_XGXS_SC_X4_BYPASSr_SC_BYPASSf_SET
#define READ_SC_X4_BYPASSr BCMI_QTC_XGXS_READ_SC_X4_BYPASSr
#define WRITE_SC_X4_BYPASSr BCMI_QTC_XGXS_WRITE_SC_X4_BYPASSr
#define MODIFY_SC_X4_BYPASSr BCMI_QTC_XGXS_MODIFY_SC_X4_BYPASSr
#define READLN_SC_X4_BYPASSr BCMI_QTC_XGXS_READLN_SC_X4_BYPASSr
#define WRITELN_SC_X4_BYPASSr BCMI_QTC_XGXS_WRITELN_SC_X4_BYPASSr
#define WRITEALL_SC_X4_BYPASSr BCMI_QTC_XGXS_WRITEALL_SC_X4_BYPASSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_BYPASSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_SC_AN_SUBP_CTL
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc029
 * DESC:     Speed control AN Subport control
 * SIZE:     32
 * FIELDS:
 *     SUBP_TO_SEE_SC   Which subport will connected to SC for the initial AN Speed configurationThis field should be written to 00 (default value) in case of NON-QSGMII mode
 */
#define BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr (0x0000c029 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_SC_AN_SUBP_CTL.
 */
typedef union BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_s {
	uint32_t v[1];
	uint32_t sc_x4_sc_an_subp_ctl[1];
	uint32_t _sc_x4_sc_an_subp_ctl;
} BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_t;

#define BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_CLR(r) (r).sc_x4_sc_an_subp_ctl[0] = 0
#define BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SET(r,d) (r).sc_x4_sc_an_subp_ctl[0] = d
#define BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_GET(r) (r).sc_x4_sc_an_subp_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SUBP_TO_SEE_SCf_GET(r) (((r).sc_x4_sc_an_subp_ctl[0]) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SUBP_TO_SEE_SCf_SET(r,f) (r).sc_x4_sc_an_subp_ctl[0]=(((r).sc_x4_sc_an_subp_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access SC_X4_SC_AN_SUBP_CTL.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_SC_AN_SUBP_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr,(_r._sc_x4_sc_an_subp_ctl))
#define BCMI_QTC_XGXS_WRITE_SC_X4_SC_AN_SUBP_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr,(_r._sc_x4_sc_an_subp_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_SC_AN_SUBP_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr,(_r._sc_x4_sc_an_subp_ctl))
#define BCMI_QTC_XGXS_READLN_SC_X4_SC_AN_SUBP_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sc_an_subp_ctl))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_SC_AN_SUBP_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sc_an_subp_ctl))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_SC_AN_SUBP_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_sc_an_subp_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_SC_AN_SUBP_CTLr BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr
#define SC_X4_SC_AN_SUBP_CTLr_SIZE BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_t SC_X4_SC_AN_SUBP_CTLr_t;
#define SC_X4_SC_AN_SUBP_CTLr_CLR BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_CLR
#define SC_X4_SC_AN_SUBP_CTLr_SET BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SET
#define SC_X4_SC_AN_SUBP_CTLr_GET BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_GET
#define SC_X4_SC_AN_SUBP_CTLr_SUBP_TO_SEE_SCf_GET BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SUBP_TO_SEE_SCf_GET
#define SC_X4_SC_AN_SUBP_CTLr_SUBP_TO_SEE_SCf_SET BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr_SUBP_TO_SEE_SCf_SET
#define READ_SC_X4_SC_AN_SUBP_CTLr BCMI_QTC_XGXS_READ_SC_X4_SC_AN_SUBP_CTLr
#define WRITE_SC_X4_SC_AN_SUBP_CTLr BCMI_QTC_XGXS_WRITE_SC_X4_SC_AN_SUBP_CTLr
#define MODIFY_SC_X4_SC_AN_SUBP_CTLr BCMI_QTC_XGXS_MODIFY_SC_X4_SC_AN_SUBP_CTLr
#define READLN_SC_X4_SC_AN_SUBP_CTLr BCMI_QTC_XGXS_READLN_SC_X4_SC_AN_SUBP_CTLr
#define WRITELN_SC_X4_SC_AN_SUBP_CTLr BCMI_QTC_XGXS_WRITELN_SC_X4_SC_AN_SUBP_CTLr
#define WRITEALL_SC_X4_SC_AN_SUBP_CTLr BCMI_QTC_XGXS_WRITEALL_SC_X4_SC_AN_SUBP_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_SC_AN_SUBP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FLD_OVRR_EN0_TYPE
 * BLOCKS:   SC_X4_FIELD_OVERRIDE_ENABLE
 * REGADDR:  0xc030
 * DESC:     Enable override of individual fields
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT_OEN 
 *     PCS_CLOCKCNT0_OEN 
 *     PCS_CREDITENABLE_OEN 
 *     REPLICATION_CNT_OEN 
 *     MAC_CREDITGENCNT_OEN 
 *     LOOPCNT1_OEN     
 *     LOOPCNT0_OEN     
 *     CLOCKCNT1_OEN    
 *     CLOCKCNT0_OEN    
 *     CREDITENABLE_OEN 
 *     SGMII_SPD_SWITCH_OEN 
 *     OS_MODE_OEN      
 *     CL36BYTEDELETEMODE_OEN 
 *     QSGMII_EN_OEN    
 */
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr (0x0000c030 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FLD_OVRR_EN0_TYPE.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_s {
	uint32_t v[1];
	uint32_t sc_x4_fld_ovrr_en0_type[1];
	uint32_t _sc_x4_fld_ovrr_en0_type;
} BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_t;

#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLR(r) (r).sc_x4_fld_ovrr_en0_type[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SET(r,d) (r).sc_x4_fld_ovrr_en0_type[0] = d
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_GET(r) (r).sc_x4_fld_ovrr_en0_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_QSGMII_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_QSGMII_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SGMII_SPD_SWITCH_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SGMII_SPD_SWITCH_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CREDITENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CREDITENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT1_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT1_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT1_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT1_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_MAC_CREDITGENCNT_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_MAC_CREDITGENCNT_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_REPLICATION_CNT_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_REPLICATION_CNT_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CLOCKCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CLOCKCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITGENCNT_OENf_GET(r) (((r).sc_x4_fld_ovrr_en0_type[0]) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITGENCNT_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access SC_X4_FLD_OVRR_EN0_TYPE.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_QTC_XGXS_READLN_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fld_ovrr_en0_type))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FLD_OVRR_EN0_TYPEr BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr
#define SC_X4_FLD_OVRR_EN0_TYPEr_SIZE BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_t SC_X4_FLD_OVRR_EN0_TYPEr_t;
#define SC_X4_FLD_OVRR_EN0_TYPEr_CLR BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLR
#define SC_X4_FLD_OVRR_EN0_TYPEr_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_QSGMII_EN_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_QSGMII_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_QSGMII_EN_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_QSGMII_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_SGMII_SPD_SWITCH_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SGMII_SPD_SWITCH_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_SGMII_SPD_SWITCH_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SGMII_SPD_SWITCH_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CREDITENABLE_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CREDITENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CREDITENABLE_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CREDITENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT0_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT0_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT1_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT1_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT1_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLOCKCNT1_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT0_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT0_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT1_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT1_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT1_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_LOOPCNT1_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_MAC_CREDITGENCNT_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_MAC_CREDITGENCNT_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_MAC_CREDITGENCNT_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_MAC_CREDITGENCNT_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_REPLICATION_CNT_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_REPLICATION_CNT_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_REPLICATION_CNT_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_REPLICATION_CNT_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITENABLE_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITENABLE_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CLOCKCNT0_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CLOCKCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CLOCKCNT0_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CLOCKCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITGENCNT_OENf_GET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITGENCNT_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITGENCNT_OENf_SET BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_PCS_CREDITGENCNT_OENf_SET
#define READ_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_QTC_XGXS_READ_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITE_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_QTC_XGXS_WRITE_SC_X4_FLD_OVRR_EN0_TYPEr
#define MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_QTC_XGXS_MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr
#define READLN_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_QTC_XGXS_READLN_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_QTC_XGXS_WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_QTC_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD_SPD
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc040
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr (0x0000c040 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd_spd[1];
	uint32_t _sc_x4_fi_sp0_rslvd_spd;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_CLR(r) (r).sc_x4_fi_sp0_rslvd_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SET(r,d) (r).sc_x4_fi_sp0_rslvd_spd[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_GET(r) (r).sc_x4_fi_sp0_rslvd_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SPEEDf_GET(r) (((r).sc_x4_fi_sp0_rslvd_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SPEEDf_SET(r,f) (r).sc_x4_fi_sp0_rslvd_spd[0]=(((r).sc_x4_fi_sp0_rslvd_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr,(_r._sc_x4_fi_sp0_rslvd_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr,(_r._sc_x4_fi_sp0_rslvd_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr,(_r._sc_x4_fi_sp0_rslvd_spd))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd_spd))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd_spd))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD_SPDr BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr
#define SC_X4_FI_SP0_RSLVD_SPDr_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_t SC_X4_FI_SP0_RSLVD_SPDr_t;
#define SC_X4_FI_SP0_RSLVD_SPDr_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_CLR
#define SC_X4_FI_SP0_RSLVD_SPDr_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SET
#define SC_X4_FI_SP0_RSLVD_SPDr_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_GET
#define SC_X4_FI_SP0_RSLVD_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SPEEDf_GET
#define SC_X4_FI_SP0_RSLVD_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr_SPEEDf_SET
#define READ_SC_X4_FI_SP0_RSLVD_SPDr BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD_SPDr
#define WRITE_SC_X4_FI_SP0_RSLVD_SPDr BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD_SPDr
#define MODIFY_SC_X4_FI_SP0_RSLVD_SPDr BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD_SPDr
#define READLN_SC_X4_FI_SP0_RSLVD_SPDr BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD_SPDr
#define WRITELN_SC_X4_FI_SP0_RSLVD_SPDr BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD_SPDr
#define WRITEALL_SC_X4_FI_SP0_RSLVD_SPDr BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD0
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc041
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r (0x0000c041 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD0.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd0[1];
	uint32_t _sc_x4_fi_sp0_rslvd0;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_CLR(r) (r).sc_x4_fi_sp0_rslvd0[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_SET(r,d) (r).sc_x4_fi_sp0_rslvd0[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_GET(r) (r).sc_x4_fi_sp0_rslvd0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_QSGMII_ENf_GET(r) ((((r).sc_x4_fi_sp0_rslvd0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_QSGMII_ENf_SET(r,f) (r).sc_x4_fi_sp0_rslvd0[0]=(((r).sc_x4_fi_sp0_rslvd0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x4_fi_sp0_rslvd0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x4_fi_sp0_rslvd0[0]=(((r).sc_x4_fi_sp0_rslvd0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_OS_MODEf_GET(r) (((r).sc_x4_fi_sp0_rslvd0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_OS_MODEf_SET(r,f) (r).sc_x4_fi_sp0_rslvd0[0]=(((r).sc_x4_fi_sp0_rslvd0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD0.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r,(_r._sc_x4_fi_sp0_rslvd0))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r,(_r._sc_x4_fi_sp0_rslvd0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r,(_r._sc_x4_fi_sp0_rslvd0))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd0))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd0))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD0r BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r
#define SC_X4_FI_SP0_RSLVD0r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_t SC_X4_FI_SP0_RSLVD0r_t;
#define SC_X4_FI_SP0_RSLVD0r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_CLR
#define SC_X4_FI_SP0_RSLVD0r_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_SET
#define SC_X4_FI_SP0_RSLVD0r_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_GET
#define SC_X4_FI_SP0_RSLVD0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_QSGMII_ENf_GET
#define SC_X4_FI_SP0_RSLVD0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_QSGMII_ENf_SET
#define SC_X4_FI_SP0_RSLVD0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_CL36BYTEDELETEMODEf_GET
#define SC_X4_FI_SP0_RSLVD0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_CL36BYTEDELETEMODEf_SET
#define SC_X4_FI_SP0_RSLVD0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_OS_MODEf_GET
#define SC_X4_FI_SP0_RSLVD0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r_OS_MODEf_SET
#define READ_SC_X4_FI_SP0_RSLVD0r BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD0r
#define WRITE_SC_X4_FI_SP0_RSLVD0r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD0r
#define MODIFY_SC_X4_FI_SP0_RSLVD0r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD0r
#define READLN_SC_X4_FI_SP0_RSLVD0r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD0r
#define WRITELN_SC_X4_FI_SP0_RSLVD0r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD0r
#define WRITEALL_SC_X4_FI_SP0_RSLVD0r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD1
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc042
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r (0x0000c042 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD1.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd1[1];
	uint32_t _sc_x4_fi_sp0_rslvd1;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_CLR(r) (r).sc_x4_fi_sp0_rslvd1[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SET(r,d) (r).sc_x4_fi_sp0_rslvd1[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_GET(r) (r).sc_x4_fi_sp0_rslvd1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x4_fi_sp0_rslvd1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x4_fi_sp0_rslvd1[0]=(((r).sc_x4_fi_sp0_rslvd1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp0_rslvd1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp0_rslvd1[0]=(((r).sc_x4_fi_sp0_rslvd1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD1.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r,(_r._sc_x4_fi_sp0_rslvd1))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r,(_r._sc_x4_fi_sp0_rslvd1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r,(_r._sc_x4_fi_sp0_rslvd1))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd1))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd1))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD1r BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r
#define SC_X4_FI_SP0_RSLVD1r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_t SC_X4_FI_SP0_RSLVD1r_t;
#define SC_X4_FI_SP0_RSLVD1r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_CLR
#define SC_X4_FI_SP0_RSLVD1r_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SET
#define SC_X4_FI_SP0_RSLVD1r_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_GET
#define SC_X4_FI_SP0_RSLVD1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SGMII_SPD_SWITCHf_GET
#define SC_X4_FI_SP0_RSLVD1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_SGMII_SPD_SWITCHf_SET
#define SC_X4_FI_SP0_RSLVD1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_CLOCKCNT0f_GET
#define SC_X4_FI_SP0_RSLVD1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP0_RSLVD1r BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD1r
#define WRITE_SC_X4_FI_SP0_RSLVD1r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD1r
#define MODIFY_SC_X4_FI_SP0_RSLVD1r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD1r
#define READLN_SC_X4_FI_SP0_RSLVD1r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD1r
#define WRITELN_SC_X4_FI_SP0_RSLVD1r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD1r
#define WRITEALL_SC_X4_FI_SP0_RSLVD1r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD2
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc043
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r (0x0000c043 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD2.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd2[1];
	uint32_t _sc_x4_fi_sp0_rslvd2;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_CLR(r) (r).sc_x4_fi_sp0_rslvd2[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_SET(r,d) (r).sc_x4_fi_sp0_rslvd2[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_GET(r) (r).sc_x4_fi_sp0_rslvd2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_CLOCKCNT1f_GET(r) (((r).sc_x4_fi_sp0_rslvd2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_CLOCKCNT1f_SET(r,f) (r).sc_x4_fi_sp0_rslvd2[0]=(((r).sc_x4_fi_sp0_rslvd2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD2.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r,(_r._sc_x4_fi_sp0_rslvd2))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r,(_r._sc_x4_fi_sp0_rslvd2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r,(_r._sc_x4_fi_sp0_rslvd2))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd2))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd2))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD2r BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r
#define SC_X4_FI_SP0_RSLVD2r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_t SC_X4_FI_SP0_RSLVD2r_t;
#define SC_X4_FI_SP0_RSLVD2r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_CLR
#define SC_X4_FI_SP0_RSLVD2r_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_SET
#define SC_X4_FI_SP0_RSLVD2r_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_GET
#define SC_X4_FI_SP0_RSLVD2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_CLOCKCNT1f_GET
#define SC_X4_FI_SP0_RSLVD2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r_CLOCKCNT1f_SET
#define READ_SC_X4_FI_SP0_RSLVD2r BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD2r
#define WRITE_SC_X4_FI_SP0_RSLVD2r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD2r
#define MODIFY_SC_X4_FI_SP0_RSLVD2r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD2r
#define READLN_SC_X4_FI_SP0_RSLVD2r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD2r
#define WRITELN_SC_X4_FI_SP0_RSLVD2r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD2r
#define WRITEALL_SC_X4_FI_SP0_RSLVD2r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD3
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc044
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r (0x0000c044 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD3.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd3[1];
	uint32_t _sc_x4_fi_sp0_rslvd3;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_CLR(r) (r).sc_x4_fi_sp0_rslvd3[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_SET(r,d) (r).sc_x4_fi_sp0_rslvd3[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_GET(r) (r).sc_x4_fi_sp0_rslvd3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT0f_GET(r) ((((r).sc_x4_fi_sp0_rslvd3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT0f_SET(r,f) (r).sc_x4_fi_sp0_rslvd3[0]=(((r).sc_x4_fi_sp0_rslvd3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT1f_GET(r) (((r).sc_x4_fi_sp0_rslvd3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT1f_SET(r,f) (r).sc_x4_fi_sp0_rslvd3[0]=(((r).sc_x4_fi_sp0_rslvd3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD3.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r,(_r._sc_x4_fi_sp0_rslvd3))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r,(_r._sc_x4_fi_sp0_rslvd3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r,(_r._sc_x4_fi_sp0_rslvd3))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd3))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd3))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD3r BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r
#define SC_X4_FI_SP0_RSLVD3r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_t SC_X4_FI_SP0_RSLVD3r_t;
#define SC_X4_FI_SP0_RSLVD3r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_CLR
#define SC_X4_FI_SP0_RSLVD3r_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_SET
#define SC_X4_FI_SP0_RSLVD3r_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_GET
#define SC_X4_FI_SP0_RSLVD3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT0f_GET
#define SC_X4_FI_SP0_RSLVD3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT0f_SET
#define SC_X4_FI_SP0_RSLVD3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT1f_GET
#define SC_X4_FI_SP0_RSLVD3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r_LOOPCNT1f_SET
#define READ_SC_X4_FI_SP0_RSLVD3r BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD3r
#define WRITE_SC_X4_FI_SP0_RSLVD3r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD3r
#define MODIFY_SC_X4_FI_SP0_RSLVD3r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD3r
#define READLN_SC_X4_FI_SP0_RSLVD3r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD3r
#define WRITELN_SC_X4_FI_SP0_RSLVD3r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD3r
#define WRITEALL_SC_X4_FI_SP0_RSLVD3r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD4
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc045
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r (0x0000c045 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD4.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd4[1];
	uint32_t _sc_x4_fi_sp0_rslvd4;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_CLR(r) (r).sc_x4_fi_sp0_rslvd4[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_SET(r,d) (r).sc_x4_fi_sp0_rslvd4[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_GET(r) (r).sc_x4_fi_sp0_rslvd4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp0_rslvd4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp0_rslvd4[0]=(((r).sc_x4_fi_sp0_rslvd4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD4.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r,(_r._sc_x4_fi_sp0_rslvd4))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r,(_r._sc_x4_fi_sp0_rslvd4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r,(_r._sc_x4_fi_sp0_rslvd4))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd4))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd4))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD4r BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r
#define SC_X4_FI_SP0_RSLVD4r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_t SC_X4_FI_SP0_RSLVD4r_t;
#define SC_X4_FI_SP0_RSLVD4r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_CLR
#define SC_X4_FI_SP0_RSLVD4r_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_SET
#define SC_X4_FI_SP0_RSLVD4r_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_GET
#define SC_X4_FI_SP0_RSLVD4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_MAC_CREDITGENCNTf_GET
#define SC_X4_FI_SP0_RSLVD4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP0_RSLVD4r BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD4r
#define WRITE_SC_X4_FI_SP0_RSLVD4r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD4r
#define MODIFY_SC_X4_FI_SP0_RSLVD4r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD4r
#define READLN_SC_X4_FI_SP0_RSLVD4r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD4r
#define WRITELN_SC_X4_FI_SP0_RSLVD4r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD4r
#define WRITEALL_SC_X4_FI_SP0_RSLVD4r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD5
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc046
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r (0x0000c046 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD5.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd5[1];
	uint32_t _sc_x4_fi_sp0_rslvd5;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_CLR(r) (r).sc_x4_fi_sp0_rslvd5[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_SET(r,d) (r).sc_x4_fi_sp0_rslvd5[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_GET(r) (r).sc_x4_fi_sp0_rslvd5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_REPLICATION_CNTf_GET(r) ((((r).sc_x4_fi_sp0_rslvd5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_REPLICATION_CNTf_SET(r,f) (r).sc_x4_fi_sp0_rslvd5[0]=(((r).sc_x4_fi_sp0_rslvd5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x4_fi_sp0_rslvd5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x4_fi_sp0_rslvd5[0]=(((r).sc_x4_fi_sp0_rslvd5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp0_rslvd5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp0_rslvd5[0]=(((r).sc_x4_fi_sp0_rslvd5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD5.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r,(_r._sc_x4_fi_sp0_rslvd5))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r,(_r._sc_x4_fi_sp0_rslvd5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r,(_r._sc_x4_fi_sp0_rslvd5))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd5))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd5))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD5r BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r
#define SC_X4_FI_SP0_RSLVD5r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_t SC_X4_FI_SP0_RSLVD5r_t;
#define SC_X4_FI_SP0_RSLVD5r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_CLR
#define SC_X4_FI_SP0_RSLVD5r_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_SET
#define SC_X4_FI_SP0_RSLVD5r_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_GET
#define SC_X4_FI_SP0_RSLVD5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_REPLICATION_CNTf_GET
#define SC_X4_FI_SP0_RSLVD5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_REPLICATION_CNTf_SET
#define SC_X4_FI_SP0_RSLVD5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CREDITENABLEf_GET
#define SC_X4_FI_SP0_RSLVD5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CREDITENABLEf_SET
#define SC_X4_FI_SP0_RSLVD5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CLOCKCNT0f_GET
#define SC_X4_FI_SP0_RSLVD5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP0_RSLVD5r BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD5r
#define WRITE_SC_X4_FI_SP0_RSLVD5r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD5r
#define MODIFY_SC_X4_FI_SP0_RSLVD5r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD5r
#define READLN_SC_X4_FI_SP0_RSLVD5r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD5r
#define WRITELN_SC_X4_FI_SP0_RSLVD5r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD5r
#define WRITEALL_SC_X4_FI_SP0_RSLVD5r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP0_RSLVD6
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP0
 * REGADDR:  0xc047
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r (0x0000c047 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP0_RSLVD6.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp0_rslvd6[1];
	uint32_t _sc_x4_fi_sp0_rslvd6;
} BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_CLR(r) (r).sc_x4_fi_sp0_rslvd6[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_SET(r,d) (r).sc_x4_fi_sp0_rslvd6[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_GET(r) (r).sc_x4_fi_sp0_rslvd6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp0_rslvd6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp0_rslvd6[0]=(((r).sc_x4_fi_sp0_rslvd6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP0_RSLVD6.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r,(_r._sc_x4_fi_sp0_rslvd6))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r,(_r._sc_x4_fi_sp0_rslvd6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r,(_r._sc_x4_fi_sp0_rslvd6))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd6))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp0_rslvd6))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp0_rslvd6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP0_RSLVD6r BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r
#define SC_X4_FI_SP0_RSLVD6r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_t SC_X4_FI_SP0_RSLVD6r_t;
#define SC_X4_FI_SP0_RSLVD6r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_CLR
#define SC_X4_FI_SP0_RSLVD6r_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_SET
#define SC_X4_FI_SP0_RSLVD6r_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_GET
#define SC_X4_FI_SP0_RSLVD6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_PCS_CREDITGENCNTf_GET
#define SC_X4_FI_SP0_RSLVD6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP0_RSLVD6r BCMI_QTC_XGXS_READ_SC_X4_FI_SP0_RSLVD6r
#define WRITE_SC_X4_FI_SP0_RSLVD6r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP0_RSLVD6r
#define MODIFY_SC_X4_FI_SP0_RSLVD6r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP0_RSLVD6r
#define READLN_SC_X4_FI_SP0_RSLVD6r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP0_RSLVD6r
#define WRITELN_SC_X4_FI_SP0_RSLVD6r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP0_RSLVD6r
#define WRITEALL_SC_X4_FI_SP0_RSLVD6r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP0_RSLVD6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP0_RSLVD6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD_SPD
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc050
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr (0x0000c050 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd_spd[1];
	uint32_t _sc_x4_fi_sp1_rslvd_spd;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_CLR(r) (r).sc_x4_fi_sp1_rslvd_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SET(r,d) (r).sc_x4_fi_sp1_rslvd_spd[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_GET(r) (r).sc_x4_fi_sp1_rslvd_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SPEEDf_GET(r) (((r).sc_x4_fi_sp1_rslvd_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SPEEDf_SET(r,f) (r).sc_x4_fi_sp1_rslvd_spd[0]=(((r).sc_x4_fi_sp1_rslvd_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr,(_r._sc_x4_fi_sp1_rslvd_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr,(_r._sc_x4_fi_sp1_rslvd_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr,(_r._sc_x4_fi_sp1_rslvd_spd))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd_spd))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd_spd))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD_SPDr BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr
#define SC_X4_FI_SP1_RSLVD_SPDr_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_t SC_X4_FI_SP1_RSLVD_SPDr_t;
#define SC_X4_FI_SP1_RSLVD_SPDr_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_CLR
#define SC_X4_FI_SP1_RSLVD_SPDr_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SET
#define SC_X4_FI_SP1_RSLVD_SPDr_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_GET
#define SC_X4_FI_SP1_RSLVD_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SPEEDf_GET
#define SC_X4_FI_SP1_RSLVD_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr_SPEEDf_SET
#define READ_SC_X4_FI_SP1_RSLVD_SPDr BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD_SPDr
#define WRITE_SC_X4_FI_SP1_RSLVD_SPDr BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD_SPDr
#define MODIFY_SC_X4_FI_SP1_RSLVD_SPDr BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD_SPDr
#define READLN_SC_X4_FI_SP1_RSLVD_SPDr BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD_SPDr
#define WRITELN_SC_X4_FI_SP1_RSLVD_SPDr BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD_SPDr
#define WRITEALL_SC_X4_FI_SP1_RSLVD_SPDr BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD0
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc051
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r (0x0000c051 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD0.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd0[1];
	uint32_t _sc_x4_fi_sp1_rslvd0;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_CLR(r) (r).sc_x4_fi_sp1_rslvd0[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_SET(r,d) (r).sc_x4_fi_sp1_rslvd0[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_GET(r) (r).sc_x4_fi_sp1_rslvd0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_QSGMII_ENf_GET(r) ((((r).sc_x4_fi_sp1_rslvd0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_QSGMII_ENf_SET(r,f) (r).sc_x4_fi_sp1_rslvd0[0]=(((r).sc_x4_fi_sp1_rslvd0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x4_fi_sp1_rslvd0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x4_fi_sp1_rslvd0[0]=(((r).sc_x4_fi_sp1_rslvd0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_OS_MODEf_GET(r) (((r).sc_x4_fi_sp1_rslvd0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_OS_MODEf_SET(r,f) (r).sc_x4_fi_sp1_rslvd0[0]=(((r).sc_x4_fi_sp1_rslvd0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD0.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r,(_r._sc_x4_fi_sp1_rslvd0))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r,(_r._sc_x4_fi_sp1_rslvd0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r,(_r._sc_x4_fi_sp1_rslvd0))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd0))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd0))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD0r BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r
#define SC_X4_FI_SP1_RSLVD0r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_t SC_X4_FI_SP1_RSLVD0r_t;
#define SC_X4_FI_SP1_RSLVD0r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_CLR
#define SC_X4_FI_SP1_RSLVD0r_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_SET
#define SC_X4_FI_SP1_RSLVD0r_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_GET
#define SC_X4_FI_SP1_RSLVD0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_QSGMII_ENf_GET
#define SC_X4_FI_SP1_RSLVD0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_QSGMII_ENf_SET
#define SC_X4_FI_SP1_RSLVD0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_CL36BYTEDELETEMODEf_GET
#define SC_X4_FI_SP1_RSLVD0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_CL36BYTEDELETEMODEf_SET
#define SC_X4_FI_SP1_RSLVD0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_OS_MODEf_GET
#define SC_X4_FI_SP1_RSLVD0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r_OS_MODEf_SET
#define READ_SC_X4_FI_SP1_RSLVD0r BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD0r
#define WRITE_SC_X4_FI_SP1_RSLVD0r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD0r
#define MODIFY_SC_X4_FI_SP1_RSLVD0r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD0r
#define READLN_SC_X4_FI_SP1_RSLVD0r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD0r
#define WRITELN_SC_X4_FI_SP1_RSLVD0r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD0r
#define WRITEALL_SC_X4_FI_SP1_RSLVD0r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD1
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc052
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r (0x0000c052 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD1.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd1[1];
	uint32_t _sc_x4_fi_sp1_rslvd1;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_CLR(r) (r).sc_x4_fi_sp1_rslvd1[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SET(r,d) (r).sc_x4_fi_sp1_rslvd1[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_GET(r) (r).sc_x4_fi_sp1_rslvd1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x4_fi_sp1_rslvd1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x4_fi_sp1_rslvd1[0]=(((r).sc_x4_fi_sp1_rslvd1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp1_rslvd1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp1_rslvd1[0]=(((r).sc_x4_fi_sp1_rslvd1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD1.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r,(_r._sc_x4_fi_sp1_rslvd1))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r,(_r._sc_x4_fi_sp1_rslvd1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r,(_r._sc_x4_fi_sp1_rslvd1))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd1))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd1))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD1r BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r
#define SC_X4_FI_SP1_RSLVD1r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_t SC_X4_FI_SP1_RSLVD1r_t;
#define SC_X4_FI_SP1_RSLVD1r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_CLR
#define SC_X4_FI_SP1_RSLVD1r_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SET
#define SC_X4_FI_SP1_RSLVD1r_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_GET
#define SC_X4_FI_SP1_RSLVD1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SGMII_SPD_SWITCHf_GET
#define SC_X4_FI_SP1_RSLVD1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_SGMII_SPD_SWITCHf_SET
#define SC_X4_FI_SP1_RSLVD1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_CLOCKCNT0f_GET
#define SC_X4_FI_SP1_RSLVD1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP1_RSLVD1r BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD1r
#define WRITE_SC_X4_FI_SP1_RSLVD1r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD1r
#define MODIFY_SC_X4_FI_SP1_RSLVD1r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD1r
#define READLN_SC_X4_FI_SP1_RSLVD1r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD1r
#define WRITELN_SC_X4_FI_SP1_RSLVD1r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD1r
#define WRITEALL_SC_X4_FI_SP1_RSLVD1r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD2
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc053
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r (0x0000c053 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD2.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd2[1];
	uint32_t _sc_x4_fi_sp1_rslvd2;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_CLR(r) (r).sc_x4_fi_sp1_rslvd2[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_SET(r,d) (r).sc_x4_fi_sp1_rslvd2[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_GET(r) (r).sc_x4_fi_sp1_rslvd2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_CLOCKCNT1f_GET(r) (((r).sc_x4_fi_sp1_rslvd2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_CLOCKCNT1f_SET(r,f) (r).sc_x4_fi_sp1_rslvd2[0]=(((r).sc_x4_fi_sp1_rslvd2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD2.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r,(_r._sc_x4_fi_sp1_rslvd2))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r,(_r._sc_x4_fi_sp1_rslvd2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r,(_r._sc_x4_fi_sp1_rslvd2))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd2))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd2))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD2r BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r
#define SC_X4_FI_SP1_RSLVD2r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_t SC_X4_FI_SP1_RSLVD2r_t;
#define SC_X4_FI_SP1_RSLVD2r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_CLR
#define SC_X4_FI_SP1_RSLVD2r_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_SET
#define SC_X4_FI_SP1_RSLVD2r_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_GET
#define SC_X4_FI_SP1_RSLVD2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_CLOCKCNT1f_GET
#define SC_X4_FI_SP1_RSLVD2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r_CLOCKCNT1f_SET
#define READ_SC_X4_FI_SP1_RSLVD2r BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD2r
#define WRITE_SC_X4_FI_SP1_RSLVD2r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD2r
#define MODIFY_SC_X4_FI_SP1_RSLVD2r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD2r
#define READLN_SC_X4_FI_SP1_RSLVD2r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD2r
#define WRITELN_SC_X4_FI_SP1_RSLVD2r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD2r
#define WRITEALL_SC_X4_FI_SP1_RSLVD2r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD3
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc054
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r (0x0000c054 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD3.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd3[1];
	uint32_t _sc_x4_fi_sp1_rslvd3;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_CLR(r) (r).sc_x4_fi_sp1_rslvd3[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_SET(r,d) (r).sc_x4_fi_sp1_rslvd3[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_GET(r) (r).sc_x4_fi_sp1_rslvd3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT0f_GET(r) ((((r).sc_x4_fi_sp1_rslvd3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT0f_SET(r,f) (r).sc_x4_fi_sp1_rslvd3[0]=(((r).sc_x4_fi_sp1_rslvd3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT1f_GET(r) (((r).sc_x4_fi_sp1_rslvd3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT1f_SET(r,f) (r).sc_x4_fi_sp1_rslvd3[0]=(((r).sc_x4_fi_sp1_rslvd3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD3.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r,(_r._sc_x4_fi_sp1_rslvd3))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r,(_r._sc_x4_fi_sp1_rslvd3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r,(_r._sc_x4_fi_sp1_rslvd3))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd3))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd3))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD3r BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r
#define SC_X4_FI_SP1_RSLVD3r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_t SC_X4_FI_SP1_RSLVD3r_t;
#define SC_X4_FI_SP1_RSLVD3r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_CLR
#define SC_X4_FI_SP1_RSLVD3r_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_SET
#define SC_X4_FI_SP1_RSLVD3r_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_GET
#define SC_X4_FI_SP1_RSLVD3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT0f_GET
#define SC_X4_FI_SP1_RSLVD3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT0f_SET
#define SC_X4_FI_SP1_RSLVD3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT1f_GET
#define SC_X4_FI_SP1_RSLVD3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r_LOOPCNT1f_SET
#define READ_SC_X4_FI_SP1_RSLVD3r BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD3r
#define WRITE_SC_X4_FI_SP1_RSLVD3r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD3r
#define MODIFY_SC_X4_FI_SP1_RSLVD3r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD3r
#define READLN_SC_X4_FI_SP1_RSLVD3r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD3r
#define WRITELN_SC_X4_FI_SP1_RSLVD3r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD3r
#define WRITEALL_SC_X4_FI_SP1_RSLVD3r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD4
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc055
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r (0x0000c055 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD4.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd4[1];
	uint32_t _sc_x4_fi_sp1_rslvd4;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_CLR(r) (r).sc_x4_fi_sp1_rslvd4[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_SET(r,d) (r).sc_x4_fi_sp1_rslvd4[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_GET(r) (r).sc_x4_fi_sp1_rslvd4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp1_rslvd4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp1_rslvd4[0]=(((r).sc_x4_fi_sp1_rslvd4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD4.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r,(_r._sc_x4_fi_sp1_rslvd4))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r,(_r._sc_x4_fi_sp1_rslvd4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r,(_r._sc_x4_fi_sp1_rslvd4))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd4))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd4))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD4r BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r
#define SC_X4_FI_SP1_RSLVD4r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_t SC_X4_FI_SP1_RSLVD4r_t;
#define SC_X4_FI_SP1_RSLVD4r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_CLR
#define SC_X4_FI_SP1_RSLVD4r_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_SET
#define SC_X4_FI_SP1_RSLVD4r_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_GET
#define SC_X4_FI_SP1_RSLVD4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_MAC_CREDITGENCNTf_GET
#define SC_X4_FI_SP1_RSLVD4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP1_RSLVD4r BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD4r
#define WRITE_SC_X4_FI_SP1_RSLVD4r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD4r
#define MODIFY_SC_X4_FI_SP1_RSLVD4r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD4r
#define READLN_SC_X4_FI_SP1_RSLVD4r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD4r
#define WRITELN_SC_X4_FI_SP1_RSLVD4r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD4r
#define WRITEALL_SC_X4_FI_SP1_RSLVD4r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD5
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc056
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r (0x0000c056 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD5.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd5[1];
	uint32_t _sc_x4_fi_sp1_rslvd5;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_CLR(r) (r).sc_x4_fi_sp1_rslvd5[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_SET(r,d) (r).sc_x4_fi_sp1_rslvd5[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_GET(r) (r).sc_x4_fi_sp1_rslvd5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_REPLICATION_CNTf_GET(r) ((((r).sc_x4_fi_sp1_rslvd5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_REPLICATION_CNTf_SET(r,f) (r).sc_x4_fi_sp1_rslvd5[0]=(((r).sc_x4_fi_sp1_rslvd5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x4_fi_sp1_rslvd5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x4_fi_sp1_rslvd5[0]=(((r).sc_x4_fi_sp1_rslvd5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp1_rslvd5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp1_rslvd5[0]=(((r).sc_x4_fi_sp1_rslvd5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD5.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r,(_r._sc_x4_fi_sp1_rslvd5))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r,(_r._sc_x4_fi_sp1_rslvd5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r,(_r._sc_x4_fi_sp1_rslvd5))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd5))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd5))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD5r BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r
#define SC_X4_FI_SP1_RSLVD5r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_t SC_X4_FI_SP1_RSLVD5r_t;
#define SC_X4_FI_SP1_RSLVD5r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_CLR
#define SC_X4_FI_SP1_RSLVD5r_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_SET
#define SC_X4_FI_SP1_RSLVD5r_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_GET
#define SC_X4_FI_SP1_RSLVD5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_REPLICATION_CNTf_GET
#define SC_X4_FI_SP1_RSLVD5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_REPLICATION_CNTf_SET
#define SC_X4_FI_SP1_RSLVD5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CREDITENABLEf_GET
#define SC_X4_FI_SP1_RSLVD5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CREDITENABLEf_SET
#define SC_X4_FI_SP1_RSLVD5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CLOCKCNT0f_GET
#define SC_X4_FI_SP1_RSLVD5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP1_RSLVD5r BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD5r
#define WRITE_SC_X4_FI_SP1_RSLVD5r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD5r
#define MODIFY_SC_X4_FI_SP1_RSLVD5r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD5r
#define READLN_SC_X4_FI_SP1_RSLVD5r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD5r
#define WRITELN_SC_X4_FI_SP1_RSLVD5r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD5r
#define WRITEALL_SC_X4_FI_SP1_RSLVD5r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP1_RSLVD6
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP1
 * REGADDR:  0xc057
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r (0x0000c057 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP1_RSLVD6.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp1_rslvd6[1];
	uint32_t _sc_x4_fi_sp1_rslvd6;
} BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_CLR(r) (r).sc_x4_fi_sp1_rslvd6[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_SET(r,d) (r).sc_x4_fi_sp1_rslvd6[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_GET(r) (r).sc_x4_fi_sp1_rslvd6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp1_rslvd6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp1_rslvd6[0]=(((r).sc_x4_fi_sp1_rslvd6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP1_RSLVD6.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r,(_r._sc_x4_fi_sp1_rslvd6))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r,(_r._sc_x4_fi_sp1_rslvd6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r,(_r._sc_x4_fi_sp1_rslvd6))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd6))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp1_rslvd6))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp1_rslvd6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP1_RSLVD6r BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r
#define SC_X4_FI_SP1_RSLVD6r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_t SC_X4_FI_SP1_RSLVD6r_t;
#define SC_X4_FI_SP1_RSLVD6r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_CLR
#define SC_X4_FI_SP1_RSLVD6r_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_SET
#define SC_X4_FI_SP1_RSLVD6r_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_GET
#define SC_X4_FI_SP1_RSLVD6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_PCS_CREDITGENCNTf_GET
#define SC_X4_FI_SP1_RSLVD6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP1_RSLVD6r BCMI_QTC_XGXS_READ_SC_X4_FI_SP1_RSLVD6r
#define WRITE_SC_X4_FI_SP1_RSLVD6r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP1_RSLVD6r
#define MODIFY_SC_X4_FI_SP1_RSLVD6r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP1_RSLVD6r
#define READLN_SC_X4_FI_SP1_RSLVD6r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP1_RSLVD6r
#define WRITELN_SC_X4_FI_SP1_RSLVD6r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP1_RSLVD6r
#define WRITEALL_SC_X4_FI_SP1_RSLVD6r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP1_RSLVD6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP1_RSLVD6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD_SPD
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc060
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr (0x0000c060 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd_spd[1];
	uint32_t _sc_x4_fi_sp2_rslvd_spd;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_CLR(r) (r).sc_x4_fi_sp2_rslvd_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SET(r,d) (r).sc_x4_fi_sp2_rslvd_spd[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_GET(r) (r).sc_x4_fi_sp2_rslvd_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SPEEDf_GET(r) (((r).sc_x4_fi_sp2_rslvd_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SPEEDf_SET(r,f) (r).sc_x4_fi_sp2_rslvd_spd[0]=(((r).sc_x4_fi_sp2_rslvd_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr,(_r._sc_x4_fi_sp2_rslvd_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr,(_r._sc_x4_fi_sp2_rslvd_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr,(_r._sc_x4_fi_sp2_rslvd_spd))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd_spd))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd_spd))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD_SPDr BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr
#define SC_X4_FI_SP2_RSLVD_SPDr_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_t SC_X4_FI_SP2_RSLVD_SPDr_t;
#define SC_X4_FI_SP2_RSLVD_SPDr_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_CLR
#define SC_X4_FI_SP2_RSLVD_SPDr_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SET
#define SC_X4_FI_SP2_RSLVD_SPDr_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_GET
#define SC_X4_FI_SP2_RSLVD_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SPEEDf_GET
#define SC_X4_FI_SP2_RSLVD_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr_SPEEDf_SET
#define READ_SC_X4_FI_SP2_RSLVD_SPDr BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD_SPDr
#define WRITE_SC_X4_FI_SP2_RSLVD_SPDr BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD_SPDr
#define MODIFY_SC_X4_FI_SP2_RSLVD_SPDr BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD_SPDr
#define READLN_SC_X4_FI_SP2_RSLVD_SPDr BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD_SPDr
#define WRITELN_SC_X4_FI_SP2_RSLVD_SPDr BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD_SPDr
#define WRITEALL_SC_X4_FI_SP2_RSLVD_SPDr BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD0
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc061
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r (0x0000c061 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD0.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd0[1];
	uint32_t _sc_x4_fi_sp2_rslvd0;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_CLR(r) (r).sc_x4_fi_sp2_rslvd0[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_SET(r,d) (r).sc_x4_fi_sp2_rslvd0[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_GET(r) (r).sc_x4_fi_sp2_rslvd0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_QSGMII_ENf_GET(r) ((((r).sc_x4_fi_sp2_rslvd0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_QSGMII_ENf_SET(r,f) (r).sc_x4_fi_sp2_rslvd0[0]=(((r).sc_x4_fi_sp2_rslvd0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x4_fi_sp2_rslvd0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x4_fi_sp2_rslvd0[0]=(((r).sc_x4_fi_sp2_rslvd0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_OS_MODEf_GET(r) (((r).sc_x4_fi_sp2_rslvd0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_OS_MODEf_SET(r,f) (r).sc_x4_fi_sp2_rslvd0[0]=(((r).sc_x4_fi_sp2_rslvd0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD0.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r,(_r._sc_x4_fi_sp2_rslvd0))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r,(_r._sc_x4_fi_sp2_rslvd0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r,(_r._sc_x4_fi_sp2_rslvd0))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd0))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd0))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD0r BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r
#define SC_X4_FI_SP2_RSLVD0r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_t SC_X4_FI_SP2_RSLVD0r_t;
#define SC_X4_FI_SP2_RSLVD0r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_CLR
#define SC_X4_FI_SP2_RSLVD0r_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_SET
#define SC_X4_FI_SP2_RSLVD0r_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_GET
#define SC_X4_FI_SP2_RSLVD0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_QSGMII_ENf_GET
#define SC_X4_FI_SP2_RSLVD0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_QSGMII_ENf_SET
#define SC_X4_FI_SP2_RSLVD0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_CL36BYTEDELETEMODEf_GET
#define SC_X4_FI_SP2_RSLVD0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_CL36BYTEDELETEMODEf_SET
#define SC_X4_FI_SP2_RSLVD0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_OS_MODEf_GET
#define SC_X4_FI_SP2_RSLVD0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r_OS_MODEf_SET
#define READ_SC_X4_FI_SP2_RSLVD0r BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD0r
#define WRITE_SC_X4_FI_SP2_RSLVD0r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD0r
#define MODIFY_SC_X4_FI_SP2_RSLVD0r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD0r
#define READLN_SC_X4_FI_SP2_RSLVD0r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD0r
#define WRITELN_SC_X4_FI_SP2_RSLVD0r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD0r
#define WRITEALL_SC_X4_FI_SP2_RSLVD0r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD1
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc062
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r (0x0000c062 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD1.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd1[1];
	uint32_t _sc_x4_fi_sp2_rslvd1;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_CLR(r) (r).sc_x4_fi_sp2_rslvd1[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SET(r,d) (r).sc_x4_fi_sp2_rslvd1[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_GET(r) (r).sc_x4_fi_sp2_rslvd1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x4_fi_sp2_rslvd1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x4_fi_sp2_rslvd1[0]=(((r).sc_x4_fi_sp2_rslvd1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp2_rslvd1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp2_rslvd1[0]=(((r).sc_x4_fi_sp2_rslvd1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD1.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r,(_r._sc_x4_fi_sp2_rslvd1))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r,(_r._sc_x4_fi_sp2_rslvd1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r,(_r._sc_x4_fi_sp2_rslvd1))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd1))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd1))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD1r BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r
#define SC_X4_FI_SP2_RSLVD1r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_t SC_X4_FI_SP2_RSLVD1r_t;
#define SC_X4_FI_SP2_RSLVD1r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_CLR
#define SC_X4_FI_SP2_RSLVD1r_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SET
#define SC_X4_FI_SP2_RSLVD1r_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_GET
#define SC_X4_FI_SP2_RSLVD1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SGMII_SPD_SWITCHf_GET
#define SC_X4_FI_SP2_RSLVD1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_SGMII_SPD_SWITCHf_SET
#define SC_X4_FI_SP2_RSLVD1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_CLOCKCNT0f_GET
#define SC_X4_FI_SP2_RSLVD1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP2_RSLVD1r BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD1r
#define WRITE_SC_X4_FI_SP2_RSLVD1r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD1r
#define MODIFY_SC_X4_FI_SP2_RSLVD1r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD1r
#define READLN_SC_X4_FI_SP2_RSLVD1r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD1r
#define WRITELN_SC_X4_FI_SP2_RSLVD1r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD1r
#define WRITEALL_SC_X4_FI_SP2_RSLVD1r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD2
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc063
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r (0x0000c063 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD2.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd2[1];
	uint32_t _sc_x4_fi_sp2_rslvd2;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_CLR(r) (r).sc_x4_fi_sp2_rslvd2[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_SET(r,d) (r).sc_x4_fi_sp2_rslvd2[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_GET(r) (r).sc_x4_fi_sp2_rslvd2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_CLOCKCNT1f_GET(r) (((r).sc_x4_fi_sp2_rslvd2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_CLOCKCNT1f_SET(r,f) (r).sc_x4_fi_sp2_rslvd2[0]=(((r).sc_x4_fi_sp2_rslvd2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD2.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r,(_r._sc_x4_fi_sp2_rslvd2))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r,(_r._sc_x4_fi_sp2_rslvd2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r,(_r._sc_x4_fi_sp2_rslvd2))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd2))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd2))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD2r BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r
#define SC_X4_FI_SP2_RSLVD2r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_t SC_X4_FI_SP2_RSLVD2r_t;
#define SC_X4_FI_SP2_RSLVD2r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_CLR
#define SC_X4_FI_SP2_RSLVD2r_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_SET
#define SC_X4_FI_SP2_RSLVD2r_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_GET
#define SC_X4_FI_SP2_RSLVD2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_CLOCKCNT1f_GET
#define SC_X4_FI_SP2_RSLVD2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r_CLOCKCNT1f_SET
#define READ_SC_X4_FI_SP2_RSLVD2r BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD2r
#define WRITE_SC_X4_FI_SP2_RSLVD2r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD2r
#define MODIFY_SC_X4_FI_SP2_RSLVD2r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD2r
#define READLN_SC_X4_FI_SP2_RSLVD2r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD2r
#define WRITELN_SC_X4_FI_SP2_RSLVD2r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD2r
#define WRITEALL_SC_X4_FI_SP2_RSLVD2r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD3
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc064
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r (0x0000c064 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD3.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd3[1];
	uint32_t _sc_x4_fi_sp2_rslvd3;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_CLR(r) (r).sc_x4_fi_sp2_rslvd3[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_SET(r,d) (r).sc_x4_fi_sp2_rslvd3[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_GET(r) (r).sc_x4_fi_sp2_rslvd3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT0f_GET(r) ((((r).sc_x4_fi_sp2_rslvd3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT0f_SET(r,f) (r).sc_x4_fi_sp2_rslvd3[0]=(((r).sc_x4_fi_sp2_rslvd3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT1f_GET(r) (((r).sc_x4_fi_sp2_rslvd3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT1f_SET(r,f) (r).sc_x4_fi_sp2_rslvd3[0]=(((r).sc_x4_fi_sp2_rslvd3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD3.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r,(_r._sc_x4_fi_sp2_rslvd3))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r,(_r._sc_x4_fi_sp2_rslvd3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r,(_r._sc_x4_fi_sp2_rslvd3))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd3))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd3))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD3r BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r
#define SC_X4_FI_SP2_RSLVD3r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_t SC_X4_FI_SP2_RSLVD3r_t;
#define SC_X4_FI_SP2_RSLVD3r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_CLR
#define SC_X4_FI_SP2_RSLVD3r_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_SET
#define SC_X4_FI_SP2_RSLVD3r_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_GET
#define SC_X4_FI_SP2_RSLVD3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT0f_GET
#define SC_X4_FI_SP2_RSLVD3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT0f_SET
#define SC_X4_FI_SP2_RSLVD3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT1f_GET
#define SC_X4_FI_SP2_RSLVD3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r_LOOPCNT1f_SET
#define READ_SC_X4_FI_SP2_RSLVD3r BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD3r
#define WRITE_SC_X4_FI_SP2_RSLVD3r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD3r
#define MODIFY_SC_X4_FI_SP2_RSLVD3r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD3r
#define READLN_SC_X4_FI_SP2_RSLVD3r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD3r
#define WRITELN_SC_X4_FI_SP2_RSLVD3r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD3r
#define WRITEALL_SC_X4_FI_SP2_RSLVD3r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD4
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc065
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r (0x0000c065 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD4.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd4[1];
	uint32_t _sc_x4_fi_sp2_rslvd4;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_CLR(r) (r).sc_x4_fi_sp2_rslvd4[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_SET(r,d) (r).sc_x4_fi_sp2_rslvd4[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_GET(r) (r).sc_x4_fi_sp2_rslvd4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp2_rslvd4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp2_rslvd4[0]=(((r).sc_x4_fi_sp2_rslvd4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD4.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r,(_r._sc_x4_fi_sp2_rslvd4))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r,(_r._sc_x4_fi_sp2_rslvd4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r,(_r._sc_x4_fi_sp2_rslvd4))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd4))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd4))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD4r BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r
#define SC_X4_FI_SP2_RSLVD4r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_t SC_X4_FI_SP2_RSLVD4r_t;
#define SC_X4_FI_SP2_RSLVD4r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_CLR
#define SC_X4_FI_SP2_RSLVD4r_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_SET
#define SC_X4_FI_SP2_RSLVD4r_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_GET
#define SC_X4_FI_SP2_RSLVD4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_MAC_CREDITGENCNTf_GET
#define SC_X4_FI_SP2_RSLVD4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP2_RSLVD4r BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD4r
#define WRITE_SC_X4_FI_SP2_RSLVD4r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD4r
#define MODIFY_SC_X4_FI_SP2_RSLVD4r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD4r
#define READLN_SC_X4_FI_SP2_RSLVD4r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD4r
#define WRITELN_SC_X4_FI_SP2_RSLVD4r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD4r
#define WRITEALL_SC_X4_FI_SP2_RSLVD4r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD5
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc066
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r (0x0000c066 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD5.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd5[1];
	uint32_t _sc_x4_fi_sp2_rslvd5;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_CLR(r) (r).sc_x4_fi_sp2_rslvd5[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_SET(r,d) (r).sc_x4_fi_sp2_rslvd5[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_GET(r) (r).sc_x4_fi_sp2_rslvd5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_REPLICATION_CNTf_GET(r) ((((r).sc_x4_fi_sp2_rslvd5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_REPLICATION_CNTf_SET(r,f) (r).sc_x4_fi_sp2_rslvd5[0]=(((r).sc_x4_fi_sp2_rslvd5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x4_fi_sp2_rslvd5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x4_fi_sp2_rslvd5[0]=(((r).sc_x4_fi_sp2_rslvd5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp2_rslvd5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp2_rslvd5[0]=(((r).sc_x4_fi_sp2_rslvd5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD5.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r,(_r._sc_x4_fi_sp2_rslvd5))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r,(_r._sc_x4_fi_sp2_rslvd5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r,(_r._sc_x4_fi_sp2_rslvd5))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd5))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd5))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD5r BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r
#define SC_X4_FI_SP2_RSLVD5r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_t SC_X4_FI_SP2_RSLVD5r_t;
#define SC_X4_FI_SP2_RSLVD5r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_CLR
#define SC_X4_FI_SP2_RSLVD5r_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_SET
#define SC_X4_FI_SP2_RSLVD5r_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_GET
#define SC_X4_FI_SP2_RSLVD5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_REPLICATION_CNTf_GET
#define SC_X4_FI_SP2_RSLVD5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_REPLICATION_CNTf_SET
#define SC_X4_FI_SP2_RSLVD5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CREDITENABLEf_GET
#define SC_X4_FI_SP2_RSLVD5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CREDITENABLEf_SET
#define SC_X4_FI_SP2_RSLVD5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CLOCKCNT0f_GET
#define SC_X4_FI_SP2_RSLVD5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP2_RSLVD5r BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD5r
#define WRITE_SC_X4_FI_SP2_RSLVD5r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD5r
#define MODIFY_SC_X4_FI_SP2_RSLVD5r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD5r
#define READLN_SC_X4_FI_SP2_RSLVD5r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD5r
#define WRITELN_SC_X4_FI_SP2_RSLVD5r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD5r
#define WRITEALL_SC_X4_FI_SP2_RSLVD5r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP2_RSLVD6
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP2
 * REGADDR:  0xc067
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r (0x0000c067 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP2_RSLVD6.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp2_rslvd6[1];
	uint32_t _sc_x4_fi_sp2_rslvd6;
} BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_CLR(r) (r).sc_x4_fi_sp2_rslvd6[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_SET(r,d) (r).sc_x4_fi_sp2_rslvd6[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_GET(r) (r).sc_x4_fi_sp2_rslvd6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp2_rslvd6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp2_rslvd6[0]=(((r).sc_x4_fi_sp2_rslvd6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP2_RSLVD6.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r,(_r._sc_x4_fi_sp2_rslvd6))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r,(_r._sc_x4_fi_sp2_rslvd6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r,(_r._sc_x4_fi_sp2_rslvd6))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd6))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp2_rslvd6))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp2_rslvd6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP2_RSLVD6r BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r
#define SC_X4_FI_SP2_RSLVD6r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_t SC_X4_FI_SP2_RSLVD6r_t;
#define SC_X4_FI_SP2_RSLVD6r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_CLR
#define SC_X4_FI_SP2_RSLVD6r_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_SET
#define SC_X4_FI_SP2_RSLVD6r_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_GET
#define SC_X4_FI_SP2_RSLVD6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_PCS_CREDITGENCNTf_GET
#define SC_X4_FI_SP2_RSLVD6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP2_RSLVD6r BCMI_QTC_XGXS_READ_SC_X4_FI_SP2_RSLVD6r
#define WRITE_SC_X4_FI_SP2_RSLVD6r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP2_RSLVD6r
#define MODIFY_SC_X4_FI_SP2_RSLVD6r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP2_RSLVD6r
#define READLN_SC_X4_FI_SP2_RSLVD6r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP2_RSLVD6r
#define WRITELN_SC_X4_FI_SP2_RSLVD6r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP2_RSLVD6r
#define WRITEALL_SC_X4_FI_SP2_RSLVD6r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP2_RSLVD6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP2_RSLVD6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD_SPD
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc070
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     SPEED            Speed ID to use for this configuration
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr (0x0000c070 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD_SPD.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd_spd[1];
	uint32_t _sc_x4_fi_sp3_rslvd_spd;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_CLR(r) (r).sc_x4_fi_sp3_rslvd_spd[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SET(r,d) (r).sc_x4_fi_sp3_rslvd_spd[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_GET(r) (r).sc_x4_fi_sp3_rslvd_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SPEEDf_GET(r) (((r).sc_x4_fi_sp3_rslvd_spd[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SPEEDf_SET(r,f) (r).sc_x4_fi_sp3_rslvd_spd[0]=(((r).sc_x4_fi_sp3_rslvd_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD_SPD.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr,(_r._sc_x4_fi_sp3_rslvd_spd))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr,(_r._sc_x4_fi_sp3_rslvd_spd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr,(_r._sc_x4_fi_sp3_rslvd_spd))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd_spd))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD_SPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd_spd))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD_SPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd_spd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD_SPDr BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr
#define SC_X4_FI_SP3_RSLVD_SPDr_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_t SC_X4_FI_SP3_RSLVD_SPDr_t;
#define SC_X4_FI_SP3_RSLVD_SPDr_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_CLR
#define SC_X4_FI_SP3_RSLVD_SPDr_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SET
#define SC_X4_FI_SP3_RSLVD_SPDr_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_GET
#define SC_X4_FI_SP3_RSLVD_SPDr_SPEEDf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SPEEDf_GET
#define SC_X4_FI_SP3_RSLVD_SPDr_SPEEDf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr_SPEEDf_SET
#define READ_SC_X4_FI_SP3_RSLVD_SPDr BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD_SPDr
#define WRITE_SC_X4_FI_SP3_RSLVD_SPDr BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD_SPDr
#define MODIFY_SC_X4_FI_SP3_RSLVD_SPDr BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD_SPDr
#define READLN_SC_X4_FI_SP3_RSLVD_SPDr BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD_SPDr
#define WRITELN_SC_X4_FI_SP3_RSLVD_SPDr BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD_SPDr
#define WRITEALL_SC_X4_FI_SP3_RSLVD_SPDr BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD_SPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD0
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc071
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r (0x0000c071 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD0.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd0[1];
	uint32_t _sc_x4_fi_sp3_rslvd0;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_CLR(r) (r).sc_x4_fi_sp3_rslvd0[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_SET(r,d) (r).sc_x4_fi_sp3_rslvd0[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_GET(r) (r).sc_x4_fi_sp3_rslvd0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_QSGMII_ENf_GET(r) ((((r).sc_x4_fi_sp3_rslvd0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_QSGMII_ENf_SET(r,f) (r).sc_x4_fi_sp3_rslvd0[0]=(((r).sc_x4_fi_sp3_rslvd0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x4_fi_sp3_rslvd0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x4_fi_sp3_rslvd0[0]=(((r).sc_x4_fi_sp3_rslvd0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_OS_MODEf_GET(r) (((r).sc_x4_fi_sp3_rslvd0[0]) & 0xf)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_OS_MODEf_SET(r,f) (r).sc_x4_fi_sp3_rslvd0[0]=(((r).sc_x4_fi_sp3_rslvd0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD0.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r,(_r._sc_x4_fi_sp3_rslvd0))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r,(_r._sc_x4_fi_sp3_rslvd0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r,(_r._sc_x4_fi_sp3_rslvd0))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd0))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd0))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD0r BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r
#define SC_X4_FI_SP3_RSLVD0r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_t SC_X4_FI_SP3_RSLVD0r_t;
#define SC_X4_FI_SP3_RSLVD0r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_CLR
#define SC_X4_FI_SP3_RSLVD0r_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_SET
#define SC_X4_FI_SP3_RSLVD0r_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_GET
#define SC_X4_FI_SP3_RSLVD0r_QSGMII_ENf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_QSGMII_ENf_GET
#define SC_X4_FI_SP3_RSLVD0r_QSGMII_ENf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_QSGMII_ENf_SET
#define SC_X4_FI_SP3_RSLVD0r_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_CL36BYTEDELETEMODEf_GET
#define SC_X4_FI_SP3_RSLVD0r_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_CL36BYTEDELETEMODEf_SET
#define SC_X4_FI_SP3_RSLVD0r_OS_MODEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_OS_MODEf_GET
#define SC_X4_FI_SP3_RSLVD0r_OS_MODEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r_OS_MODEf_SET
#define READ_SC_X4_FI_SP3_RSLVD0r BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD0r
#define WRITE_SC_X4_FI_SP3_RSLVD0r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD0r
#define MODIFY_SC_X4_FI_SP3_RSLVD0r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD0r
#define READLN_SC_X4_FI_SP3_RSLVD0r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD0r
#define WRITELN_SC_X4_FI_SP3_RSLVD0r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD0r
#define WRITEALL_SC_X4_FI_SP3_RSLVD0r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD1
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc072
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r (0x0000c072 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD1.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd1[1];
	uint32_t _sc_x4_fi_sp3_rslvd1;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_CLR(r) (r).sc_x4_fi_sp3_rslvd1[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SET(r,d) (r).sc_x4_fi_sp3_rslvd1[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_GET(r) (r).sc_x4_fi_sp3_rslvd1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x4_fi_sp3_rslvd1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x4_fi_sp3_rslvd1[0]=(((r).sc_x4_fi_sp3_rslvd1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp3_rslvd1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp3_rslvd1[0]=(((r).sc_x4_fi_sp3_rslvd1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD1.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r,(_r._sc_x4_fi_sp3_rslvd1))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r,(_r._sc_x4_fi_sp3_rslvd1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r,(_r._sc_x4_fi_sp3_rslvd1))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd1))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd1))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD1r BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r
#define SC_X4_FI_SP3_RSLVD1r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_t SC_X4_FI_SP3_RSLVD1r_t;
#define SC_X4_FI_SP3_RSLVD1r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_CLR
#define SC_X4_FI_SP3_RSLVD1r_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SET
#define SC_X4_FI_SP3_RSLVD1r_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_GET
#define SC_X4_FI_SP3_RSLVD1r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SGMII_SPD_SWITCHf_GET
#define SC_X4_FI_SP3_RSLVD1r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_SGMII_SPD_SWITCHf_SET
#define SC_X4_FI_SP3_RSLVD1r_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_CLOCKCNT0f_GET
#define SC_X4_FI_SP3_RSLVD1r_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP3_RSLVD1r BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD1r
#define WRITE_SC_X4_FI_SP3_RSLVD1r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD1r
#define MODIFY_SC_X4_FI_SP3_RSLVD1r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD1r
#define READLN_SC_X4_FI_SP3_RSLVD1r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD1r
#define WRITELN_SC_X4_FI_SP3_RSLVD1r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD1r
#define WRITEALL_SC_X4_FI_SP3_RSLVD1r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD2
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc073
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r (0x0000c073 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD2.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd2[1];
	uint32_t _sc_x4_fi_sp3_rslvd2;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_CLR(r) (r).sc_x4_fi_sp3_rslvd2[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_SET(r,d) (r).sc_x4_fi_sp3_rslvd2[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_GET(r) (r).sc_x4_fi_sp3_rslvd2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_CLOCKCNT1f_GET(r) (((r).sc_x4_fi_sp3_rslvd2[0]) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_CLOCKCNT1f_SET(r,f) (r).sc_x4_fi_sp3_rslvd2[0]=(((r).sc_x4_fi_sp3_rslvd2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD2.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r,(_r._sc_x4_fi_sp3_rslvd2))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r,(_r._sc_x4_fi_sp3_rslvd2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r,(_r._sc_x4_fi_sp3_rslvd2))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd2))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd2))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD2r BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r
#define SC_X4_FI_SP3_RSLVD2r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_t SC_X4_FI_SP3_RSLVD2r_t;
#define SC_X4_FI_SP3_RSLVD2r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_CLR
#define SC_X4_FI_SP3_RSLVD2r_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_SET
#define SC_X4_FI_SP3_RSLVD2r_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_GET
#define SC_X4_FI_SP3_RSLVD2r_CLOCKCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_CLOCKCNT1f_GET
#define SC_X4_FI_SP3_RSLVD2r_CLOCKCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r_CLOCKCNT1f_SET
#define READ_SC_X4_FI_SP3_RSLVD2r BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD2r
#define WRITE_SC_X4_FI_SP3_RSLVD2r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD2r
#define MODIFY_SC_X4_FI_SP3_RSLVD2r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD2r
#define READLN_SC_X4_FI_SP3_RSLVD2r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD2r
#define WRITELN_SC_X4_FI_SP3_RSLVD2r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD2r
#define WRITEALL_SC_X4_FI_SP3_RSLVD2r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD3
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc074
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r (0x0000c074 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD3.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd3[1];
	uint32_t _sc_x4_fi_sp3_rslvd3;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_CLR(r) (r).sc_x4_fi_sp3_rslvd3[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_SET(r,d) (r).sc_x4_fi_sp3_rslvd3[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_GET(r) (r).sc_x4_fi_sp3_rslvd3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT0f_GET(r) ((((r).sc_x4_fi_sp3_rslvd3[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT0f_SET(r,f) (r).sc_x4_fi_sp3_rslvd3[0]=(((r).sc_x4_fi_sp3_rslvd3[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT1f_GET(r) (((r).sc_x4_fi_sp3_rslvd3[0]) & 0x3f)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT1f_SET(r,f) (r).sc_x4_fi_sp3_rslvd3[0]=(((r).sc_x4_fi_sp3_rslvd3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD3.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r,(_r._sc_x4_fi_sp3_rslvd3))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r,(_r._sc_x4_fi_sp3_rslvd3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r,(_r._sc_x4_fi_sp3_rslvd3))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd3))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd3))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD3r BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r
#define SC_X4_FI_SP3_RSLVD3r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_t SC_X4_FI_SP3_RSLVD3r_t;
#define SC_X4_FI_SP3_RSLVD3r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_CLR
#define SC_X4_FI_SP3_RSLVD3r_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_SET
#define SC_X4_FI_SP3_RSLVD3r_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_GET
#define SC_X4_FI_SP3_RSLVD3r_LOOPCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT0f_GET
#define SC_X4_FI_SP3_RSLVD3r_LOOPCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT0f_SET
#define SC_X4_FI_SP3_RSLVD3r_LOOPCNT1f_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT1f_GET
#define SC_X4_FI_SP3_RSLVD3r_LOOPCNT1f_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r_LOOPCNT1f_SET
#define READ_SC_X4_FI_SP3_RSLVD3r BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD3r
#define WRITE_SC_X4_FI_SP3_RSLVD3r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD3r
#define MODIFY_SC_X4_FI_SP3_RSLVD3r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD3r
#define READLN_SC_X4_FI_SP3_RSLVD3r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD3r
#define WRITELN_SC_X4_FI_SP3_RSLVD3r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD3r
#define WRITEALL_SC_X4_FI_SP3_RSLVD3r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD4
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc075
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r (0x0000c075 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD4.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd4[1];
	uint32_t _sc_x4_fi_sp3_rslvd4;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_CLR(r) (r).sc_x4_fi_sp3_rslvd4[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_SET(r,d) (r).sc_x4_fi_sp3_rslvd4[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_GET(r) (r).sc_x4_fi_sp3_rslvd4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp3_rslvd4[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp3_rslvd4[0]=(((r).sc_x4_fi_sp3_rslvd4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD4.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r,(_r._sc_x4_fi_sp3_rslvd4))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r,(_r._sc_x4_fi_sp3_rslvd4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r,(_r._sc_x4_fi_sp3_rslvd4))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd4))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd4))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD4r BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r
#define SC_X4_FI_SP3_RSLVD4r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_t SC_X4_FI_SP3_RSLVD4r_t;
#define SC_X4_FI_SP3_RSLVD4r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_CLR
#define SC_X4_FI_SP3_RSLVD4r_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_SET
#define SC_X4_FI_SP3_RSLVD4r_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_GET
#define SC_X4_FI_SP3_RSLVD4r_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_MAC_CREDITGENCNTf_GET
#define SC_X4_FI_SP3_RSLVD4r_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r_MAC_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP3_RSLVD4r BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD4r
#define WRITE_SC_X4_FI_SP3_RSLVD4r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD4r
#define MODIFY_SC_X4_FI_SP3_RSLVD4r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD4r
#define READLN_SC_X4_FI_SP3_RSLVD4r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD4r
#define WRITELN_SC_X4_FI_SP3_RSLVD4r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD4r
#define WRITEALL_SC_X4_FI_SP3_RSLVD4r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD5
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc076
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r (0x0000c076 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD5.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd5[1];
	uint32_t _sc_x4_fi_sp3_rslvd5;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_CLR(r) (r).sc_x4_fi_sp3_rslvd5[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_SET(r,d) (r).sc_x4_fi_sp3_rslvd5[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_GET(r) (r).sc_x4_fi_sp3_rslvd5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_REPLICATION_CNTf_GET(r) ((((r).sc_x4_fi_sp3_rslvd5[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_REPLICATION_CNTf_SET(r,f) (r).sc_x4_fi_sp3_rslvd5[0]=(((r).sc_x4_fi_sp3_rslvd5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x4_fi_sp3_rslvd5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x4_fi_sp3_rslvd5[0]=(((r).sc_x4_fi_sp3_rslvd5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x4_fi_sp3_rslvd5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x4_fi_sp3_rslvd5[0]=(((r).sc_x4_fi_sp3_rslvd5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD5.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r,(_r._sc_x4_fi_sp3_rslvd5))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r,(_r._sc_x4_fi_sp3_rslvd5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r,(_r._sc_x4_fi_sp3_rslvd5))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd5))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd5))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD5r BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r
#define SC_X4_FI_SP3_RSLVD5r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_t SC_X4_FI_SP3_RSLVD5r_t;
#define SC_X4_FI_SP3_RSLVD5r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_CLR
#define SC_X4_FI_SP3_RSLVD5r_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_SET
#define SC_X4_FI_SP3_RSLVD5r_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_GET
#define SC_X4_FI_SP3_RSLVD5r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_REPLICATION_CNTf_GET
#define SC_X4_FI_SP3_RSLVD5r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_REPLICATION_CNTf_SET
#define SC_X4_FI_SP3_RSLVD5r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CREDITENABLEf_GET
#define SC_X4_FI_SP3_RSLVD5r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CREDITENABLEf_SET
#define SC_X4_FI_SP3_RSLVD5r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CLOCKCNT0f_GET
#define SC_X4_FI_SP3_RSLVD5r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r_PCS_CLOCKCNT0f_SET
#define READ_SC_X4_FI_SP3_RSLVD5r BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD5r
#define WRITE_SC_X4_FI_SP3_RSLVD5r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD5r
#define MODIFY_SC_X4_FI_SP3_RSLVD5r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD5r
#define READLN_SC_X4_FI_SP3_RSLVD5r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD5r
#define WRITELN_SC_X4_FI_SP3_RSLVD5r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD5r
#define WRITEALL_SC_X4_FI_SP3_RSLVD5r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SC_X4_FI_SP3_RSLVD6
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS_SP3
 * REGADDR:  0xc077
 * DESC:     Final speed configuration for PCS
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r (0x0000c077 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FI_SP3_RSLVD6.
 */
typedef union BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_s {
	uint32_t v[1];
	uint32_t sc_x4_fi_sp3_rslvd6[1];
	uint32_t _sc_x4_fi_sp3_rslvd6;
} BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_t;

#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_CLR(r) (r).sc_x4_fi_sp3_rslvd6[0] = 0
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_SET(r,d) (r).sc_x4_fi_sp3_rslvd6[0] = d
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_GET(r) (r).sc_x4_fi_sp3_rslvd6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x4_fi_sp3_rslvd6[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x4_fi_sp3_rslvd6[0]=(((r).sc_x4_fi_sp3_rslvd6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SC_X4_FI_SP3_RSLVD6.
 */
#define BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r,(_r._sc_x4_fi_sp3_rslvd6))
#define BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r,(_r._sc_x4_fi_sp3_rslvd6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r,(_r._sc_x4_fi_sp3_rslvd6))
#define BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd6))
#define BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fi_sp3_rslvd6))
#define BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fi_sp3_rslvd6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FI_SP3_RSLVD6r BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r
#define SC_X4_FI_SP3_RSLVD6r_SIZE BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_SIZE
typedef BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_t SC_X4_FI_SP3_RSLVD6r_t;
#define SC_X4_FI_SP3_RSLVD6r_CLR BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_CLR
#define SC_X4_FI_SP3_RSLVD6r_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_SET
#define SC_X4_FI_SP3_RSLVD6r_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_GET
#define SC_X4_FI_SP3_RSLVD6r_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_PCS_CREDITGENCNTf_GET
#define SC_X4_FI_SP3_RSLVD6r_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r_PCS_CREDITGENCNTf_SET
#define READ_SC_X4_FI_SP3_RSLVD6r BCMI_QTC_XGXS_READ_SC_X4_FI_SP3_RSLVD6r
#define WRITE_SC_X4_FI_SP3_RSLVD6r BCMI_QTC_XGXS_WRITE_SC_X4_FI_SP3_RSLVD6r
#define MODIFY_SC_X4_FI_SP3_RSLVD6r BCMI_QTC_XGXS_MODIFY_SC_X4_FI_SP3_RSLVD6r
#define READLN_SC_X4_FI_SP3_RSLVD6r BCMI_QTC_XGXS_READLN_SC_X4_FI_SP3_RSLVD6r
#define WRITELN_SC_X4_FI_SP3_RSLVD6r BCMI_QTC_XGXS_WRITELN_SC_X4_FI_SP3_RSLVD6r
#define WRITEALL_SC_X4_FI_SP3_RSLVD6r BCMI_QTC_XGXS_WRITEALL_SC_X4_FI_SP3_RSLVD6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SC_X4_FI_SP3_RSLVD6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP0_CRED0
 * BLOCKS:   TX_X4_CREDIT_SP0
 * REGADDR:  0xc100
 * DESC:     clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     CREDITENABLE     Enables credits to be generated for the MAC.
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r (0x0000c100 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP0_CRED0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp0_cred0[1];
	uint32_t _tx_x4_sp0_cred0;
} BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CLR(r) (r).tx_x4_sp0_cred0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SET(r,d) (r).tx_x4_sp0_cred0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_GET(r) (r).tx_x4_sp0_cred0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SGMII_SPD_SWITCHf_GET(r) ((((r).tx_x4_sp0_cred0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SGMII_SPD_SWITCHf_SET(r,f) (r).tx_x4_sp0_cred0[0]=(((r).tx_x4_sp0_cred0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CREDITENABLEf_GET(r) ((((r).tx_x4_sp0_cred0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CREDITENABLEf_SET(r,f) (r).tx_x4_sp0_cred0[0]=(((r).tx_x4_sp0_cred0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CLOCKCNT0f_GET(r) (((r).tx_x4_sp0_cred0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp0_cred0[0]=(((r).tx_x4_sp0_cred0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP0_CRED0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP0_CRED0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED0r,(_r._tx_x4_sp0_cred0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP0_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED0r,(_r._tx_x4_sp0_cred0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED0r,(_r._tx_x4_sp0_cred0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP0_CRED0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_cred0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_CRED0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_cred0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp0_cred0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP0_CRED0r BCMI_QTC_XGXS_TX_X4_SP0_CRED0r
#define TX_X4_SP0_CRED0r_SIZE BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_t TX_X4_SP0_CRED0r_t;
#define TX_X4_SP0_CRED0r_CLR BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CLR
#define TX_X4_SP0_CRED0r_SET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SET
#define TX_X4_SP0_CRED0r_GET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_GET
#define TX_X4_SP0_CRED0r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SGMII_SPD_SWITCHf_GET
#define TX_X4_SP0_CRED0r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_SGMII_SPD_SWITCHf_SET
#define TX_X4_SP0_CRED0r_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CREDITENABLEf_GET
#define TX_X4_SP0_CRED0r_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CREDITENABLEf_SET
#define TX_X4_SP0_CRED0r_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CLOCKCNT0f_GET
#define TX_X4_SP0_CRED0r_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP0_CRED0r_CLOCKCNT0f_SET
#define READ_TX_X4_SP0_CRED0r BCMI_QTC_XGXS_READ_TX_X4_SP0_CRED0r
#define WRITE_TX_X4_SP0_CRED0r BCMI_QTC_XGXS_WRITE_TX_X4_SP0_CRED0r
#define MODIFY_TX_X4_SP0_CRED0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_CRED0r
#define READLN_TX_X4_SP0_CRED0r BCMI_QTC_XGXS_READLN_TX_X4_SP0_CRED0r
#define WRITELN_TX_X4_SP0_CRED0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_CRED0r
#define WRITEALL_TX_X4_SP0_CRED0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_CRED0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP0_CRED0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP0_CRED1
 * BLOCKS:   TX_X4_CREDIT_SP0
 * REGADDR:  0xc101
 * DESC:     clock count 1 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED1r (0x0000c101 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP0_CRED1.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp0_cred1[1];
	uint32_t _tx_x4_sp0_cred1;
} BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_t;

#define BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_CLR(r) (r).tx_x4_sp0_cred1[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_SET(r,d) (r).tx_x4_sp0_cred1[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_GET(r) (r).tx_x4_sp0_cred1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_CLOCKCNT1f_GET(r) (((r).tx_x4_sp0_cred1[0]) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_CLOCKCNT1f_SET(r,f) (r).tx_x4_sp0_cred1[0]=(((r).tx_x4_sp0_cred1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access TX_X4_SP0_CRED1.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP0_CRED1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED1r,(_r._tx_x4_sp0_cred1))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP0_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED1r,(_r._tx_x4_sp0_cred1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED1r,(_r._tx_x4_sp0_cred1))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP0_CRED1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_cred1))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_CRED1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_cred1))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp0_cred1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP0_CRED1r BCMI_QTC_XGXS_TX_X4_SP0_CRED1r
#define TX_X4_SP0_CRED1r_SIZE BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_t TX_X4_SP0_CRED1r_t;
#define TX_X4_SP0_CRED1r_CLR BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_CLR
#define TX_X4_SP0_CRED1r_SET BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_SET
#define TX_X4_SP0_CRED1r_GET BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_GET
#define TX_X4_SP0_CRED1r_CLOCKCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_CLOCKCNT1f_GET
#define TX_X4_SP0_CRED1r_CLOCKCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP0_CRED1r_CLOCKCNT1f_SET
#define READ_TX_X4_SP0_CRED1r BCMI_QTC_XGXS_READ_TX_X4_SP0_CRED1r
#define WRITE_TX_X4_SP0_CRED1r BCMI_QTC_XGXS_WRITE_TX_X4_SP0_CRED1r
#define MODIFY_TX_X4_SP0_CRED1r BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_CRED1r
#define READLN_TX_X4_SP0_CRED1r BCMI_QTC_XGXS_READLN_TX_X4_SP0_CRED1r
#define WRITELN_TX_X4_SP0_CRED1r BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_CRED1r
#define WRITEALL_TX_X4_SP0_CRED1r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_CRED1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP0_CRED1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP0_LOOPCNT
 * BLOCKS:   TX_X4_CREDIT_SP0
 * REGADDR:  0xc102
 * DESC:     loop count 1_0 register
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr (0x0000c102 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP0_LOOPCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp0_loopcnt[1];
	uint32_t _tx_x4_sp0_loopcnt;
} BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_CLR(r) (r).tx_x4_sp0_loopcnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_SET(r,d) (r).tx_x4_sp0_loopcnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_GET(r) (r).tx_x4_sp0_loopcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT0f_GET(r) ((((r).tx_x4_sp0_loopcnt[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT0f_SET(r,f) (r).tx_x4_sp0_loopcnt[0]=(((r).tx_x4_sp0_loopcnt[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT1f_GET(r) (((r).tx_x4_sp0_loopcnt[0]) & 0x3f)
#define BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT1f_SET(r,f) (r).tx_x4_sp0_loopcnt[0]=(((r).tx_x4_sp0_loopcnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access TX_X4_SP0_LOOPCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP0_LOOPCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr,(_r._tx_x4_sp0_loopcnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP0_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr,(_r._tx_x4_sp0_loopcnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr,(_r._tx_x4_sp0_loopcnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP0_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_loopcnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_loopcnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp0_loopcnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP0_LOOPCNTr BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr
#define TX_X4_SP0_LOOPCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_t TX_X4_SP0_LOOPCNTr_t;
#define TX_X4_SP0_LOOPCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_CLR
#define TX_X4_SP0_LOOPCNTr_SET BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_SET
#define TX_X4_SP0_LOOPCNTr_GET BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_GET
#define TX_X4_SP0_LOOPCNTr_LOOPCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT0f_GET
#define TX_X4_SP0_LOOPCNTr_LOOPCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT0f_SET
#define TX_X4_SP0_LOOPCNTr_LOOPCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT1f_GET
#define TX_X4_SP0_LOOPCNTr_LOOPCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr_LOOPCNT1f_SET
#define READ_TX_X4_SP0_LOOPCNTr BCMI_QTC_XGXS_READ_TX_X4_SP0_LOOPCNTr
#define WRITE_TX_X4_SP0_LOOPCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP0_LOOPCNTr
#define MODIFY_TX_X4_SP0_LOOPCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_LOOPCNTr
#define READLN_TX_X4_SP0_LOOPCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP0_LOOPCNTr
#define WRITELN_TX_X4_SP0_LOOPCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_LOOPCNTr
#define WRITEALL_TX_X4_SP0_LOOPCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_LOOPCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP0_LOOPCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP0_MAC_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP0
 * REGADDR:  0xc103
 * DESC:     credit gen count register
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr (0x0000c103 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP0_MAC_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp0_mac_credgencnt[1];
	uint32_t _tx_x4_sp0_mac_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_CLR(r) (r).tx_x4_sp0_mac_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_SET(r,d) (r).tx_x4_sp0_mac_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_GET(r) (r).tx_x4_sp0_mac_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET(r) (((r).tx_x4_sp0_mac_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp0_mac_credgencnt[0]=(((r).tx_x4_sp0_mac_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP0_MAC_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP0_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr,(_r._tx_x4_sp0_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP0_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr,(_r._tx_x4_sp0_mac_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr,(_r._tx_x4_sp0_mac_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP0_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp0_mac_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP0_MAC_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr
#define TX_X4_SP0_MAC_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_t TX_X4_SP0_MAC_CREDGENCNTr_t;
#define TX_X4_SP0_MAC_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_CLR
#define TX_X4_SP0_MAC_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_SET
#define TX_X4_SP0_MAC_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_GET
#define TX_X4_SP0_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET
#define TX_X4_SP0_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET
#define READ_TX_X4_SP0_MAC_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP0_MAC_CREDGENCNTr
#define WRITE_TX_X4_SP0_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP0_MAC_CREDGENCNTr
#define MODIFY_TX_X4_SP0_MAC_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_MAC_CREDGENCNTr
#define READLN_TX_X4_SP0_MAC_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP0_MAC_CREDGENCNTr
#define WRITELN_TX_X4_SP0_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_MAC_CREDGENCNTr
#define WRITEALL_TX_X4_SP0_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_MAC_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP0_MAC_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP0_PCS_CLKCNT0
 * BLOCKS:   TX_X4_CREDIT_SP0
 * REGADDR:  0xc104
 * DESC:     pcs clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r (0x0000c104 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP0_PCS_CLKCNT0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp0_pcs_clkcnt0[1];
	uint32_t _tx_x4_sp0_pcs_clkcnt0;
} BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_CLR(r) (r).tx_x4_sp0_pcs_clkcnt0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_SET(r,d) (r).tx_x4_sp0_pcs_clkcnt0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_GET(r) (r).tx_x4_sp0_pcs_clkcnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_REPLICATION_CNTf_GET(r) ((((r).tx_x4_sp0_pcs_clkcnt0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_REPLICATION_CNTf_SET(r,f) (r).tx_x4_sp0_pcs_clkcnt0[0]=(((r).tx_x4_sp0_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET(r) ((((r).tx_x4_sp0_pcs_clkcnt0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET(r,f) (r).tx_x4_sp0_pcs_clkcnt0[0]=(((r).tx_x4_sp0_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET(r) (((r).tx_x4_sp0_pcs_clkcnt0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp0_pcs_clkcnt0[0]=(((r).tx_x4_sp0_pcs_clkcnt0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP0_PCS_CLKCNT0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP0_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r,(_r._tx_x4_sp0_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP0_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r,(_r._tx_x4_sp0_pcs_clkcnt0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r,(_r._tx_x4_sp0_pcs_clkcnt0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP0_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp0_pcs_clkcnt0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP0_PCS_CLKCNT0r BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r
#define TX_X4_SP0_PCS_CLKCNT0r_SIZE BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_t TX_X4_SP0_PCS_CLKCNT0r_t;
#define TX_X4_SP0_PCS_CLKCNT0r_CLR BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_CLR
#define TX_X4_SP0_PCS_CLKCNT0r_SET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_SET
#define TX_X4_SP0_PCS_CLKCNT0r_GET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_GET
#define TX_X4_SP0_PCS_CLKCNT0r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_REPLICATION_CNTf_GET
#define TX_X4_SP0_PCS_CLKCNT0r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_REPLICATION_CNTf_SET
#define TX_X4_SP0_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET
#define TX_X4_SP0_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET
#define TX_X4_SP0_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET
#define TX_X4_SP0_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET
#define READ_TX_X4_SP0_PCS_CLKCNT0r BCMI_QTC_XGXS_READ_TX_X4_SP0_PCS_CLKCNT0r
#define WRITE_TX_X4_SP0_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITE_TX_X4_SP0_PCS_CLKCNT0r
#define MODIFY_TX_X4_SP0_PCS_CLKCNT0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_PCS_CLKCNT0r
#define READLN_TX_X4_SP0_PCS_CLKCNT0r BCMI_QTC_XGXS_READLN_TX_X4_SP0_PCS_CLKCNT0r
#define WRITELN_TX_X4_SP0_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_PCS_CLKCNT0r
#define WRITEALL_TX_X4_SP0_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_PCS_CLKCNT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP0_PCS_CLKCNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP0_PCS_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP0
 * REGADDR:  0xc105
 * DESC:     pcs credit gen count register
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT pcs clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr (0x0000c105 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP0_PCS_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp0_pcs_credgencnt[1];
	uint32_t _tx_x4_sp0_pcs_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_CLR(r) (r).tx_x4_sp0_pcs_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_SET(r,d) (r).tx_x4_sp0_pcs_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_GET(r) (r).tx_x4_sp0_pcs_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET(r) (((r).tx_x4_sp0_pcs_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp0_pcs_credgencnt[0]=(((r).tx_x4_sp0_pcs_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP0_PCS_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP0_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr,(_r._tx_x4_sp0_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP0_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr,(_r._tx_x4_sp0_pcs_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr,(_r._tx_x4_sp0_pcs_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP0_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp0_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp0_pcs_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP0_PCS_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr
#define TX_X4_SP0_PCS_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_t TX_X4_SP0_PCS_CREDGENCNTr_t;
#define TX_X4_SP0_PCS_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_CLR
#define TX_X4_SP0_PCS_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_SET
#define TX_X4_SP0_PCS_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_GET
#define TX_X4_SP0_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET
#define TX_X4_SP0_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET
#define READ_TX_X4_SP0_PCS_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP0_PCS_CREDGENCNTr
#define WRITE_TX_X4_SP0_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP0_PCS_CREDGENCNTr
#define MODIFY_TX_X4_SP0_PCS_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP0_PCS_CREDGENCNTr
#define READLN_TX_X4_SP0_PCS_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP0_PCS_CREDGENCNTr
#define WRITELN_TX_X4_SP0_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP0_PCS_CREDGENCNTr
#define WRITEALL_TX_X4_SP0_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP0_PCS_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP0_PCS_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP1_CRED0
 * BLOCKS:   TX_X4_CREDIT_SP1
 * REGADDR:  0xc110
 * DESC:     clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     CREDITENABLE     Enables credits to be generated for the MAC.
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r (0x0000c110 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP1_CRED0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp1_cred0[1];
	uint32_t _tx_x4_sp1_cred0;
} BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CLR(r) (r).tx_x4_sp1_cred0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SET(r,d) (r).tx_x4_sp1_cred0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_GET(r) (r).tx_x4_sp1_cred0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SGMII_SPD_SWITCHf_GET(r) ((((r).tx_x4_sp1_cred0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SGMII_SPD_SWITCHf_SET(r,f) (r).tx_x4_sp1_cred0[0]=(((r).tx_x4_sp1_cred0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CREDITENABLEf_GET(r) ((((r).tx_x4_sp1_cred0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CREDITENABLEf_SET(r,f) (r).tx_x4_sp1_cred0[0]=(((r).tx_x4_sp1_cred0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CLOCKCNT0f_GET(r) (((r).tx_x4_sp1_cred0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp1_cred0[0]=(((r).tx_x4_sp1_cred0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP1_CRED0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP1_CRED0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED0r,(_r._tx_x4_sp1_cred0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP1_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED0r,(_r._tx_x4_sp1_cred0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED0r,(_r._tx_x4_sp1_cred0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP1_CRED0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_cred0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_CRED0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_cred0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp1_cred0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP1_CRED0r BCMI_QTC_XGXS_TX_X4_SP1_CRED0r
#define TX_X4_SP1_CRED0r_SIZE BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_t TX_X4_SP1_CRED0r_t;
#define TX_X4_SP1_CRED0r_CLR BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CLR
#define TX_X4_SP1_CRED0r_SET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SET
#define TX_X4_SP1_CRED0r_GET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_GET
#define TX_X4_SP1_CRED0r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SGMII_SPD_SWITCHf_GET
#define TX_X4_SP1_CRED0r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_SGMII_SPD_SWITCHf_SET
#define TX_X4_SP1_CRED0r_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CREDITENABLEf_GET
#define TX_X4_SP1_CRED0r_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CREDITENABLEf_SET
#define TX_X4_SP1_CRED0r_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CLOCKCNT0f_GET
#define TX_X4_SP1_CRED0r_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP1_CRED0r_CLOCKCNT0f_SET
#define READ_TX_X4_SP1_CRED0r BCMI_QTC_XGXS_READ_TX_X4_SP1_CRED0r
#define WRITE_TX_X4_SP1_CRED0r BCMI_QTC_XGXS_WRITE_TX_X4_SP1_CRED0r
#define MODIFY_TX_X4_SP1_CRED0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_CRED0r
#define READLN_TX_X4_SP1_CRED0r BCMI_QTC_XGXS_READLN_TX_X4_SP1_CRED0r
#define WRITELN_TX_X4_SP1_CRED0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_CRED0r
#define WRITEALL_TX_X4_SP1_CRED0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_CRED0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP1_CRED0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP1_CRED1
 * BLOCKS:   TX_X4_CREDIT_SP1
 * REGADDR:  0xc111
 * DESC:     clock count 1 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED1r (0x0000c111 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP1_CRED1.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp1_cred1[1];
	uint32_t _tx_x4_sp1_cred1;
} BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_t;

#define BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_CLR(r) (r).tx_x4_sp1_cred1[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_SET(r,d) (r).tx_x4_sp1_cred1[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_GET(r) (r).tx_x4_sp1_cred1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_CLOCKCNT1f_GET(r) (((r).tx_x4_sp1_cred1[0]) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_CLOCKCNT1f_SET(r,f) (r).tx_x4_sp1_cred1[0]=(((r).tx_x4_sp1_cred1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access TX_X4_SP1_CRED1.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP1_CRED1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED1r,(_r._tx_x4_sp1_cred1))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP1_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED1r,(_r._tx_x4_sp1_cred1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED1r,(_r._tx_x4_sp1_cred1))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP1_CRED1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_cred1))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_CRED1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_cred1))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp1_cred1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP1_CRED1r BCMI_QTC_XGXS_TX_X4_SP1_CRED1r
#define TX_X4_SP1_CRED1r_SIZE BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_t TX_X4_SP1_CRED1r_t;
#define TX_X4_SP1_CRED1r_CLR BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_CLR
#define TX_X4_SP1_CRED1r_SET BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_SET
#define TX_X4_SP1_CRED1r_GET BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_GET
#define TX_X4_SP1_CRED1r_CLOCKCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_CLOCKCNT1f_GET
#define TX_X4_SP1_CRED1r_CLOCKCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP1_CRED1r_CLOCKCNT1f_SET
#define READ_TX_X4_SP1_CRED1r BCMI_QTC_XGXS_READ_TX_X4_SP1_CRED1r
#define WRITE_TX_X4_SP1_CRED1r BCMI_QTC_XGXS_WRITE_TX_X4_SP1_CRED1r
#define MODIFY_TX_X4_SP1_CRED1r BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_CRED1r
#define READLN_TX_X4_SP1_CRED1r BCMI_QTC_XGXS_READLN_TX_X4_SP1_CRED1r
#define WRITELN_TX_X4_SP1_CRED1r BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_CRED1r
#define WRITEALL_TX_X4_SP1_CRED1r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_CRED1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP1_CRED1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP1_LOOPCNT
 * BLOCKS:   TX_X4_CREDIT_SP1
 * REGADDR:  0xc112
 * DESC:     loop count 1_0 register
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr (0x0000c112 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP1_LOOPCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp1_loopcnt[1];
	uint32_t _tx_x4_sp1_loopcnt;
} BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_CLR(r) (r).tx_x4_sp1_loopcnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_SET(r,d) (r).tx_x4_sp1_loopcnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_GET(r) (r).tx_x4_sp1_loopcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT0f_GET(r) ((((r).tx_x4_sp1_loopcnt[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT0f_SET(r,f) (r).tx_x4_sp1_loopcnt[0]=(((r).tx_x4_sp1_loopcnt[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT1f_GET(r) (((r).tx_x4_sp1_loopcnt[0]) & 0x3f)
#define BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT1f_SET(r,f) (r).tx_x4_sp1_loopcnt[0]=(((r).tx_x4_sp1_loopcnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access TX_X4_SP1_LOOPCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP1_LOOPCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr,(_r._tx_x4_sp1_loopcnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP1_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr,(_r._tx_x4_sp1_loopcnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr,(_r._tx_x4_sp1_loopcnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP1_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_loopcnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_loopcnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp1_loopcnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP1_LOOPCNTr BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr
#define TX_X4_SP1_LOOPCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_t TX_X4_SP1_LOOPCNTr_t;
#define TX_X4_SP1_LOOPCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_CLR
#define TX_X4_SP1_LOOPCNTr_SET BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_SET
#define TX_X4_SP1_LOOPCNTr_GET BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_GET
#define TX_X4_SP1_LOOPCNTr_LOOPCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT0f_GET
#define TX_X4_SP1_LOOPCNTr_LOOPCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT0f_SET
#define TX_X4_SP1_LOOPCNTr_LOOPCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT1f_GET
#define TX_X4_SP1_LOOPCNTr_LOOPCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr_LOOPCNT1f_SET
#define READ_TX_X4_SP1_LOOPCNTr BCMI_QTC_XGXS_READ_TX_X4_SP1_LOOPCNTr
#define WRITE_TX_X4_SP1_LOOPCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP1_LOOPCNTr
#define MODIFY_TX_X4_SP1_LOOPCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_LOOPCNTr
#define READLN_TX_X4_SP1_LOOPCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP1_LOOPCNTr
#define WRITELN_TX_X4_SP1_LOOPCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_LOOPCNTr
#define WRITEALL_TX_X4_SP1_LOOPCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_LOOPCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP1_LOOPCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP1_MAC_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP1
 * REGADDR:  0xc113
 * DESC:     credit gen count register
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr (0x0000c113 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP1_MAC_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp1_mac_credgencnt[1];
	uint32_t _tx_x4_sp1_mac_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_CLR(r) (r).tx_x4_sp1_mac_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_SET(r,d) (r).tx_x4_sp1_mac_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_GET(r) (r).tx_x4_sp1_mac_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET(r) (((r).tx_x4_sp1_mac_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp1_mac_credgencnt[0]=(((r).tx_x4_sp1_mac_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP1_MAC_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP1_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr,(_r._tx_x4_sp1_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP1_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr,(_r._tx_x4_sp1_mac_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr,(_r._tx_x4_sp1_mac_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP1_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp1_mac_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP1_MAC_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr
#define TX_X4_SP1_MAC_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_t TX_X4_SP1_MAC_CREDGENCNTr_t;
#define TX_X4_SP1_MAC_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_CLR
#define TX_X4_SP1_MAC_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_SET
#define TX_X4_SP1_MAC_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_GET
#define TX_X4_SP1_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET
#define TX_X4_SP1_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET
#define READ_TX_X4_SP1_MAC_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP1_MAC_CREDGENCNTr
#define WRITE_TX_X4_SP1_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP1_MAC_CREDGENCNTr
#define MODIFY_TX_X4_SP1_MAC_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_MAC_CREDGENCNTr
#define READLN_TX_X4_SP1_MAC_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP1_MAC_CREDGENCNTr
#define WRITELN_TX_X4_SP1_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_MAC_CREDGENCNTr
#define WRITEALL_TX_X4_SP1_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_MAC_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP1_MAC_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP1_PCS_CLKCNT0
 * BLOCKS:   TX_X4_CREDIT_SP1
 * REGADDR:  0xc114
 * DESC:     pcs clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r (0x0000c114 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP1_PCS_CLKCNT0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp1_pcs_clkcnt0[1];
	uint32_t _tx_x4_sp1_pcs_clkcnt0;
} BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_CLR(r) (r).tx_x4_sp1_pcs_clkcnt0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_SET(r,d) (r).tx_x4_sp1_pcs_clkcnt0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_GET(r) (r).tx_x4_sp1_pcs_clkcnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_REPLICATION_CNTf_GET(r) ((((r).tx_x4_sp1_pcs_clkcnt0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_REPLICATION_CNTf_SET(r,f) (r).tx_x4_sp1_pcs_clkcnt0[0]=(((r).tx_x4_sp1_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET(r) ((((r).tx_x4_sp1_pcs_clkcnt0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET(r,f) (r).tx_x4_sp1_pcs_clkcnt0[0]=(((r).tx_x4_sp1_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET(r) (((r).tx_x4_sp1_pcs_clkcnt0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp1_pcs_clkcnt0[0]=(((r).tx_x4_sp1_pcs_clkcnt0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP1_PCS_CLKCNT0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP1_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r,(_r._tx_x4_sp1_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP1_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r,(_r._tx_x4_sp1_pcs_clkcnt0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r,(_r._tx_x4_sp1_pcs_clkcnt0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP1_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp1_pcs_clkcnt0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP1_PCS_CLKCNT0r BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r
#define TX_X4_SP1_PCS_CLKCNT0r_SIZE BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_t TX_X4_SP1_PCS_CLKCNT0r_t;
#define TX_X4_SP1_PCS_CLKCNT0r_CLR BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_CLR
#define TX_X4_SP1_PCS_CLKCNT0r_SET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_SET
#define TX_X4_SP1_PCS_CLKCNT0r_GET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_GET
#define TX_X4_SP1_PCS_CLKCNT0r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_REPLICATION_CNTf_GET
#define TX_X4_SP1_PCS_CLKCNT0r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_REPLICATION_CNTf_SET
#define TX_X4_SP1_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET
#define TX_X4_SP1_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET
#define TX_X4_SP1_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET
#define TX_X4_SP1_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET
#define READ_TX_X4_SP1_PCS_CLKCNT0r BCMI_QTC_XGXS_READ_TX_X4_SP1_PCS_CLKCNT0r
#define WRITE_TX_X4_SP1_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITE_TX_X4_SP1_PCS_CLKCNT0r
#define MODIFY_TX_X4_SP1_PCS_CLKCNT0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_PCS_CLKCNT0r
#define READLN_TX_X4_SP1_PCS_CLKCNT0r BCMI_QTC_XGXS_READLN_TX_X4_SP1_PCS_CLKCNT0r
#define WRITELN_TX_X4_SP1_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_PCS_CLKCNT0r
#define WRITEALL_TX_X4_SP1_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_PCS_CLKCNT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP1_PCS_CLKCNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP1_PCS_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP1
 * REGADDR:  0xc115
 * DESC:     pcs credit gen count register
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT pcs clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr (0x0000c115 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP1_PCS_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp1_pcs_credgencnt[1];
	uint32_t _tx_x4_sp1_pcs_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_CLR(r) (r).tx_x4_sp1_pcs_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_SET(r,d) (r).tx_x4_sp1_pcs_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_GET(r) (r).tx_x4_sp1_pcs_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET(r) (((r).tx_x4_sp1_pcs_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp1_pcs_credgencnt[0]=(((r).tx_x4_sp1_pcs_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP1_PCS_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP1_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr,(_r._tx_x4_sp1_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP1_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr,(_r._tx_x4_sp1_pcs_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr,(_r._tx_x4_sp1_pcs_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP1_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp1_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp1_pcs_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP1_PCS_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr
#define TX_X4_SP1_PCS_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_t TX_X4_SP1_PCS_CREDGENCNTr_t;
#define TX_X4_SP1_PCS_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_CLR
#define TX_X4_SP1_PCS_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_SET
#define TX_X4_SP1_PCS_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_GET
#define TX_X4_SP1_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET
#define TX_X4_SP1_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET
#define READ_TX_X4_SP1_PCS_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP1_PCS_CREDGENCNTr
#define WRITE_TX_X4_SP1_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP1_PCS_CREDGENCNTr
#define MODIFY_TX_X4_SP1_PCS_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP1_PCS_CREDGENCNTr
#define READLN_TX_X4_SP1_PCS_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP1_PCS_CREDGENCNTr
#define WRITELN_TX_X4_SP1_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP1_PCS_CREDGENCNTr
#define WRITEALL_TX_X4_SP1_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP1_PCS_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP1_PCS_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP2_CRED0
 * BLOCKS:   TX_X4_CREDIT_SP2
 * REGADDR:  0xc120
 * DESC:     clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     CREDITENABLE     Enables credits to be generated for the MAC.
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r (0x0000c120 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP2_CRED0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp2_cred0[1];
	uint32_t _tx_x4_sp2_cred0;
} BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CLR(r) (r).tx_x4_sp2_cred0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SET(r,d) (r).tx_x4_sp2_cred0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_GET(r) (r).tx_x4_sp2_cred0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SGMII_SPD_SWITCHf_GET(r) ((((r).tx_x4_sp2_cred0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SGMII_SPD_SWITCHf_SET(r,f) (r).tx_x4_sp2_cred0[0]=(((r).tx_x4_sp2_cred0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CREDITENABLEf_GET(r) ((((r).tx_x4_sp2_cred0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CREDITENABLEf_SET(r,f) (r).tx_x4_sp2_cred0[0]=(((r).tx_x4_sp2_cred0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CLOCKCNT0f_GET(r) (((r).tx_x4_sp2_cred0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp2_cred0[0]=(((r).tx_x4_sp2_cred0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP2_CRED0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP2_CRED0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED0r,(_r._tx_x4_sp2_cred0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP2_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED0r,(_r._tx_x4_sp2_cred0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED0r,(_r._tx_x4_sp2_cred0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP2_CRED0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_cred0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_CRED0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_cred0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp2_cred0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP2_CRED0r BCMI_QTC_XGXS_TX_X4_SP2_CRED0r
#define TX_X4_SP2_CRED0r_SIZE BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_t TX_X4_SP2_CRED0r_t;
#define TX_X4_SP2_CRED0r_CLR BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CLR
#define TX_X4_SP2_CRED0r_SET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SET
#define TX_X4_SP2_CRED0r_GET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_GET
#define TX_X4_SP2_CRED0r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SGMII_SPD_SWITCHf_GET
#define TX_X4_SP2_CRED0r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_SGMII_SPD_SWITCHf_SET
#define TX_X4_SP2_CRED0r_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CREDITENABLEf_GET
#define TX_X4_SP2_CRED0r_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CREDITENABLEf_SET
#define TX_X4_SP2_CRED0r_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CLOCKCNT0f_GET
#define TX_X4_SP2_CRED0r_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP2_CRED0r_CLOCKCNT0f_SET
#define READ_TX_X4_SP2_CRED0r BCMI_QTC_XGXS_READ_TX_X4_SP2_CRED0r
#define WRITE_TX_X4_SP2_CRED0r BCMI_QTC_XGXS_WRITE_TX_X4_SP2_CRED0r
#define MODIFY_TX_X4_SP2_CRED0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_CRED0r
#define READLN_TX_X4_SP2_CRED0r BCMI_QTC_XGXS_READLN_TX_X4_SP2_CRED0r
#define WRITELN_TX_X4_SP2_CRED0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_CRED0r
#define WRITEALL_TX_X4_SP2_CRED0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_CRED0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP2_CRED0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP2_CRED1
 * BLOCKS:   TX_X4_CREDIT_SP2
 * REGADDR:  0xc121
 * DESC:     clock count 1 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED1r (0x0000c121 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP2_CRED1.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp2_cred1[1];
	uint32_t _tx_x4_sp2_cred1;
} BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_t;

#define BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_CLR(r) (r).tx_x4_sp2_cred1[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_SET(r,d) (r).tx_x4_sp2_cred1[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_GET(r) (r).tx_x4_sp2_cred1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_CLOCKCNT1f_GET(r) (((r).tx_x4_sp2_cred1[0]) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_CLOCKCNT1f_SET(r,f) (r).tx_x4_sp2_cred1[0]=(((r).tx_x4_sp2_cred1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access TX_X4_SP2_CRED1.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP2_CRED1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED1r,(_r._tx_x4_sp2_cred1))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP2_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED1r,(_r._tx_x4_sp2_cred1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED1r,(_r._tx_x4_sp2_cred1))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP2_CRED1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_cred1))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_CRED1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_cred1))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp2_cred1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP2_CRED1r BCMI_QTC_XGXS_TX_X4_SP2_CRED1r
#define TX_X4_SP2_CRED1r_SIZE BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_t TX_X4_SP2_CRED1r_t;
#define TX_X4_SP2_CRED1r_CLR BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_CLR
#define TX_X4_SP2_CRED1r_SET BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_SET
#define TX_X4_SP2_CRED1r_GET BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_GET
#define TX_X4_SP2_CRED1r_CLOCKCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_CLOCKCNT1f_GET
#define TX_X4_SP2_CRED1r_CLOCKCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP2_CRED1r_CLOCKCNT1f_SET
#define READ_TX_X4_SP2_CRED1r BCMI_QTC_XGXS_READ_TX_X4_SP2_CRED1r
#define WRITE_TX_X4_SP2_CRED1r BCMI_QTC_XGXS_WRITE_TX_X4_SP2_CRED1r
#define MODIFY_TX_X4_SP2_CRED1r BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_CRED1r
#define READLN_TX_X4_SP2_CRED1r BCMI_QTC_XGXS_READLN_TX_X4_SP2_CRED1r
#define WRITELN_TX_X4_SP2_CRED1r BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_CRED1r
#define WRITEALL_TX_X4_SP2_CRED1r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_CRED1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP2_CRED1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP2_LOOPCNT
 * BLOCKS:   TX_X4_CREDIT_SP2
 * REGADDR:  0xc122
 * DESC:     loop count 1_0 register
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr (0x0000c122 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP2_LOOPCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp2_loopcnt[1];
	uint32_t _tx_x4_sp2_loopcnt;
} BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_CLR(r) (r).tx_x4_sp2_loopcnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_SET(r,d) (r).tx_x4_sp2_loopcnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_GET(r) (r).tx_x4_sp2_loopcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT0f_GET(r) ((((r).tx_x4_sp2_loopcnt[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT0f_SET(r,f) (r).tx_x4_sp2_loopcnt[0]=(((r).tx_x4_sp2_loopcnt[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT1f_GET(r) (((r).tx_x4_sp2_loopcnt[0]) & 0x3f)
#define BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT1f_SET(r,f) (r).tx_x4_sp2_loopcnt[0]=(((r).tx_x4_sp2_loopcnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access TX_X4_SP2_LOOPCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP2_LOOPCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr,(_r._tx_x4_sp2_loopcnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP2_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr,(_r._tx_x4_sp2_loopcnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr,(_r._tx_x4_sp2_loopcnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP2_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_loopcnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_loopcnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp2_loopcnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP2_LOOPCNTr BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr
#define TX_X4_SP2_LOOPCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_t TX_X4_SP2_LOOPCNTr_t;
#define TX_X4_SP2_LOOPCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_CLR
#define TX_X4_SP2_LOOPCNTr_SET BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_SET
#define TX_X4_SP2_LOOPCNTr_GET BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_GET
#define TX_X4_SP2_LOOPCNTr_LOOPCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT0f_GET
#define TX_X4_SP2_LOOPCNTr_LOOPCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT0f_SET
#define TX_X4_SP2_LOOPCNTr_LOOPCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT1f_GET
#define TX_X4_SP2_LOOPCNTr_LOOPCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr_LOOPCNT1f_SET
#define READ_TX_X4_SP2_LOOPCNTr BCMI_QTC_XGXS_READ_TX_X4_SP2_LOOPCNTr
#define WRITE_TX_X4_SP2_LOOPCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP2_LOOPCNTr
#define MODIFY_TX_X4_SP2_LOOPCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_LOOPCNTr
#define READLN_TX_X4_SP2_LOOPCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP2_LOOPCNTr
#define WRITELN_TX_X4_SP2_LOOPCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_LOOPCNTr
#define WRITEALL_TX_X4_SP2_LOOPCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_LOOPCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP2_LOOPCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP2_MAC_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP2
 * REGADDR:  0xc123
 * DESC:     credit gen count register
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr (0x0000c123 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP2_MAC_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp2_mac_credgencnt[1];
	uint32_t _tx_x4_sp2_mac_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_CLR(r) (r).tx_x4_sp2_mac_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_SET(r,d) (r).tx_x4_sp2_mac_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_GET(r) (r).tx_x4_sp2_mac_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET(r) (((r).tx_x4_sp2_mac_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp2_mac_credgencnt[0]=(((r).tx_x4_sp2_mac_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP2_MAC_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP2_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr,(_r._tx_x4_sp2_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP2_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr,(_r._tx_x4_sp2_mac_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr,(_r._tx_x4_sp2_mac_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP2_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp2_mac_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP2_MAC_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr
#define TX_X4_SP2_MAC_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_t TX_X4_SP2_MAC_CREDGENCNTr_t;
#define TX_X4_SP2_MAC_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_CLR
#define TX_X4_SP2_MAC_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_SET
#define TX_X4_SP2_MAC_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_GET
#define TX_X4_SP2_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET
#define TX_X4_SP2_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET
#define READ_TX_X4_SP2_MAC_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP2_MAC_CREDGENCNTr
#define WRITE_TX_X4_SP2_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP2_MAC_CREDGENCNTr
#define MODIFY_TX_X4_SP2_MAC_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_MAC_CREDGENCNTr
#define READLN_TX_X4_SP2_MAC_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP2_MAC_CREDGENCNTr
#define WRITELN_TX_X4_SP2_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_MAC_CREDGENCNTr
#define WRITEALL_TX_X4_SP2_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_MAC_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP2_MAC_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP2_PCS_CLKCNT0
 * BLOCKS:   TX_X4_CREDIT_SP2
 * REGADDR:  0xc124
 * DESC:     pcs clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r (0x0000c124 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP2_PCS_CLKCNT0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp2_pcs_clkcnt0[1];
	uint32_t _tx_x4_sp2_pcs_clkcnt0;
} BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_CLR(r) (r).tx_x4_sp2_pcs_clkcnt0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_SET(r,d) (r).tx_x4_sp2_pcs_clkcnt0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_GET(r) (r).tx_x4_sp2_pcs_clkcnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_REPLICATION_CNTf_GET(r) ((((r).tx_x4_sp2_pcs_clkcnt0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_REPLICATION_CNTf_SET(r,f) (r).tx_x4_sp2_pcs_clkcnt0[0]=(((r).tx_x4_sp2_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET(r) ((((r).tx_x4_sp2_pcs_clkcnt0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET(r,f) (r).tx_x4_sp2_pcs_clkcnt0[0]=(((r).tx_x4_sp2_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET(r) (((r).tx_x4_sp2_pcs_clkcnt0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp2_pcs_clkcnt0[0]=(((r).tx_x4_sp2_pcs_clkcnt0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP2_PCS_CLKCNT0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP2_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r,(_r._tx_x4_sp2_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP2_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r,(_r._tx_x4_sp2_pcs_clkcnt0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r,(_r._tx_x4_sp2_pcs_clkcnt0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP2_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp2_pcs_clkcnt0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP2_PCS_CLKCNT0r BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r
#define TX_X4_SP2_PCS_CLKCNT0r_SIZE BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_t TX_X4_SP2_PCS_CLKCNT0r_t;
#define TX_X4_SP2_PCS_CLKCNT0r_CLR BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_CLR
#define TX_X4_SP2_PCS_CLKCNT0r_SET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_SET
#define TX_X4_SP2_PCS_CLKCNT0r_GET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_GET
#define TX_X4_SP2_PCS_CLKCNT0r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_REPLICATION_CNTf_GET
#define TX_X4_SP2_PCS_CLKCNT0r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_REPLICATION_CNTf_SET
#define TX_X4_SP2_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET
#define TX_X4_SP2_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET
#define TX_X4_SP2_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET
#define TX_X4_SP2_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET
#define READ_TX_X4_SP2_PCS_CLKCNT0r BCMI_QTC_XGXS_READ_TX_X4_SP2_PCS_CLKCNT0r
#define WRITE_TX_X4_SP2_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITE_TX_X4_SP2_PCS_CLKCNT0r
#define MODIFY_TX_X4_SP2_PCS_CLKCNT0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_PCS_CLKCNT0r
#define READLN_TX_X4_SP2_PCS_CLKCNT0r BCMI_QTC_XGXS_READLN_TX_X4_SP2_PCS_CLKCNT0r
#define WRITELN_TX_X4_SP2_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_PCS_CLKCNT0r
#define WRITEALL_TX_X4_SP2_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_PCS_CLKCNT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP2_PCS_CLKCNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP2_PCS_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP2
 * REGADDR:  0xc125
 * DESC:     pcs credit gen count register
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT pcs clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr (0x0000c125 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP2_PCS_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp2_pcs_credgencnt[1];
	uint32_t _tx_x4_sp2_pcs_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_CLR(r) (r).tx_x4_sp2_pcs_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_SET(r,d) (r).tx_x4_sp2_pcs_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_GET(r) (r).tx_x4_sp2_pcs_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET(r) (((r).tx_x4_sp2_pcs_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp2_pcs_credgencnt[0]=(((r).tx_x4_sp2_pcs_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP2_PCS_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP2_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr,(_r._tx_x4_sp2_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP2_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr,(_r._tx_x4_sp2_pcs_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr,(_r._tx_x4_sp2_pcs_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP2_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp2_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp2_pcs_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP2_PCS_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr
#define TX_X4_SP2_PCS_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_t TX_X4_SP2_PCS_CREDGENCNTr_t;
#define TX_X4_SP2_PCS_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_CLR
#define TX_X4_SP2_PCS_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_SET
#define TX_X4_SP2_PCS_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_GET
#define TX_X4_SP2_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET
#define TX_X4_SP2_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET
#define READ_TX_X4_SP2_PCS_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP2_PCS_CREDGENCNTr
#define WRITE_TX_X4_SP2_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP2_PCS_CREDGENCNTr
#define MODIFY_TX_X4_SP2_PCS_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP2_PCS_CREDGENCNTr
#define READLN_TX_X4_SP2_PCS_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP2_PCS_CREDGENCNTr
#define WRITELN_TX_X4_SP2_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP2_PCS_CREDGENCNTr
#define WRITEALL_TX_X4_SP2_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP2_PCS_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP2_PCS_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP3_CRED0
 * BLOCKS:   TX_X4_CREDIT_SP3
 * REGADDR:  0xc130
 * DESC:     clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     CREDITENABLE     Enables credits to be generated for the MAC.
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r (0x0000c130 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP3_CRED0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp3_cred0[1];
	uint32_t _tx_x4_sp3_cred0;
} BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CLR(r) (r).tx_x4_sp3_cred0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SET(r,d) (r).tx_x4_sp3_cred0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_GET(r) (r).tx_x4_sp3_cred0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SGMII_SPD_SWITCHf_GET(r) ((((r).tx_x4_sp3_cred0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SGMII_SPD_SWITCHf_SET(r,f) (r).tx_x4_sp3_cred0[0]=(((r).tx_x4_sp3_cred0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CREDITENABLEf_GET(r) ((((r).tx_x4_sp3_cred0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CREDITENABLEf_SET(r,f) (r).tx_x4_sp3_cred0[0]=(((r).tx_x4_sp3_cred0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CLOCKCNT0f_GET(r) (((r).tx_x4_sp3_cred0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp3_cred0[0]=(((r).tx_x4_sp3_cred0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP3_CRED0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP3_CRED0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED0r,(_r._tx_x4_sp3_cred0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP3_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED0r,(_r._tx_x4_sp3_cred0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED0r,(_r._tx_x4_sp3_cred0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP3_CRED0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_cred0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_CRED0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_cred0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_CRED0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp3_cred0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP3_CRED0r BCMI_QTC_XGXS_TX_X4_SP3_CRED0r
#define TX_X4_SP3_CRED0r_SIZE BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_t TX_X4_SP3_CRED0r_t;
#define TX_X4_SP3_CRED0r_CLR BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CLR
#define TX_X4_SP3_CRED0r_SET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SET
#define TX_X4_SP3_CRED0r_GET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_GET
#define TX_X4_SP3_CRED0r_SGMII_SPD_SWITCHf_GET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SGMII_SPD_SWITCHf_GET
#define TX_X4_SP3_CRED0r_SGMII_SPD_SWITCHf_SET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_SGMII_SPD_SWITCHf_SET
#define TX_X4_SP3_CRED0r_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CREDITENABLEf_GET
#define TX_X4_SP3_CRED0r_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CREDITENABLEf_SET
#define TX_X4_SP3_CRED0r_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CLOCKCNT0f_GET
#define TX_X4_SP3_CRED0r_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP3_CRED0r_CLOCKCNT0f_SET
#define READ_TX_X4_SP3_CRED0r BCMI_QTC_XGXS_READ_TX_X4_SP3_CRED0r
#define WRITE_TX_X4_SP3_CRED0r BCMI_QTC_XGXS_WRITE_TX_X4_SP3_CRED0r
#define MODIFY_TX_X4_SP3_CRED0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_CRED0r
#define READLN_TX_X4_SP3_CRED0r BCMI_QTC_XGXS_READLN_TX_X4_SP3_CRED0r
#define WRITELN_TX_X4_SP3_CRED0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_CRED0r
#define WRITEALL_TX_X4_SP3_CRED0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_CRED0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP3_CRED0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP3_CRED1
 * BLOCKS:   TX_X4_CREDIT_SP3
 * REGADDR:  0xc131
 * DESC:     clock count 1 register
 * SIZE:     32
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED1r (0x0000c131 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP3_CRED1.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp3_cred1[1];
	uint32_t _tx_x4_sp3_cred1;
} BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_t;

#define BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_CLR(r) (r).tx_x4_sp3_cred1[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_SET(r,d) (r).tx_x4_sp3_cred1[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_GET(r) (r).tx_x4_sp3_cred1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_CLOCKCNT1f_GET(r) (((r).tx_x4_sp3_cred1[0]) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_CLOCKCNT1f_SET(r,f) (r).tx_x4_sp3_cred1[0]=(((r).tx_x4_sp3_cred1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access TX_X4_SP3_CRED1.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP3_CRED1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED1r,(_r._tx_x4_sp3_cred1))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP3_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED1r,(_r._tx_x4_sp3_cred1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED1r,(_r._tx_x4_sp3_cred1))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP3_CRED1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_cred1))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_CRED1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_cred1))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_CRED1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp3_cred1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP3_CRED1r BCMI_QTC_XGXS_TX_X4_SP3_CRED1r
#define TX_X4_SP3_CRED1r_SIZE BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_t TX_X4_SP3_CRED1r_t;
#define TX_X4_SP3_CRED1r_CLR BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_CLR
#define TX_X4_SP3_CRED1r_SET BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_SET
#define TX_X4_SP3_CRED1r_GET BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_GET
#define TX_X4_SP3_CRED1r_CLOCKCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_CLOCKCNT1f_GET
#define TX_X4_SP3_CRED1r_CLOCKCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP3_CRED1r_CLOCKCNT1f_SET
#define READ_TX_X4_SP3_CRED1r BCMI_QTC_XGXS_READ_TX_X4_SP3_CRED1r
#define WRITE_TX_X4_SP3_CRED1r BCMI_QTC_XGXS_WRITE_TX_X4_SP3_CRED1r
#define MODIFY_TX_X4_SP3_CRED1r BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_CRED1r
#define READLN_TX_X4_SP3_CRED1r BCMI_QTC_XGXS_READLN_TX_X4_SP3_CRED1r
#define WRITELN_TX_X4_SP3_CRED1r BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_CRED1r
#define WRITEALL_TX_X4_SP3_CRED1r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_CRED1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP3_CRED1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP3_LOOPCNT
 * BLOCKS:   TX_X4_CREDIT_SP3
 * REGADDR:  0xc132
 * DESC:     loop count 1_0 register
 * SIZE:     32
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr (0x0000c132 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP3_LOOPCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp3_loopcnt[1];
	uint32_t _tx_x4_sp3_loopcnt;
} BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_CLR(r) (r).tx_x4_sp3_loopcnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_SET(r,d) (r).tx_x4_sp3_loopcnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_GET(r) (r).tx_x4_sp3_loopcnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT0f_GET(r) ((((r).tx_x4_sp3_loopcnt[0]) >> 6) & 0xff)
#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT0f_SET(r,f) (r).tx_x4_sp3_loopcnt[0]=(((r).tx_x4_sp3_loopcnt[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT1f_GET(r) (((r).tx_x4_sp3_loopcnt[0]) & 0x3f)
#define BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT1f_SET(r,f) (r).tx_x4_sp3_loopcnt[0]=(((r).tx_x4_sp3_loopcnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access TX_X4_SP3_LOOPCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP3_LOOPCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr,(_r._tx_x4_sp3_loopcnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP3_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr,(_r._tx_x4_sp3_loopcnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr,(_r._tx_x4_sp3_loopcnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP3_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_loopcnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_LOOPCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_loopcnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_LOOPCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp3_loopcnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP3_LOOPCNTr BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr
#define TX_X4_SP3_LOOPCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_t TX_X4_SP3_LOOPCNTr_t;
#define TX_X4_SP3_LOOPCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_CLR
#define TX_X4_SP3_LOOPCNTr_SET BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_SET
#define TX_X4_SP3_LOOPCNTr_GET BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_GET
#define TX_X4_SP3_LOOPCNTr_LOOPCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT0f_GET
#define TX_X4_SP3_LOOPCNTr_LOOPCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT0f_SET
#define TX_X4_SP3_LOOPCNTr_LOOPCNT1f_GET BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT1f_GET
#define TX_X4_SP3_LOOPCNTr_LOOPCNT1f_SET BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr_LOOPCNT1f_SET
#define READ_TX_X4_SP3_LOOPCNTr BCMI_QTC_XGXS_READ_TX_X4_SP3_LOOPCNTr
#define WRITE_TX_X4_SP3_LOOPCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP3_LOOPCNTr
#define MODIFY_TX_X4_SP3_LOOPCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_LOOPCNTr
#define READLN_TX_X4_SP3_LOOPCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP3_LOOPCNTr
#define WRITELN_TX_X4_SP3_LOOPCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_LOOPCNTr
#define WRITEALL_TX_X4_SP3_LOOPCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_LOOPCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP3_LOOPCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP3_MAC_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP3
 * REGADDR:  0xc133
 * DESC:     credit gen count register
 * SIZE:     32
 * FIELDS:
 *     MAC_CREDITGENCNT clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr (0x0000c133 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP3_MAC_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp3_mac_credgencnt[1];
	uint32_t _tx_x4_sp3_mac_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_CLR(r) (r).tx_x4_sp3_mac_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_SET(r,d) (r).tx_x4_sp3_mac_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_GET(r) (r).tx_x4_sp3_mac_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET(r) (((r).tx_x4_sp3_mac_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp3_mac_credgencnt[0]=(((r).tx_x4_sp3_mac_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP3_MAC_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP3_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr,(_r._tx_x4_sp3_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP3_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr,(_r._tx_x4_sp3_mac_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr,(_r._tx_x4_sp3_mac_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP3_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_MAC_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_mac_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_MAC_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp3_mac_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP3_MAC_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr
#define TX_X4_SP3_MAC_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_t TX_X4_SP3_MAC_CREDGENCNTr_t;
#define TX_X4_SP3_MAC_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_CLR
#define TX_X4_SP3_MAC_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_SET
#define TX_X4_SP3_MAC_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_GET
#define TX_X4_SP3_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET
#define TX_X4_SP3_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET
#define READ_TX_X4_SP3_MAC_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP3_MAC_CREDGENCNTr
#define WRITE_TX_X4_SP3_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP3_MAC_CREDGENCNTr
#define MODIFY_TX_X4_SP3_MAC_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_MAC_CREDGENCNTr
#define READLN_TX_X4_SP3_MAC_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP3_MAC_CREDGENCNTr
#define WRITELN_TX_X4_SP3_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_MAC_CREDGENCNTr
#define WRITEALL_TX_X4_SP3_MAC_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_MAC_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP3_MAC_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP3_PCS_CLKCNT0
 * BLOCKS:   TX_X4_CREDIT_SP3
 * REGADDR:  0xc134
 * DESC:     pcs clock count 0 register
 * SIZE:     32
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r (0x0000c134 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP3_PCS_CLKCNT0.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_s {
	uint32_t v[1];
	uint32_t tx_x4_sp3_pcs_clkcnt0[1];
	uint32_t _tx_x4_sp3_pcs_clkcnt0;
} BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_t;

#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_CLR(r) (r).tx_x4_sp3_pcs_clkcnt0[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_SET(r,d) (r).tx_x4_sp3_pcs_clkcnt0[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_GET(r) (r).tx_x4_sp3_pcs_clkcnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_REPLICATION_CNTf_GET(r) ((((r).tx_x4_sp3_pcs_clkcnt0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_REPLICATION_CNTf_SET(r,f) (r).tx_x4_sp3_pcs_clkcnt0[0]=(((r).tx_x4_sp3_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET(r) ((((r).tx_x4_sp3_pcs_clkcnt0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET(r,f) (r).tx_x4_sp3_pcs_clkcnt0[0]=(((r).tx_x4_sp3_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET(r) (((r).tx_x4_sp3_pcs_clkcnt0[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET(r,f) (r).tx_x4_sp3_pcs_clkcnt0[0]=(((r).tx_x4_sp3_pcs_clkcnt0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_X4_SP3_PCS_CLKCNT0.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP3_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r,(_r._tx_x4_sp3_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP3_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r,(_r._tx_x4_sp3_pcs_clkcnt0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r,(_r._tx_x4_sp3_pcs_clkcnt0))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP3_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_PCS_CLKCNT0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_pcs_clkcnt0))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_PCS_CLKCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp3_pcs_clkcnt0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP3_PCS_CLKCNT0r BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r
#define TX_X4_SP3_PCS_CLKCNT0r_SIZE BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_t TX_X4_SP3_PCS_CLKCNT0r_t;
#define TX_X4_SP3_PCS_CLKCNT0r_CLR BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_CLR
#define TX_X4_SP3_PCS_CLKCNT0r_SET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_SET
#define TX_X4_SP3_PCS_CLKCNT0r_GET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_GET
#define TX_X4_SP3_PCS_CLKCNT0r_REPLICATION_CNTf_GET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_REPLICATION_CNTf_GET
#define TX_X4_SP3_PCS_CLKCNT0r_REPLICATION_CNTf_SET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_REPLICATION_CNTf_SET
#define TX_X4_SP3_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET
#define TX_X4_SP3_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET
#define TX_X4_SP3_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET
#define TX_X4_SP3_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET
#define READ_TX_X4_SP3_PCS_CLKCNT0r BCMI_QTC_XGXS_READ_TX_X4_SP3_PCS_CLKCNT0r
#define WRITE_TX_X4_SP3_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITE_TX_X4_SP3_PCS_CLKCNT0r
#define MODIFY_TX_X4_SP3_PCS_CLKCNT0r BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_PCS_CLKCNT0r
#define READLN_TX_X4_SP3_PCS_CLKCNT0r BCMI_QTC_XGXS_READLN_TX_X4_SP3_PCS_CLKCNT0r
#define WRITELN_TX_X4_SP3_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_PCS_CLKCNT0r
#define WRITEALL_TX_X4_SP3_PCS_CLKCNT0r BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_PCS_CLKCNT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP3_PCS_CLKCNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_X4_SP3_PCS_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT_SP3
 * REGADDR:  0xc135
 * DESC:     pcs credit gen count register
 * SIZE:     32
 * FIELDS:
 *     PCS_CREDITGENCNT pcs clock count 0 for credit programming, range 1 to 2063
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr (0x0000c135 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_SP3_PCS_CREDGENCNT.
 */
typedef union BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_sp3_pcs_credgencnt[1];
	uint32_t _tx_x4_sp3_pcs_credgencnt;
} BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_t;

#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_CLR(r) (r).tx_x4_sp3_pcs_credgencnt[0] = 0
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_SET(r,d) (r).tx_x4_sp3_pcs_credgencnt[0] = d
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_GET(r) (r).tx_x4_sp3_pcs_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET(r) (((r).tx_x4_sp3_pcs_credgencnt[0]) & 0x1fff)
#define BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET(r,f) (r).tx_x4_sp3_pcs_credgencnt[0]=(((r).tx_x4_sp3_pcs_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access TX_X4_SP3_PCS_CREDGENCNT.
 */
#define BCMI_QTC_XGXS_READ_TX_X4_SP3_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr,(_r._tx_x4_sp3_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITE_TX_X4_SP3_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr,(_r._tx_x4_sp3_pcs_credgencnt)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr,(_r._tx_x4_sp3_pcs_credgencnt))
#define BCMI_QTC_XGXS_READLN_TX_X4_SP3_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_PCS_CREDGENCNTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_sp3_pcs_credgencnt))
#define BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_PCS_CREDGENCNTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_sp3_pcs_credgencnt))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_SP3_PCS_CREDGENCNTr BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr
#define TX_X4_SP3_PCS_CREDGENCNTr_SIZE BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_SIZE
typedef BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_t TX_X4_SP3_PCS_CREDGENCNTr_t;
#define TX_X4_SP3_PCS_CREDGENCNTr_CLR BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_CLR
#define TX_X4_SP3_PCS_CREDGENCNTr_SET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_SET
#define TX_X4_SP3_PCS_CREDGENCNTr_GET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_GET
#define TX_X4_SP3_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET
#define TX_X4_SP3_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET
#define READ_TX_X4_SP3_PCS_CREDGENCNTr BCMI_QTC_XGXS_READ_TX_X4_SP3_PCS_CREDGENCNTr
#define WRITE_TX_X4_SP3_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITE_TX_X4_SP3_PCS_CREDGENCNTr
#define MODIFY_TX_X4_SP3_PCS_CREDGENCNTr BCMI_QTC_XGXS_MODIFY_TX_X4_SP3_PCS_CREDGENCNTr
#define READLN_TX_X4_SP3_PCS_CREDGENCNTr BCMI_QTC_XGXS_READLN_TX_X4_SP3_PCS_CREDGENCNTr
#define WRITELN_TX_X4_SP3_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITELN_TX_X4_SP3_PCS_CREDGENCNTr
#define WRITEALL_TX_X4_SP3_PCS_CREDGENCNTr BCMI_QTC_XGXS_WRITEALL_TX_X4_SP3_PCS_CREDGENCNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_X4_SP3_PCS_CREDGENCNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MISC
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc140
 * DESC:     Misc register
 * SIZE:     32
 * FIELDS:
 *     ENABLE_TX_LANE   Per lane enable to allow DVs from MAC to enter TXP
 *     RSTB_TX_LANE     Low active reset for txp lanes
 *     TX_FIFO_WATERMARK Per logical lane tx fifo watermark for tx gearbox0: N/A1: Depth of 12: Depth of 23: Depth of 3
 */
#define BCMI_QTC_XGXS_MISCr (0x0000c140 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MISCr_SIZE 4

/*
 * This structure should be used to declare and program MISC.
 */
typedef union BCMI_QTC_XGXS_MISCr_s {
	uint32_t v[1];
	uint32_t misc[1];
	uint32_t _misc;
} BCMI_QTC_XGXS_MISCr_t;

#define BCMI_QTC_XGXS_MISCr_CLR(r) (r).misc[0] = 0
#define BCMI_QTC_XGXS_MISCr_SET(r,d) (r).misc[0] = d
#define BCMI_QTC_XGXS_MISCr_GET(r) (r).misc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MISCr_TX_FIFO_WATERMARKf_GET(r) ((((r).misc[0]) >> 2) & 0xf)
#define BCMI_QTC_XGXS_MISCr_TX_FIFO_WATERMARKf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_QTC_XGXS_MISCr_RSTB_TX_LANEf_GET(r) ((((r).misc[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_MISCr_RSTB_TX_LANEf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_MISCr_ENABLE_TX_LANEf_GET(r) (((r).misc[0]) & 0x1)
#define BCMI_QTC_XGXS_MISCr_ENABLE_TX_LANEf_SET(r,f) (r).misc[0]=(((r).misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access MISC.
 */
#define BCMI_QTC_XGXS_READ_MISCr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MISCr,(_r._misc))
#define BCMI_QTC_XGXS_WRITE_MISCr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MISCr,(_r._misc)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MISCr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MISCr,(_r._misc))
#define BCMI_QTC_XGXS_READLN_MISCr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._misc))
#define BCMI_QTC_XGXS_WRITELN_MISCr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._misc))
#define BCMI_QTC_XGXS_WRITEALL_MISCr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MISCr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._misc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MISCr BCMI_QTC_XGXS_MISCr
#define MISCr_SIZE BCMI_QTC_XGXS_MISCr_SIZE
typedef BCMI_QTC_XGXS_MISCr_t MISCr_t;
#define MISCr_CLR BCMI_QTC_XGXS_MISCr_CLR
#define MISCr_SET BCMI_QTC_XGXS_MISCr_SET
#define MISCr_GET BCMI_QTC_XGXS_MISCr_GET
#define MISCr_TX_FIFO_WATERMARKf_GET BCMI_QTC_XGXS_MISCr_TX_FIFO_WATERMARKf_GET
#define MISCr_TX_FIFO_WATERMARKf_SET BCMI_QTC_XGXS_MISCr_TX_FIFO_WATERMARKf_SET
#define MISCr_RSTB_TX_LANEf_GET BCMI_QTC_XGXS_MISCr_RSTB_TX_LANEf_GET
#define MISCr_RSTB_TX_LANEf_SET BCMI_QTC_XGXS_MISCr_RSTB_TX_LANEf_SET
#define MISCr_ENABLE_TX_LANEf_GET BCMI_QTC_XGXS_MISCr_ENABLE_TX_LANEf_GET
#define MISCr_ENABLE_TX_LANEf_SET BCMI_QTC_XGXS_MISCr_ENABLE_TX_LANEf_SET
#define READ_MISCr BCMI_QTC_XGXS_READ_MISCr
#define WRITE_MISCr BCMI_QTC_XGXS_WRITE_MISCr
#define MODIFY_MISCr BCMI_QTC_XGXS_MODIFY_MISCr
#define READLN_MISCr BCMI_QTC_XGXS_READLN_MISCr
#define WRITELN_MISCr BCMI_QTC_XGXS_WRITELN_MISCr
#define WRITEALL_MISCr BCMI_QTC_XGXS_WRITEALL_MISCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MISCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL36TX_CTL
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc141
 * DESC:     CL36 TX control register
 * SIZE:     32
 * FIELDS:
 *     CL36TX_LPI_EN    Support for transmit of /LI/ code: 1=enabled , 0=disabledIf disabled (0), LPIs are converted to IDLEs
 *     CL36TX_CATCH_ALL_8B10B_DIS The following logic implements the catch-all special code-group case indicatedin the IEEE Std 802.3-2005, Table 48-2. Basically, it states that any invalidcode-group NOT defined in either Table 36-2 Valid special code-groups, orTable 48-2 XGMII character to PCS code-group mapping, shall be mapped tospecial code-group K30.7 (i.e. 10'h1FE). An input mux muxes out the actualinput data[7:0] or the 10'h1FE onto the internal bus, data_int, which drivesthe orginal 8b10b logic. A control, named catch_all_8b10b_dis, is used to turn offthe catch-all; default is catch-all is ON.
 *     QSGMII_EN        
 */
#define BCMI_QTC_XGXS_CL36TX_CTLr (0x0000c141 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL36TX_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL36TX_CTL.
 */
typedef union BCMI_QTC_XGXS_CL36TX_CTLr_s {
	uint32_t v[1];
	uint32_t cl36tx_ctl[1];
	uint32_t _cl36tx_ctl;
} BCMI_QTC_XGXS_CL36TX_CTLr_t;

#define BCMI_QTC_XGXS_CL36TX_CTLr_CLR(r) (r).cl36tx_ctl[0] = 0
#define BCMI_QTC_XGXS_CL36TX_CTLr_SET(r,d) (r).cl36tx_ctl[0] = d
#define BCMI_QTC_XGXS_CL36TX_CTLr_GET(r) (r).cl36tx_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL36TX_CTLr_QSGMII_ENf_GET(r) ((((r).cl36tx_ctl[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_CL36TX_CTLr_QSGMII_ENf_SET(r,f) (r).cl36tx_ctl[0]=(((r).cl36tx_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_GET(r) ((((r).cl36tx_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_SET(r,f) (r).cl36tx_ctl[0]=(((r).cl36tx_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_LPI_ENf_GET(r) ((((r).cl36tx_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_LPI_ENf_SET(r,f) (r).cl36tx_ctl[0]=(((r).cl36tx_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access CL36TX_CTL.
 */
#define BCMI_QTC_XGXS_READ_CL36TX_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36TX_CTLr,(_r._cl36tx_ctl))
#define BCMI_QTC_XGXS_WRITE_CL36TX_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36TX_CTLr,(_r._cl36tx_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL36TX_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36TX_CTLr,(_r._cl36tx_ctl))
#define BCMI_QTC_XGXS_READLN_CL36TX_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36TX_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36tx_ctl))
#define BCMI_QTC_XGXS_WRITELN_CL36TX_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36TX_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36tx_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CL36TX_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36TX_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl36tx_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL36TX_CTLr BCMI_QTC_XGXS_CL36TX_CTLr
#define CL36TX_CTLr_SIZE BCMI_QTC_XGXS_CL36TX_CTLr_SIZE
typedef BCMI_QTC_XGXS_CL36TX_CTLr_t CL36TX_CTLr_t;
#define CL36TX_CTLr_CLR BCMI_QTC_XGXS_CL36TX_CTLr_CLR
#define CL36TX_CTLr_SET BCMI_QTC_XGXS_CL36TX_CTLr_SET
#define CL36TX_CTLr_GET BCMI_QTC_XGXS_CL36TX_CTLr_GET
#define CL36TX_CTLr_QSGMII_ENf_GET BCMI_QTC_XGXS_CL36TX_CTLr_QSGMII_ENf_GET
#define CL36TX_CTLr_QSGMII_ENf_SET BCMI_QTC_XGXS_CL36TX_CTLr_QSGMII_ENf_SET
#define CL36TX_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_GET BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_GET
#define CL36TX_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_SET BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_SET
#define CL36TX_CTLr_CL36TX_LPI_ENf_GET BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_LPI_ENf_GET
#define CL36TX_CTLr_CL36TX_LPI_ENf_SET BCMI_QTC_XGXS_CL36TX_CTLr_CL36TX_LPI_ENf_SET
#define READ_CL36TX_CTLr BCMI_QTC_XGXS_READ_CL36TX_CTLr
#define WRITE_CL36TX_CTLr BCMI_QTC_XGXS_WRITE_CL36TX_CTLr
#define MODIFY_CL36TX_CTLr BCMI_QTC_XGXS_MODIFY_CL36TX_CTLr
#define READLN_CL36TX_CTLr BCMI_QTC_XGXS_READLN_CL36TX_CTLr
#define WRITELN_CL36TX_CTLr BCMI_QTC_XGXS_WRITELN_CL36TX_CTLr
#define WRITEALL_CL36TX_CTLr BCMI_QTC_XGXS_WRITEALL_CL36TX_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL36TX_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL36_FSM_STS
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc150
 * DESC:     CL36 FSM Status register
 * SIZE:     32
 * FIELDS:
 *     CL36_TXSM_STATE  Transmit SM - state debug information
 */
#define BCMI_QTC_XGXS_CL36_FSM_STSr (0x0000c150 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL36_FSM_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL36_FSM_STS.
 */
typedef union BCMI_QTC_XGXS_CL36_FSM_STSr_s {
	uint32_t v[1];
	uint32_t cl36_fsm_sts[1];
	uint32_t _cl36_fsm_sts;
} BCMI_QTC_XGXS_CL36_FSM_STSr_t;

#define BCMI_QTC_XGXS_CL36_FSM_STSr_CLR(r) (r).cl36_fsm_sts[0] = 0
#define BCMI_QTC_XGXS_CL36_FSM_STSr_SET(r,d) (r).cl36_fsm_sts[0] = d
#define BCMI_QTC_XGXS_CL36_FSM_STSr_GET(r) (r).cl36_fsm_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL36_FSM_STSr_CL36_TXSM_STATEf_GET(r) (((r).cl36_fsm_sts[0]) & 0xf)
#define BCMI_QTC_XGXS_CL36_FSM_STSr_CL36_TXSM_STATEf_SET(r,f) (r).cl36_fsm_sts[0]=(((r).cl36_fsm_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access CL36_FSM_STS.
 */
#define BCMI_QTC_XGXS_READ_CL36_FSM_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_FSM_STSr,(_r._cl36_fsm_sts))
#define BCMI_QTC_XGXS_WRITE_CL36_FSM_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_FSM_STSr,(_r._cl36_fsm_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL36_FSM_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_FSM_STSr,(_r._cl36_fsm_sts))
#define BCMI_QTC_XGXS_READLN_CL36_FSM_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_FSM_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_fsm_sts))
#define BCMI_QTC_XGXS_WRITELN_CL36_FSM_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_FSM_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_fsm_sts))
#define BCMI_QTC_XGXS_WRITEALL_CL36_FSM_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_FSM_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl36_fsm_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL36_FSM_STSr BCMI_QTC_XGXS_CL36_FSM_STSr
#define CL36_FSM_STSr_SIZE BCMI_QTC_XGXS_CL36_FSM_STSr_SIZE
typedef BCMI_QTC_XGXS_CL36_FSM_STSr_t CL36_FSM_STSr_t;
#define CL36_FSM_STSr_CLR BCMI_QTC_XGXS_CL36_FSM_STSr_CLR
#define CL36_FSM_STSr_SET BCMI_QTC_XGXS_CL36_FSM_STSr_SET
#define CL36_FSM_STSr_GET BCMI_QTC_XGXS_CL36_FSM_STSr_GET
#define CL36_FSM_STSr_CL36_TXSM_STATEf_GET BCMI_QTC_XGXS_CL36_FSM_STSr_CL36_TXSM_STATEf_GET
#define CL36_FSM_STSr_CL36_TXSM_STATEf_SET BCMI_QTC_XGXS_CL36_FSM_STSr_CL36_TXSM_STATEf_SET
#define READ_CL36_FSM_STSr BCMI_QTC_XGXS_READ_CL36_FSM_STSr
#define WRITE_CL36_FSM_STSr BCMI_QTC_XGXS_WRITE_CL36_FSM_STSr
#define MODIFY_CL36_FSM_STSr BCMI_QTC_XGXS_MODIFY_CL36_FSM_STSr
#define READLN_CL36_FSM_STSr BCMI_QTC_XGXS_READLN_CL36_FSM_STSr
#define WRITELN_CL36_FSM_STSr BCMI_QTC_XGXS_WRITELN_CL36_FSM_STSr
#define WRITEALL_CL36_FSM_STSr BCMI_QTC_XGXS_WRITEALL_CL36_FSM_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL36_FSM_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_RATE_MISMATCH
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc151
 * DESC:     Tx sync FIFO rate mismatch indication
 * SIZE:     32
 * FIELDS:
 *     TX_LANE_RATE_MISMATCH If set indicates that there is a rate mismatch error on a fifo assosiated which this port
 */
#define BCMI_QTC_XGXS_TX_RATE_MISMATCHr (0x0000c151 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_RATE_MISMATCHr_SIZE 4

/*
 * This structure should be used to declare and program TX_RATE_MISMATCH.
 */
typedef union BCMI_QTC_XGXS_TX_RATE_MISMATCHr_s {
	uint32_t v[1];
	uint32_t tx_rate_mismatch[1];
	uint32_t _tx_rate_mismatch;
} BCMI_QTC_XGXS_TX_RATE_MISMATCHr_t;

#define BCMI_QTC_XGXS_TX_RATE_MISMATCHr_CLR(r) (r).tx_rate_mismatch[0] = 0
#define BCMI_QTC_XGXS_TX_RATE_MISMATCHr_SET(r,d) (r).tx_rate_mismatch[0] = d
#define BCMI_QTC_XGXS_TX_RATE_MISMATCHr_GET(r) (r).tx_rate_mismatch[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_GET(r) (((r).tx_rate_mismatch[0]) & 0x1)
#define BCMI_QTC_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_SET(r,f) (r).tx_rate_mismatch[0]=(((r).tx_rate_mismatch[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TX_RATE_MISMATCH.
 */
#define BCMI_QTC_XGXS_READ_TX_RATE_MISMATCHr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_RATE_MISMATCHr,(_r._tx_rate_mismatch))
#define BCMI_QTC_XGXS_WRITE_TX_RATE_MISMATCHr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_RATE_MISMATCHr,(_r._tx_rate_mismatch)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_RATE_MISMATCHr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_RATE_MISMATCHr,(_r._tx_rate_mismatch))
#define BCMI_QTC_XGXS_READLN_TX_RATE_MISMATCHr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_RATE_MISMATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_rate_mismatch))
#define BCMI_QTC_XGXS_WRITELN_TX_RATE_MISMATCHr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_RATE_MISMATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_rate_mismatch))
#define BCMI_QTC_XGXS_WRITEALL_TX_RATE_MISMATCHr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_RATE_MISMATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_rate_mismatch))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_RATE_MISMATCHr BCMI_QTC_XGXS_TX_RATE_MISMATCHr
#define TX_RATE_MISMATCHr_SIZE BCMI_QTC_XGXS_TX_RATE_MISMATCHr_SIZE
typedef BCMI_QTC_XGXS_TX_RATE_MISMATCHr_t TX_RATE_MISMATCHr_t;
#define TX_RATE_MISMATCHr_CLR BCMI_QTC_XGXS_TX_RATE_MISMATCHr_CLR
#define TX_RATE_MISMATCHr_SET BCMI_QTC_XGXS_TX_RATE_MISMATCHr_SET
#define TX_RATE_MISMATCHr_GET BCMI_QTC_XGXS_TX_RATE_MISMATCHr_GET
#define TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_GET BCMI_QTC_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_GET
#define TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_SET BCMI_QTC_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_SET
#define READ_TX_RATE_MISMATCHr BCMI_QTC_XGXS_READ_TX_RATE_MISMATCHr
#define WRITE_TX_RATE_MISMATCHr BCMI_QTC_XGXS_WRITE_TX_RATE_MISMATCHr
#define MODIFY_TX_RATE_MISMATCHr BCMI_QTC_XGXS_MODIFY_TX_RATE_MISMATCHr
#define READLN_TX_RATE_MISMATCHr BCMI_QTC_XGXS_READLN_TX_RATE_MISMATCHr
#define WRITELN_TX_RATE_MISMATCHr BCMI_QTC_XGXS_WRITELN_TX_RATE_MISMATCHr
#define WRITEALL_TX_RATE_MISMATCHr BCMI_QTC_XGXS_WRITEALL_TX_RATE_MISMATCHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_RATE_MISMATCHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PCS_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc160
 * DESC:     Rx PCS control register
 * SIZE:     32
 * FIELDS:
 *     DISPARITY_ERR_NOT_CAUSE_LOSS_SYNC 1: ignore running disparity errors in rx sync fsm
 *     RUNNING_DISPARITY_ERR_MSK mask running disparity errors only in QSGMII mode1: disparity error is disabled
 *     LPI_ENABLE       If off (0), LPIs are converted to IDLEs
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     CL36_RXSM_DEBUG_SP_SEL 2'd00 - sp0 is picked for rxsm debug registers2'd01 - sp1 is picked for rxsm debug registers2'd02 - sp2 is picked for rxsm debug registers2'd03 - sp3 is picked for rxsm debug registers
 *     SYNC_ACQ_STATUS_DEBUG_SP_SEL 2'd00 - sp0 is picked for sync acq status debug registers2'd01 - sp1 is picked for sync acq status debug registers2'd02 - sp2 is picked for sync acq status debug registers2'd03 - sp3 is picked for sync acq status debug registers
 */
#define BCMI_QTC_XGXS_PCS_CTLr (0x0000c160 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PCS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PCS_CTL.
 */
typedef union BCMI_QTC_XGXS_PCS_CTLr_s {
	uint32_t v[1];
	uint32_t pcs_ctl[1];
	uint32_t _pcs_ctl;
} BCMI_QTC_XGXS_PCS_CTLr_t;

#define BCMI_QTC_XGXS_PCS_CTLr_CLR(r) (r).pcs_ctl[0] = 0
#define BCMI_QTC_XGXS_PCS_CTLr_SET(r,d) (r).pcs_ctl[0] = d
#define BCMI_QTC_XGXS_PCS_CTLr_GET(r) (r).pcs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PCS_CTLr_SYNC_ACQ_STATUS_DEBUG_SP_SELf_GET(r) ((((r).pcs_ctl[0]) >> 7) & 0x3)
#define BCMI_QTC_XGXS_PCS_CTLr_SYNC_ACQ_STATUS_DEBUG_SP_SELf_SET(r,f) (r).pcs_ctl[0]=(((r).pcs_ctl[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_QTC_XGXS_PCS_CTLr_CL36_RXSM_DEBUG_SP_SELf_GET(r) ((((r).pcs_ctl[0]) >> 5) & 0x3)
#define BCMI_QTC_XGXS_PCS_CTLr_CL36_RXSM_DEBUG_SP_SELf_SET(r,f) (r).pcs_ctl[0]=(((r).pcs_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_QTC_XGXS_PCS_CTLr_CL36BYTEDELETEMODEf_GET(r) ((((r).pcs_ctl[0]) >> 3) & 0x3)
#define BCMI_QTC_XGXS_PCS_CTLr_CL36BYTEDELETEMODEf_SET(r,f) (r).pcs_ctl[0]=(((r).pcs_ctl[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_QTC_XGXS_PCS_CTLr_LPI_ENABLEf_GET(r) ((((r).pcs_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PCS_CTLr_LPI_ENABLEf_SET(r,f) (r).pcs_ctl[0]=(((r).pcs_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PCS_CTLr_RUNNING_DISPARITY_ERR_MSKf_GET(r) ((((r).pcs_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PCS_CTLr_RUNNING_DISPARITY_ERR_MSKf_SET(r,f) (r).pcs_ctl[0]=(((r).pcs_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PCS_CTLr_DISPARITY_ERR_NOT_CAUSE_LOSS_SYNCf_GET(r) (((r).pcs_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_PCS_CTLr_DISPARITY_ERR_NOT_CAUSE_LOSS_SYNCf_SET(r,f) (r).pcs_ctl[0]=(((r).pcs_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PCS_CTL.
 */
#define BCMI_QTC_XGXS_READ_PCS_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PCS_CTLr,(_r._pcs_ctl))
#define BCMI_QTC_XGXS_WRITE_PCS_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_CTLr,(_r._pcs_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PCS_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_CTLr,(_r._pcs_ctl))
#define BCMI_QTC_XGXS_READLN_PCS_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PCS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pcs_ctl))
#define BCMI_QTC_XGXS_WRITELN_PCS_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pcs_ctl))
#define BCMI_QTC_XGXS_WRITEALL_PCS_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pcs_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_CTLr BCMI_QTC_XGXS_PCS_CTLr
#define PCS_CTLr_SIZE BCMI_QTC_XGXS_PCS_CTLr_SIZE
typedef BCMI_QTC_XGXS_PCS_CTLr_t PCS_CTLr_t;
#define PCS_CTLr_CLR BCMI_QTC_XGXS_PCS_CTLr_CLR
#define PCS_CTLr_SET BCMI_QTC_XGXS_PCS_CTLr_SET
#define PCS_CTLr_GET BCMI_QTC_XGXS_PCS_CTLr_GET
#define PCS_CTLr_SYNC_ACQ_STATUS_DEBUG_SP_SELf_GET BCMI_QTC_XGXS_PCS_CTLr_SYNC_ACQ_STATUS_DEBUG_SP_SELf_GET
#define PCS_CTLr_SYNC_ACQ_STATUS_DEBUG_SP_SELf_SET BCMI_QTC_XGXS_PCS_CTLr_SYNC_ACQ_STATUS_DEBUG_SP_SELf_SET
#define PCS_CTLr_CL36_RXSM_DEBUG_SP_SELf_GET BCMI_QTC_XGXS_PCS_CTLr_CL36_RXSM_DEBUG_SP_SELf_GET
#define PCS_CTLr_CL36_RXSM_DEBUG_SP_SELf_SET BCMI_QTC_XGXS_PCS_CTLr_CL36_RXSM_DEBUG_SP_SELf_SET
#define PCS_CTLr_CL36BYTEDELETEMODEf_GET BCMI_QTC_XGXS_PCS_CTLr_CL36BYTEDELETEMODEf_GET
#define PCS_CTLr_CL36BYTEDELETEMODEf_SET BCMI_QTC_XGXS_PCS_CTLr_CL36BYTEDELETEMODEf_SET
#define PCS_CTLr_LPI_ENABLEf_GET BCMI_QTC_XGXS_PCS_CTLr_LPI_ENABLEf_GET
#define PCS_CTLr_LPI_ENABLEf_SET BCMI_QTC_XGXS_PCS_CTLr_LPI_ENABLEf_SET
#define PCS_CTLr_RUNNING_DISPARITY_ERR_MSKf_GET BCMI_QTC_XGXS_PCS_CTLr_RUNNING_DISPARITY_ERR_MSKf_GET
#define PCS_CTLr_RUNNING_DISPARITY_ERR_MSKf_SET BCMI_QTC_XGXS_PCS_CTLr_RUNNING_DISPARITY_ERR_MSKf_SET
#define PCS_CTLr_DISPARITY_ERR_NOT_CAUSE_LOSS_SYNCf_GET BCMI_QTC_XGXS_PCS_CTLr_DISPARITY_ERR_NOT_CAUSE_LOSS_SYNCf_GET
#define PCS_CTLr_DISPARITY_ERR_NOT_CAUSE_LOSS_SYNCf_SET BCMI_QTC_XGXS_PCS_CTLr_DISPARITY_ERR_NOT_CAUSE_LOSS_SYNCf_SET
#define READ_PCS_CTLr BCMI_QTC_XGXS_READ_PCS_CTLr
#define WRITE_PCS_CTLr BCMI_QTC_XGXS_WRITE_PCS_CTLr
#define MODIFY_PCS_CTLr BCMI_QTC_XGXS_MODIFY_PCS_CTLr
#define READLN_PCS_CTLr BCMI_QTC_XGXS_READLN_PCS_CTLr
#define WRITELN_PCS_CTLr BCMI_QTC_XGXS_WRITELN_PCS_CTLr
#define WRITEALL_PCS_CTLr BCMI_QTC_XGXS_WRITEALL_PCS_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PCS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL36_RX
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc161
 * DESC:     CL36 Rx control register
 * SIZE:     32
 * FIELDS:
 *     QSGMII_EN        
 *     DISABLE_CARRIER_EXTEND Disable carrier extensions
 *     CL36_FORCE_COMMA_ALIGN_ENABLE Force comma alignment function, and over-ride CL36 Synchronization function
 *     CL36_BER_EN      cl36 RX BER count: 1=enable , 0=disable
 */
#define BCMI_QTC_XGXS_CL36_RXr (0x0000c161 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL36_RXr_SIZE 4

/*
 * This structure should be used to declare and program CL36_RX.
 */
typedef union BCMI_QTC_XGXS_CL36_RXr_s {
	uint32_t v[1];
	uint32_t cl36_rx[1];
	uint32_t _cl36_rx;
} BCMI_QTC_XGXS_CL36_RXr_t;

#define BCMI_QTC_XGXS_CL36_RXr_CLR(r) (r).cl36_rx[0] = 0
#define BCMI_QTC_XGXS_CL36_RXr_SET(r,d) (r).cl36_rx[0] = d
#define BCMI_QTC_XGXS_CL36_RXr_GET(r) (r).cl36_rx[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL36_RXr_CL36_BER_ENf_GET(r) ((((r).cl36_rx[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_CL36_RXr_CL36_BER_ENf_SET(r,f) (r).cl36_rx[0]=(((r).cl36_rx[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_CL36_RXr_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET(r) ((((r).cl36_rx[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CL36_RXr_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET(r,f) (r).cl36_rx[0]=(((r).cl36_rx[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CL36_RXr_DISABLE_CARRIER_EXTENDf_GET(r) ((((r).cl36_rx[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CL36_RXr_DISABLE_CARRIER_EXTENDf_SET(r,f) (r).cl36_rx[0]=(((r).cl36_rx[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CL36_RXr_QSGMII_ENf_GET(r) (((r).cl36_rx[0]) & 0x1)
#define BCMI_QTC_XGXS_CL36_RXr_QSGMII_ENf_SET(r,f) (r).cl36_rx[0]=(((r).cl36_rx[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL36_RX.
 */
#define BCMI_QTC_XGXS_READ_CL36_RXr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXr,(_r._cl36_rx))
#define BCMI_QTC_XGXS_WRITE_CL36_RXr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXr,(_r._cl36_rx)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL36_RXr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXr,(_r._cl36_rx))
#define BCMI_QTC_XGXS_READLN_CL36_RXr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rx))
#define BCMI_QTC_XGXS_WRITELN_CL36_RXr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rx))
#define BCMI_QTC_XGXS_WRITEALL_CL36_RXr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl36_rx))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL36_RXr BCMI_QTC_XGXS_CL36_RXr
#define CL36_RXr_SIZE BCMI_QTC_XGXS_CL36_RXr_SIZE
typedef BCMI_QTC_XGXS_CL36_RXr_t CL36_RXr_t;
#define CL36_RXr_CLR BCMI_QTC_XGXS_CL36_RXr_CLR
#define CL36_RXr_SET BCMI_QTC_XGXS_CL36_RXr_SET
#define CL36_RXr_GET BCMI_QTC_XGXS_CL36_RXr_GET
#define CL36_RXr_CL36_BER_ENf_GET BCMI_QTC_XGXS_CL36_RXr_CL36_BER_ENf_GET
#define CL36_RXr_CL36_BER_ENf_SET BCMI_QTC_XGXS_CL36_RXr_CL36_BER_ENf_SET
#define CL36_RXr_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET BCMI_QTC_XGXS_CL36_RXr_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET
#define CL36_RXr_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET BCMI_QTC_XGXS_CL36_RXr_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET
#define CL36_RXr_DISABLE_CARRIER_EXTENDf_GET BCMI_QTC_XGXS_CL36_RXr_DISABLE_CARRIER_EXTENDf_GET
#define CL36_RXr_DISABLE_CARRIER_EXTENDf_SET BCMI_QTC_XGXS_CL36_RXr_DISABLE_CARRIER_EXTENDf_SET
#define CL36_RXr_QSGMII_ENf_GET BCMI_QTC_XGXS_CL36_RXr_QSGMII_ENf_GET
#define CL36_RXr_QSGMII_ENf_SET BCMI_QTC_XGXS_CL36_RXr_QSGMII_ENf_SET
#define READ_CL36_RXr BCMI_QTC_XGXS_READ_CL36_RXr
#define WRITE_CL36_RXr BCMI_QTC_XGXS_WRITE_CL36_RXr
#define MODIFY_CL36_RXr BCMI_QTC_XGXS_MODIFY_CL36_RXr
#define READLN_CL36_RXr BCMI_QTC_XGXS_READLN_CL36_RXr
#define WRITELN_CL36_RXr BCMI_QTC_XGXS_WRITELN_CL36_RXr
#define WRITEALL_CL36_RXr BCMI_QTC_XGXS_WRITEALL_CL36_RXr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL36_RXr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PMA_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc162
 * DESC:     Rx PMA control register
 * SIZE:     32
 * FIELDS:
 *     RSTB_LANE        Low activer per lane reset for RXP
 *     RX_GBOX_AFRST_EN 
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 8 - divide by 87: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,98: OS MODE 10 - divide by 10
 */
#define BCMI_QTC_XGXS_PMA_CTLr (0x0000c162 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PMA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMA_CTL.
 */
typedef union BCMI_QTC_XGXS_PMA_CTLr_s {
	uint32_t v[1];
	uint32_t pma_ctl[1];
	uint32_t _pma_ctl;
} BCMI_QTC_XGXS_PMA_CTLr_t;

#define BCMI_QTC_XGXS_PMA_CTLr_CLR(r) (r).pma_ctl[0] = 0
#define BCMI_QTC_XGXS_PMA_CTLr_SET(r,d) (r).pma_ctl[0] = d
#define BCMI_QTC_XGXS_PMA_CTLr_GET(r) (r).pma_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PMA_CTLr_OS_MODEf_GET(r) ((((r).pma_ctl[0]) >> 3) & 0xf)
#define BCMI_QTC_XGXS_PMA_CTLr_OS_MODEf_SET(r,f) (r).pma_ctl[0]=(((r).pma_ctl[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_QTC_XGXS_PMA_CTLr_RX_GBOX_AFRST_ENf_GET(r) ((((r).pma_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PMA_CTLr_RX_GBOX_AFRST_ENf_SET(r,f) (r).pma_ctl[0]=(((r).pma_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PMA_CTLr_RSTB_LANEf_GET(r) (((r).pma_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_PMA_CTLr_RSTB_LANEf_SET(r,f) (r).pma_ctl[0]=(((r).pma_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PMA_CTL.
 */
#define BCMI_QTC_XGXS_READ_PMA_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMA_CTLr,(_r._pma_ctl))
#define BCMI_QTC_XGXS_WRITE_PMA_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMA_CTLr,(_r._pma_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PMA_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMA_CTLr,(_r._pma_ctl))
#define BCMI_QTC_XGXS_READLN_PMA_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PMA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pma_ctl))
#define BCMI_QTC_XGXS_WRITELN_PMA_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pma_ctl))
#define BCMI_QTC_XGXS_WRITEALL_PMA_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PMA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pma_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMA_CTLr BCMI_QTC_XGXS_PMA_CTLr
#define PMA_CTLr_SIZE BCMI_QTC_XGXS_PMA_CTLr_SIZE
typedef BCMI_QTC_XGXS_PMA_CTLr_t PMA_CTLr_t;
#define PMA_CTLr_CLR BCMI_QTC_XGXS_PMA_CTLr_CLR
#define PMA_CTLr_SET BCMI_QTC_XGXS_PMA_CTLr_SET
#define PMA_CTLr_GET BCMI_QTC_XGXS_PMA_CTLr_GET
#define PMA_CTLr_OS_MODEf_GET BCMI_QTC_XGXS_PMA_CTLr_OS_MODEf_GET
#define PMA_CTLr_OS_MODEf_SET BCMI_QTC_XGXS_PMA_CTLr_OS_MODEf_SET
#define PMA_CTLr_RX_GBOX_AFRST_ENf_GET BCMI_QTC_XGXS_PMA_CTLr_RX_GBOX_AFRST_ENf_GET
#define PMA_CTLr_RX_GBOX_AFRST_ENf_SET BCMI_QTC_XGXS_PMA_CTLr_RX_GBOX_AFRST_ENf_SET
#define PMA_CTLr_RSTB_LANEf_GET BCMI_QTC_XGXS_PMA_CTLr_RSTB_LANEf_GET
#define PMA_CTLr_RSTB_LANEf_SET BCMI_QTC_XGXS_PMA_CTLr_RSTB_LANEf_SET
#define READ_PMA_CTLr BCMI_QTC_XGXS_READ_PMA_CTLr
#define WRITE_PMA_CTLr BCMI_QTC_XGXS_WRITE_PMA_CTLr
#define MODIFY_PMA_CTLr BCMI_QTC_XGXS_MODIFY_PMA_CTLr
#define READLN_PMA_CTLr BCMI_QTC_XGXS_READLN_PMA_CTLr
#define WRITELN_PMA_CTLr BCMI_QTC_XGXS_WRITELN_PMA_CTLr
#define WRITEALL_PMA_CTLr BCMI_QTC_XGXS_WRITEALL_PMA_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PMA_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  LNK_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc163
 * DESC:     Link status control
 * SIZE:     32
 * FIELDS:
 *     LATCH_LINKDOWN_ENABLE Per port configuration1'b1 - If the link status transitions from UP (1) to DOWN (0), this bit maintains the DOWN (0) value of the link status until the SW clears this bit.1'b0 - The link status information is passed directly from the PCS to the MAC and status registers without modification
 */
#define BCMI_QTC_XGXS_LNK_CTLr (0x0000c163 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_LNK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LNK_CTL.
 */
typedef union BCMI_QTC_XGXS_LNK_CTLr_s {
	uint32_t v[1];
	uint32_t lnk_ctl[1];
	uint32_t _lnk_ctl;
} BCMI_QTC_XGXS_LNK_CTLr_t;

#define BCMI_QTC_XGXS_LNK_CTLr_CLR(r) (r).lnk_ctl[0] = 0
#define BCMI_QTC_XGXS_LNK_CTLr_SET(r,d) (r).lnk_ctl[0] = d
#define BCMI_QTC_XGXS_LNK_CTLr_GET(r) (r).lnk_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET(r) (((r).lnk_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET(r,f) (r).lnk_ctl[0]=(((r).lnk_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access LNK_CTL.
 */
#define BCMI_QTC_XGXS_READ_LNK_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_LNK_CTLr,(_r._lnk_ctl))
#define BCMI_QTC_XGXS_WRITE_LNK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_CTLr,(_r._lnk_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_LNK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_CTLr,(_r._lnk_ctl))
#define BCMI_QTC_XGXS_READLN_LNK_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnk_ctl))
#define BCMI_QTC_XGXS_WRITELN_LNK_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnk_ctl))
#define BCMI_QTC_XGXS_WRITEALL_LNK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnk_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LNK_CTLr BCMI_QTC_XGXS_LNK_CTLr
#define LNK_CTLr_SIZE BCMI_QTC_XGXS_LNK_CTLr_SIZE
typedef BCMI_QTC_XGXS_LNK_CTLr_t LNK_CTLr_t;
#define LNK_CTLr_CLR BCMI_QTC_XGXS_LNK_CTLr_CLR
#define LNK_CTLr_SET BCMI_QTC_XGXS_LNK_CTLr_SET
#define LNK_CTLr_GET BCMI_QTC_XGXS_LNK_CTLr_GET
#define LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET BCMI_QTC_XGXS_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET
#define LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET BCMI_QTC_XGXS_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET
#define READ_LNK_CTLr BCMI_QTC_XGXS_READ_LNK_CTLr
#define WRITE_LNK_CTLr BCMI_QTC_XGXS_WRITE_LNK_CTLr
#define MODIFY_LNK_CTLr BCMI_QTC_XGXS_MODIFY_LNK_CTLr
#define READLN_LNK_CTLr BCMI_QTC_XGXS_READLN_LNK_CTLr
#define WRITELN_LNK_CTLr BCMI_QTC_XGXS_WRITELN_LNK_CTLr
#define WRITEALL_LNK_CTLr BCMI_QTC_XGXS_WRITEALL_LNK_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_LNK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  BARREL_SHIFTER_ST
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc170
 * DESC:     Barrel Shifter State
 * SIZE:     32
 * FIELDS:
 *     SHIFT_AMMOUNT    
 */
#define BCMI_QTC_XGXS_BARREL_SHIFTER_STr (0x0000c170 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SIZE 4

/*
 * This structure should be used to declare and program BARREL_SHIFTER_ST.
 */
typedef union BCMI_QTC_XGXS_BARREL_SHIFTER_STr_s {
	uint32_t v[1];
	uint32_t barrel_shifter_st[1];
	uint32_t _barrel_shifter_st;
} BCMI_QTC_XGXS_BARREL_SHIFTER_STr_t;

#define BCMI_QTC_XGXS_BARREL_SHIFTER_STr_CLR(r) (r).barrel_shifter_st[0] = 0
#define BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SET(r,d) (r).barrel_shifter_st[0] = d
#define BCMI_QTC_XGXS_BARREL_SHIFTER_STr_GET(r) (r).barrel_shifter_st[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_GET(r) (((r).barrel_shifter_st[0]) & 0xff)
#define BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_SET(r,f) (r).barrel_shifter_st[0]=(((r).barrel_shifter_st[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access BARREL_SHIFTER_ST.
 */
#define BCMI_QTC_XGXS_READ_BARREL_SHIFTER_STr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_BARREL_SHIFTER_STr,(_r._barrel_shifter_st))
#define BCMI_QTC_XGXS_WRITE_BARREL_SHIFTER_STr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BARREL_SHIFTER_STr,(_r._barrel_shifter_st)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_BARREL_SHIFTER_STr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BARREL_SHIFTER_STr,(_r._barrel_shifter_st))
#define BCMI_QTC_XGXS_READLN_BARREL_SHIFTER_STr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_BARREL_SHIFTER_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._barrel_shifter_st))
#define BCMI_QTC_XGXS_WRITELN_BARREL_SHIFTER_STr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BARREL_SHIFTER_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._barrel_shifter_st))
#define BCMI_QTC_XGXS_WRITEALL_BARREL_SHIFTER_STr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BARREL_SHIFTER_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._barrel_shifter_st))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BARREL_SHIFTER_STr BCMI_QTC_XGXS_BARREL_SHIFTER_STr
#define BARREL_SHIFTER_STr_SIZE BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SIZE
typedef BCMI_QTC_XGXS_BARREL_SHIFTER_STr_t BARREL_SHIFTER_STr_t;
#define BARREL_SHIFTER_STr_CLR BCMI_QTC_XGXS_BARREL_SHIFTER_STr_CLR
#define BARREL_SHIFTER_STr_SET BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SET
#define BARREL_SHIFTER_STr_GET BCMI_QTC_XGXS_BARREL_SHIFTER_STr_GET
#define BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_GET BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_GET
#define BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_SET BCMI_QTC_XGXS_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_SET
#define READ_BARREL_SHIFTER_STr BCMI_QTC_XGXS_READ_BARREL_SHIFTER_STr
#define WRITE_BARREL_SHIFTER_STr BCMI_QTC_XGXS_WRITE_BARREL_SHIFTER_STr
#define MODIFY_BARREL_SHIFTER_STr BCMI_QTC_XGXS_MODIFY_BARREL_SHIFTER_STr
#define READLN_BARREL_SHIFTER_STr BCMI_QTC_XGXS_READLN_BARREL_SHIFTER_STr
#define WRITELN_BARREL_SHIFTER_STr BCMI_QTC_XGXS_WRITELN_BARREL_SHIFTER_STr
#define WRITEALL_BARREL_SHIFTER_STr BCMI_QTC_XGXS_WRITEALL_BARREL_SHIFTER_STr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_BARREL_SHIFTER_STr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SYNCACQ_STS_0_SP0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc171
 * DESC:     Rx syncacq FSM debug status register
 * SIZE:     32
 * FIELDS:
 *     CL36_SYNCACQ_STATE_CODED_PER_LN cl36 sync acquisition fsm - next state4'd0 - LOSS_OF_SYNC4'd1 - COMMA_DET_14'd2 - ACQ_SYNC_14'd3 - COMMA_DET_24'd4 - ACQ_SYNC_24'd5 - COMMA_DET_34'd6 - SYNC_ACQ_14'd7 - SYNC_ACQ_24'd8 - SYNC_ACQ_34'd9 - SYNC_ACQ_44'd10 - SYNC_ACQ_2A4'd11 - SYNC_ACQ_3A4'd12 - SYNC_ACQ_4A
 */
#define BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r (0x0000c171 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_SIZE 4

/*
 * This structure should be used to declare and program SYNCACQ_STS_0_SP0.
 */
typedef union BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_s {
	uint32_t v[1];
	uint32_t syncacq_sts_0_sp0[1];
	uint32_t _syncacq_sts_0_sp0;
} BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_t;

#define BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_CLR(r) (r).syncacq_sts_0_sp0[0] = 0
#define BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_SET(r,d) (r).syncacq_sts_0_sp0[0] = d
#define BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_GET(r) (r).syncacq_sts_0_sp0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET(r) (((r).syncacq_sts_0_sp0[0]) & 0xf)
#define BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET(r,f) (r).syncacq_sts_0_sp0[0]=(((r).syncacq_sts_0_sp0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access SYNCACQ_STS_0_SP0.
 */
#define BCMI_QTC_XGXS_READ_SYNCACQ_STS_0_SP0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r,(_r._syncacq_sts_0_sp0))
#define BCMI_QTC_XGXS_WRITE_SYNCACQ_STS_0_SP0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r,(_r._syncacq_sts_0_sp0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SYNCACQ_STS_0_SP0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r,(_r._syncacq_sts_0_sp0))
#define BCMI_QTC_XGXS_READLN_SYNCACQ_STS_0_SP0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._syncacq_sts_0_sp0))
#define BCMI_QTC_XGXS_WRITELN_SYNCACQ_STS_0_SP0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._syncacq_sts_0_sp0))
#define BCMI_QTC_XGXS_WRITEALL_SYNCACQ_STS_0_SP0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._syncacq_sts_0_sp0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SYNCACQ_STS_0_SP0r BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r
#define SYNCACQ_STS_0_SP0r_SIZE BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_SIZE
typedef BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_t SYNCACQ_STS_0_SP0r_t;
#define SYNCACQ_STS_0_SP0r_CLR BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_CLR
#define SYNCACQ_STS_0_SP0r_SET BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_SET
#define SYNCACQ_STS_0_SP0r_GET BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_GET
#define SYNCACQ_STS_0_SP0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET
#define SYNCACQ_STS_0_SP0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET
#define READ_SYNCACQ_STS_0_SP0r BCMI_QTC_XGXS_READ_SYNCACQ_STS_0_SP0r
#define WRITE_SYNCACQ_STS_0_SP0r BCMI_QTC_XGXS_WRITE_SYNCACQ_STS_0_SP0r
#define MODIFY_SYNCACQ_STS_0_SP0r BCMI_QTC_XGXS_MODIFY_SYNCACQ_STS_0_SP0r
#define READLN_SYNCACQ_STS_0_SP0r BCMI_QTC_XGXS_READLN_SYNCACQ_STS_0_SP0r
#define WRITELN_SYNCACQ_STS_0_SP0r BCMI_QTC_XGXS_WRITELN_SYNCACQ_STS_0_SP0r
#define WRITEALL_SYNCACQ_STS_0_SP0r BCMI_QTC_XGXS_WRITEALL_SYNCACQ_STS_0_SP0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SYNCACQ_STS_0_SP0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SYNCACQ_STS_1_SP0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc172
 * DESC:     Rx syncacq FSM debug status register
 * SIZE:     32
 * FIELDS:
 *     CL36_SYNCACQ_HIS_STATE_PER_LN bit 0 - LOSS_OF_SYNCbit 1 - COMMA_DET_1bit 2 - ACQ_SYNC_1bit 3 - COMMA_DET_2bit 4 - ACQ_SYNC_2bit 5 - COMMA_DET_3bit 6 - SYNC_ACQ_1bit 7 - SYNC_ACQ_2bit 8 - SYNC_ACQ_3bit 9 - SYNC_ACQ_4bit 10 - SYNC_ACQ_2Abit 11 - SYNC_ACQ_3Abit 12 - SYNC_ACQ_4A
 */
#define BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r (0x0000c172 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_SIZE 4

/*
 * This structure should be used to declare and program SYNCACQ_STS_1_SP0.
 */
typedef union BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_s {
	uint32_t v[1];
	uint32_t syncacq_sts_1_sp0[1];
	uint32_t _syncacq_sts_1_sp0;
} BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_t;

#define BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_CLR(r) (r).syncacq_sts_1_sp0[0] = 0
#define BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_SET(r,d) (r).syncacq_sts_1_sp0[0] = d
#define BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_GET(r) (r).syncacq_sts_1_sp0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET(r) (((r).syncacq_sts_1_sp0[0]) & 0x1fff)
#define BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET(r,f) (r).syncacq_sts_1_sp0[0]=(((r).syncacq_sts_1_sp0[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access SYNCACQ_STS_1_SP0.
 */
#define BCMI_QTC_XGXS_READ_SYNCACQ_STS_1_SP0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r,(_r._syncacq_sts_1_sp0))
#define BCMI_QTC_XGXS_WRITE_SYNCACQ_STS_1_SP0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r,(_r._syncacq_sts_1_sp0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SYNCACQ_STS_1_SP0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r,(_r._syncacq_sts_1_sp0))
#define BCMI_QTC_XGXS_READLN_SYNCACQ_STS_1_SP0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._syncacq_sts_1_sp0))
#define BCMI_QTC_XGXS_WRITELN_SYNCACQ_STS_1_SP0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._syncacq_sts_1_sp0))
#define BCMI_QTC_XGXS_WRITEALL_SYNCACQ_STS_1_SP0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._syncacq_sts_1_sp0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SYNCACQ_STS_1_SP0r BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r
#define SYNCACQ_STS_1_SP0r_SIZE BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_SIZE
typedef BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_t SYNCACQ_STS_1_SP0r_t;
#define SYNCACQ_STS_1_SP0r_CLR BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_CLR
#define SYNCACQ_STS_1_SP0r_SET BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_SET
#define SYNCACQ_STS_1_SP0r_GET BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_GET
#define SYNCACQ_STS_1_SP0r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET
#define SYNCACQ_STS_1_SP0r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET
#define READ_SYNCACQ_STS_1_SP0r BCMI_QTC_XGXS_READ_SYNCACQ_STS_1_SP0r
#define WRITE_SYNCACQ_STS_1_SP0r BCMI_QTC_XGXS_WRITE_SYNCACQ_STS_1_SP0r
#define MODIFY_SYNCACQ_STS_1_SP0r BCMI_QTC_XGXS_MODIFY_SYNCACQ_STS_1_SP0r
#define READLN_SYNCACQ_STS_1_SP0r BCMI_QTC_XGXS_READLN_SYNCACQ_STS_1_SP0r
#define WRITELN_SYNCACQ_STS_1_SP0r BCMI_QTC_XGXS_WRITELN_SYNCACQ_STS_1_SP0r
#define WRITEALL_SYNCACQ_STS_1_SP0r BCMI_QTC_XGXS_WRITEALL_SYNCACQ_STS_1_SP0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SYNCACQ_STS_1_SP0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL36_RXSM_BINARY_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc173
 * DESC:     CL36 Rx FSM encode status register
 * SIZE:     32
 * FIELDS:
 *     CL36_RXSM_STATE_SPN cl36 Rx fsm status-- next state for subport N
 */
#define BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr (0x0000c173 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL36_RXSM_BINARY_STS.
 */
typedef union BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_s {
	uint32_t v[1];
	uint32_t cl36_rxsm_binary_sts[1];
	uint32_t _cl36_rxsm_binary_sts;
} BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_t;

#define BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_CLR(r) (r).cl36_rxsm_binary_sts[0] = 0
#define BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_SET(r,d) (r).cl36_rxsm_binary_sts[0] = d
#define BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_GET(r) (r).cl36_rxsm_binary_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_CL36_RXSM_STATE_SPNf_GET(r) (((r).cl36_rxsm_binary_sts[0]) & 0x1f)
#define BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_CL36_RXSM_STATE_SPNf_SET(r,f) (r).cl36_rxsm_binary_sts[0]=(((r).cl36_rxsm_binary_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access CL36_RXSM_BINARY_STS.
 */
#define BCMI_QTC_XGXS_READ_CL36_RXSM_BINARY_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr,(_r._cl36_rxsm_binary_sts))
#define BCMI_QTC_XGXS_WRITE_CL36_RXSM_BINARY_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr,(_r._cl36_rxsm_binary_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL36_RXSM_BINARY_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr,(_r._cl36_rxsm_binary_sts))
#define BCMI_QTC_XGXS_READLN_CL36_RXSM_BINARY_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rxsm_binary_sts))
#define BCMI_QTC_XGXS_WRITELN_CL36_RXSM_BINARY_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rxsm_binary_sts))
#define BCMI_QTC_XGXS_WRITEALL_CL36_RXSM_BINARY_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl36_rxsm_binary_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL36_RXSM_BINARY_STSr BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr
#define CL36_RXSM_BINARY_STSr_SIZE BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_SIZE
typedef BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_t CL36_RXSM_BINARY_STSr_t;
#define CL36_RXSM_BINARY_STSr_CLR BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_CLR
#define CL36_RXSM_BINARY_STSr_SET BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_SET
#define CL36_RXSM_BINARY_STSr_GET BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_GET
#define CL36_RXSM_BINARY_STSr_CL36_RXSM_STATE_SPNf_GET BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_CL36_RXSM_STATE_SPNf_GET
#define CL36_RXSM_BINARY_STSr_CL36_RXSM_STATE_SPNf_SET BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr_CL36_RXSM_STATE_SPNf_SET
#define READ_CL36_RXSM_BINARY_STSr BCMI_QTC_XGXS_READ_CL36_RXSM_BINARY_STSr
#define WRITE_CL36_RXSM_BINARY_STSr BCMI_QTC_XGXS_WRITE_CL36_RXSM_BINARY_STSr
#define MODIFY_CL36_RXSM_BINARY_STSr BCMI_QTC_XGXS_MODIFY_CL36_RXSM_BINARY_STSr
#define READLN_CL36_RXSM_BINARY_STSr BCMI_QTC_XGXS_READLN_CL36_RXSM_BINARY_STSr
#define WRITELN_CL36_RXSM_BINARY_STSr BCMI_QTC_XGXS_WRITELN_CL36_RXSM_BINARY_STSr
#define WRITEALL_CL36_RXSM_BINARY_STSr BCMI_QTC_XGXS_WRITEALL_CL36_RXSM_BINARY_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL36_RXSM_BINARY_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL36_RXSM_ONEHOT_STS0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc174
 * DESC:     CL36 Rx FSM onehot latched status register
 * SIZE:     32
 * FIELDS:
 *     CL36_RXSM_ONEHOT_LATCHED_LO_STATUS cl36 rxsm fsmbit 0 - LINK_FAILED_BITbit 1 - WAIT_FOR_K_BITbit 2 - RX_K_BITbit 3 - RX_CB_BITbit 4 - RX_CC_BITbit 5 - RX_CD_BITbit 6 - RX_INVALID_BITbit 7 - IDLE_D_BITbit 8 - FALSE_CARRIER_ST_BITbit 9 - START_OF_PACKET_BITbit 10 - RX_DATA_BITbit 11 - RX_DATA_ERROR_BITbit 12 - EARLY_END_BITbit 13 - TRIaRPI_BITbit 14 - TRRaEXTEND_BITbit 15 - EARLY_END_EXT_ST_BIT
 */
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r (0x0000c174 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL36_RXSM_ONEHOT_STS0.
 */
typedef union BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_s {
	uint32_t v[1];
	uint32_t cl36_rxsm_onehot_sts0[1];
	uint32_t _cl36_rxsm_onehot_sts0;
} BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_t;

#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_CLR(r) (r).cl36_rxsm_onehot_sts0[0] = 0
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_SET(r,d) (r).cl36_rxsm_onehot_sts0[0] = d
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_GET(r) (r).cl36_rxsm_onehot_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_CL36_RXSM_ONEHOT_LATCHED_LO_STATUSf_GET(r) (((r).cl36_rxsm_onehot_sts0[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_CL36_RXSM_ONEHOT_LATCHED_LO_STATUSf_SET(r,f) (r).cl36_rxsm_onehot_sts0[0]=(((r).cl36_rxsm_onehot_sts0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL36_RXSM_ONEHOT_STS0.
 */
#define BCMI_QTC_XGXS_READ_CL36_RXSM_ONEHOT_STS0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r,(_r._cl36_rxsm_onehot_sts0))
#define BCMI_QTC_XGXS_WRITE_CL36_RXSM_ONEHOT_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r,(_r._cl36_rxsm_onehot_sts0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL36_RXSM_ONEHOT_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r,(_r._cl36_rxsm_onehot_sts0))
#define BCMI_QTC_XGXS_READLN_CL36_RXSM_ONEHOT_STS0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rxsm_onehot_sts0))
#define BCMI_QTC_XGXS_WRITELN_CL36_RXSM_ONEHOT_STS0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rxsm_onehot_sts0))
#define BCMI_QTC_XGXS_WRITEALL_CL36_RXSM_ONEHOT_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl36_rxsm_onehot_sts0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL36_RXSM_ONEHOT_STS0r BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r
#define CL36_RXSM_ONEHOT_STS0r_SIZE BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_SIZE
typedef BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_t CL36_RXSM_ONEHOT_STS0r_t;
#define CL36_RXSM_ONEHOT_STS0r_CLR BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_CLR
#define CL36_RXSM_ONEHOT_STS0r_SET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_SET
#define CL36_RXSM_ONEHOT_STS0r_GET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_GET
#define CL36_RXSM_ONEHOT_STS0r_CL36_RXSM_ONEHOT_LATCHED_LO_STATUSf_GET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_CL36_RXSM_ONEHOT_LATCHED_LO_STATUSf_GET
#define CL36_RXSM_ONEHOT_STS0r_CL36_RXSM_ONEHOT_LATCHED_LO_STATUSf_SET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r_CL36_RXSM_ONEHOT_LATCHED_LO_STATUSf_SET
#define READ_CL36_RXSM_ONEHOT_STS0r BCMI_QTC_XGXS_READ_CL36_RXSM_ONEHOT_STS0r
#define WRITE_CL36_RXSM_ONEHOT_STS0r BCMI_QTC_XGXS_WRITE_CL36_RXSM_ONEHOT_STS0r
#define MODIFY_CL36_RXSM_ONEHOT_STS0r BCMI_QTC_XGXS_MODIFY_CL36_RXSM_ONEHOT_STS0r
#define READLN_CL36_RXSM_ONEHOT_STS0r BCMI_QTC_XGXS_READLN_CL36_RXSM_ONEHOT_STS0r
#define WRITELN_CL36_RXSM_ONEHOT_STS0r BCMI_QTC_XGXS_WRITELN_CL36_RXSM_ONEHOT_STS0r
#define WRITEALL_CL36_RXSM_ONEHOT_STS0r BCMI_QTC_XGXS_WRITEALL_CL36_RXSM_ONEHOT_STS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL36_RXSM_ONEHOT_STS1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc175
 * DESC:     CL36 Rx FSM onehot latched status register
 * SIZE:     32
 * FIELDS:
 *     CL36_RXSM_ONEHOT_LATCHED_HI_STATUS cl36 rxsm fsmbit 16 - PACKET_BURST_RRS_BITbit 17 - EXTEND_ERR_BITbit 18 - LP_IDLE_D_BITbit 19 - LP_RX_K_BIT
 */
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r (0x0000c175 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_SIZE 4

/*
 * This structure should be used to declare and program CL36_RXSM_ONEHOT_STS1.
 */
typedef union BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_s {
	uint32_t v[1];
	uint32_t cl36_rxsm_onehot_sts1[1];
	uint32_t _cl36_rxsm_onehot_sts1;
} BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_t;

#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_CLR(r) (r).cl36_rxsm_onehot_sts1[0] = 0
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_SET(r,d) (r).cl36_rxsm_onehot_sts1[0] = d
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_GET(r) (r).cl36_rxsm_onehot_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_CL36_RXSM_ONEHOT_LATCHED_HI_STATUSf_GET(r) (((r).cl36_rxsm_onehot_sts1[0]) & 0xf)
#define BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_CL36_RXSM_ONEHOT_LATCHED_HI_STATUSf_SET(r,f) (r).cl36_rxsm_onehot_sts1[0]=(((r).cl36_rxsm_onehot_sts1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access CL36_RXSM_ONEHOT_STS1.
 */
#define BCMI_QTC_XGXS_READ_CL36_RXSM_ONEHOT_STS1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r,(_r._cl36_rxsm_onehot_sts1))
#define BCMI_QTC_XGXS_WRITE_CL36_RXSM_ONEHOT_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r,(_r._cl36_rxsm_onehot_sts1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL36_RXSM_ONEHOT_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r,(_r._cl36_rxsm_onehot_sts1))
#define BCMI_QTC_XGXS_READLN_CL36_RXSM_ONEHOT_STS1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rxsm_onehot_sts1))
#define BCMI_QTC_XGXS_WRITELN_CL36_RXSM_ONEHOT_STS1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl36_rxsm_onehot_sts1))
#define BCMI_QTC_XGXS_WRITEALL_CL36_RXSM_ONEHOT_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl36_rxsm_onehot_sts1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL36_RXSM_ONEHOT_STS1r BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r
#define CL36_RXSM_ONEHOT_STS1r_SIZE BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_SIZE
typedef BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_t CL36_RXSM_ONEHOT_STS1r_t;
#define CL36_RXSM_ONEHOT_STS1r_CLR BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_CLR
#define CL36_RXSM_ONEHOT_STS1r_SET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_SET
#define CL36_RXSM_ONEHOT_STS1r_GET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_GET
#define CL36_RXSM_ONEHOT_STS1r_CL36_RXSM_ONEHOT_LATCHED_HI_STATUSf_GET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_CL36_RXSM_ONEHOT_LATCHED_HI_STATUSf_GET
#define CL36_RXSM_ONEHOT_STS1r_CL36_RXSM_ONEHOT_LATCHED_HI_STATUSf_SET BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r_CL36_RXSM_ONEHOT_LATCHED_HI_STATUSf_SET
#define READ_CL36_RXSM_ONEHOT_STS1r BCMI_QTC_XGXS_READ_CL36_RXSM_ONEHOT_STS1r
#define WRITE_CL36_RXSM_ONEHOT_STS1r BCMI_QTC_XGXS_WRITE_CL36_RXSM_ONEHOT_STS1r
#define MODIFY_CL36_RXSM_ONEHOT_STS1r BCMI_QTC_XGXS_MODIFY_CL36_RXSM_ONEHOT_STS1r
#define READLN_CL36_RXSM_ONEHOT_STS1r BCMI_QTC_XGXS_READLN_CL36_RXSM_ONEHOT_STS1r
#define WRITELN_CL36_RXSM_ONEHOT_STS1r BCMI_QTC_XGXS_WRITELN_CL36_RXSM_ONEHOT_STS1r
#define WRITEALL_CL36_RXSM_ONEHOT_STS1r BCMI_QTC_XGXS_WRITEALL_CL36_RXSM_ONEHOT_STS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL36_RXSM_ONEHOT_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  BERCNT0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc176
 * DESC:     bercount register0
 * SIZE:     32
 * FIELDS:
 *     BER_COUNT_SP0    For cl36 - This field is the 8b/10b symbol error counter that increments1. upon detecting symbol error (due to invalid symbol or disparity error)2. when comma aligns on the wrong boundaryThe error conditions are detected only when cl36 sync_status is asserted.The counter saturates at 8'hFF and clears on read.
 *     BER_COUNT_SP1    
 */
#define BCMI_QTC_XGXS_BERCNT0r (0x0000c176 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_BERCNT0r_SIZE 4

/*
 * This structure should be used to declare and program BERCNT0.
 */
typedef union BCMI_QTC_XGXS_BERCNT0r_s {
	uint32_t v[1];
	uint32_t bercnt0[1];
	uint32_t _bercnt0;
} BCMI_QTC_XGXS_BERCNT0r_t;

#define BCMI_QTC_XGXS_BERCNT0r_CLR(r) (r).bercnt0[0] = 0
#define BCMI_QTC_XGXS_BERCNT0r_SET(r,d) (r).bercnt0[0] = d
#define BCMI_QTC_XGXS_BERCNT0r_GET(r) (r).bercnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP1f_GET(r) ((((r).bercnt0[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP1f_SET(r,f) (r).bercnt0[0]=(((r).bercnt0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP0f_GET(r) (((r).bercnt0[0]) & 0xff)
#define BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP0f_SET(r,f) (r).bercnt0[0]=(((r).bercnt0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access BERCNT0.
 */
#define BCMI_QTC_XGXS_READ_BERCNT0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_BERCNT0r,(_r._bercnt0))
#define BCMI_QTC_XGXS_WRITE_BERCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT0r,(_r._bercnt0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_BERCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT0r,(_r._bercnt0))
#define BCMI_QTC_XGXS_READLN_BERCNT0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_BERCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._bercnt0))
#define BCMI_QTC_XGXS_WRITELN_BERCNT0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._bercnt0))
#define BCMI_QTC_XGXS_WRITEALL_BERCNT0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._bercnt0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BERCNT0r BCMI_QTC_XGXS_BERCNT0r
#define BERCNT0r_SIZE BCMI_QTC_XGXS_BERCNT0r_SIZE
typedef BCMI_QTC_XGXS_BERCNT0r_t BERCNT0r_t;
#define BERCNT0r_CLR BCMI_QTC_XGXS_BERCNT0r_CLR
#define BERCNT0r_SET BCMI_QTC_XGXS_BERCNT0r_SET
#define BERCNT0r_GET BCMI_QTC_XGXS_BERCNT0r_GET
#define BERCNT0r_BER_COUNT_SP1f_GET BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP1f_GET
#define BERCNT0r_BER_COUNT_SP1f_SET BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP1f_SET
#define BERCNT0r_BER_COUNT_SP0f_GET BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP0f_GET
#define BERCNT0r_BER_COUNT_SP0f_SET BCMI_QTC_XGXS_BERCNT0r_BER_COUNT_SP0f_SET
#define READ_BERCNT0r BCMI_QTC_XGXS_READ_BERCNT0r
#define WRITE_BERCNT0r BCMI_QTC_XGXS_WRITE_BERCNT0r
#define MODIFY_BERCNT0r BCMI_QTC_XGXS_MODIFY_BERCNT0r
#define READLN_BERCNT0r BCMI_QTC_XGXS_READLN_BERCNT0r
#define WRITELN_BERCNT0r BCMI_QTC_XGXS_WRITELN_BERCNT0r
#define WRITEALL_BERCNT0r BCMI_QTC_XGXS_WRITEALL_BERCNT0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_BERCNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  BERCNT1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc177
 * DESC:     bercount register1
 * SIZE:     32
 * FIELDS:
 *     BER_COUNT_SP2    
 *     BER_COUNT_SP3    
 */
#define BCMI_QTC_XGXS_BERCNT1r (0x0000c177 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_BERCNT1r_SIZE 4

/*
 * This structure should be used to declare and program BERCNT1.
 */
typedef union BCMI_QTC_XGXS_BERCNT1r_s {
	uint32_t v[1];
	uint32_t bercnt1[1];
	uint32_t _bercnt1;
} BCMI_QTC_XGXS_BERCNT1r_t;

#define BCMI_QTC_XGXS_BERCNT1r_CLR(r) (r).bercnt1[0] = 0
#define BCMI_QTC_XGXS_BERCNT1r_SET(r,d) (r).bercnt1[0] = d
#define BCMI_QTC_XGXS_BERCNT1r_GET(r) (r).bercnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP3f_GET(r) ((((r).bercnt1[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP3f_SET(r,f) (r).bercnt1[0]=(((r).bercnt1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP2f_GET(r) (((r).bercnt1[0]) & 0xff)
#define BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP2f_SET(r,f) (r).bercnt1[0]=(((r).bercnt1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access BERCNT1.
 */
#define BCMI_QTC_XGXS_READ_BERCNT1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_BERCNT1r,(_r._bercnt1))
#define BCMI_QTC_XGXS_WRITE_BERCNT1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT1r,(_r._bercnt1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_BERCNT1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT1r,(_r._bercnt1))
#define BCMI_QTC_XGXS_READLN_BERCNT1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_BERCNT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._bercnt1))
#define BCMI_QTC_XGXS_WRITELN_BERCNT1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._bercnt1))
#define BCMI_QTC_XGXS_WRITEALL_BERCNT1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_BERCNT1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._bercnt1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define BERCNT1r BCMI_QTC_XGXS_BERCNT1r
#define BERCNT1r_SIZE BCMI_QTC_XGXS_BERCNT1r_SIZE
typedef BCMI_QTC_XGXS_BERCNT1r_t BERCNT1r_t;
#define BERCNT1r_CLR BCMI_QTC_XGXS_BERCNT1r_CLR
#define BERCNT1r_SET BCMI_QTC_XGXS_BERCNT1r_SET
#define BERCNT1r_GET BCMI_QTC_XGXS_BERCNT1r_GET
#define BERCNT1r_BER_COUNT_SP3f_GET BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP3f_GET
#define BERCNT1r_BER_COUNT_SP3f_SET BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP3f_SET
#define BERCNT1r_BER_COUNT_SP2f_GET BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP2f_GET
#define BERCNT1r_BER_COUNT_SP2f_SET BCMI_QTC_XGXS_BERCNT1r_BER_COUNT_SP2f_SET
#define READ_BERCNT1r BCMI_QTC_XGXS_READ_BERCNT1r
#define WRITE_BERCNT1r BCMI_QTC_XGXS_WRITE_BERCNT1r
#define MODIFY_BERCNT1r BCMI_QTC_XGXS_MODIFY_BERCNT1r
#define READLN_BERCNT1r BCMI_QTC_XGXS_READLN_BERCNT1r
#define WRITELN_BERCNT1r BCMI_QTC_XGXS_WRITELN_BERCNT1r
#define WRITEALL_BERCNT1r BCMI_QTC_XGXS_WRITEALL_BERCNT1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_BERCNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PCS_LATCH_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc178
 * DESC:     Misc link status indication - latched
 * SIZE:     32
 * FIELDS:
 *     SYNC_STATUS_LL_SP0 PER sub port: Sync Status indicator has transitioned low since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     SYNC_STATUS_LH_SP0 PER sub port: Sync Status indicator has transitioned high since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     LINK_STATUS_LL_SP0 PER sub port: Link Status indicator has transitioned low since last readClear on read
 *     LINK_STATUS_LH_SP0 PER sub port: Link Status indicator has transitioned high since last readClear on read
 *     SYNC_STATUS_LL_SP1 PER sub port: Sync Status indicator has transitioned low since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     SYNC_STATUS_LH_SP1 PER sub port: Sync Status indicator has transitioned high since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     LINK_STATUS_LL_SP1 PER sub port: Link Status indicator has transitioned low since last readClear on read
 *     LINK_STATUS_LH_SP1 PER sub port: Link Status indicator has transitioned high since last readClear on read
 *     SYNC_STATUS_LL_SP2 PER sub port: Sync Status indicator has transitioned low since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     SYNC_STATUS_LH_SP2 PER sub port: Sync Status indicator has transitioned high since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     LINK_STATUS_LL_SP2 PER sub port: Link Status indicator has transitioned low since last readClear on read
 *     LINK_STATUS_LH_SP2 PER sub port: Link Status indicator has transitioned high since last readClear on read
 *     SYNC_STATUS_LL_SP3 PER sub port: Sync Status indicator has transitioned low since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     SYNC_STATUS_LH_SP3 PER sub port: Sync Status indicator has transitioned high since last read.sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     LINK_STATUS_LL_SP3 PER sub port: Link Status indicator has transitioned low since last readClear on read
 *     LINK_STATUS_LH_SP3 PER sub port: Link Status indicator has transitioned high since last readClear on read
 */
#define BCMI_QTC_XGXS_PCS_LATCH_STSr (0x0000c178 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LATCH_STS.
 */
typedef union BCMI_QTC_XGXS_PCS_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t pcs_latch_sts[1];
	uint32_t _pcs_latch_sts;
} BCMI_QTC_XGXS_PCS_LATCH_STSr_t;

#define BCMI_QTC_XGXS_PCS_LATCH_STSr_CLR(r) (r).pcs_latch_sts[0] = 0
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SET(r,d) (r).pcs_latch_sts[0] = d
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_GET(r) (r).pcs_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP3f_GET(r) ((((r).pcs_latch_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP3f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP3f_GET(r) ((((r).pcs_latch_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP3f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP3f_GET(r) ((((r).pcs_latch_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP3f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP3f_GET(r) ((((r).pcs_latch_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP3f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP2f_GET(r) ((((r).pcs_latch_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP2f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP2f_GET(r) ((((r).pcs_latch_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP2f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP2f_GET(r) ((((r).pcs_latch_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP2f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP2f_GET(r) ((((r).pcs_latch_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP2f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP1f_GET(r) ((((r).pcs_latch_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP1f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP1f_GET(r) ((((r).pcs_latch_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP1f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP1f_GET(r) ((((r).pcs_latch_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP1f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP1f_GET(r) ((((r).pcs_latch_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP1f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP0f_GET(r) ((((r).pcs_latch_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP0f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP0f_GET(r) ((((r).pcs_latch_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP0f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP0f_GET(r) ((((r).pcs_latch_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP0f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP0f_GET(r) (((r).pcs_latch_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP0f_SET(r,f) (r).pcs_latch_sts[0]=(((r).pcs_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PCS_LATCH_STS.
 */
#define BCMI_QTC_XGXS_READ_PCS_LATCH_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PCS_LATCH_STSr,(_r._pcs_latch_sts))
#define BCMI_QTC_XGXS_WRITE_PCS_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LATCH_STSr,(_r._pcs_latch_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PCS_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LATCH_STSr,(_r._pcs_latch_sts))
#define BCMI_QTC_XGXS_READLN_PCS_LATCH_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PCS_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pcs_latch_sts))
#define BCMI_QTC_XGXS_WRITELN_PCS_LATCH_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pcs_latch_sts))
#define BCMI_QTC_XGXS_WRITEALL_PCS_LATCH_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pcs_latch_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_LATCH_STSr BCMI_QTC_XGXS_PCS_LATCH_STSr
#define PCS_LATCH_STSr_SIZE BCMI_QTC_XGXS_PCS_LATCH_STSr_SIZE
typedef BCMI_QTC_XGXS_PCS_LATCH_STSr_t PCS_LATCH_STSr_t;
#define PCS_LATCH_STSr_CLR BCMI_QTC_XGXS_PCS_LATCH_STSr_CLR
#define PCS_LATCH_STSr_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SET
#define PCS_LATCH_STSr_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_GET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP3f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP3f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP3f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP3f_SET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP3f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP3f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP3f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP3f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP3f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP3f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP3f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP3f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP3f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP3f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP3f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP3f_SET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP2f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP2f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP2f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP2f_SET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP2f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP2f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP2f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP2f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP2f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP2f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP2f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP2f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP2f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP2f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP2f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP2f_SET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP1f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP1f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP1f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP1f_SET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP1f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP1f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP1f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP1f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP1f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP1f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP1f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP1f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP1f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP1f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP1f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP1f_SET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP0f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP0f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LH_SP0f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LH_SP0f_SET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP0f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP0f_GET
#define PCS_LATCH_STSr_LINK_STATUS_LL_SP0f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_LINK_STATUS_LL_SP0f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP0f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP0f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LH_SP0f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LH_SP0f_SET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP0f_GET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP0f_GET
#define PCS_LATCH_STSr_SYNC_STATUS_LL_SP0f_SET BCMI_QTC_XGXS_PCS_LATCH_STSr_SYNC_STATUS_LL_SP0f_SET
#define READ_PCS_LATCH_STSr BCMI_QTC_XGXS_READ_PCS_LATCH_STSr
#define WRITE_PCS_LATCH_STSr BCMI_QTC_XGXS_WRITE_PCS_LATCH_STSr
#define MODIFY_PCS_LATCH_STSr BCMI_QTC_XGXS_MODIFY_PCS_LATCH_STSr
#define READLN_PCS_LATCH_STSr BCMI_QTC_XGXS_READLN_PCS_LATCH_STSr
#define WRITELN_PCS_LATCH_STSr BCMI_QTC_XGXS_WRITELN_PCS_LATCH_STSr
#define WRITEALL_PCS_LATCH_STSr BCMI_QTC_XGXS_WRITEALL_PCS_LATCH_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PCS_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PCS_LIVE_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc179
 * DESC:     Misc link status indication - live
 * SIZE:     32
 * FIELDS:
 *     SYNC_STATUS_SP0  PER sub port: Live Sync Status indicator for cl36.
 *     LINK_STATUS_SP0  PER sub port: Live Link Status indicator
 *     SYNC_STATUS_SP1  PER sub port: Live Sync Status indicator for cl36.
 *     LINK_STATUS_SP1  PER sub port: Live Link Status indicator
 *     SYNC_STATUS_SP2  PER sub port: Live Sync Status indicator for cl36.
 *     LINK_STATUS_SP2  PER sub port: Live Link Status indicator
 *     SYNC_STATUS_SP3  PER sub port: Live Sync Status indicator for cl36.
 *     LINK_STATUS_SP3  PER sub port: Live Link Status indicator
 */
#define BCMI_QTC_XGXS_PCS_LIVE_STSr (0x0000c179 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LIVE_STS.
 */
typedef union BCMI_QTC_XGXS_PCS_LIVE_STSr_s {
	uint32_t v[1];
	uint32_t pcs_live_sts[1];
	uint32_t _pcs_live_sts;
} BCMI_QTC_XGXS_PCS_LIVE_STSr_t;

#define BCMI_QTC_XGXS_PCS_LIVE_STSr_CLR(r) (r).pcs_live_sts[0] = 0
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SET(r,d) (r).pcs_live_sts[0] = d
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_GET(r) (r).pcs_live_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP3f_GET(r) ((((r).pcs_live_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP3f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP3f_GET(r) ((((r).pcs_live_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP3f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP2f_GET(r) ((((r).pcs_live_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP2f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP2f_GET(r) ((((r).pcs_live_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP2f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP1f_GET(r) ((((r).pcs_live_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP1f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP1f_GET(r) ((((r).pcs_live_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP1f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP0f_GET(r) ((((r).pcs_live_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP0f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP0f_GET(r) (((r).pcs_live_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP0f_SET(r,f) (r).pcs_live_sts[0]=(((r).pcs_live_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PCS_LIVE_STS.
 */
#define BCMI_QTC_XGXS_READ_PCS_LIVE_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PCS_LIVE_STSr,(_r._pcs_live_sts))
#define BCMI_QTC_XGXS_WRITE_PCS_LIVE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LIVE_STSr,(_r._pcs_live_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PCS_LIVE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LIVE_STSr,(_r._pcs_live_sts))
#define BCMI_QTC_XGXS_READLN_PCS_LIVE_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PCS_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pcs_live_sts))
#define BCMI_QTC_XGXS_WRITELN_PCS_LIVE_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pcs_live_sts))
#define BCMI_QTC_XGXS_WRITEALL_PCS_LIVE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PCS_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pcs_live_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_LIVE_STSr BCMI_QTC_XGXS_PCS_LIVE_STSr
#define PCS_LIVE_STSr_SIZE BCMI_QTC_XGXS_PCS_LIVE_STSr_SIZE
typedef BCMI_QTC_XGXS_PCS_LIVE_STSr_t PCS_LIVE_STSr_t;
#define PCS_LIVE_STSr_CLR BCMI_QTC_XGXS_PCS_LIVE_STSr_CLR
#define PCS_LIVE_STSr_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_SET
#define PCS_LIVE_STSr_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_GET
#define PCS_LIVE_STSr_LINK_STATUS_SP3f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP3f_GET
#define PCS_LIVE_STSr_LINK_STATUS_SP3f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP3f_SET
#define PCS_LIVE_STSr_SYNC_STATUS_SP3f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP3f_GET
#define PCS_LIVE_STSr_SYNC_STATUS_SP3f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP3f_SET
#define PCS_LIVE_STSr_LINK_STATUS_SP2f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP2f_GET
#define PCS_LIVE_STSr_LINK_STATUS_SP2f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP2f_SET
#define PCS_LIVE_STSr_SYNC_STATUS_SP2f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP2f_GET
#define PCS_LIVE_STSr_SYNC_STATUS_SP2f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP2f_SET
#define PCS_LIVE_STSr_LINK_STATUS_SP1f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP1f_GET
#define PCS_LIVE_STSr_LINK_STATUS_SP1f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP1f_SET
#define PCS_LIVE_STSr_SYNC_STATUS_SP1f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP1f_GET
#define PCS_LIVE_STSr_SYNC_STATUS_SP1f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP1f_SET
#define PCS_LIVE_STSr_LINK_STATUS_SP0f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP0f_GET
#define PCS_LIVE_STSr_LINK_STATUS_SP0f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_LINK_STATUS_SP0f_SET
#define PCS_LIVE_STSr_SYNC_STATUS_SP0f_GET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP0f_GET
#define PCS_LIVE_STSr_SYNC_STATUS_SP0f_SET BCMI_QTC_XGXS_PCS_LIVE_STSr_SYNC_STATUS_SP0f_SET
#define READ_PCS_LIVE_STSr BCMI_QTC_XGXS_READ_PCS_LIVE_STSr
#define WRITE_PCS_LIVE_STSr BCMI_QTC_XGXS_WRITE_PCS_LIVE_STSr
#define MODIFY_PCS_LIVE_STSr BCMI_QTC_XGXS_MODIFY_PCS_LIVE_STSr
#define READLN_PCS_LIVE_STSr BCMI_QTC_XGXS_READLN_PCS_LIVE_STSr
#define WRITELN_PCS_LIVE_STSr BCMI_QTC_XGXS_WRITELN_PCS_LIVE_STSr
#define WRITEALL_PCS_LIVE_STSr BCMI_QTC_XGXS_WRITEALL_PCS_LIVE_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PCS_LIVE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP0_ENS
 * BLOCKS:   AN_X4_ABILITIES_SP0
 * REGADDR:  0xc200
 * DESC:     AN ENABLES
 * SIZE:     32
 * FIELDS:
 *     CL37_AN_RESTART  CL37 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL37 AN
 *     SGMII_TO_CL37_AUTO_ENABLE SGMII to IEEE CL37 Auto-Detect EnableWhen doing Cisco SGMII auto-negotiation, if the other device is doing IEEECL37 auto-negotiation, then restart auto-negotiation in IEEE CL37 mode.
 *     CL37_BAM_TO_SGMII_AUTO_ENABLE Broadcom to SGMII Auto-Detect EnableWhen doing Broadcom CL37 auto-negotioation, if the other device is doing CiscoSGMII auto-negotiation, then restart auto-negotiation in Cisco SGMII mode.
 *     CL37_ENABLE      IEEE CL37 Auto-Negotiation Mode Enable
 *     CL37_SGMII_ENABLE Cisco SGMII Auto-Negotiation Mode Enable
 *     CL37_BAM_ENABLE  Broadcom CL37 Auto-Negotiation Mode Enable
 *     DISABLE_REMOTE_FAULT_REPORTING 1 = disable automatic reporting of remote faults, such as auto-negotiation error0 = report remote fault status to link partner via auto-negotiation when fiber mode is selected. (SGMII does not support remote faults)
 *     QSGMII_EN        Sets the AN logic in QSGMII Mode and enables all 4 AN for subport independently. Default is SGMII Mode (i.e. Subport 0 AN is running
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr (0x0000c200 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP0_ENS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp0_ens[1];
	uint32_t _an_x4_abi_sp0_ens;
} BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CLR(r) (r).an_x4_abi_sp0_ens[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SET(r,d) (r).an_x4_abi_sp0_ens[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_GET(r) (r).an_x4_abi_sp0_ens[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_QSGMII_ENf_GET(r) ((((r).an_x4_abi_sp0_ens[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_QSGMII_ENf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET(r) ((((r).an_x4_abi_sp0_ens[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_ENABLEf_GET(r) ((((r).an_x4_abi_sp0_ens[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_ENABLEf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_SGMII_ENABLEf_GET(r) ((((r).an_x4_abi_sp0_ens[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_SGMII_ENABLEf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_ENABLEf_GET(r) ((((r).an_x4_abi_sp0_ens[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_ENABLEf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp0_ens[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp0_ens[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_AN_RESTARTf_GET(r) (((r).an_x4_abi_sp0_ens[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_AN_RESTARTf_SET(r,f) (r).an_x4_abi_sp0_ens[0]=(((r).an_x4_abi_sp0_ens[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP0_ENS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_ENSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr,(_r._an_x4_abi_sp0_ens))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr,(_r._an_x4_abi_sp0_ens)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr,(_r._an_x4_abi_sp0_ens))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_ENSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_ens))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_ENSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_ens))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp0_ens))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP0_ENSr BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr
#define AN_X4_ABI_SP0_ENSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_t AN_X4_ABI_SP0_ENSr_t;
#define AN_X4_ABI_SP0_ENSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CLR
#define AN_X4_ABI_SP0_ENSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SET
#define AN_X4_ABI_SP0_ENSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_GET
#define AN_X4_ABI_SP0_ENSr_QSGMII_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_QSGMII_ENf_GET
#define AN_X4_ABI_SP0_ENSr_QSGMII_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_QSGMII_ENf_SET
#define AN_X4_ABI_SP0_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET
#define AN_X4_ABI_SP0_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET
#define AN_X4_ABI_SP0_ENSr_CL37_BAM_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_ENABLEf_GET
#define AN_X4_ABI_SP0_ENSr_CL37_BAM_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_ENABLEf_SET
#define AN_X4_ABI_SP0_ENSr_CL37_SGMII_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_SGMII_ENABLEf_GET
#define AN_X4_ABI_SP0_ENSr_CL37_SGMII_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_SGMII_ENABLEf_SET
#define AN_X4_ABI_SP0_ENSr_CL37_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_ENABLEf_GET
#define AN_X4_ABI_SP0_ENSr_CL37_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_ENABLEf_SET
#define AN_X4_ABI_SP0_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP0_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP0_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP0_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP0_ENSr_CL37_AN_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_AN_RESTARTf_GET
#define AN_X4_ABI_SP0_ENSr_CL37_AN_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr_CL37_AN_RESTARTf_SET
#define READ_AN_X4_ABI_SP0_ENSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_ENSr
#define WRITE_AN_X4_ABI_SP0_ENSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_ENSr
#define MODIFY_AN_X4_ABI_SP0_ENSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_ENSr
#define READLN_AN_X4_ABI_SP0_ENSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_ENSr
#define WRITELN_AN_X4_ABI_SP0_ENSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_ENSr
#define WRITEALL_AN_X4_ABI_SP0_ENSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_ENSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP0_ENSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP0
 * REGADDR:  0xc201
 * DESC:     CL37 BASE PAGE ABILITIES
 * SIZE:     32
 * FIELDS:
 *     SGMII_SPEED      11 = Reserved 10 = SGMII 1000 Mb/s 01 = SGMII 100 Mb/s 00 = SGMII 10 Mb/s
 *     SGMII_FULL_DUPLEX 
 *     CL37_FULL_DUPLEX 
 *     CL37_HALF_DUPLEX 
 *     CL37_PAUSE       Pause Ability[7:6]00 - No PAUSE ability10 - Asymmetric-toward-link-partner PAUSE ability01 - Symmetric PAUSE ability11 - Both symmetric and asymmetric-toward-local-device PAUSE ability
 *     CL37_NEXT_PAGE   
 *     SGMII_MASTER_MODE Set the current device as SGMII master for AN, only for debug.
 *     CL37_AN_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by remote partner.Do not set this bit for BAM modes.
 *     CL37_SW_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by SW.Do not set this bit when enabling AN for the first time. Only set it before restarting AN.Do not set this bit for BAM modes.
 *     CL37_AN_DISABLE_RESET_DISABLE Disable full pipeline reset when AN is being disabled by SW.Please set this bit for IEEE37 and SGMII AN. Do not set this bit for BAM modes.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr (0x0000c201 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp0_loc_dev_cl37_base_abil[1];
	uint32_t _an_x4_abi_sp0_loc_dev_cl37_base_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CLR(r) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SET(r,d) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_GET(r) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET(r) (((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp0_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp0_loc_dev_cl37_base_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp0_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp0_loc_dev_cl37_base_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_t AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_t;
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CLR
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET
#define READ_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr
#define WRITE_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr
#define MODIFY_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr
#define READLN_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr
#define WRITELN_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr
#define WRITEALL_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BASE_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP0
 * REGADDR:  0xc202
 * DESC:     CL37 BAM ABILITIES
 * SIZE:     32
 * FIELDS:
 *     OVER1G_PAGE_COUNT 
 *     OVER1G_ABILITY   
 *     CL37_BAM_CODE    
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr (0x0000c202 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp0_loc_dev_cl37_bam_abil[1];
	uint32_t _an_x4_abi_sp0_loc_dev_cl37_bam_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CLR(r) (r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_SET(r,d) (r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_GET(r) (r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0]) >> 3) & 0x1ff)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3)) | (511 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET(r) ((((r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET(r) (((r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp0_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp0_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp0_loc_dev_cl37_bam_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp0_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp0_loc_dev_cl37_bam_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_t AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_t;
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CLR
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET
#define AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET
#define READ_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr
#define WRITE_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr
#define MODIFY_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr
#define READLN_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr
#define WRITELN_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr
#define WRITEALL_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_CL37_BAM_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0
 * BLOCKS:   AN_X4_ABILITIES_SP0
 * REGADDR:  0xc203
 * DESC:     Cl37 OVER1G ABILITIES REG 0
 * SIZE:     32
 * FIELDS:
 *     BAM_2P5GBASE_X   MP1024 UP1.0
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r (0x0000c203 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp0_loc_dev_over1g_abil0[1];
	uint32_t _an_x4_abi_sp0_loc_dev_over1g_abil0;
} BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_CLR(r) (r).an_x4_abi_sp0_loc_dev_over1g_abil0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_SET(r,d) (r).an_x4_abi_sp0_loc_dev_over1g_abil0[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_GET(r) (r).an_x4_abi_sp0_loc_dev_over1g_abil0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET(r) (((r).an_x4_abi_sp0_loc_dev_over1g_abil0[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET(r,f) (r).an_x4_abi_sp0_loc_dev_over1g_abil0[0]=(((r).an_x4_abi_sp0_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp0_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp0_loc_dev_over1g_abil0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp0_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp0_loc_dev_over1g_abil0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r
#define AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_t AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_t;
#define AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_CLR
#define AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_SET
#define AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_GET
#define AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET
#define AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET
#define READ_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r
#define WRITE_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r
#define MODIFY_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r
#define READLN_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r
#define WRITELN_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r
#define WRITEALL_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP0_LOC_DEV_OVER1G_ABIL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP0_CTLS
 * BLOCKS:   AN_X4_ABILITIES_SP0
 * REGADDR:  0xc208
 * DESC:     AN MISC CONTROLS
 * SIZE:     32
 * FIELDS:
 *     AN_GOOD_TRAP     
 *     AN_GOOD_CHECK_TRAP 
 *     LINKFAILTIMER_DIS 
 *     LINKFAILTIMERQUAL_EN 
 *     AN_FAIL_COUNT_LIMIT Number of times AN may retry after AN failureIt indicates the max value of an_fail_count register
 *     OUI_CONTROL      bit 1: require programmable OUI to detect CL37 BAMbit 0: advertise programmable OUI in CL37 BAM
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr (0x0000c208 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP0_CTLS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp0_ctls[1];
	uint32_t _an_x4_abi_sp0_ctls;
} BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_CLR(r) (r).an_x4_abi_sp0_ctls[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_SET(r,d) (r).an_x4_abi_sp0_ctls[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_GET(r) (r).an_x4_abi_sp0_ctls[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_OUI_CONTROLf_GET(r) ((((r).an_x4_abi_sp0_ctls[0]) >> 10) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_OUI_CONTROLf_SET(r,f) (r).an_x4_abi_sp0_ctls[0]=(((r).an_x4_abi_sp0_ctls[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).an_x4_abi_sp0_ctls[0]) >> 6) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).an_x4_abi_sp0_ctls[0]=(((r).an_x4_abi_sp0_ctls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).an_x4_abi_sp0_ctls[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).an_x4_abi_sp0_ctls[0]=(((r).an_x4_abi_sp0_ctls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMER_DISf_GET(r) ((((r).an_x4_abi_sp0_ctls[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMER_DISf_SET(r,f) (r).an_x4_abi_sp0_ctls[0]=(((r).an_x4_abi_sp0_ctls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).an_x4_abi_sp0_ctls[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).an_x4_abi_sp0_ctls[0]=(((r).an_x4_abi_sp0_ctls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_TRAPf_GET(r) ((((r).an_x4_abi_sp0_ctls[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_TRAPf_SET(r,f) (r).an_x4_abi_sp0_ctls[0]=(((r).an_x4_abi_sp0_ctls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access AN_X4_ABI_SP0_CTLS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_CTLSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr,(_r._an_x4_abi_sp0_ctls))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr,(_r._an_x4_abi_sp0_ctls)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr,(_r._an_x4_abi_sp0_ctls))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_CTLSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_ctls))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_CTLSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp0_ctls))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp0_ctls))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP0_CTLSr BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr
#define AN_X4_ABI_SP0_CTLSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_t AN_X4_ABI_SP0_CTLSr_t;
#define AN_X4_ABI_SP0_CTLSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_CLR
#define AN_X4_ABI_SP0_CTLSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_SET
#define AN_X4_ABI_SP0_CTLSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_GET
#define AN_X4_ABI_SP0_CTLSr_OUI_CONTROLf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_OUI_CONTROLf_GET
#define AN_X4_ABI_SP0_CTLSr_OUI_CONTROLf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_OUI_CONTROLf_SET
#define AN_X4_ABI_SP0_CTLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_FAIL_COUNT_LIMITf_GET
#define AN_X4_ABI_SP0_CTLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_FAIL_COUNT_LIMITf_SET
#define AN_X4_ABI_SP0_CTLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMERQUAL_ENf_GET
#define AN_X4_ABI_SP0_CTLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMERQUAL_ENf_SET
#define AN_X4_ABI_SP0_CTLSr_LINKFAILTIMER_DISf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMER_DISf_GET
#define AN_X4_ABI_SP0_CTLSr_LINKFAILTIMER_DISf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_LINKFAILTIMER_DISf_SET
#define AN_X4_ABI_SP0_CTLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_CHECK_TRAPf_GET
#define AN_X4_ABI_SP0_CTLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_CHECK_TRAPf_SET
#define AN_X4_ABI_SP0_CTLSr_AN_GOOD_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_TRAPf_GET
#define AN_X4_ABI_SP0_CTLSr_AN_GOOD_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr_AN_GOOD_TRAPf_SET
#define READ_AN_X4_ABI_SP0_CTLSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP0_CTLSr
#define WRITE_AN_X4_ABI_SP0_CTLSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP0_CTLSr
#define MODIFY_AN_X4_ABI_SP0_CTLSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP0_CTLSr
#define READLN_AN_X4_ABI_SP0_CTLSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP0_CTLSr
#define WRITELN_AN_X4_ABI_SP0_CTLSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP0_CTLSr
#define WRITEALL_AN_X4_ABI_SP0_CTLSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP0_CTLSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP0_CTLSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP1_ENS
 * BLOCKS:   AN_X4_ABILITIES_SP1
 * REGADDR:  0xc210
 * DESC:     AN ENABLES
 * SIZE:     32
 * FIELDS:
 *     CL37_AN_RESTART  CL37 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL37 AN
 *     SGMII_TO_CL37_AUTO_ENABLE SGMII to IEEE CL37 Auto-Detect EnableWhen doing Cisco SGMII auto-negotiation, if the other device is doing IEEECL37 auto-negotiation, then restart auto-negotiation in IEEE CL37 mode.
 *     CL37_BAM_TO_SGMII_AUTO_ENABLE Broadcom to SGMII Auto-Detect EnableWhen doing Broadcom CL37 auto-negotioation, if the other device is doing CiscoSGMII auto-negotiation, then restart auto-negotiation in Cisco SGMII mode.
 *     CL37_ENABLE      IEEE CL37 Auto-Negotiation Mode Enable
 *     CL37_SGMII_ENABLE Cisco SGMII Auto-Negotiation Mode Enable
 *     CL37_BAM_ENABLE  Broadcom CL37 Auto-Negotiation Mode Enable
 *     DISABLE_REMOTE_FAULT_REPORTING 1 = disable automatic reporting of remote faults, such as auto-negotiation error0 = report remote fault status to link partner via auto-negotiation when fiber mode is selected. (SGMII does not support remote faults)
 *     QSGMII_EN        Sets the AN logic in QSGMII Mode and enables all 4 AN for subport independently. Default is SGMII Mode (i.e. Subport 0 AN is running
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr (0x0000c210 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP1_ENS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp1_ens[1];
	uint32_t _an_x4_abi_sp1_ens;
} BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CLR(r) (r).an_x4_abi_sp1_ens[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SET(r,d) (r).an_x4_abi_sp1_ens[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_GET(r) (r).an_x4_abi_sp1_ens[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_QSGMII_ENf_GET(r) ((((r).an_x4_abi_sp1_ens[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_QSGMII_ENf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET(r) ((((r).an_x4_abi_sp1_ens[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_ENABLEf_GET(r) ((((r).an_x4_abi_sp1_ens[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_ENABLEf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_SGMII_ENABLEf_GET(r) ((((r).an_x4_abi_sp1_ens[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_SGMII_ENABLEf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_ENABLEf_GET(r) ((((r).an_x4_abi_sp1_ens[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_ENABLEf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp1_ens[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp1_ens[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_AN_RESTARTf_GET(r) (((r).an_x4_abi_sp1_ens[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_AN_RESTARTf_SET(r,f) (r).an_x4_abi_sp1_ens[0]=(((r).an_x4_abi_sp1_ens[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP1_ENS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_ENSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr,(_r._an_x4_abi_sp1_ens))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr,(_r._an_x4_abi_sp1_ens)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr,(_r._an_x4_abi_sp1_ens))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_ENSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_ens))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_ENSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_ens))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp1_ens))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP1_ENSr BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr
#define AN_X4_ABI_SP1_ENSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_t AN_X4_ABI_SP1_ENSr_t;
#define AN_X4_ABI_SP1_ENSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CLR
#define AN_X4_ABI_SP1_ENSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SET
#define AN_X4_ABI_SP1_ENSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_GET
#define AN_X4_ABI_SP1_ENSr_QSGMII_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_QSGMII_ENf_GET
#define AN_X4_ABI_SP1_ENSr_QSGMII_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_QSGMII_ENf_SET
#define AN_X4_ABI_SP1_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET
#define AN_X4_ABI_SP1_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET
#define AN_X4_ABI_SP1_ENSr_CL37_BAM_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_ENABLEf_GET
#define AN_X4_ABI_SP1_ENSr_CL37_BAM_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_ENABLEf_SET
#define AN_X4_ABI_SP1_ENSr_CL37_SGMII_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_SGMII_ENABLEf_GET
#define AN_X4_ABI_SP1_ENSr_CL37_SGMII_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_SGMII_ENABLEf_SET
#define AN_X4_ABI_SP1_ENSr_CL37_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_ENABLEf_GET
#define AN_X4_ABI_SP1_ENSr_CL37_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_ENABLEf_SET
#define AN_X4_ABI_SP1_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP1_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP1_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP1_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP1_ENSr_CL37_AN_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_AN_RESTARTf_GET
#define AN_X4_ABI_SP1_ENSr_CL37_AN_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr_CL37_AN_RESTARTf_SET
#define READ_AN_X4_ABI_SP1_ENSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_ENSr
#define WRITE_AN_X4_ABI_SP1_ENSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_ENSr
#define MODIFY_AN_X4_ABI_SP1_ENSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_ENSr
#define READLN_AN_X4_ABI_SP1_ENSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_ENSr
#define WRITELN_AN_X4_ABI_SP1_ENSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_ENSr
#define WRITEALL_AN_X4_ABI_SP1_ENSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_ENSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP1_ENSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP1
 * REGADDR:  0xc211
 * DESC:     CL37 BASE PAGE ABILITIES
 * SIZE:     32
 * FIELDS:
 *     SGMII_SPEED      11 = Reserved 10 = SGMII 1000 Mb/s 01 = SGMII 100 Mb/s 00 = SGMII 10 Mb/s
 *     SGMII_FULL_DUPLEX 
 *     CL37_FULL_DUPLEX 
 *     CL37_HALF_DUPLEX 
 *     CL37_PAUSE       Pause Ability[7:6]00 - No PAUSE ability10 - Asymmetric-toward-link-partner PAUSE ability01 - Symmetric PAUSE ability11 - Both symmetric and asymmetric-toward-local-device PAUSE ability
 *     CL37_NEXT_PAGE   
 *     SGMII_MASTER_MODE Set the current device as SGMII master for AN, only for debug.
 *     CL37_AN_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by remote partner.Do not set this bit for BAM modes.
 *     CL37_SW_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by SW.Do not set this bit when enabling AN for the first time. Only set it before restarting AN.Do not set this bit for BAM modes.
 *     CL37_AN_DISABLE_RESET_DISABLE Disable full pipeline reset when AN is being disabled by SW.Please set this bit for IEEE37 and SGMII AN. Do not set this bit for BAM modes.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr (0x0000c211 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp1_loc_dev_cl37_base_abil[1];
	uint32_t _an_x4_abi_sp1_loc_dev_cl37_base_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CLR(r) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SET(r,d) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_GET(r) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET(r) (((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp1_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp1_loc_dev_cl37_base_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp1_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp1_loc_dev_cl37_base_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_t AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_t;
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CLR
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET
#define READ_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr
#define WRITE_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr
#define MODIFY_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr
#define READLN_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr
#define WRITELN_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr
#define WRITEALL_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BASE_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP1
 * REGADDR:  0xc212
 * DESC:     CL37 BAM ABILITIES
 * SIZE:     32
 * FIELDS:
 *     OVER1G_PAGE_COUNT 
 *     OVER1G_ABILITY   
 *     CL37_BAM_CODE    
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr (0x0000c212 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp1_loc_dev_cl37_bam_abil[1];
	uint32_t _an_x4_abi_sp1_loc_dev_cl37_bam_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CLR(r) (r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_SET(r,d) (r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_GET(r) (r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0]) >> 3) & 0x1ff)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3)) | (511 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET(r) ((((r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET(r) (((r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp1_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp1_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp1_loc_dev_cl37_bam_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp1_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp1_loc_dev_cl37_bam_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_t AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_t;
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CLR
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET
#define AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET
#define READ_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr
#define WRITE_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr
#define MODIFY_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr
#define READLN_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr
#define WRITELN_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr
#define WRITEALL_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_CL37_BAM_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0
 * BLOCKS:   AN_X4_ABILITIES_SP1
 * REGADDR:  0xc213
 * DESC:     Cl37 OVER1G ABILITIES REG 0
 * SIZE:     32
 * FIELDS:
 *     BAM_2P5GBASE_X   MP1024 UP1.0
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r (0x0000c213 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp1_loc_dev_over1g_abil0[1];
	uint32_t _an_x4_abi_sp1_loc_dev_over1g_abil0;
} BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_CLR(r) (r).an_x4_abi_sp1_loc_dev_over1g_abil0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_SET(r,d) (r).an_x4_abi_sp1_loc_dev_over1g_abil0[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_GET(r) (r).an_x4_abi_sp1_loc_dev_over1g_abil0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET(r) (((r).an_x4_abi_sp1_loc_dev_over1g_abil0[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET(r,f) (r).an_x4_abi_sp1_loc_dev_over1g_abil0[0]=(((r).an_x4_abi_sp1_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp1_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp1_loc_dev_over1g_abil0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp1_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp1_loc_dev_over1g_abil0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r
#define AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_t AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_t;
#define AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_CLR
#define AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_SET
#define AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_GET
#define AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET
#define AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET
#define READ_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r
#define WRITE_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r
#define MODIFY_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r
#define READLN_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r
#define WRITELN_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r
#define WRITEALL_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP1_LOC_DEV_OVER1G_ABIL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP1_CTLS
 * BLOCKS:   AN_X4_ABILITIES_SP1
 * REGADDR:  0xc218
 * DESC:     AN MISC CONTROLS
 * SIZE:     32
 * FIELDS:
 *     AN_GOOD_TRAP     
 *     AN_GOOD_CHECK_TRAP 
 *     LINKFAILTIMER_DIS 
 *     LINKFAILTIMERQUAL_EN 
 *     AN_FAIL_COUNT_LIMIT Number of times AN may retry after AN failureIt indicates the max value of an_fail_count register
 *     OUI_CONTROL      bit 1: require programmable OUI to detect CL37 BAMbit 0: advertise programmable OUI in CL37 BAM
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr (0x0000c218 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP1_CTLS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp1_ctls[1];
	uint32_t _an_x4_abi_sp1_ctls;
} BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_CLR(r) (r).an_x4_abi_sp1_ctls[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_SET(r,d) (r).an_x4_abi_sp1_ctls[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_GET(r) (r).an_x4_abi_sp1_ctls[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_OUI_CONTROLf_GET(r) ((((r).an_x4_abi_sp1_ctls[0]) >> 10) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_OUI_CONTROLf_SET(r,f) (r).an_x4_abi_sp1_ctls[0]=(((r).an_x4_abi_sp1_ctls[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).an_x4_abi_sp1_ctls[0]) >> 6) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).an_x4_abi_sp1_ctls[0]=(((r).an_x4_abi_sp1_ctls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).an_x4_abi_sp1_ctls[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).an_x4_abi_sp1_ctls[0]=(((r).an_x4_abi_sp1_ctls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMER_DISf_GET(r) ((((r).an_x4_abi_sp1_ctls[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMER_DISf_SET(r,f) (r).an_x4_abi_sp1_ctls[0]=(((r).an_x4_abi_sp1_ctls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).an_x4_abi_sp1_ctls[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).an_x4_abi_sp1_ctls[0]=(((r).an_x4_abi_sp1_ctls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_TRAPf_GET(r) ((((r).an_x4_abi_sp1_ctls[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_TRAPf_SET(r,f) (r).an_x4_abi_sp1_ctls[0]=(((r).an_x4_abi_sp1_ctls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access AN_X4_ABI_SP1_CTLS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_CTLSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr,(_r._an_x4_abi_sp1_ctls))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr,(_r._an_x4_abi_sp1_ctls)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr,(_r._an_x4_abi_sp1_ctls))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_CTLSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_ctls))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_CTLSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp1_ctls))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp1_ctls))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP1_CTLSr BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr
#define AN_X4_ABI_SP1_CTLSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_t AN_X4_ABI_SP1_CTLSr_t;
#define AN_X4_ABI_SP1_CTLSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_CLR
#define AN_X4_ABI_SP1_CTLSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_SET
#define AN_X4_ABI_SP1_CTLSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_GET
#define AN_X4_ABI_SP1_CTLSr_OUI_CONTROLf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_OUI_CONTROLf_GET
#define AN_X4_ABI_SP1_CTLSr_OUI_CONTROLf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_OUI_CONTROLf_SET
#define AN_X4_ABI_SP1_CTLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_FAIL_COUNT_LIMITf_GET
#define AN_X4_ABI_SP1_CTLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_FAIL_COUNT_LIMITf_SET
#define AN_X4_ABI_SP1_CTLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMERQUAL_ENf_GET
#define AN_X4_ABI_SP1_CTLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMERQUAL_ENf_SET
#define AN_X4_ABI_SP1_CTLSr_LINKFAILTIMER_DISf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMER_DISf_GET
#define AN_X4_ABI_SP1_CTLSr_LINKFAILTIMER_DISf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_LINKFAILTIMER_DISf_SET
#define AN_X4_ABI_SP1_CTLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_CHECK_TRAPf_GET
#define AN_X4_ABI_SP1_CTLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_CHECK_TRAPf_SET
#define AN_X4_ABI_SP1_CTLSr_AN_GOOD_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_TRAPf_GET
#define AN_X4_ABI_SP1_CTLSr_AN_GOOD_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr_AN_GOOD_TRAPf_SET
#define READ_AN_X4_ABI_SP1_CTLSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP1_CTLSr
#define WRITE_AN_X4_ABI_SP1_CTLSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP1_CTLSr
#define MODIFY_AN_X4_ABI_SP1_CTLSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP1_CTLSr
#define READLN_AN_X4_ABI_SP1_CTLSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP1_CTLSr
#define WRITELN_AN_X4_ABI_SP1_CTLSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP1_CTLSr
#define WRITEALL_AN_X4_ABI_SP1_CTLSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP1_CTLSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP1_CTLSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP2_ENS
 * BLOCKS:   AN_X4_ABILITIES_SP2
 * REGADDR:  0xc220
 * DESC:     AN ENABLES
 * SIZE:     32
 * FIELDS:
 *     CL37_AN_RESTART  CL37 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL37 AN
 *     SGMII_TO_CL37_AUTO_ENABLE SGMII to IEEE CL37 Auto-Detect EnableWhen doing Cisco SGMII auto-negotiation, if the other device is doing IEEECL37 auto-negotiation, then restart auto-negotiation in IEEE CL37 mode.
 *     CL37_BAM_TO_SGMII_AUTO_ENABLE Broadcom to SGMII Auto-Detect EnableWhen doing Broadcom CL37 auto-negotioation, if the other device is doing CiscoSGMII auto-negotiation, then restart auto-negotiation in Cisco SGMII mode.
 *     CL37_ENABLE      IEEE CL37 Auto-Negotiation Mode Enable
 *     CL37_SGMII_ENABLE Cisco SGMII Auto-Negotiation Mode Enable
 *     CL37_BAM_ENABLE  Broadcom CL37 Auto-Negotiation Mode Enable
 *     DISABLE_REMOTE_FAULT_REPORTING 1 = disable automatic reporting of remote faults, such as auto-negotiation error0 = report remote fault status to link partner via auto-negotiation when fiber mode is selected. (SGMII does not support remote faults)
 *     QSGMII_EN        Sets the AN logic in QSGMII Mode and enables all 4 AN for subport independently. Default is SGMII Mode (i.e. Subport 0 AN is running
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr (0x0000c220 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP2_ENS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp2_ens[1];
	uint32_t _an_x4_abi_sp2_ens;
} BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CLR(r) (r).an_x4_abi_sp2_ens[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SET(r,d) (r).an_x4_abi_sp2_ens[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_GET(r) (r).an_x4_abi_sp2_ens[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_QSGMII_ENf_GET(r) ((((r).an_x4_abi_sp2_ens[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_QSGMII_ENf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET(r) ((((r).an_x4_abi_sp2_ens[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_ENABLEf_GET(r) ((((r).an_x4_abi_sp2_ens[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_ENABLEf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_SGMII_ENABLEf_GET(r) ((((r).an_x4_abi_sp2_ens[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_SGMII_ENABLEf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_ENABLEf_GET(r) ((((r).an_x4_abi_sp2_ens[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_ENABLEf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp2_ens[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp2_ens[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_AN_RESTARTf_GET(r) (((r).an_x4_abi_sp2_ens[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_AN_RESTARTf_SET(r,f) (r).an_x4_abi_sp2_ens[0]=(((r).an_x4_abi_sp2_ens[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP2_ENS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_ENSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr,(_r._an_x4_abi_sp2_ens))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr,(_r._an_x4_abi_sp2_ens)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr,(_r._an_x4_abi_sp2_ens))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_ENSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_ens))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_ENSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_ens))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp2_ens))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP2_ENSr BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr
#define AN_X4_ABI_SP2_ENSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_t AN_X4_ABI_SP2_ENSr_t;
#define AN_X4_ABI_SP2_ENSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CLR
#define AN_X4_ABI_SP2_ENSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SET
#define AN_X4_ABI_SP2_ENSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_GET
#define AN_X4_ABI_SP2_ENSr_QSGMII_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_QSGMII_ENf_GET
#define AN_X4_ABI_SP2_ENSr_QSGMII_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_QSGMII_ENf_SET
#define AN_X4_ABI_SP2_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET
#define AN_X4_ABI_SP2_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET
#define AN_X4_ABI_SP2_ENSr_CL37_BAM_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_ENABLEf_GET
#define AN_X4_ABI_SP2_ENSr_CL37_BAM_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_ENABLEf_SET
#define AN_X4_ABI_SP2_ENSr_CL37_SGMII_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_SGMII_ENABLEf_GET
#define AN_X4_ABI_SP2_ENSr_CL37_SGMII_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_SGMII_ENABLEf_SET
#define AN_X4_ABI_SP2_ENSr_CL37_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_ENABLEf_GET
#define AN_X4_ABI_SP2_ENSr_CL37_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_ENABLEf_SET
#define AN_X4_ABI_SP2_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP2_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP2_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP2_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP2_ENSr_CL37_AN_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_AN_RESTARTf_GET
#define AN_X4_ABI_SP2_ENSr_CL37_AN_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr_CL37_AN_RESTARTf_SET
#define READ_AN_X4_ABI_SP2_ENSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_ENSr
#define WRITE_AN_X4_ABI_SP2_ENSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_ENSr
#define MODIFY_AN_X4_ABI_SP2_ENSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_ENSr
#define READLN_AN_X4_ABI_SP2_ENSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_ENSr
#define WRITELN_AN_X4_ABI_SP2_ENSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_ENSr
#define WRITEALL_AN_X4_ABI_SP2_ENSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_ENSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP2_ENSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP2
 * REGADDR:  0xc221
 * DESC:     CL37 BASE PAGE ABILITIES
 * SIZE:     32
 * FIELDS:
 *     SGMII_SPEED      11 = Reserved 10 = SGMII 1000 Mb/s 01 = SGMII 100 Mb/s 00 = SGMII 10 Mb/s
 *     SGMII_FULL_DUPLEX 
 *     CL37_FULL_DUPLEX 
 *     CL37_HALF_DUPLEX 
 *     CL37_PAUSE       Pause Ability[7:6]00 - No PAUSE ability10 - Asymmetric-toward-link-partner PAUSE ability01 - Symmetric PAUSE ability11 - Both symmetric and asymmetric-toward-local-device PAUSE ability
 *     CL37_NEXT_PAGE   
 *     SGMII_MASTER_MODE Set the current device as SGMII master for AN, only for debug.
 *     CL37_AN_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by remote partner.Do not set this bit for BAM modes.
 *     CL37_SW_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by SW.Do not set this bit when enabling AN for the first time. Only set it before restarting AN.Do not set this bit for BAM modes.
 *     CL37_AN_DISABLE_RESET_DISABLE Disable full pipeline reset when AN is being disabled by SW.Please set this bit for IEEE37 and SGMII AN. Do not set this bit for BAM modes.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr (0x0000c221 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp2_loc_dev_cl37_base_abil[1];
	uint32_t _an_x4_abi_sp2_loc_dev_cl37_base_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CLR(r) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SET(r,d) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_GET(r) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET(r) (((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp2_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp2_loc_dev_cl37_base_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp2_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp2_loc_dev_cl37_base_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_t AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_t;
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CLR
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET
#define READ_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr
#define WRITE_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr
#define MODIFY_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr
#define READLN_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr
#define WRITELN_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr
#define WRITEALL_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BASE_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP2
 * REGADDR:  0xc222
 * DESC:     CL37 BAM ABILITIES
 * SIZE:     32
 * FIELDS:
 *     OVER1G_PAGE_COUNT 
 *     OVER1G_ABILITY   
 *     CL37_BAM_CODE    
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr (0x0000c222 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp2_loc_dev_cl37_bam_abil[1];
	uint32_t _an_x4_abi_sp2_loc_dev_cl37_bam_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CLR(r) (r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_SET(r,d) (r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_GET(r) (r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0]) >> 3) & 0x1ff)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3)) | (511 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET(r) ((((r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET(r) (((r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp2_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp2_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp2_loc_dev_cl37_bam_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp2_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp2_loc_dev_cl37_bam_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_t AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_t;
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CLR
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET
#define AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET
#define READ_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr
#define WRITE_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr
#define MODIFY_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr
#define READLN_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr
#define WRITELN_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr
#define WRITEALL_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_CL37_BAM_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0
 * BLOCKS:   AN_X4_ABILITIES_SP2
 * REGADDR:  0xc223
 * DESC:     Cl37 OVER1G ABILITIES REG 0
 * SIZE:     32
 * FIELDS:
 *     BAM_2P5GBASE_X   MP1024 UP1.0
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r (0x0000c223 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp2_loc_dev_over1g_abil0[1];
	uint32_t _an_x4_abi_sp2_loc_dev_over1g_abil0;
} BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_CLR(r) (r).an_x4_abi_sp2_loc_dev_over1g_abil0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_SET(r,d) (r).an_x4_abi_sp2_loc_dev_over1g_abil0[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_GET(r) (r).an_x4_abi_sp2_loc_dev_over1g_abil0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET(r) (((r).an_x4_abi_sp2_loc_dev_over1g_abil0[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET(r,f) (r).an_x4_abi_sp2_loc_dev_over1g_abil0[0]=(((r).an_x4_abi_sp2_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp2_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp2_loc_dev_over1g_abil0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp2_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp2_loc_dev_over1g_abil0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r
#define AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_t AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_t;
#define AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_CLR
#define AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_SET
#define AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_GET
#define AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET
#define AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET
#define READ_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r
#define WRITE_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r
#define MODIFY_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r
#define READLN_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r
#define WRITELN_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r
#define WRITEALL_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP2_LOC_DEV_OVER1G_ABIL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP2_CTLS
 * BLOCKS:   AN_X4_ABILITIES_SP2
 * REGADDR:  0xc228
 * DESC:     AN MISC CONTROLS
 * SIZE:     32
 * FIELDS:
 *     AN_GOOD_TRAP     
 *     AN_GOOD_CHECK_TRAP 
 *     LINKFAILTIMER_DIS 
 *     LINKFAILTIMERQUAL_EN 
 *     AN_FAIL_COUNT_LIMIT Number of times AN may retry after AN failureIt indicates the max value of an_fail_count register
 *     OUI_CONTROL      bit 1: require programmable OUI to detect CL37 BAMbit 0: advertise programmable OUI in CL37 BAM
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr (0x0000c228 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP2_CTLS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp2_ctls[1];
	uint32_t _an_x4_abi_sp2_ctls;
} BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_CLR(r) (r).an_x4_abi_sp2_ctls[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_SET(r,d) (r).an_x4_abi_sp2_ctls[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_GET(r) (r).an_x4_abi_sp2_ctls[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_OUI_CONTROLf_GET(r) ((((r).an_x4_abi_sp2_ctls[0]) >> 10) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_OUI_CONTROLf_SET(r,f) (r).an_x4_abi_sp2_ctls[0]=(((r).an_x4_abi_sp2_ctls[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).an_x4_abi_sp2_ctls[0]) >> 6) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).an_x4_abi_sp2_ctls[0]=(((r).an_x4_abi_sp2_ctls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).an_x4_abi_sp2_ctls[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).an_x4_abi_sp2_ctls[0]=(((r).an_x4_abi_sp2_ctls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMER_DISf_GET(r) ((((r).an_x4_abi_sp2_ctls[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMER_DISf_SET(r,f) (r).an_x4_abi_sp2_ctls[0]=(((r).an_x4_abi_sp2_ctls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).an_x4_abi_sp2_ctls[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).an_x4_abi_sp2_ctls[0]=(((r).an_x4_abi_sp2_ctls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_TRAPf_GET(r) ((((r).an_x4_abi_sp2_ctls[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_TRAPf_SET(r,f) (r).an_x4_abi_sp2_ctls[0]=(((r).an_x4_abi_sp2_ctls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access AN_X4_ABI_SP2_CTLS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_CTLSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr,(_r._an_x4_abi_sp2_ctls))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr,(_r._an_x4_abi_sp2_ctls)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr,(_r._an_x4_abi_sp2_ctls))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_CTLSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_ctls))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_CTLSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp2_ctls))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp2_ctls))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP2_CTLSr BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr
#define AN_X4_ABI_SP2_CTLSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_t AN_X4_ABI_SP2_CTLSr_t;
#define AN_X4_ABI_SP2_CTLSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_CLR
#define AN_X4_ABI_SP2_CTLSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_SET
#define AN_X4_ABI_SP2_CTLSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_GET
#define AN_X4_ABI_SP2_CTLSr_OUI_CONTROLf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_OUI_CONTROLf_GET
#define AN_X4_ABI_SP2_CTLSr_OUI_CONTROLf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_OUI_CONTROLf_SET
#define AN_X4_ABI_SP2_CTLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_FAIL_COUNT_LIMITf_GET
#define AN_X4_ABI_SP2_CTLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_FAIL_COUNT_LIMITf_SET
#define AN_X4_ABI_SP2_CTLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMERQUAL_ENf_GET
#define AN_X4_ABI_SP2_CTLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMERQUAL_ENf_SET
#define AN_X4_ABI_SP2_CTLSr_LINKFAILTIMER_DISf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMER_DISf_GET
#define AN_X4_ABI_SP2_CTLSr_LINKFAILTIMER_DISf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_LINKFAILTIMER_DISf_SET
#define AN_X4_ABI_SP2_CTLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_CHECK_TRAPf_GET
#define AN_X4_ABI_SP2_CTLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_CHECK_TRAPf_SET
#define AN_X4_ABI_SP2_CTLSr_AN_GOOD_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_TRAPf_GET
#define AN_X4_ABI_SP2_CTLSr_AN_GOOD_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr_AN_GOOD_TRAPf_SET
#define READ_AN_X4_ABI_SP2_CTLSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP2_CTLSr
#define WRITE_AN_X4_ABI_SP2_CTLSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP2_CTLSr
#define MODIFY_AN_X4_ABI_SP2_CTLSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP2_CTLSr
#define READLN_AN_X4_ABI_SP2_CTLSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP2_CTLSr
#define WRITELN_AN_X4_ABI_SP2_CTLSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP2_CTLSr
#define WRITEALL_AN_X4_ABI_SP2_CTLSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP2_CTLSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP2_CTLSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP3_ENS
 * BLOCKS:   AN_X4_ABILITIES_SP3
 * REGADDR:  0xc230
 * DESC:     AN ENABLES
 * SIZE:     32
 * FIELDS:
 *     CL37_AN_RESTART  CL37 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL37 AN
 *     SGMII_TO_CL37_AUTO_ENABLE SGMII to IEEE CL37 Auto-Detect EnableWhen doing Cisco SGMII auto-negotiation, if the other device is doing IEEECL37 auto-negotiation, then restart auto-negotiation in IEEE CL37 mode.
 *     CL37_BAM_TO_SGMII_AUTO_ENABLE Broadcom to SGMII Auto-Detect EnableWhen doing Broadcom CL37 auto-negotioation, if the other device is doing CiscoSGMII auto-negotiation, then restart auto-negotiation in Cisco SGMII mode.
 *     CL37_ENABLE      IEEE CL37 Auto-Negotiation Mode Enable
 *     CL37_SGMII_ENABLE Cisco SGMII Auto-Negotiation Mode Enable
 *     CL37_BAM_ENABLE  Broadcom CL37 Auto-Negotiation Mode Enable
 *     DISABLE_REMOTE_FAULT_REPORTING 1 = disable automatic reporting of remote faults, such as auto-negotiation error0 = report remote fault status to link partner via auto-negotiation when fiber mode is selected. (SGMII does not support remote faults)
 *     QSGMII_EN        Sets the AN logic in QSGMII Mode and enables all 4 AN for subport independently. Default is SGMII Mode (i.e. Subport 0 AN is running
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr (0x0000c230 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP3_ENS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp3_ens[1];
	uint32_t _an_x4_abi_sp3_ens;
} BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CLR(r) (r).an_x4_abi_sp3_ens[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SET(r,d) (r).an_x4_abi_sp3_ens[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_GET(r) (r).an_x4_abi_sp3_ens[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_QSGMII_ENf_GET(r) ((((r).an_x4_abi_sp3_ens[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_QSGMII_ENf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET(r) ((((r).an_x4_abi_sp3_ens[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_ENABLEf_GET(r) ((((r).an_x4_abi_sp3_ens[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_ENABLEf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_SGMII_ENABLEf_GET(r) ((((r).an_x4_abi_sp3_ens[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_SGMII_ENABLEf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_ENABLEf_GET(r) ((((r).an_x4_abi_sp3_ens[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_ENABLEf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp3_ens[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET(r) ((((r).an_x4_abi_sp3_ens[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_AN_RESTARTf_GET(r) (((r).an_x4_abi_sp3_ens[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_AN_RESTARTf_SET(r,f) (r).an_x4_abi_sp3_ens[0]=(((r).an_x4_abi_sp3_ens[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP3_ENS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_ENSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr,(_r._an_x4_abi_sp3_ens))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr,(_r._an_x4_abi_sp3_ens)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr,(_r._an_x4_abi_sp3_ens))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_ENSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_ens))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_ENSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_ens))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_ENSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp3_ens))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP3_ENSr BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr
#define AN_X4_ABI_SP3_ENSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_t AN_X4_ABI_SP3_ENSr_t;
#define AN_X4_ABI_SP3_ENSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CLR
#define AN_X4_ABI_SP3_ENSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SET
#define AN_X4_ABI_SP3_ENSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_GET
#define AN_X4_ABI_SP3_ENSr_QSGMII_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_QSGMII_ENf_GET
#define AN_X4_ABI_SP3_ENSr_QSGMII_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_QSGMII_ENf_SET
#define AN_X4_ABI_SP3_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_GET
#define AN_X4_ABI_SP3_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_DISABLE_REMOTE_FAULT_REPORTINGf_SET
#define AN_X4_ABI_SP3_ENSr_CL37_BAM_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_ENABLEf_GET
#define AN_X4_ABI_SP3_ENSr_CL37_BAM_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_ENABLEf_SET
#define AN_X4_ABI_SP3_ENSr_CL37_SGMII_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_SGMII_ENABLEf_GET
#define AN_X4_ABI_SP3_ENSr_CL37_SGMII_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_SGMII_ENABLEf_SET
#define AN_X4_ABI_SP3_ENSr_CL37_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_ENABLEf_GET
#define AN_X4_ABI_SP3_ENSr_CL37_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_ENABLEf_SET
#define AN_X4_ABI_SP3_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP3_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP3_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET
#define AN_X4_ABI_SP3_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET
#define AN_X4_ABI_SP3_ENSr_CL37_AN_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_AN_RESTARTf_GET
#define AN_X4_ABI_SP3_ENSr_CL37_AN_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr_CL37_AN_RESTARTf_SET
#define READ_AN_X4_ABI_SP3_ENSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_ENSr
#define WRITE_AN_X4_ABI_SP3_ENSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_ENSr
#define MODIFY_AN_X4_ABI_SP3_ENSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_ENSr
#define READLN_AN_X4_ABI_SP3_ENSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_ENSr
#define WRITELN_AN_X4_ABI_SP3_ENSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_ENSr
#define WRITEALL_AN_X4_ABI_SP3_ENSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_ENSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP3_ENSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP3
 * REGADDR:  0xc231
 * DESC:     CL37 BASE PAGE ABILITIES
 * SIZE:     32
 * FIELDS:
 *     SGMII_SPEED      11 = Reserved 10 = SGMII 1000 Mb/s 01 = SGMII 100 Mb/s 00 = SGMII 10 Mb/s
 *     SGMII_FULL_DUPLEX 
 *     CL37_FULL_DUPLEX 
 *     CL37_HALF_DUPLEX 
 *     CL37_PAUSE       Pause Ability[7:6]00 - No PAUSE ability10 - Asymmetric-toward-link-partner PAUSE ability01 - Symmetric PAUSE ability11 - Both symmetric and asymmetric-toward-local-device PAUSE ability
 *     CL37_NEXT_PAGE   
 *     SGMII_MASTER_MODE Set the current device as SGMII master for AN, only for debug.
 *     CL37_AN_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by remote partner.Do not set this bit for BAM modes.
 *     CL37_SW_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by SW.Do not set this bit when enabling AN for the first time. Only set it before restarting AN.Do not set this bit for BAM modes.
 *     CL37_AN_DISABLE_RESET_DISABLE Disable full pipeline reset when AN is being disabled by SW.Please set this bit for IEEE37 and SGMII AN. Do not set this bit for BAM modes.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr (0x0000c231 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp3_loc_dev_cl37_base_abil[1];
	uint32_t _an_x4_abi_sp3_loc_dev_cl37_base_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CLR(r) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SET(r,d) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_GET(r) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET(r) (((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp3_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp3_loc_dev_cl37_base_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_abi_sp3_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_loc_dev_cl37_base_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp3_loc_dev_cl37_base_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_t AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_t;
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CLR
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_DISABLE_RESET_DISABLEf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET
#define READ_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr
#define WRITE_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr
#define MODIFY_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr
#define READLN_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr
#define WRITELN_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr
#define WRITEALL_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BASE_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES_SP3
 * REGADDR:  0xc232
 * DESC:     CL37 BAM ABILITIES
 * SIZE:     32
 * FIELDS:
 *     OVER1G_PAGE_COUNT 
 *     OVER1G_ABILITY   
 *     CL37_BAM_CODE    
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr (0x0000c232 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABIL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp3_loc_dev_cl37_bam_abil[1];
	uint32_t _an_x4_abi_sp3_loc_dev_cl37_bam_abil;
} BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CLR(r) (r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_SET(r,d) (r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_GET(r) (r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0]) >> 3) & 0x1ff)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3)) | (511 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET(r) ((((r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET(r) (((r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0]=(((r).an_x4_abi_sp3_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABIL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp3_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp3_loc_dev_cl37_bam_abil)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_abi_sp3_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_loc_dev_cl37_bam_abil))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp3_loc_dev_cl37_bam_abil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_t AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_t;
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CLR
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET
#define AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET
#define READ_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr
#define WRITE_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr
#define MODIFY_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr
#define READLN_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr
#define WRITELN_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr
#define WRITEALL_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_CL37_BAM_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0
 * BLOCKS:   AN_X4_ABILITIES_SP3
 * REGADDR:  0xc233
 * DESC:     Cl37 OVER1G ABILITIES REG 0
 * SIZE:     32
 * FIELDS:
 *     BAM_2P5GBASE_X   MP1024 UP1.0
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r (0x0000c233 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp3_loc_dev_over1g_abil0[1];
	uint32_t _an_x4_abi_sp3_loc_dev_over1g_abil0;
} BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_CLR(r) (r).an_x4_abi_sp3_loc_dev_over1g_abil0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_SET(r,d) (r).an_x4_abi_sp3_loc_dev_over1g_abil0[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_GET(r) (r).an_x4_abi_sp3_loc_dev_over1g_abil0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET(r) (((r).an_x4_abi_sp3_loc_dev_over1g_abil0[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET(r,f) (r).an_x4_abi_sp3_loc_dev_over1g_abil0[0]=(((r).an_x4_abi_sp3_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp3_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp3_loc_dev_over1g_abil0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_abi_sp3_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_loc_dev_over1g_abil0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp3_loc_dev_over1g_abil0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r
#define AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_t AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_t;
#define AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_CLR
#define AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_SET
#define AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_GET
#define AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET
#define AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET
#define READ_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r
#define WRITE_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r
#define MODIFY_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r
#define READLN_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r
#define WRITELN_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r
#define WRITEALL_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP3_LOC_DEV_OVER1G_ABIL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_ABI_SP3_CTLS
 * BLOCKS:   AN_X4_ABILITIES_SP3
 * REGADDR:  0xc238
 * DESC:     AN MISC CONTROLS
 * SIZE:     32
 * FIELDS:
 *     AN_GOOD_TRAP     
 *     AN_GOOD_CHECK_TRAP 
 *     LINKFAILTIMER_DIS 
 *     LINKFAILTIMERQUAL_EN 
 *     AN_FAIL_COUNT_LIMIT Number of times AN may retry after AN failureIt indicates the max value of an_fail_count register
 *     OUI_CONTROL      bit 1: require programmable OUI to detect CL37 BAMbit 0: advertise programmable OUI in CL37 BAM
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr (0x0000c238 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ABI_SP3_CTLS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_s {
	uint32_t v[1];
	uint32_t an_x4_abi_sp3_ctls[1];
	uint32_t _an_x4_abi_sp3_ctls;
} BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_t;

#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_CLR(r) (r).an_x4_abi_sp3_ctls[0] = 0
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_SET(r,d) (r).an_x4_abi_sp3_ctls[0] = d
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_GET(r) (r).an_x4_abi_sp3_ctls[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_OUI_CONTROLf_GET(r) ((((r).an_x4_abi_sp3_ctls[0]) >> 10) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_OUI_CONTROLf_SET(r,f) (r).an_x4_abi_sp3_ctls[0]=(((r).an_x4_abi_sp3_ctls[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).an_x4_abi_sp3_ctls[0]) >> 6) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).an_x4_abi_sp3_ctls[0]=(((r).an_x4_abi_sp3_ctls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).an_x4_abi_sp3_ctls[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).an_x4_abi_sp3_ctls[0]=(((r).an_x4_abi_sp3_ctls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMER_DISf_GET(r) ((((r).an_x4_abi_sp3_ctls[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMER_DISf_SET(r,f) (r).an_x4_abi_sp3_ctls[0]=(((r).an_x4_abi_sp3_ctls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).an_x4_abi_sp3_ctls[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).an_x4_abi_sp3_ctls[0]=(((r).an_x4_abi_sp3_ctls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_TRAPf_GET(r) ((((r).an_x4_abi_sp3_ctls[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_TRAPf_SET(r,f) (r).an_x4_abi_sp3_ctls[0]=(((r).an_x4_abi_sp3_ctls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access AN_X4_ABI_SP3_CTLS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_CTLSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr,(_r._an_x4_abi_sp3_ctls))
#define BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr,(_r._an_x4_abi_sp3_ctls)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr,(_r._an_x4_abi_sp3_ctls))
#define BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_CTLSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_ctls))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_CTLSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_abi_sp3_ctls))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_CTLSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_abi_sp3_ctls))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ABI_SP3_CTLSr BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr
#define AN_X4_ABI_SP3_CTLSr_SIZE BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_t AN_X4_ABI_SP3_CTLSr_t;
#define AN_X4_ABI_SP3_CTLSr_CLR BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_CLR
#define AN_X4_ABI_SP3_CTLSr_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_SET
#define AN_X4_ABI_SP3_CTLSr_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_GET
#define AN_X4_ABI_SP3_CTLSr_OUI_CONTROLf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_OUI_CONTROLf_GET
#define AN_X4_ABI_SP3_CTLSr_OUI_CONTROLf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_OUI_CONTROLf_SET
#define AN_X4_ABI_SP3_CTLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_FAIL_COUNT_LIMITf_GET
#define AN_X4_ABI_SP3_CTLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_FAIL_COUNT_LIMITf_SET
#define AN_X4_ABI_SP3_CTLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMERQUAL_ENf_GET
#define AN_X4_ABI_SP3_CTLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMERQUAL_ENf_SET
#define AN_X4_ABI_SP3_CTLSr_LINKFAILTIMER_DISf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMER_DISf_GET
#define AN_X4_ABI_SP3_CTLSr_LINKFAILTIMER_DISf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_LINKFAILTIMER_DISf_SET
#define AN_X4_ABI_SP3_CTLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_CHECK_TRAPf_GET
#define AN_X4_ABI_SP3_CTLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_CHECK_TRAPf_SET
#define AN_X4_ABI_SP3_CTLSr_AN_GOOD_TRAPf_GET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_TRAPf_GET
#define AN_X4_ABI_SP3_CTLSr_AN_GOOD_TRAPf_SET BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr_AN_GOOD_TRAPf_SET
#define READ_AN_X4_ABI_SP3_CTLSr BCMI_QTC_XGXS_READ_AN_X4_ABI_SP3_CTLSr
#define WRITE_AN_X4_ABI_SP3_CTLSr BCMI_QTC_XGXS_WRITE_AN_X4_ABI_SP3_CTLSr
#define MODIFY_AN_X4_ABI_SP3_CTLSr BCMI_QTC_XGXS_MODIFY_AN_X4_ABI_SP3_CTLSr
#define READLN_AN_X4_ABI_SP3_CTLSr BCMI_QTC_XGXS_READLN_AN_X4_ABI_SP3_CTLSr
#define WRITELN_AN_X4_ABI_SP3_CTLSr BCMI_QTC_XGXS_WRITELN_AN_X4_ABI_SP3_CTLSr
#define WRITEALL_AN_X4_ABI_SP3_CTLSr BCMI_QTC_XGXS_WRITEALL_AN_X4_ABI_SP3_CTLSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_ABI_SP3_CTLSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP5_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc240
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[23:13]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r (0x0000c240 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP5_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp5_up1[1];
	uint32_t _an_x4_lp_sp0_lp_mp5_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_CLR(r) (r).an_x4_lp_sp0_lp_mp5_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_SET(r,d) (r).an_x4_lp_sp0_lp_mp5_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_GET(r) (r).an_x4_lp_sp0_lp_mp5_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp5_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp5_up1[0]=(((r).an_x4_lp_sp0_lp_mp5_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP5_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r,(_r._an_x4_lp_sp0_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r,(_r._an_x4_lp_sp0_lp_mp5_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r,(_r._an_x4_lp_sp0_lp_mp5_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp5_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP5_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r
#define AN_X4_LP_SP0_LP_MP5_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_t AN_X4_LP_SP0_LP_MP5_UP1r_t;
#define AN_X4_LP_SP0_LP_MP5_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_CLR
#define AN_X4_LP_SP0_LP_MP5_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_SET
#define AN_X4_LP_SP0_LP_MP5_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_GET
#define AN_X4_LP_SP0_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP5_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP1r
#define WRITE_AN_X4_LP_SP0_LP_MP5_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP1r
#define MODIFY_AN_X4_LP_SP0_LP_MP5_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP1r
#define READLN_AN_X4_LP_SP0_LP_MP5_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP1r
#define WRITELN_AN_X4_LP_SP0_LP_MP5_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP1r
#define WRITEALL_AN_X4_LP_SP0_LP_MP5_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP5_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc241
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[12:2]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r (0x0000c241 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP5_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp5_up2[1];
	uint32_t _an_x4_lp_sp0_lp_mp5_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_CLR(r) (r).an_x4_lp_sp0_lp_mp5_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_SET(r,d) (r).an_x4_lp_sp0_lp_mp5_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_GET(r) (r).an_x4_lp_sp0_lp_mp5_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp5_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp5_up2[0]=(((r).an_x4_lp_sp0_lp_mp5_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP5_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r,(_r._an_x4_lp_sp0_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r,(_r._an_x4_lp_sp0_lp_mp5_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r,(_r._an_x4_lp_sp0_lp_mp5_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp5_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP5_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r
#define AN_X4_LP_SP0_LP_MP5_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_t AN_X4_LP_SP0_LP_MP5_UP2r_t;
#define AN_X4_LP_SP0_LP_MP5_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_CLR
#define AN_X4_LP_SP0_LP_MP5_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_SET
#define AN_X4_LP_SP0_LP_MP5_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_GET
#define AN_X4_LP_SP0_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP5_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP2r
#define WRITE_AN_X4_LP_SP0_LP_MP5_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP2r
#define MODIFY_AN_X4_LP_SP0_LP_MP5_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP2r
#define READLN_AN_X4_LP_SP0_LP_MP5_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP2r
#define WRITELN_AN_X4_LP_SP0_LP_MP5_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP2r
#define WRITEALL_AN_X4_LP_SP0_LP_MP5_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP5_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc242
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:9      - OUI[1:0]8:0       - User-Defined Code[19:11]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r (0x0000c242 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP5_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp5_up3[1];
	uint32_t _an_x4_lp_sp0_lp_mp5_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_CLR(r) (r).an_x4_lp_sp0_lp_mp5_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_SET(r,d) (r).an_x4_lp_sp0_lp_mp5_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_GET(r) (r).an_x4_lp_sp0_lp_mp5_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp5_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp5_up3[0]=(((r).an_x4_lp_sp0_lp_mp5_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP5_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r,(_r._an_x4_lp_sp0_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r,(_r._an_x4_lp_sp0_lp_mp5_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r,(_r._an_x4_lp_sp0_lp_mp5_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp5_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP5_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r
#define AN_X4_LP_SP0_LP_MP5_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_t AN_X4_LP_SP0_LP_MP5_UP3r_t;
#define AN_X4_LP_SP0_LP_MP5_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_CLR
#define AN_X4_LP_SP0_LP_MP5_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_SET
#define AN_X4_LP_SP0_LP_MP5_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_GET
#define AN_X4_LP_SP0_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP5_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP3r
#define WRITE_AN_X4_LP_SP0_LP_MP5_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP3r
#define MODIFY_AN_X4_LP_SP0_LP_MP5_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP3r
#define READLN_AN_X4_LP_SP0_LP_MP5_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP3r
#define WRITELN_AN_X4_LP_SP0_LP_MP5_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP3r
#define WRITEALL_AN_X4_LP_SP0_LP_MP5_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP5_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc243
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - User-Defined Code[10:0]In Hewlett-Packard auto-neg mode, an OUI[23:0] of 0x643150, andan User-Defined Code[19:0] of 0xABE20 indicate that the device is capable of 20G-KR2.In Broadcom auto-neg mode, User-Defined Code[19:11] contain a BAM code, andUser-Defined Code[10:0] contain BAM abilities.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r (0x0000c243 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP5_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp5_up4[1];
	uint32_t _an_x4_lp_sp0_lp_mp5_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_CLR(r) (r).an_x4_lp_sp0_lp_mp5_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_SET(r,d) (r).an_x4_lp_sp0_lp_mp5_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_GET(r) (r).an_x4_lp_sp0_lp_mp5_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp5_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp5_up4[0]=(((r).an_x4_lp_sp0_lp_mp5_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP5_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r,(_r._an_x4_lp_sp0_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r,(_r._an_x4_lp_sp0_lp_mp5_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r,(_r._an_x4_lp_sp0_lp_mp5_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp5_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP5_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r
#define AN_X4_LP_SP0_LP_MP5_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_t AN_X4_LP_SP0_LP_MP5_UP4r_t;
#define AN_X4_LP_SP0_LP_MP5_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_CLR
#define AN_X4_LP_SP0_LP_MP5_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_SET
#define AN_X4_LP_SP0_LP_MP5_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_GET
#define AN_X4_LP_SP0_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP5_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP5_UP4r
#define WRITE_AN_X4_LP_SP0_LP_MP5_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP5_UP4r
#define MODIFY_AN_X4_LP_SP0_LP_MP5_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP5_UP4r
#define READLN_AN_X4_LP_SP0_LP_MP5_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP5_UP4r
#define WRITELN_AN_X4_LP_SP0_LP_MP5_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP5_UP4r
#define WRITEALL_AN_X4_LP_SP0_LP_MP5_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP5_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP5_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP1024_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc244
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Speed Ability 20G-CX49         - Speed Ability 16G-X48         - Speed Ability 15G-X47         - Speed Ability 13G-X46         - Speed Ability 12.5G-X45         - Speed Ability 12G-X44         - Speed Ability 10G-CX43         - Speed Ability 10G-X42         - Speed Ability 6G-X41         - Speed Ability 5G-X40         - Speed Ability 2.5G-X1
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r (0x0000c244 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP1024_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp1024_up1[1];
	uint32_t _an_x4_lp_sp0_lp_mp1024_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_CLR(r) (r).an_x4_lp_sp0_lp_mp1024_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_SET(r,d) (r).an_x4_lp_sp0_lp_mp1024_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_GET(r) (r).an_x4_lp_sp0_lp_mp1024_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp1024_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp1024_up1[0]=(((r).an_x4_lp_sp0_lp_mp1024_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP1024_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r,(_r._an_x4_lp_sp0_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r,(_r._an_x4_lp_sp0_lp_mp1024_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r,(_r._an_x4_lp_sp0_lp_mp1024_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp1024_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP1024_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r
#define AN_X4_LP_SP0_LP_MP1024_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_t AN_X4_LP_SP0_LP_MP1024_UP1r_t;
#define AN_X4_LP_SP0_LP_MP1024_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_CLR
#define AN_X4_LP_SP0_LP_MP1024_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_SET
#define AN_X4_LP_SP0_LP_MP1024_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_GET
#define AN_X4_LP_SP0_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP1024_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP1r
#define WRITE_AN_X4_LP_SP0_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP1r
#define MODIFY_AN_X4_LP_SP0_LP_MP1024_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP1r
#define READLN_AN_X4_LP_SP0_LP_MP1024_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP1r
#define WRITELN_AN_X4_LP_SP0_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP1r
#define WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP1024_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc245
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Transmitter-Equalization values are valid9:6       - Transmitter-Equalization preemphasis5:3       - Transmitter-Equalization idriver2:0       - Transmitter-Equalization ipredriver
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r (0x0000c245 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP1024_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp1024_up2[1];
	uint32_t _an_x4_lp_sp0_lp_mp1024_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_CLR(r) (r).an_x4_lp_sp0_lp_mp1024_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_SET(r,d) (r).an_x4_lp_sp0_lp_mp1024_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_GET(r) (r).an_x4_lp_sp0_lp_mp1024_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp1024_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp1024_up2[0]=(((r).an_x4_lp_sp0_lp_mp1024_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP1024_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r,(_r._an_x4_lp_sp0_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r,(_r._an_x4_lp_sp0_lp_mp1024_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r,(_r._an_x4_lp_sp0_lp_mp1024_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp1024_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP1024_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r
#define AN_X4_LP_SP0_LP_MP1024_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_t AN_X4_LP_SP0_LP_MP1024_UP2r_t;
#define AN_X4_LP_SP0_LP_MP1024_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_CLR
#define AN_X4_LP_SP0_LP_MP1024_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_SET
#define AN_X4_LP_SP0_LP_MP1024_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_GET
#define AN_X4_LP_SP0_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP1024_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP2r
#define WRITE_AN_X4_LP_SP0_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP2r
#define MODIFY_AN_X4_LP_SP0_LP_MP1024_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP2r
#define READLN_AN_X4_LP_SP0_LP_MP1024_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP2r
#define WRITELN_AN_X4_LP_SP0_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP2r
#define WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP1024_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc246
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 21G-X48         - Speed Ability 25.45G-X47         - Speed Ability 31.5G-X46         - Speed Ability 32.7G5         - Speed Ability 40G-X44:3       - reserved2         - CL72 Training Ability1         - cl74 Forward-Error Correction Ability0         - High-Gig II Ability
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r (0x0000c246 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP1024_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp1024_up3[1];
	uint32_t _an_x4_lp_sp0_lp_mp1024_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_CLR(r) (r).an_x4_lp_sp0_lp_mp1024_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_SET(r,d) (r).an_x4_lp_sp0_lp_mp1024_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_GET(r) (r).an_x4_lp_sp0_lp_mp1024_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp1024_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp1024_up3[0]=(((r).an_x4_lp_sp0_lp_mp1024_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP1024_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r,(_r._an_x4_lp_sp0_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r,(_r._an_x4_lp_sp0_lp_mp1024_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r,(_r._an_x4_lp_sp0_lp_mp1024_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp1024_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP1024_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r
#define AN_X4_LP_SP0_LP_MP1024_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_t AN_X4_LP_SP0_LP_MP1024_UP3r_t;
#define AN_X4_LP_SP0_LP_MP1024_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_CLR
#define AN_X4_LP_SP0_LP_MP1024_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_SET
#define AN_X4_LP_SP0_LP_MP1024_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_GET
#define AN_X4_LP_SP0_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP1024_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP3r
#define WRITE_AN_X4_LP_SP0_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP3r
#define MODIFY_AN_X4_LP_SP0_LP_MP1024_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP3r
#define READLN_AN_X4_LP_SP0_LP_MP1024_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP3r
#define WRITELN_AN_X4_LP_SP0_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP3r
#define WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_MP1024_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc247
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 1G-CX18         - Speed Ability 10G-CX17         - Speed Ability 15.75G-X26         - Speed Ability 20G-CX25         - Speed Ability 20G-X24         - Speed Ability 12.7G-X23         - Speed Ability 10.5G-X22         - Speed Ability 10G-CX21         - Speed Ability 10G-X20         - Speed Ability 20G-X4
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r (0x0000c247 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_MP1024_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_mp1024_up4[1];
	uint32_t _an_x4_lp_sp0_lp_mp1024_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_CLR(r) (r).an_x4_lp_sp0_lp_mp1024_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_SET(r,d) (r).an_x4_lp_sp0_lp_mp1024_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_GET(r) (r).an_x4_lp_sp0_lp_mp1024_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_mp1024_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_mp1024_up4[0]=(((r).an_x4_lp_sp0_lp_mp1024_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_MP1024_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r,(_r._an_x4_lp_sp0_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r,(_r._an_x4_lp_sp0_lp_mp1024_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r,(_r._an_x4_lp_sp0_lp_mp1024_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_mp1024_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_MP1024_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r
#define AN_X4_LP_SP0_LP_MP1024_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_t AN_X4_LP_SP0_LP_MP1024_UP4r_t;
#define AN_X4_LP_SP0_LP_MP1024_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_CLR
#define AN_X4_LP_SP0_LP_MP1024_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_SET
#define AN_X4_LP_SP0_LP_MP1024_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_GET
#define AN_X4_LP_SP0_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_MP1024_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_MP1024_UP4r
#define WRITE_AN_X4_LP_SP0_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_MP1024_UP4r
#define MODIFY_AN_X4_LP_SP0_LP_MP1024_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_MP1024_UP4r
#define READLN_AN_X4_LP_SP0_LP_MP1024_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_MP1024_UP4r
#define WRITELN_AN_X4_LP_SP0_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_MP1024_UP4r
#define WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_MP1024_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_MP1024_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_BASE_PAGE1
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc248
 * DESC:     LINK PARTNER BASE PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE1_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 1CL3715        - Next Page Indication14        - Receive Acknowledge13:12     - Remote Fault Status11:9      - reserved8:7       - Pause Ability6:5       - Duplex Ability4:0       - ReservedSGMII15        - Link Up14        - Receive Acknowledge13        - reserved12        - Duplex Ability11:10     - Speed Ability9:1       - reserved0         - SGMII IndicatorCL7315        - Next Page Indication14        - Receive Acknowledge13        - Remote Fault Status12        - reserved11:10     - Pause Ability9:5       - Echo of Received Nonce4:0       - Selector
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r (0x0000c248 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_BASE_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_base_page1[1];
	uint32_t _an_x4_lp_sp0_lp_base_page1;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_CLR(r) (r).an_x4_lp_sp0_lp_base_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_SET(r,d) (r).an_x4_lp_sp0_lp_base_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_GET(r) (r).an_x4_lp_sp0_lp_base_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_base_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_base_page1[0]=(((r).an_x4_lp_sp0_lp_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_BASE_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r,(_r._an_x4_lp_sp0_lp_base_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r,(_r._an_x4_lp_sp0_lp_base_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r,(_r._an_x4_lp_sp0_lp_base_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_base_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_base_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_base_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_BASE_PAGE1r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r
#define AN_X4_LP_SP0_LP_BASE_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_t AN_X4_LP_SP0_LP_BASE_PAGE1r_t;
#define AN_X4_LP_SP0_LP_BASE_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_CLR
#define AN_X4_LP_SP0_LP_BASE_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_SET
#define AN_X4_LP_SP0_LP_BASE_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_GET
#define AN_X4_LP_SP0_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_BASE_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_BASE_PAGE1r
#define WRITE_AN_X4_LP_SP0_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_BASE_PAGE1r
#define MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE1r
#define READLN_AN_X4_LP_SP0_LP_BASE_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_BASE_PAGE1r
#define WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE1r
#define WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_BASE_PAGE2
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc249
 * DESC:     LINK PARTNER BASE PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE2_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 2CL7315:11      - reserved10         - 100G-CR109         - 40G-CR48         - 40G-KR47         - 10G-KR Ability6         - 10G-KX4 Ability5         - 1G-KX Ability4:0       - Transmit Nonce
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r (0x0000c249 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_BASE_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_base_page2[1];
	uint32_t _an_x4_lp_sp0_lp_base_page2;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_CLR(r) (r).an_x4_lp_sp0_lp_base_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_SET(r,d) (r).an_x4_lp_sp0_lp_base_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_GET(r) (r).an_x4_lp_sp0_lp_base_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_base_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_base_page2[0]=(((r).an_x4_lp_sp0_lp_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_BASE_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r,(_r._an_x4_lp_sp0_lp_base_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r,(_r._an_x4_lp_sp0_lp_base_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r,(_r._an_x4_lp_sp0_lp_base_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_base_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_base_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_base_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_BASE_PAGE2r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r
#define AN_X4_LP_SP0_LP_BASE_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_t AN_X4_LP_SP0_LP_BASE_PAGE2r_t;
#define AN_X4_LP_SP0_LP_BASE_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_CLR
#define AN_X4_LP_SP0_LP_BASE_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_SET
#define AN_X4_LP_SP0_LP_BASE_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_GET
#define AN_X4_LP_SP0_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_BASE_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_BASE_PAGE2r
#define WRITE_AN_X4_LP_SP0_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_BASE_PAGE2r
#define MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE2r
#define READLN_AN_X4_LP_SP0_LP_BASE_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_BASE_PAGE2r
#define WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE2r
#define WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP0_LP_BASE_PAGE3
 * BLOCKS:   AN_X4_LP_PAGES_SP0
 * REGADDR:  0xc24a
 * DESC:     LINK PARTNER BASE PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE3_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 3CL7315:14     - FEC13:0      - reserved
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r (0x0000c24a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP0_LP_BASE_PAGE3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp0_lp_base_page3[1];
	uint32_t _an_x4_lp_sp0_lp_base_page3;
} BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_CLR(r) (r).an_x4_lp_sp0_lp_base_page3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_SET(r,d) (r).an_x4_lp_sp0_lp_base_page3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_GET(r) (r).an_x4_lp_sp0_lp_base_page3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp0_lp_base_page3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp0_lp_base_page3[0]=(((r).an_x4_lp_sp0_lp_base_page3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP0_LP_BASE_PAGE3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r,(_r._an_x4_lp_sp0_lp_base_page3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r,(_r._an_x4_lp_sp0_lp_base_page3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r,(_r._an_x4_lp_sp0_lp_base_page3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_base_page3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp0_lp_base_page3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp0_lp_base_page3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP0_LP_BASE_PAGE3r BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r
#define AN_X4_LP_SP0_LP_BASE_PAGE3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_t AN_X4_LP_SP0_LP_BASE_PAGE3r_t;
#define AN_X4_LP_SP0_LP_BASE_PAGE3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_CLR
#define AN_X4_LP_SP0_LP_BASE_PAGE3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_SET
#define AN_X4_LP_SP0_LP_BASE_PAGE3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_GET
#define AN_X4_LP_SP0_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET
#define AN_X4_LP_SP0_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP0_LP_BASE_PAGE3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP0_LP_BASE_PAGE3r
#define WRITE_AN_X4_LP_SP0_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP0_LP_BASE_PAGE3r
#define MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP0_LP_BASE_PAGE3r
#define READLN_AN_X4_LP_SP0_LP_BASE_PAGE3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP0_LP_BASE_PAGE3r
#define WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP0_LP_BASE_PAGE3r
#define WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP0_LP_BASE_PAGE3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP0_LP_BASE_PAGE3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP5_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc250
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[23:13]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r (0x0000c250 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP5_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp5_up1[1];
	uint32_t _an_x4_lp_sp1_lp_mp5_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_CLR(r) (r).an_x4_lp_sp1_lp_mp5_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_SET(r,d) (r).an_x4_lp_sp1_lp_mp5_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_GET(r) (r).an_x4_lp_sp1_lp_mp5_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp5_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp5_up1[0]=(((r).an_x4_lp_sp1_lp_mp5_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP5_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r,(_r._an_x4_lp_sp1_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r,(_r._an_x4_lp_sp1_lp_mp5_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r,(_r._an_x4_lp_sp1_lp_mp5_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp5_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP5_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r
#define AN_X4_LP_SP1_LP_MP5_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_t AN_X4_LP_SP1_LP_MP5_UP1r_t;
#define AN_X4_LP_SP1_LP_MP5_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_CLR
#define AN_X4_LP_SP1_LP_MP5_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_SET
#define AN_X4_LP_SP1_LP_MP5_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_GET
#define AN_X4_LP_SP1_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP5_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP1r
#define WRITE_AN_X4_LP_SP1_LP_MP5_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP1r
#define MODIFY_AN_X4_LP_SP1_LP_MP5_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP1r
#define READLN_AN_X4_LP_SP1_LP_MP5_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP1r
#define WRITELN_AN_X4_LP_SP1_LP_MP5_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP1r
#define WRITEALL_AN_X4_LP_SP1_LP_MP5_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP5_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc251
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[12:2]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r (0x0000c251 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP5_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp5_up2[1];
	uint32_t _an_x4_lp_sp1_lp_mp5_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_CLR(r) (r).an_x4_lp_sp1_lp_mp5_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_SET(r,d) (r).an_x4_lp_sp1_lp_mp5_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_GET(r) (r).an_x4_lp_sp1_lp_mp5_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp5_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp5_up2[0]=(((r).an_x4_lp_sp1_lp_mp5_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP5_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r,(_r._an_x4_lp_sp1_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r,(_r._an_x4_lp_sp1_lp_mp5_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r,(_r._an_x4_lp_sp1_lp_mp5_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp5_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP5_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r
#define AN_X4_LP_SP1_LP_MP5_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_t AN_X4_LP_SP1_LP_MP5_UP2r_t;
#define AN_X4_LP_SP1_LP_MP5_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_CLR
#define AN_X4_LP_SP1_LP_MP5_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_SET
#define AN_X4_LP_SP1_LP_MP5_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_GET
#define AN_X4_LP_SP1_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP5_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP2r
#define WRITE_AN_X4_LP_SP1_LP_MP5_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP2r
#define MODIFY_AN_X4_LP_SP1_LP_MP5_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP2r
#define READLN_AN_X4_LP_SP1_LP_MP5_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP2r
#define WRITELN_AN_X4_LP_SP1_LP_MP5_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP2r
#define WRITEALL_AN_X4_LP_SP1_LP_MP5_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP5_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc252
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:9      - OUI[1:0]8:0       - User-Defined Code[19:11]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r (0x0000c252 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP5_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp5_up3[1];
	uint32_t _an_x4_lp_sp1_lp_mp5_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_CLR(r) (r).an_x4_lp_sp1_lp_mp5_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_SET(r,d) (r).an_x4_lp_sp1_lp_mp5_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_GET(r) (r).an_x4_lp_sp1_lp_mp5_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp5_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp5_up3[0]=(((r).an_x4_lp_sp1_lp_mp5_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP5_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r,(_r._an_x4_lp_sp1_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r,(_r._an_x4_lp_sp1_lp_mp5_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r,(_r._an_x4_lp_sp1_lp_mp5_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp5_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP5_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r
#define AN_X4_LP_SP1_LP_MP5_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_t AN_X4_LP_SP1_LP_MP5_UP3r_t;
#define AN_X4_LP_SP1_LP_MP5_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_CLR
#define AN_X4_LP_SP1_LP_MP5_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_SET
#define AN_X4_LP_SP1_LP_MP5_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_GET
#define AN_X4_LP_SP1_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP5_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP3r
#define WRITE_AN_X4_LP_SP1_LP_MP5_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP3r
#define MODIFY_AN_X4_LP_SP1_LP_MP5_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP3r
#define READLN_AN_X4_LP_SP1_LP_MP5_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP3r
#define WRITELN_AN_X4_LP_SP1_LP_MP5_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP3r
#define WRITEALL_AN_X4_LP_SP1_LP_MP5_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP5_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc253
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - User-Defined Code[10:0]In Hewlett-Packard auto-neg mode, an OUI[23:0] of 0x643150, andan User-Defined Code[19:0] of 0xABE20 indicate that the device is capable of 20G-KR2.In Broadcom auto-neg mode, User-Defined Code[19:11] contain a BAM code, andUser-Defined Code[10:0] contain BAM abilities.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r (0x0000c253 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP5_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp5_up4[1];
	uint32_t _an_x4_lp_sp1_lp_mp5_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_CLR(r) (r).an_x4_lp_sp1_lp_mp5_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_SET(r,d) (r).an_x4_lp_sp1_lp_mp5_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_GET(r) (r).an_x4_lp_sp1_lp_mp5_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp5_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp5_up4[0]=(((r).an_x4_lp_sp1_lp_mp5_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP5_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r,(_r._an_x4_lp_sp1_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r,(_r._an_x4_lp_sp1_lp_mp5_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r,(_r._an_x4_lp_sp1_lp_mp5_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp5_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP5_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r
#define AN_X4_LP_SP1_LP_MP5_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_t AN_X4_LP_SP1_LP_MP5_UP4r_t;
#define AN_X4_LP_SP1_LP_MP5_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_CLR
#define AN_X4_LP_SP1_LP_MP5_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_SET
#define AN_X4_LP_SP1_LP_MP5_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_GET
#define AN_X4_LP_SP1_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP5_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP5_UP4r
#define WRITE_AN_X4_LP_SP1_LP_MP5_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP5_UP4r
#define MODIFY_AN_X4_LP_SP1_LP_MP5_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP5_UP4r
#define READLN_AN_X4_LP_SP1_LP_MP5_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP5_UP4r
#define WRITELN_AN_X4_LP_SP1_LP_MP5_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP5_UP4r
#define WRITEALL_AN_X4_LP_SP1_LP_MP5_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP5_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP5_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP1024_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc254
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Speed Ability 20G-CX49         - Speed Ability 16G-X48         - Speed Ability 15G-X47         - Speed Ability 13G-X46         - Speed Ability 12.5G-X45         - Speed Ability 12G-X44         - Speed Ability 10G-CX43         - Speed Ability 10G-X42         - Speed Ability 6G-X41         - Speed Ability 5G-X40         - Speed Ability 2.5G-X1
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r (0x0000c254 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP1024_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp1024_up1[1];
	uint32_t _an_x4_lp_sp1_lp_mp1024_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_CLR(r) (r).an_x4_lp_sp1_lp_mp1024_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_SET(r,d) (r).an_x4_lp_sp1_lp_mp1024_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_GET(r) (r).an_x4_lp_sp1_lp_mp1024_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp1024_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp1024_up1[0]=(((r).an_x4_lp_sp1_lp_mp1024_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP1024_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r,(_r._an_x4_lp_sp1_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r,(_r._an_x4_lp_sp1_lp_mp1024_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r,(_r._an_x4_lp_sp1_lp_mp1024_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp1024_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP1024_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r
#define AN_X4_LP_SP1_LP_MP1024_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_t AN_X4_LP_SP1_LP_MP1024_UP1r_t;
#define AN_X4_LP_SP1_LP_MP1024_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_CLR
#define AN_X4_LP_SP1_LP_MP1024_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_SET
#define AN_X4_LP_SP1_LP_MP1024_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_GET
#define AN_X4_LP_SP1_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP1024_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP1r
#define WRITE_AN_X4_LP_SP1_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP1r
#define MODIFY_AN_X4_LP_SP1_LP_MP1024_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP1r
#define READLN_AN_X4_LP_SP1_LP_MP1024_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP1r
#define WRITELN_AN_X4_LP_SP1_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP1r
#define WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP1024_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc255
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Transmitter-Equalization values are valid9:6       - Transmitter-Equalization preemphasis5:3       - Transmitter-Equalization idriver2:0       - Transmitter-Equalization ipredriver
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r (0x0000c255 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP1024_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp1024_up2[1];
	uint32_t _an_x4_lp_sp1_lp_mp1024_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_CLR(r) (r).an_x4_lp_sp1_lp_mp1024_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_SET(r,d) (r).an_x4_lp_sp1_lp_mp1024_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_GET(r) (r).an_x4_lp_sp1_lp_mp1024_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp1024_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp1024_up2[0]=(((r).an_x4_lp_sp1_lp_mp1024_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP1024_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r,(_r._an_x4_lp_sp1_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r,(_r._an_x4_lp_sp1_lp_mp1024_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r,(_r._an_x4_lp_sp1_lp_mp1024_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp1024_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP1024_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r
#define AN_X4_LP_SP1_LP_MP1024_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_t AN_X4_LP_SP1_LP_MP1024_UP2r_t;
#define AN_X4_LP_SP1_LP_MP1024_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_CLR
#define AN_X4_LP_SP1_LP_MP1024_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_SET
#define AN_X4_LP_SP1_LP_MP1024_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_GET
#define AN_X4_LP_SP1_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP1024_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP2r
#define WRITE_AN_X4_LP_SP1_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP2r
#define MODIFY_AN_X4_LP_SP1_LP_MP1024_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP2r
#define READLN_AN_X4_LP_SP1_LP_MP1024_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP2r
#define WRITELN_AN_X4_LP_SP1_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP2r
#define WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP1024_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc256
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 21G-X48         - Speed Ability 25.45G-X47         - Speed Ability 31.5G-X46         - Speed Ability 32.7G5         - Speed Ability 40G-X44:3       - reserved2         - CL72 Training Ability1         - cl74 Forward-Error Correction Ability0         - High-Gig II Ability
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r (0x0000c256 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP1024_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp1024_up3[1];
	uint32_t _an_x4_lp_sp1_lp_mp1024_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_CLR(r) (r).an_x4_lp_sp1_lp_mp1024_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_SET(r,d) (r).an_x4_lp_sp1_lp_mp1024_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_GET(r) (r).an_x4_lp_sp1_lp_mp1024_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp1024_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp1024_up3[0]=(((r).an_x4_lp_sp1_lp_mp1024_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP1024_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r,(_r._an_x4_lp_sp1_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r,(_r._an_x4_lp_sp1_lp_mp1024_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r,(_r._an_x4_lp_sp1_lp_mp1024_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp1024_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP1024_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r
#define AN_X4_LP_SP1_LP_MP1024_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_t AN_X4_LP_SP1_LP_MP1024_UP3r_t;
#define AN_X4_LP_SP1_LP_MP1024_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_CLR
#define AN_X4_LP_SP1_LP_MP1024_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_SET
#define AN_X4_LP_SP1_LP_MP1024_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_GET
#define AN_X4_LP_SP1_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP1024_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP3r
#define WRITE_AN_X4_LP_SP1_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP3r
#define MODIFY_AN_X4_LP_SP1_LP_MP1024_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP3r
#define READLN_AN_X4_LP_SP1_LP_MP1024_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP3r
#define WRITELN_AN_X4_LP_SP1_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP3r
#define WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_MP1024_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc257
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 1G-CX18         - Speed Ability 10G-CX17         - Speed Ability 15.75G-X26         - Speed Ability 20G-CX25         - Speed Ability 20G-X24         - Speed Ability 12.7G-X23         - Speed Ability 10.5G-X22         - Speed Ability 10G-CX21         - Speed Ability 10G-X20         - Speed Ability 20G-X4
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r (0x0000c257 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_MP1024_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_mp1024_up4[1];
	uint32_t _an_x4_lp_sp1_lp_mp1024_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_CLR(r) (r).an_x4_lp_sp1_lp_mp1024_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_SET(r,d) (r).an_x4_lp_sp1_lp_mp1024_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_GET(r) (r).an_x4_lp_sp1_lp_mp1024_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_mp1024_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_mp1024_up4[0]=(((r).an_x4_lp_sp1_lp_mp1024_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_MP1024_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r,(_r._an_x4_lp_sp1_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r,(_r._an_x4_lp_sp1_lp_mp1024_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r,(_r._an_x4_lp_sp1_lp_mp1024_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_mp1024_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_MP1024_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r
#define AN_X4_LP_SP1_LP_MP1024_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_t AN_X4_LP_SP1_LP_MP1024_UP4r_t;
#define AN_X4_LP_SP1_LP_MP1024_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_CLR
#define AN_X4_LP_SP1_LP_MP1024_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_SET
#define AN_X4_LP_SP1_LP_MP1024_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_GET
#define AN_X4_LP_SP1_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_MP1024_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_MP1024_UP4r
#define WRITE_AN_X4_LP_SP1_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_MP1024_UP4r
#define MODIFY_AN_X4_LP_SP1_LP_MP1024_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_MP1024_UP4r
#define READLN_AN_X4_LP_SP1_LP_MP1024_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_MP1024_UP4r
#define WRITELN_AN_X4_LP_SP1_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_MP1024_UP4r
#define WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_MP1024_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_MP1024_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_BASE_PAGE1
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc258
 * DESC:     LINK PARTNER BASE PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE1_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 1CL3715        - Next Page Indication14        - Receive Acknowledge13:12     - Remote Fault Status11:9      - reserved8:7       - Pause Ability6:5       - Duplex Ability4:0       - ReservedSGMII15        - Link Up14        - Receive Acknowledge13        - reserved12        - Duplex Ability11:10     - Speed Ability9:1       - reserved0         - SGMII IndicatorCL7315        - Next Page Indication14        - Receive Acknowledge13        - Remote Fault Status12        - reserved11:10     - Pause Ability9:5       - Echo of Received Nonce4:0       - Selector
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r (0x0000c258 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_BASE_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_base_page1[1];
	uint32_t _an_x4_lp_sp1_lp_base_page1;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_CLR(r) (r).an_x4_lp_sp1_lp_base_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_SET(r,d) (r).an_x4_lp_sp1_lp_base_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_GET(r) (r).an_x4_lp_sp1_lp_base_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_base_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_base_page1[0]=(((r).an_x4_lp_sp1_lp_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_BASE_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r,(_r._an_x4_lp_sp1_lp_base_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r,(_r._an_x4_lp_sp1_lp_base_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r,(_r._an_x4_lp_sp1_lp_base_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_base_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_base_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_base_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_BASE_PAGE1r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r
#define AN_X4_LP_SP1_LP_BASE_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_t AN_X4_LP_SP1_LP_BASE_PAGE1r_t;
#define AN_X4_LP_SP1_LP_BASE_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_CLR
#define AN_X4_LP_SP1_LP_BASE_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_SET
#define AN_X4_LP_SP1_LP_BASE_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_GET
#define AN_X4_LP_SP1_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_BASE_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_BASE_PAGE1r
#define WRITE_AN_X4_LP_SP1_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_BASE_PAGE1r
#define MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE1r
#define READLN_AN_X4_LP_SP1_LP_BASE_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_BASE_PAGE1r
#define WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE1r
#define WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_BASE_PAGE2
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc259
 * DESC:     LINK PARTNER BASE PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE2_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 2CL7315:11      - reserved10         - 100G-CR109         - 40G-CR48         - 40G-KR47         - 10G-KR Ability6         - 10G-KX4 Ability5         - 1G-KX Ability4:0       - Transmit Nonce
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r (0x0000c259 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_BASE_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_base_page2[1];
	uint32_t _an_x4_lp_sp1_lp_base_page2;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_CLR(r) (r).an_x4_lp_sp1_lp_base_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_SET(r,d) (r).an_x4_lp_sp1_lp_base_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_GET(r) (r).an_x4_lp_sp1_lp_base_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_base_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_base_page2[0]=(((r).an_x4_lp_sp1_lp_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_BASE_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r,(_r._an_x4_lp_sp1_lp_base_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r,(_r._an_x4_lp_sp1_lp_base_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r,(_r._an_x4_lp_sp1_lp_base_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_base_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_base_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_base_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_BASE_PAGE2r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r
#define AN_X4_LP_SP1_LP_BASE_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_t AN_X4_LP_SP1_LP_BASE_PAGE2r_t;
#define AN_X4_LP_SP1_LP_BASE_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_CLR
#define AN_X4_LP_SP1_LP_BASE_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_SET
#define AN_X4_LP_SP1_LP_BASE_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_GET
#define AN_X4_LP_SP1_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_BASE_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_BASE_PAGE2r
#define WRITE_AN_X4_LP_SP1_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_BASE_PAGE2r
#define MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE2r
#define READLN_AN_X4_LP_SP1_LP_BASE_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_BASE_PAGE2r
#define WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE2r
#define WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP1_LP_BASE_PAGE3
 * BLOCKS:   AN_X4_LP_PAGES_SP1
 * REGADDR:  0xc25a
 * DESC:     LINK PARTNER BASE PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE3_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 3CL7315:14     - FEC13:0      - reserved
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r (0x0000c25a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP1_LP_BASE_PAGE3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp1_lp_base_page3[1];
	uint32_t _an_x4_lp_sp1_lp_base_page3;
} BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_CLR(r) (r).an_x4_lp_sp1_lp_base_page3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_SET(r,d) (r).an_x4_lp_sp1_lp_base_page3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_GET(r) (r).an_x4_lp_sp1_lp_base_page3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp1_lp_base_page3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp1_lp_base_page3[0]=(((r).an_x4_lp_sp1_lp_base_page3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP1_LP_BASE_PAGE3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r,(_r._an_x4_lp_sp1_lp_base_page3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r,(_r._an_x4_lp_sp1_lp_base_page3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r,(_r._an_x4_lp_sp1_lp_base_page3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_base_page3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp1_lp_base_page3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp1_lp_base_page3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP1_LP_BASE_PAGE3r BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r
#define AN_X4_LP_SP1_LP_BASE_PAGE3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_t AN_X4_LP_SP1_LP_BASE_PAGE3r_t;
#define AN_X4_LP_SP1_LP_BASE_PAGE3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_CLR
#define AN_X4_LP_SP1_LP_BASE_PAGE3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_SET
#define AN_X4_LP_SP1_LP_BASE_PAGE3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_GET
#define AN_X4_LP_SP1_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET
#define AN_X4_LP_SP1_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP1_LP_BASE_PAGE3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP1_LP_BASE_PAGE3r
#define WRITE_AN_X4_LP_SP1_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP1_LP_BASE_PAGE3r
#define MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP1_LP_BASE_PAGE3r
#define READLN_AN_X4_LP_SP1_LP_BASE_PAGE3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP1_LP_BASE_PAGE3r
#define WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP1_LP_BASE_PAGE3r
#define WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP1_LP_BASE_PAGE3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP1_LP_BASE_PAGE3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP5_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc260
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[23:13]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r (0x0000c260 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP5_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp5_up1[1];
	uint32_t _an_x4_lp_sp2_lp_mp5_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_CLR(r) (r).an_x4_lp_sp2_lp_mp5_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_SET(r,d) (r).an_x4_lp_sp2_lp_mp5_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_GET(r) (r).an_x4_lp_sp2_lp_mp5_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp5_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp5_up1[0]=(((r).an_x4_lp_sp2_lp_mp5_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP5_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r,(_r._an_x4_lp_sp2_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r,(_r._an_x4_lp_sp2_lp_mp5_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r,(_r._an_x4_lp_sp2_lp_mp5_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp5_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP5_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r
#define AN_X4_LP_SP2_LP_MP5_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_t AN_X4_LP_SP2_LP_MP5_UP1r_t;
#define AN_X4_LP_SP2_LP_MP5_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_CLR
#define AN_X4_LP_SP2_LP_MP5_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_SET
#define AN_X4_LP_SP2_LP_MP5_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_GET
#define AN_X4_LP_SP2_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP5_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP1r
#define WRITE_AN_X4_LP_SP2_LP_MP5_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP1r
#define MODIFY_AN_X4_LP_SP2_LP_MP5_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP1r
#define READLN_AN_X4_LP_SP2_LP_MP5_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP1r
#define WRITELN_AN_X4_LP_SP2_LP_MP5_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP1r
#define WRITEALL_AN_X4_LP_SP2_LP_MP5_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP5_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc261
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[12:2]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r (0x0000c261 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP5_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp5_up2[1];
	uint32_t _an_x4_lp_sp2_lp_mp5_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_CLR(r) (r).an_x4_lp_sp2_lp_mp5_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_SET(r,d) (r).an_x4_lp_sp2_lp_mp5_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_GET(r) (r).an_x4_lp_sp2_lp_mp5_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp5_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp5_up2[0]=(((r).an_x4_lp_sp2_lp_mp5_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP5_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r,(_r._an_x4_lp_sp2_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r,(_r._an_x4_lp_sp2_lp_mp5_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r,(_r._an_x4_lp_sp2_lp_mp5_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp5_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP5_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r
#define AN_X4_LP_SP2_LP_MP5_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_t AN_X4_LP_SP2_LP_MP5_UP2r_t;
#define AN_X4_LP_SP2_LP_MP5_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_CLR
#define AN_X4_LP_SP2_LP_MP5_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_SET
#define AN_X4_LP_SP2_LP_MP5_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_GET
#define AN_X4_LP_SP2_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP5_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP2r
#define WRITE_AN_X4_LP_SP2_LP_MP5_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP2r
#define MODIFY_AN_X4_LP_SP2_LP_MP5_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP2r
#define READLN_AN_X4_LP_SP2_LP_MP5_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP2r
#define WRITELN_AN_X4_LP_SP2_LP_MP5_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP2r
#define WRITEALL_AN_X4_LP_SP2_LP_MP5_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP5_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc262
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:9      - OUI[1:0]8:0       - User-Defined Code[19:11]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r (0x0000c262 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP5_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp5_up3[1];
	uint32_t _an_x4_lp_sp2_lp_mp5_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_CLR(r) (r).an_x4_lp_sp2_lp_mp5_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_SET(r,d) (r).an_x4_lp_sp2_lp_mp5_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_GET(r) (r).an_x4_lp_sp2_lp_mp5_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp5_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp5_up3[0]=(((r).an_x4_lp_sp2_lp_mp5_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP5_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r,(_r._an_x4_lp_sp2_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r,(_r._an_x4_lp_sp2_lp_mp5_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r,(_r._an_x4_lp_sp2_lp_mp5_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp5_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP5_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r
#define AN_X4_LP_SP2_LP_MP5_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_t AN_X4_LP_SP2_LP_MP5_UP3r_t;
#define AN_X4_LP_SP2_LP_MP5_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_CLR
#define AN_X4_LP_SP2_LP_MP5_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_SET
#define AN_X4_LP_SP2_LP_MP5_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_GET
#define AN_X4_LP_SP2_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP5_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP3r
#define WRITE_AN_X4_LP_SP2_LP_MP5_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP3r
#define MODIFY_AN_X4_LP_SP2_LP_MP5_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP3r
#define READLN_AN_X4_LP_SP2_LP_MP5_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP3r
#define WRITELN_AN_X4_LP_SP2_LP_MP5_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP3r
#define WRITEALL_AN_X4_LP_SP2_LP_MP5_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP5_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc263
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - User-Defined Code[10:0]In Hewlett-Packard auto-neg mode, an OUI[23:0] of 0x643150, andan User-Defined Code[19:0] of 0xABE20 indicate that the device is capable of 20G-KR2.In Broadcom auto-neg mode, User-Defined Code[19:11] contain a BAM code, andUser-Defined Code[10:0] contain BAM abilities.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r (0x0000c263 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP5_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp5_up4[1];
	uint32_t _an_x4_lp_sp2_lp_mp5_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_CLR(r) (r).an_x4_lp_sp2_lp_mp5_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_SET(r,d) (r).an_x4_lp_sp2_lp_mp5_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_GET(r) (r).an_x4_lp_sp2_lp_mp5_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp5_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp5_up4[0]=(((r).an_x4_lp_sp2_lp_mp5_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP5_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r,(_r._an_x4_lp_sp2_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r,(_r._an_x4_lp_sp2_lp_mp5_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r,(_r._an_x4_lp_sp2_lp_mp5_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp5_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP5_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r
#define AN_X4_LP_SP2_LP_MP5_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_t AN_X4_LP_SP2_LP_MP5_UP4r_t;
#define AN_X4_LP_SP2_LP_MP5_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_CLR
#define AN_X4_LP_SP2_LP_MP5_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_SET
#define AN_X4_LP_SP2_LP_MP5_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_GET
#define AN_X4_LP_SP2_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP5_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP5_UP4r
#define WRITE_AN_X4_LP_SP2_LP_MP5_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP5_UP4r
#define MODIFY_AN_X4_LP_SP2_LP_MP5_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP5_UP4r
#define READLN_AN_X4_LP_SP2_LP_MP5_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP5_UP4r
#define WRITELN_AN_X4_LP_SP2_LP_MP5_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP5_UP4r
#define WRITEALL_AN_X4_LP_SP2_LP_MP5_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP5_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP5_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP1024_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc264
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Speed Ability 20G-CX49         - Speed Ability 16G-X48         - Speed Ability 15G-X47         - Speed Ability 13G-X46         - Speed Ability 12.5G-X45         - Speed Ability 12G-X44         - Speed Ability 10G-CX43         - Speed Ability 10G-X42         - Speed Ability 6G-X41         - Speed Ability 5G-X40         - Speed Ability 2.5G-X1
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r (0x0000c264 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP1024_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp1024_up1[1];
	uint32_t _an_x4_lp_sp2_lp_mp1024_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_CLR(r) (r).an_x4_lp_sp2_lp_mp1024_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_SET(r,d) (r).an_x4_lp_sp2_lp_mp1024_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_GET(r) (r).an_x4_lp_sp2_lp_mp1024_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp1024_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp1024_up1[0]=(((r).an_x4_lp_sp2_lp_mp1024_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP1024_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r,(_r._an_x4_lp_sp2_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r,(_r._an_x4_lp_sp2_lp_mp1024_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r,(_r._an_x4_lp_sp2_lp_mp1024_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp1024_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP1024_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r
#define AN_X4_LP_SP2_LP_MP1024_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_t AN_X4_LP_SP2_LP_MP1024_UP1r_t;
#define AN_X4_LP_SP2_LP_MP1024_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_CLR
#define AN_X4_LP_SP2_LP_MP1024_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_SET
#define AN_X4_LP_SP2_LP_MP1024_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_GET
#define AN_X4_LP_SP2_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP1024_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP1r
#define WRITE_AN_X4_LP_SP2_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP1r
#define MODIFY_AN_X4_LP_SP2_LP_MP1024_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP1r
#define READLN_AN_X4_LP_SP2_LP_MP1024_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP1r
#define WRITELN_AN_X4_LP_SP2_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP1r
#define WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP1024_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc265
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Transmitter-Equalization values are valid9:6       - Transmitter-Equalization preemphasis5:3       - Transmitter-Equalization idriver2:0       - Transmitter-Equalization ipredriver
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r (0x0000c265 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP1024_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp1024_up2[1];
	uint32_t _an_x4_lp_sp2_lp_mp1024_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_CLR(r) (r).an_x4_lp_sp2_lp_mp1024_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_SET(r,d) (r).an_x4_lp_sp2_lp_mp1024_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_GET(r) (r).an_x4_lp_sp2_lp_mp1024_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp1024_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp1024_up2[0]=(((r).an_x4_lp_sp2_lp_mp1024_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP1024_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r,(_r._an_x4_lp_sp2_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r,(_r._an_x4_lp_sp2_lp_mp1024_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r,(_r._an_x4_lp_sp2_lp_mp1024_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp1024_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP1024_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r
#define AN_X4_LP_SP2_LP_MP1024_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_t AN_X4_LP_SP2_LP_MP1024_UP2r_t;
#define AN_X4_LP_SP2_LP_MP1024_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_CLR
#define AN_X4_LP_SP2_LP_MP1024_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_SET
#define AN_X4_LP_SP2_LP_MP1024_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_GET
#define AN_X4_LP_SP2_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP1024_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP2r
#define WRITE_AN_X4_LP_SP2_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP2r
#define MODIFY_AN_X4_LP_SP2_LP_MP1024_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP2r
#define READLN_AN_X4_LP_SP2_LP_MP1024_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP2r
#define WRITELN_AN_X4_LP_SP2_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP2r
#define WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP1024_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc266
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 21G-X48         - Speed Ability 25.45G-X47         - Speed Ability 31.5G-X46         - Speed Ability 32.7G5         - Speed Ability 40G-X44:3       - reserved2         - CL72 Training Ability1         - cl74 Forward-Error Correction Ability0         - High-Gig II Ability
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r (0x0000c266 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP1024_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp1024_up3[1];
	uint32_t _an_x4_lp_sp2_lp_mp1024_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_CLR(r) (r).an_x4_lp_sp2_lp_mp1024_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_SET(r,d) (r).an_x4_lp_sp2_lp_mp1024_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_GET(r) (r).an_x4_lp_sp2_lp_mp1024_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp1024_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp1024_up3[0]=(((r).an_x4_lp_sp2_lp_mp1024_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP1024_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r,(_r._an_x4_lp_sp2_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r,(_r._an_x4_lp_sp2_lp_mp1024_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r,(_r._an_x4_lp_sp2_lp_mp1024_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp1024_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP1024_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r
#define AN_X4_LP_SP2_LP_MP1024_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_t AN_X4_LP_SP2_LP_MP1024_UP3r_t;
#define AN_X4_LP_SP2_LP_MP1024_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_CLR
#define AN_X4_LP_SP2_LP_MP1024_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_SET
#define AN_X4_LP_SP2_LP_MP1024_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_GET
#define AN_X4_LP_SP2_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP1024_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP3r
#define WRITE_AN_X4_LP_SP2_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP3r
#define MODIFY_AN_X4_LP_SP2_LP_MP1024_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP3r
#define READLN_AN_X4_LP_SP2_LP_MP1024_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP3r
#define WRITELN_AN_X4_LP_SP2_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP3r
#define WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_MP1024_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc267
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 1G-CX18         - Speed Ability 10G-CX17         - Speed Ability 15.75G-X26         - Speed Ability 20G-CX25         - Speed Ability 20G-X24         - Speed Ability 12.7G-X23         - Speed Ability 10.5G-X22         - Speed Ability 10G-CX21         - Speed Ability 10G-X20         - Speed Ability 20G-X4
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r (0x0000c267 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_MP1024_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_mp1024_up4[1];
	uint32_t _an_x4_lp_sp2_lp_mp1024_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_CLR(r) (r).an_x4_lp_sp2_lp_mp1024_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_SET(r,d) (r).an_x4_lp_sp2_lp_mp1024_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_GET(r) (r).an_x4_lp_sp2_lp_mp1024_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_mp1024_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_mp1024_up4[0]=(((r).an_x4_lp_sp2_lp_mp1024_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_MP1024_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r,(_r._an_x4_lp_sp2_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r,(_r._an_x4_lp_sp2_lp_mp1024_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r,(_r._an_x4_lp_sp2_lp_mp1024_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_mp1024_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_MP1024_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r
#define AN_X4_LP_SP2_LP_MP1024_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_t AN_X4_LP_SP2_LP_MP1024_UP4r_t;
#define AN_X4_LP_SP2_LP_MP1024_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_CLR
#define AN_X4_LP_SP2_LP_MP1024_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_SET
#define AN_X4_LP_SP2_LP_MP1024_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_GET
#define AN_X4_LP_SP2_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_MP1024_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_MP1024_UP4r
#define WRITE_AN_X4_LP_SP2_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_MP1024_UP4r
#define MODIFY_AN_X4_LP_SP2_LP_MP1024_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_MP1024_UP4r
#define READLN_AN_X4_LP_SP2_LP_MP1024_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_MP1024_UP4r
#define WRITELN_AN_X4_LP_SP2_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_MP1024_UP4r
#define WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_MP1024_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_MP1024_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_BASE_PAGE1
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc268
 * DESC:     LINK PARTNER BASE PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE1_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 1CL3715        - Next Page Indication14        - Receive Acknowledge13:12     - Remote Fault Status11:9      - reserved8:7       - Pause Ability6:5       - Duplex Ability4:0       - ReservedSGMII15        - Link Up14        - Receive Acknowledge13        - reserved12        - Duplex Ability11:10     - Speed Ability9:1       - reserved0         - SGMII IndicatorCL7315        - Next Page Indication14        - Receive Acknowledge13        - Remote Fault Status12        - reserved11:10     - Pause Ability9:5       - Echo of Received Nonce4:0       - Selector
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r (0x0000c268 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_BASE_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_base_page1[1];
	uint32_t _an_x4_lp_sp2_lp_base_page1;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_CLR(r) (r).an_x4_lp_sp2_lp_base_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_SET(r,d) (r).an_x4_lp_sp2_lp_base_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_GET(r) (r).an_x4_lp_sp2_lp_base_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_base_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_base_page1[0]=(((r).an_x4_lp_sp2_lp_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_BASE_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r,(_r._an_x4_lp_sp2_lp_base_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r,(_r._an_x4_lp_sp2_lp_base_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r,(_r._an_x4_lp_sp2_lp_base_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_base_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_base_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_base_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_BASE_PAGE1r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r
#define AN_X4_LP_SP2_LP_BASE_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_t AN_X4_LP_SP2_LP_BASE_PAGE1r_t;
#define AN_X4_LP_SP2_LP_BASE_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_CLR
#define AN_X4_LP_SP2_LP_BASE_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_SET
#define AN_X4_LP_SP2_LP_BASE_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_GET
#define AN_X4_LP_SP2_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_BASE_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_BASE_PAGE1r
#define WRITE_AN_X4_LP_SP2_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_BASE_PAGE1r
#define MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE1r
#define READLN_AN_X4_LP_SP2_LP_BASE_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_BASE_PAGE1r
#define WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE1r
#define WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_BASE_PAGE2
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc269
 * DESC:     LINK PARTNER BASE PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE2_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 2CL7315:11      - reserved10         - 100G-CR109         - 40G-CR48         - 40G-KR47         - 10G-KR Ability6         - 10G-KX4 Ability5         - 1G-KX Ability4:0       - Transmit Nonce
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r (0x0000c269 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_BASE_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_base_page2[1];
	uint32_t _an_x4_lp_sp2_lp_base_page2;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_CLR(r) (r).an_x4_lp_sp2_lp_base_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_SET(r,d) (r).an_x4_lp_sp2_lp_base_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_GET(r) (r).an_x4_lp_sp2_lp_base_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_base_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_base_page2[0]=(((r).an_x4_lp_sp2_lp_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_BASE_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r,(_r._an_x4_lp_sp2_lp_base_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r,(_r._an_x4_lp_sp2_lp_base_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r,(_r._an_x4_lp_sp2_lp_base_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_base_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_base_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_base_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_BASE_PAGE2r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r
#define AN_X4_LP_SP2_LP_BASE_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_t AN_X4_LP_SP2_LP_BASE_PAGE2r_t;
#define AN_X4_LP_SP2_LP_BASE_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_CLR
#define AN_X4_LP_SP2_LP_BASE_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_SET
#define AN_X4_LP_SP2_LP_BASE_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_GET
#define AN_X4_LP_SP2_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_BASE_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_BASE_PAGE2r
#define WRITE_AN_X4_LP_SP2_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_BASE_PAGE2r
#define MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE2r
#define READLN_AN_X4_LP_SP2_LP_BASE_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_BASE_PAGE2r
#define WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE2r
#define WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP2_LP_BASE_PAGE3
 * BLOCKS:   AN_X4_LP_PAGES_SP2
 * REGADDR:  0xc26a
 * DESC:     LINK PARTNER BASE PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE3_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 3CL7315:14     - FEC13:0      - reserved
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r (0x0000c26a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP2_LP_BASE_PAGE3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp2_lp_base_page3[1];
	uint32_t _an_x4_lp_sp2_lp_base_page3;
} BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_CLR(r) (r).an_x4_lp_sp2_lp_base_page3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_SET(r,d) (r).an_x4_lp_sp2_lp_base_page3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_GET(r) (r).an_x4_lp_sp2_lp_base_page3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp2_lp_base_page3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp2_lp_base_page3[0]=(((r).an_x4_lp_sp2_lp_base_page3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP2_LP_BASE_PAGE3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r,(_r._an_x4_lp_sp2_lp_base_page3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r,(_r._an_x4_lp_sp2_lp_base_page3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r,(_r._an_x4_lp_sp2_lp_base_page3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_base_page3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp2_lp_base_page3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp2_lp_base_page3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP2_LP_BASE_PAGE3r BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r
#define AN_X4_LP_SP2_LP_BASE_PAGE3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_t AN_X4_LP_SP2_LP_BASE_PAGE3r_t;
#define AN_X4_LP_SP2_LP_BASE_PAGE3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_CLR
#define AN_X4_LP_SP2_LP_BASE_PAGE3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_SET
#define AN_X4_LP_SP2_LP_BASE_PAGE3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_GET
#define AN_X4_LP_SP2_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET
#define AN_X4_LP_SP2_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP2_LP_BASE_PAGE3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP2_LP_BASE_PAGE3r
#define WRITE_AN_X4_LP_SP2_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP2_LP_BASE_PAGE3r
#define MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP2_LP_BASE_PAGE3r
#define READLN_AN_X4_LP_SP2_LP_BASE_PAGE3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP2_LP_BASE_PAGE3r
#define WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP2_LP_BASE_PAGE3r
#define WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP2_LP_BASE_PAGE3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP2_LP_BASE_PAGE3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP5_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc270
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[23:13]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r (0x0000c270 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP5_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp5_up1[1];
	uint32_t _an_x4_lp_sp3_lp_mp5_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_CLR(r) (r).an_x4_lp_sp3_lp_mp5_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_SET(r,d) (r).an_x4_lp_sp3_lp_mp5_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_GET(r) (r).an_x4_lp_sp3_lp_mp5_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp5_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp5_up1[0]=(((r).an_x4_lp_sp3_lp_mp5_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP5_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r,(_r._an_x4_lp_sp3_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r,(_r._an_x4_lp_sp3_lp_mp5_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r,(_r._an_x4_lp_sp3_lp_mp5_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp5_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP5_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r
#define AN_X4_LP_SP3_LP_MP5_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_t AN_X4_LP_SP3_LP_MP5_UP1r_t;
#define AN_X4_LP_SP3_LP_MP5_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_CLR
#define AN_X4_LP_SP3_LP_MP5_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_SET
#define AN_X4_LP_SP3_LP_MP5_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_GET
#define AN_X4_LP_SP3_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP5_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP1r
#define WRITE_AN_X4_LP_SP3_LP_MP5_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP1r
#define MODIFY_AN_X4_LP_SP3_LP_MP5_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP1r
#define READLN_AN_X4_LP_SP3_LP_MP5_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP1r
#define WRITELN_AN_X4_LP_SP3_LP_MP5_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP1r
#define WRITEALL_AN_X4_LP_SP3_LP_MP5_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP5_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc271
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[12:2]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r (0x0000c271 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP5_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp5_up2[1];
	uint32_t _an_x4_lp_sp3_lp_mp5_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_CLR(r) (r).an_x4_lp_sp3_lp_mp5_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_SET(r,d) (r).an_x4_lp_sp3_lp_mp5_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_GET(r) (r).an_x4_lp_sp3_lp_mp5_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp5_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp5_up2[0]=(((r).an_x4_lp_sp3_lp_mp5_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP5_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r,(_r._an_x4_lp_sp3_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r,(_r._an_x4_lp_sp3_lp_mp5_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r,(_r._an_x4_lp_sp3_lp_mp5_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp5_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP5_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r
#define AN_X4_LP_SP3_LP_MP5_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_t AN_X4_LP_SP3_LP_MP5_UP2r_t;
#define AN_X4_LP_SP3_LP_MP5_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_CLR
#define AN_X4_LP_SP3_LP_MP5_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_SET
#define AN_X4_LP_SP3_LP_MP5_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_GET
#define AN_X4_LP_SP3_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP5_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP2r
#define WRITE_AN_X4_LP_SP3_LP_MP5_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP2r
#define MODIFY_AN_X4_LP_SP3_LP_MP5_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP2r
#define READLN_AN_X4_LP_SP3_LP_MP5_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP2r
#define WRITELN_AN_X4_LP_SP3_LP_MP5_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP2r
#define WRITEALL_AN_X4_LP_SP3_LP_MP5_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP5_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc272
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:9      - OUI[1:0]8:0       - User-Defined Code[19:11]
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r (0x0000c272 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP5_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp5_up3[1];
	uint32_t _an_x4_lp_sp3_lp_mp5_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_CLR(r) (r).an_x4_lp_sp3_lp_mp5_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_SET(r,d) (r).an_x4_lp_sp3_lp_mp5_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_GET(r) (r).an_x4_lp_sp3_lp_mp5_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp5_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp5_up3[0]=(((r).an_x4_lp_sp3_lp_mp5_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP5_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r,(_r._an_x4_lp_sp3_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r,(_r._an_x4_lp_sp3_lp_mp5_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r,(_r._an_x4_lp_sp3_lp_mp5_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp5_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP5_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r
#define AN_X4_LP_SP3_LP_MP5_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_t AN_X4_LP_SP3_LP_MP5_UP3r_t;
#define AN_X4_LP_SP3_LP_MP5_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_CLR
#define AN_X4_LP_SP3_LP_MP5_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_SET
#define AN_X4_LP_SP3_LP_MP5_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_GET
#define AN_X4_LP_SP3_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP5_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP3r
#define WRITE_AN_X4_LP_SP3_LP_MP5_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP3r
#define MODIFY_AN_X4_LP_SP3_LP_MP5_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP3r
#define READLN_AN_X4_LP_SP3_LP_MP5_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP3r
#define WRITELN_AN_X4_LP_SP3_LP_MP5_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP3r
#define WRITEALL_AN_X4_LP_SP3_LP_MP5_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP5_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc273
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP5_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - User-Defined Code[10:0]In Hewlett-Packard auto-neg mode, an OUI[23:0] of 0x643150, andan User-Defined Code[19:0] of 0xABE20 indicate that the device is capable of 20G-KR2.In Broadcom auto-neg mode, User-Defined Code[19:11] contain a BAM code, andUser-Defined Code[10:0] contain BAM abilities.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r (0x0000c273 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP5_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp5_up4[1];
	uint32_t _an_x4_lp_sp3_lp_mp5_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_CLR(r) (r).an_x4_lp_sp3_lp_mp5_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_SET(r,d) (r).an_x4_lp_sp3_lp_mp5_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_GET(r) (r).an_x4_lp_sp3_lp_mp5_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp5_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp5_up4[0]=(((r).an_x4_lp_sp3_lp_mp5_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP5_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r,(_r._an_x4_lp_sp3_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r,(_r._an_x4_lp_sp3_lp_mp5_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r,(_r._an_x4_lp_sp3_lp_mp5_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp5_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp5_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP5_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r
#define AN_X4_LP_SP3_LP_MP5_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_t AN_X4_LP_SP3_LP_MP5_UP4r_t;
#define AN_X4_LP_SP3_LP_MP5_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_CLR
#define AN_X4_LP_SP3_LP_MP5_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_SET
#define AN_X4_LP_SP3_LP_MP5_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_GET
#define AN_X4_LP_SP3_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP5_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP5_UP4r
#define WRITE_AN_X4_LP_SP3_LP_MP5_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP5_UP4r
#define MODIFY_AN_X4_LP_SP3_LP_MP5_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP5_UP4r
#define READLN_AN_X4_LP_SP3_LP_MP5_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP5_UP4r
#define WRITELN_AN_X4_LP_SP3_LP_MP5_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP5_UP4r
#define WRITEALL_AN_X4_LP_SP3_LP_MP5_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP5_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP5_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP1024_UP1
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc274
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Speed Ability 20G-CX49         - Speed Ability 16G-X48         - Speed Ability 15G-X47         - Speed Ability 13G-X46         - Speed Ability 12.5G-X45         - Speed Ability 12G-X44         - Speed Ability 10G-CX43         - Speed Ability 10G-X42         - Speed Ability 6G-X41         - Speed Ability 5G-X40         - Speed Ability 2.5G-X1
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r (0x0000c274 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP1024_UP1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp1024_up1[1];
	uint32_t _an_x4_lp_sp3_lp_mp1024_up1;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_CLR(r) (r).an_x4_lp_sp3_lp_mp1024_up1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_SET(r,d) (r).an_x4_lp_sp3_lp_mp1024_up1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_GET(r) (r).an_x4_lp_sp3_lp_mp1024_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp1024_up1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp1024_up1[0]=(((r).an_x4_lp_sp3_lp_mp1024_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP1024_UP1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r,(_r._an_x4_lp_sp3_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r,(_r._an_x4_lp_sp3_lp_mp1024_up1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r,(_r._an_x4_lp_sp3_lp_mp1024_up1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp1024_up1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP1024_UP1r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r
#define AN_X4_LP_SP3_LP_MP1024_UP1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_t AN_X4_LP_SP3_LP_MP1024_UP1r_t;
#define AN_X4_LP_SP3_LP_MP1024_UP1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_CLR
#define AN_X4_LP_SP3_LP_MP1024_UP1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_SET
#define AN_X4_LP_SP3_LP_MP1024_UP1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_GET
#define AN_X4_LP_SP3_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP1024_UP1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP1r
#define WRITE_AN_X4_LP_SP3_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP1r
#define MODIFY_AN_X4_LP_SP3_LP_MP1024_UP1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP1r
#define READLN_AN_X4_LP_SP3_LP_MP1024_UP1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP1r
#define WRITELN_AN_X4_LP_SP3_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP1r
#define WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP1024_UP2
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc275
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Transmitter-Equalization values are valid9:6       - Transmitter-Equalization preemphasis5:3       - Transmitter-Equalization idriver2:0       - Transmitter-Equalization ipredriver
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r (0x0000c275 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP1024_UP2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp1024_up2[1];
	uint32_t _an_x4_lp_sp3_lp_mp1024_up2;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_CLR(r) (r).an_x4_lp_sp3_lp_mp1024_up2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_SET(r,d) (r).an_x4_lp_sp3_lp_mp1024_up2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_GET(r) (r).an_x4_lp_sp3_lp_mp1024_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp1024_up2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp1024_up2[0]=(((r).an_x4_lp_sp3_lp_mp1024_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP1024_UP2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r,(_r._an_x4_lp_sp3_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r,(_r._an_x4_lp_sp3_lp_mp1024_up2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r,(_r._an_x4_lp_sp3_lp_mp1024_up2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp1024_up2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP1024_UP2r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r
#define AN_X4_LP_SP3_LP_MP1024_UP2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_t AN_X4_LP_SP3_LP_MP1024_UP2r_t;
#define AN_X4_LP_SP3_LP_MP1024_UP2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_CLR
#define AN_X4_LP_SP3_LP_MP1024_UP2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_SET
#define AN_X4_LP_SP3_LP_MP1024_UP2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_GET
#define AN_X4_LP_SP3_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP1024_UP2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP2r
#define WRITE_AN_X4_LP_SP3_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP2r
#define MODIFY_AN_X4_LP_SP3_LP_MP1024_UP2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP2r
#define READLN_AN_X4_LP_SP3_LP_MP1024_UP2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP2r
#define WRITELN_AN_X4_LP_SP3_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP2r
#define WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP1024_UP3
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc276
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 21G-X48         - Speed Ability 25.45G-X47         - Speed Ability 31.5G-X46         - Speed Ability 32.7G5         - Speed Ability 40G-X44:3       - reserved2         - CL72 Training Ability1         - cl74 Forward-Error Correction Ability0         - High-Gig II Ability
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r (0x0000c276 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP1024_UP3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp1024_up3[1];
	uint32_t _an_x4_lp_sp3_lp_mp1024_up3;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_CLR(r) (r).an_x4_lp_sp3_lp_mp1024_up3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_SET(r,d) (r).an_x4_lp_sp3_lp_mp1024_up3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_GET(r) (r).an_x4_lp_sp3_lp_mp1024_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp1024_up3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp1024_up3[0]=(((r).an_x4_lp_sp3_lp_mp1024_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP1024_UP3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r,(_r._an_x4_lp_sp3_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r,(_r._an_x4_lp_sp3_lp_mp1024_up3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r,(_r._an_x4_lp_sp3_lp_mp1024_up3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp1024_up3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP1024_UP3r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r
#define AN_X4_LP_SP3_LP_MP1024_UP3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_t AN_X4_LP_SP3_LP_MP1024_UP3r_t;
#define AN_X4_LP_SP3_LP_MP1024_UP3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_CLR
#define AN_X4_LP_SP3_LP_MP1024_UP3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_SET
#define AN_X4_LP_SP3_LP_MP1024_UP3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_GET
#define AN_X4_LP_SP3_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP1024_UP3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP3r
#define WRITE_AN_X4_LP_SP3_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP3r
#define MODIFY_AN_X4_LP_SP3_LP_MP1024_UP3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP3r
#define READLN_AN_X4_LP_SP3_LP_MP1024_UP3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP3r
#define WRITELN_AN_X4_LP_SP3_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP3r
#define WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_MP1024_UP4
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc277
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 4
 * SIZE:     32
 * FIELDS:
 *     LP_MP1024_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 1G-CX18         - Speed Ability 10G-CX17         - Speed Ability 15.75G-X26         - Speed Ability 20G-CX25         - Speed Ability 20G-X24         - Speed Ability 12.7G-X23         - Speed Ability 10.5G-X22         - Speed Ability 10G-CX21         - Speed Ability 10G-X20         - Speed Ability 20G-X4
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r (0x0000c277 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_MP1024_UP4.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_mp1024_up4[1];
	uint32_t _an_x4_lp_sp3_lp_mp1024_up4;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_CLR(r) (r).an_x4_lp_sp3_lp_mp1024_up4[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_SET(r,d) (r).an_x4_lp_sp3_lp_mp1024_up4[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_GET(r) (r).an_x4_lp_sp3_lp_mp1024_up4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_mp1024_up4[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_mp1024_up4[0]=(((r).an_x4_lp_sp3_lp_mp1024_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_MP1024_UP4.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r,(_r._an_x4_lp_sp3_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r,(_r._an_x4_lp_sp3_lp_mp1024_up4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r,(_r._an_x4_lp_sp3_lp_mp1024_up4))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_mp1024_up4))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_mp1024_up4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_MP1024_UP4r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r
#define AN_X4_LP_SP3_LP_MP1024_UP4r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_t AN_X4_LP_SP3_LP_MP1024_UP4r_t;
#define AN_X4_LP_SP3_LP_MP1024_UP4r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_CLR
#define AN_X4_LP_SP3_LP_MP1024_UP4r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_SET
#define AN_X4_LP_SP3_LP_MP1024_UP4r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_GET
#define AN_X4_LP_SP3_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_MP1024_UP4r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_MP1024_UP4r
#define WRITE_AN_X4_LP_SP3_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_MP1024_UP4r
#define MODIFY_AN_X4_LP_SP3_LP_MP1024_UP4r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_MP1024_UP4r
#define READLN_AN_X4_LP_SP3_LP_MP1024_UP4r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_MP1024_UP4r
#define WRITELN_AN_X4_LP_SP3_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_MP1024_UP4r
#define WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP4r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_MP1024_UP4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_MP1024_UP4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_BASE_PAGE1
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc278
 * DESC:     LINK PARTNER BASE PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE1_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 1CL3715        - Next Page Indication14        - Receive Acknowledge13:12     - Remote Fault Status11:9      - reserved8:7       - Pause Ability6:5       - Duplex Ability4:0       - ReservedSGMII15        - Link Up14        - Receive Acknowledge13        - reserved12        - Duplex Ability11:10     - Speed Ability9:1       - reserved0         - SGMII IndicatorCL7315        - Next Page Indication14        - Receive Acknowledge13        - Remote Fault Status12        - reserved11:10     - Pause Ability9:5       - Echo of Received Nonce4:0       - Selector
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r (0x0000c278 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_BASE_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_base_page1[1];
	uint32_t _an_x4_lp_sp3_lp_base_page1;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_CLR(r) (r).an_x4_lp_sp3_lp_base_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_SET(r,d) (r).an_x4_lp_sp3_lp_base_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_GET(r) (r).an_x4_lp_sp3_lp_base_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_base_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_base_page1[0]=(((r).an_x4_lp_sp3_lp_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_BASE_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r,(_r._an_x4_lp_sp3_lp_base_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r,(_r._an_x4_lp_sp3_lp_base_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r,(_r._an_x4_lp_sp3_lp_base_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_base_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_base_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_base_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_BASE_PAGE1r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r
#define AN_X4_LP_SP3_LP_BASE_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_t AN_X4_LP_SP3_LP_BASE_PAGE1r_t;
#define AN_X4_LP_SP3_LP_BASE_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_CLR
#define AN_X4_LP_SP3_LP_BASE_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_SET
#define AN_X4_LP_SP3_LP_BASE_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_GET
#define AN_X4_LP_SP3_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_BASE_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_BASE_PAGE1r
#define WRITE_AN_X4_LP_SP3_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_BASE_PAGE1r
#define MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE1r
#define READLN_AN_X4_LP_SP3_LP_BASE_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_BASE_PAGE1r
#define WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE1r
#define WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_BASE_PAGE2
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc279
 * DESC:     LINK PARTNER BASE PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE2_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 2CL7315:11      - reserved10         - 100G-CR109         - 40G-CR48         - 40G-KR47         - 10G-KR Ability6         - 10G-KX4 Ability5         - 1G-KX Ability4:0       - Transmit Nonce
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r (0x0000c279 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_BASE_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_base_page2[1];
	uint32_t _an_x4_lp_sp3_lp_base_page2;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_CLR(r) (r).an_x4_lp_sp3_lp_base_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_SET(r,d) (r).an_x4_lp_sp3_lp_base_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_GET(r) (r).an_x4_lp_sp3_lp_base_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_base_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_base_page2[0]=(((r).an_x4_lp_sp3_lp_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_BASE_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r,(_r._an_x4_lp_sp3_lp_base_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r,(_r._an_x4_lp_sp3_lp_base_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r,(_r._an_x4_lp_sp3_lp_base_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_base_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_base_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_base_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_BASE_PAGE2r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r
#define AN_X4_LP_SP3_LP_BASE_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_t AN_X4_LP_SP3_LP_BASE_PAGE2r_t;
#define AN_X4_LP_SP3_LP_BASE_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_CLR
#define AN_X4_LP_SP3_LP_BASE_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_SET
#define AN_X4_LP_SP3_LP_BASE_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_GET
#define AN_X4_LP_SP3_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_BASE_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_BASE_PAGE2r
#define WRITE_AN_X4_LP_SP3_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_BASE_PAGE2r
#define MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE2r
#define READLN_AN_X4_LP_SP3_LP_BASE_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_BASE_PAGE2r
#define WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE2r
#define WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_LP_SP3_LP_BASE_PAGE3
 * BLOCKS:   AN_X4_LP_PAGES_SP3
 * REGADDR:  0xc27a
 * DESC:     LINK PARTNER BASE PAGE 3
 * SIZE:     32
 * FIELDS:
 *     LP_BASE_PAGE3_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 3CL7315:14     - FEC13:0      - reserved
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r (0x0000c27a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_SP3_LP_BASE_PAGE3.
 */
typedef union BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_sp3_lp_base_page3[1];
	uint32_t _an_x4_lp_sp3_lp_base_page3;
} BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_t;

#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_CLR(r) (r).an_x4_lp_sp3_lp_base_page3[0] = 0
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_SET(r,d) (r).an_x4_lp_sp3_lp_base_page3[0] = d
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_GET(r) (r).an_x4_lp_sp3_lp_base_page3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET(r) (((r).an_x4_lp_sp3_lp_base_page3[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_sp3_lp_base_page3[0]=(((r).an_x4_lp_sp3_lp_base_page3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_LP_SP3_LP_BASE_PAGE3.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r,(_r._an_x4_lp_sp3_lp_base_page3))
#define BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r,(_r._an_x4_lp_sp3_lp_base_page3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r,(_r._an_x4_lp_sp3_lp_base_page3))
#define BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_base_page3))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_sp3_lp_base_page3))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_sp3_lp_base_page3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_SP3_LP_BASE_PAGE3r BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r
#define AN_X4_LP_SP3_LP_BASE_PAGE3r_SIZE BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_t AN_X4_LP_SP3_LP_BASE_PAGE3r_t;
#define AN_X4_LP_SP3_LP_BASE_PAGE3r_CLR BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_CLR
#define AN_X4_LP_SP3_LP_BASE_PAGE3r_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_SET
#define AN_X4_LP_SP3_LP_BASE_PAGE3r_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_GET
#define AN_X4_LP_SP3_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET
#define AN_X4_LP_SP3_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET
#define READ_AN_X4_LP_SP3_LP_BASE_PAGE3r BCMI_QTC_XGXS_READ_AN_X4_LP_SP3_LP_BASE_PAGE3r
#define WRITE_AN_X4_LP_SP3_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITE_AN_X4_LP_SP3_LP_BASE_PAGE3r
#define MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE3r BCMI_QTC_XGXS_MODIFY_AN_X4_LP_SP3_LP_BASE_PAGE3r
#define READLN_AN_X4_LP_SP3_LP_BASE_PAGE3r BCMI_QTC_XGXS_READLN_AN_X4_LP_SP3_LP_BASE_PAGE3r
#define WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITELN_AN_X4_LP_SP3_LP_BASE_PAGE3r
#define WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE3r BCMI_QTC_XGXS_WRITEALL_AN_X4_LP_SP3_LP_BASE_PAGE3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_LP_SP3_LP_BASE_PAGE3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_LD_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc280
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_2_PAGE_DATA LOCAL DEVICE PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r (0x0000c280 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_LD_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_ld_page2[1];
	uint32_t _an_x4_sw_sp0_ld_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_CLR(r) (r).an_x4_sw_sp0_ld_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_SET(r,d) (r).an_x4_sw_sp0_ld_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_GET(r) (r).an_x4_sw_sp0_ld_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp0_ld_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp0_ld_page2[0]=(((r).an_x4_sw_sp0_ld_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_LD_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r,(_r._an_x4_sw_sp0_ld_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r,(_r._an_x4_sw_sp0_ld_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r,(_r._an_x4_sw_sp0_ld_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_ld_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_LD_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r
#define AN_X4_SW_SP0_LD_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_t AN_X4_SW_SP0_LD_PAGE2r_t;
#define AN_X4_SW_SP0_LD_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_CLR
#define AN_X4_SW_SP0_LD_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_SET
#define AN_X4_SW_SP0_LD_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_GET
#define AN_X4_SW_SP0_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP0_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP0_LD_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_PAGE2r
#define WRITE_AN_X4_SW_SP0_LD_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_PAGE2r
#define MODIFY_AN_X4_SW_SP0_LD_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_PAGE2r
#define READLN_AN_X4_SW_SP0_LD_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_PAGE2r
#define WRITELN_AN_X4_SW_SP0_LD_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_PAGE2r
#define WRITEALL_AN_X4_SW_SP0_LD_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_LD_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc281
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_1_PAGE_DATA LOCAL DEVICE PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r (0x0000c281 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_LD_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_ld_page1[1];
	uint32_t _an_x4_sw_sp0_ld_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_CLR(r) (r).an_x4_sw_sp0_ld_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_SET(r,d) (r).an_x4_sw_sp0_ld_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_GET(r) (r).an_x4_sw_sp0_ld_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp0_ld_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp0_ld_page1[0]=(((r).an_x4_sw_sp0_ld_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_LD_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r,(_r._an_x4_sw_sp0_ld_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r,(_r._an_x4_sw_sp0_ld_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r,(_r._an_x4_sw_sp0_ld_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_ld_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_LD_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r
#define AN_X4_SW_SP0_LD_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_t AN_X4_SW_SP0_LD_PAGE1r_t;
#define AN_X4_SW_SP0_LD_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_CLR
#define AN_X4_SW_SP0_LD_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_SET
#define AN_X4_SW_SP0_LD_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_GET
#define AN_X4_SW_SP0_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP0_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP0_LD_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_PAGE1r
#define WRITE_AN_X4_SW_SP0_LD_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_PAGE1r
#define MODIFY_AN_X4_SW_SP0_LD_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_PAGE1r
#define READLN_AN_X4_SW_SP0_LD_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_PAGE1r
#define WRITELN_AN_X4_SW_SP0_LD_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_PAGE1r
#define WRITEALL_AN_X4_SW_SP0_LD_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_LD_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc282
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_0_PAGE_DATA LOCAL DEVICE PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r (0x0000c282 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_LD_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_ld_page0[1];
	uint32_t _an_x4_sw_sp0_ld_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_CLR(r) (r).an_x4_sw_sp0_ld_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_SET(r,d) (r).an_x4_sw_sp0_ld_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_GET(r) (r).an_x4_sw_sp0_ld_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp0_ld_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp0_ld_page0[0]=(((r).an_x4_sw_sp0_ld_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_LD_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r,(_r._an_x4_sw_sp0_ld_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r,(_r._an_x4_sw_sp0_ld_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r,(_r._an_x4_sw_sp0_ld_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_ld_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_LD_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r
#define AN_X4_SW_SP0_LD_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_t AN_X4_SW_SP0_LD_PAGE0r_t;
#define AN_X4_SW_SP0_LD_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_CLR
#define AN_X4_SW_SP0_LD_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_SET
#define AN_X4_SW_SP0_LD_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_GET
#define AN_X4_SW_SP0_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP0_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP0_LD_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_PAGE0r
#define WRITE_AN_X4_SW_SP0_LD_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_PAGE0r
#define MODIFY_AN_X4_SW_SP0_LD_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_PAGE0r
#define READLN_AN_X4_SW_SP0_LD_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_PAGE0r
#define WRITELN_AN_X4_SW_SP0_LD_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_PAGE0r
#define WRITEALL_AN_X4_SW_SP0_LD_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_LP_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc283
 * DESC:     LINK PARNTER SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_2_PAGE_DATA LINK PARTNER PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r (0x0000c283 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_LP_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_lp_page2[1];
	uint32_t _an_x4_sw_sp0_lp_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_CLR(r) (r).an_x4_sw_sp0_lp_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_SET(r,d) (r).an_x4_sw_sp0_lp_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_GET(r) (r).an_x4_sw_sp0_lp_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp0_lp_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp0_lp_page2[0]=(((r).an_x4_sw_sp0_lp_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_LP_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r,(_r._an_x4_sw_sp0_lp_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r,(_r._an_x4_sw_sp0_lp_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r,(_r._an_x4_sw_sp0_lp_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_lp_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_lp_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_lp_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_LP_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r
#define AN_X4_SW_SP0_LP_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_t AN_X4_SW_SP0_LP_PAGE2r_t;
#define AN_X4_SW_SP0_LP_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_CLR
#define AN_X4_SW_SP0_LP_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_SET
#define AN_X4_SW_SP0_LP_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_GET
#define AN_X4_SW_SP0_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP0_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP0_LP_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LP_PAGE2r
#define WRITE_AN_X4_SW_SP0_LP_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LP_PAGE2r
#define MODIFY_AN_X4_SW_SP0_LP_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LP_PAGE2r
#define READLN_AN_X4_SW_SP0_LP_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LP_PAGE2r
#define WRITELN_AN_X4_SW_SP0_LP_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LP_PAGE2r
#define WRITEALL_AN_X4_SW_SP0_LP_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LP_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_LP_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc284
 * DESC:     LINK PARNTER SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_1_PAGE_DATA LINK PARTNER PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r (0x0000c284 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_LP_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_lp_page1[1];
	uint32_t _an_x4_sw_sp0_lp_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_CLR(r) (r).an_x4_sw_sp0_lp_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_SET(r,d) (r).an_x4_sw_sp0_lp_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_GET(r) (r).an_x4_sw_sp0_lp_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp0_lp_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp0_lp_page1[0]=(((r).an_x4_sw_sp0_lp_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_LP_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r,(_r._an_x4_sw_sp0_lp_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r,(_r._an_x4_sw_sp0_lp_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r,(_r._an_x4_sw_sp0_lp_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_lp_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_lp_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_lp_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_LP_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r
#define AN_X4_SW_SP0_LP_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_t AN_X4_SW_SP0_LP_PAGE1r_t;
#define AN_X4_SW_SP0_LP_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_CLR
#define AN_X4_SW_SP0_LP_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_SET
#define AN_X4_SW_SP0_LP_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_GET
#define AN_X4_SW_SP0_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP0_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP0_LP_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LP_PAGE1r
#define WRITE_AN_X4_SW_SP0_LP_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LP_PAGE1r
#define MODIFY_AN_X4_SW_SP0_LP_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LP_PAGE1r
#define READLN_AN_X4_SW_SP0_LP_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LP_PAGE1r
#define WRITELN_AN_X4_SW_SP0_LP_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LP_PAGE1r
#define WRITEALL_AN_X4_SW_SP0_LP_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LP_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_LP_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc285
 * DESC:     LINK PARNTER SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_0_PAGE_DATA LINK PARTNER PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r (0x0000c285 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_LP_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_lp_page0[1];
	uint32_t _an_x4_sw_sp0_lp_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_CLR(r) (r).an_x4_sw_sp0_lp_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_SET(r,d) (r).an_x4_sw_sp0_lp_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_GET(r) (r).an_x4_sw_sp0_lp_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp0_lp_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp0_lp_page0[0]=(((r).an_x4_sw_sp0_lp_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_LP_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r,(_r._an_x4_sw_sp0_lp_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r,(_r._an_x4_sw_sp0_lp_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r,(_r._an_x4_sw_sp0_lp_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_lp_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_lp_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_lp_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_LP_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r
#define AN_X4_SW_SP0_LP_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_t AN_X4_SW_SP0_LP_PAGE0r_t;
#define AN_X4_SW_SP0_LP_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_CLR
#define AN_X4_SW_SP0_LP_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_SET
#define AN_X4_SW_SP0_LP_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_GET
#define AN_X4_SW_SP0_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP0_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP0_LP_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LP_PAGE0r
#define WRITE_AN_X4_SW_SP0_LP_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LP_PAGE0r
#define MODIFY_AN_X4_SW_SP0_LP_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LP_PAGE0r
#define READLN_AN_X4_SW_SP0_LP_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LP_PAGE0r
#define WRITELN_AN_X4_SW_SP0_LP_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LP_PAGE0r
#define WRITEALL_AN_X4_SW_SP0_LP_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LP_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_LP_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_SW_CTL_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc286
 * DESC:     SW CONTROL STATUS INFORMATION
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS1 TLA Lane sequencer fsm latched status cont.Clear on read of tla_ln_seq_status register
 *     PD_CL37_COMPLETED Parallel detect process has selected cl37 and it was completed.
 *     LP_STATUS_VALID  Set by HW, Clear on Read of lp_page_0
 *     LD_CONTROL_VALID Set by SW write to ld_page_0, Cleared when HW transfers the ld_page's
 *     AN_COMPLETED_SW  Software control page sequence. All page exchanges have completed
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr (0x0000c286 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_SW_CTL_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_sw_ctl_sts[1];
	uint32_t _an_x4_sw_sp0_sw_ctl_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_CLR(r) (r).an_x4_sw_sp0_sw_ctl_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_SET(r,d) (r).an_x4_sw_sp0_sw_ctl_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_GET(r) (r).an_x4_sw_sp0_sw_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_AN_COMPLETED_SWf_GET(r) ((((r).an_x4_sw_sp0_sw_ctl_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_AN_COMPLETED_SWf_SET(r,f) (r).an_x4_sw_sp0_sw_ctl_sts[0]=(((r).an_x4_sw_sp0_sw_ctl_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LD_CONTROL_VALIDf_GET(r) ((((r).an_x4_sw_sp0_sw_ctl_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LD_CONTROL_VALIDf_SET(r,f) (r).an_x4_sw_sp0_sw_ctl_sts[0]=(((r).an_x4_sw_sp0_sw_ctl_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LP_STATUS_VALIDf_GET(r) ((((r).an_x4_sw_sp0_sw_ctl_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LP_STATUS_VALIDf_SET(r,f) (r).an_x4_sw_sp0_sw_ctl_sts[0]=(((r).an_x4_sw_sp0_sw_ctl_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp0_sw_ctl_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp0_sw_ctl_sts[0]=(((r).an_x4_sw_sp0_sw_ctl_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET(r) (((r).an_x4_sw_sp0_sw_ctl_sts[0]) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET(r,f) (r).an_x4_sw_sp0_sw_ctl_sts[0]=(((r).an_x4_sw_sp0_sw_ctl_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_SW_CTL_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr,(_r._an_x4_sw_sp0_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr,(_r._an_x4_sw_sp0_sw_ctl_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr,(_r._an_x4_sw_sp0_sw_ctl_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_sw_ctl_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_SW_CTL_STSr BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr
#define AN_X4_SW_SP0_SW_CTL_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_t AN_X4_SW_SP0_SW_CTL_STSr_t;
#define AN_X4_SW_SP0_SW_CTL_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_CLR
#define AN_X4_SW_SP0_SW_CTL_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_SET
#define AN_X4_SW_SP0_SW_CTL_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_GET
#define AN_X4_SW_SP0_SW_CTL_STSr_AN_COMPLETED_SWf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_AN_COMPLETED_SWf_GET
#define AN_X4_SW_SP0_SW_CTL_STSr_AN_COMPLETED_SWf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_AN_COMPLETED_SWf_SET
#define AN_X4_SW_SP0_SW_CTL_STSr_LD_CONTROL_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LD_CONTROL_VALIDf_GET
#define AN_X4_SW_SP0_SW_CTL_STSr_LD_CONTROL_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LD_CONTROL_VALIDf_SET
#define AN_X4_SW_SP0_SW_CTL_STSr_LP_STATUS_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LP_STATUS_VALIDf_GET
#define AN_X4_SW_SP0_SW_CTL_STSr_LP_STATUS_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_LP_STATUS_VALIDf_SET
#define AN_X4_SW_SP0_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET
#define AN_X4_SW_SP0_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET
#define AN_X4_SW_SP0_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET
#define AN_X4_SW_SP0_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET
#define READ_AN_X4_SW_SP0_SW_CTL_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_SW_CTL_STSr
#define WRITE_AN_X4_SW_SP0_SW_CTL_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_SW_CTL_STSr
#define MODIFY_AN_X4_SW_SP0_SW_CTL_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_SW_CTL_STSr
#define READLN_AN_X4_SW_SP0_SW_CTL_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_SW_CTL_STSr
#define WRITELN_AN_X4_SW_SP0_SW_CTL_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_SW_CTL_STSr
#define WRITEALL_AN_X4_SW_SP0_SW_CTL_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_SW_CTL_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_SW_CTL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_LD_CTL
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc287
 * DESC:     LOCAL DEVICE CONTROLS
 * SIZE:     32
 * FIELDS:
 *     SW_HCD           Indicates HW does not perform HCD
 *     SW_AN            Indicates SW managed AN
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr (0x0000c287 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_LD_CTL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_ld_ctl[1];
	uint32_t _an_x4_sw_sp0_ld_ctl;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_CLR(r) (r).an_x4_sw_sp0_ld_ctl[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SET(r,d) (r).an_x4_sw_sp0_ld_ctl[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_GET(r) (r).an_x4_sw_sp0_ld_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_ANf_GET(r) ((((r).an_x4_sw_sp0_ld_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_ANf_SET(r,f) (r).an_x4_sw_sp0_ld_ctl[0]=(((r).an_x4_sw_sp0_ld_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_HCDf_GET(r) (((r).an_x4_sw_sp0_ld_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_HCDf_SET(r,f) (r).an_x4_sw_sp0_ld_ctl[0]=(((r).an_x4_sw_sp0_ld_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_LD_CTL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr,(_r._an_x4_sw_sp0_ld_ctl))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr,(_r._an_x4_sw_sp0_ld_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr,(_r._an_x4_sw_sp0_ld_ctl))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_ctl))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_ld_ctl))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_ld_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_LD_CTLr BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr
#define AN_X4_SW_SP0_LD_CTLr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_t AN_X4_SW_SP0_LD_CTLr_t;
#define AN_X4_SW_SP0_LD_CTLr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_CLR
#define AN_X4_SW_SP0_LD_CTLr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SET
#define AN_X4_SW_SP0_LD_CTLr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_GET
#define AN_X4_SW_SP0_LD_CTLr_SW_ANf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_ANf_GET
#define AN_X4_SW_SP0_LD_CTLr_SW_ANf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_ANf_SET
#define AN_X4_SW_SP0_LD_CTLr_SW_HCDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_HCDf_GET
#define AN_X4_SW_SP0_LD_CTLr_SW_HCDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr_SW_HCDf_SET
#define READ_AN_X4_SW_SP0_LD_CTLr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_LD_CTLr
#define WRITE_AN_X4_SW_SP0_LD_CTLr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_LD_CTLr
#define MODIFY_AN_X4_SW_SP0_LD_CTLr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_LD_CTLr
#define READLN_AN_X4_SW_SP0_LD_CTLr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_LD_CTLr
#define WRITELN_AN_X4_SW_SP0_LD_CTLr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_LD_CTLr
#define WRITEALL_AN_X4_SW_SP0_LD_CTLr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_LD_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_LD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc288
 * DESC:     AN PAGE SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CL73_COMPLETE CL73 auto-neg is complete
 *     AN_ST_CL37_COMPLETE CL37 auto-neg is completeClear on read
 *     AN_ST_RX_NP_TOGGLE_ERR Received auto-neg next page without T togglingClear on read
 *     AN_ST_RX_INVALID_SEQ Received invalid auto-neg page sequenceClear on read
 *     AN_ST_RX_UP_OUI_MATCH Received auto-neg MPS-5 OUI matchClear on read
 *     AN_ST_RX_UP_OUI_MISMATCH Received auto-neg MPS-5 OUI mismatchClear on read
 *     AN_ST_RX_UP_3    Received auto-neg unformatted page 3Clear on read
 *     AN_ST_RX_MP_MISMATCH Received mismatching auto-neg message pageClear on read
 *     AN_ST_RX_MP_OVER1G Received auto-neg message page 1024 (Over1G Message)Clear on read
 *     AN_ST_RX_MP_OUI  Received auto-neg message page 5 (Organizationally Unique Identifier Message)Clear on read
 *     AN_ST_RX_MP_NULL Received auto-neg message page 1 (Null Message)Clear on read
 *     AN_ST_RX_NP      Received auto-neg next pageClear on read
 *     AN_ST_RX_BP      Received auto-neg base pageClear on read
 *     AN_ST_RX_SGMII_MISMATCH Received non-SGMII page when in SGMII auto-neg modeClear on read
 *     AN_ST_HP_MODE    In Hewlett-Packard auto-neg modeClear on read
 *     AN_ST_SGMII_MODE In Cisco SGMII auto-neg modeClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr (0x0000c288 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_an_page_sequencer_sts[1];
	uint32_t _an_x4_sw_sp0_an_page_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp0_an_page_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp0_an_page_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET(r) ((((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET(r) (((r).an_x4_sw_sp0_an_page_sequencer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET(r,f) (r).an_x4_sw_sp0_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp0_an_page_sequencer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp0_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp0_an_page_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp0_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_an_page_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_t AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_t;
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET
#define AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET
#define READ_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc289
 * DESC:     AN PAGE EXCHANGER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CONFIG_RESTART Received auto-neg restart (0) page
 *     AN_ST_IDLE_DETECT Entered auto-neg IDLE_DETECT stateClear on read
 *     AN_ST_DISABLE_LINK Entered auto-neg DISABLE_LINK stateClear on read
 *     AN_ST_ERROR_STATE Entered auto-neg ERROR stateClear on read
 *     AN_ST_AN_ENABLE  Entered auto-neg AN_ENABLE stateClear on read
 *     AN_ST_ABILITY_DETECT Entered auto-neg ABILITY_DETECT stateClear on read
 *     AN_ST_ACK_DETECT Entered auto-neg ACKNOWLEDGE_DETECT stateClear on read
 *     AN_ST_COMPLETE_ACK Entered auto-neg COMPLETE_ACKNOWLEDGE stateClear on read
 *     AN_ST_CONSISTENCY_MISMATCH Auto-neg consistency mismatch detectedClear on read
 *     AN_ST_CONFIG_NONZERO Page Exchanger Received non-zero configuration ordered setClear on read
 *     AN_ST_RESTART    Page Exchanger entered AN_RESTART stateClear on read
 *     AN_ST_AN_GOOD_CHECK Page Exchanger entered AN_GOOD_CHECK stateClear on read
 *     AN_ST_LINK_OK    Page Exchanger entered LINK_OK stateClear on read
 *     AN_ST_NEXT_PAGE_WAIT Page Exchanger entered NEXT_PAGE_WAIT stateClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr (0x0000c289 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_an_page_exchangeer_sts[1];
	uint32_t _an_x4_sw_sp0_an_page_exchangeer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_CLR(r) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_SET(r,d) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_GET(r) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET(r) ((((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET(r) (((r).an_x4_sw_sp0_an_page_exchangeer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET(r,f) (r).an_x4_sw_sp0_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp0_an_page_exchangeer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp0_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp0_an_page_exchangeer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp0_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_an_page_exchangeer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_t AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_t;
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_CLR
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET
#define AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET
#define READ_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr
#define WRITE_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr
#define MODIFY_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr
#define READLN_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr
#define WRITELN_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr
#define WRITEALL_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_EXCHANGEER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_AN_PAGE_DECR_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc28a
 * DESC:     AN PAGE DECODER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_RX_ST_STATE   DME Receive State
 *     AN_RX_ST_RUDI_INVALID Received invalid ordered setClear on read
 *     AN_RX_ST_RUDI_CONFIG Received configuration ordered setClear on read
 *     AN_RX_ST_RUDI_IDLE Received idle ordered setClear on read
 *     AN_RX_ST_PAGE    Valid DME page receivedClear on read
 *     AN_RX_ST_MV_PAIR DME Delimiter detectedClear on read
 *     AN_RX_ST_CLK_TRANS_MISS Missing DME clock transition detectedClear on read
 *     AN_RX_ST_PAGE_TOO_LONG A CL73 DME page longer than the maximum specified by cl73_page_test_max_timer was detectedClear on read
 *     AN_RX_ST_PAGE_TOO_SHORT A CL73 DME page shorter than the  minimum specified by cl73_page_test_min_timer was detectedClear on read
 *     AN_RX_ST_PULSE_TOO_LONG Too long DME pulse detectedDuration - minimum 35 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_SHORT Too short DME pulse detectedDuration - 2 to 4 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_MODERATE Too moderate DME pulse detectedDuration - 19 to 29 samples. Each sample 0.4nsClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr (0x0000c28a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_AN_PAGE_DECR_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_an_page_decr_sts[1];
	uint32_t _an_x4_sw_sp0_an_page_decr_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_CLR(r) (r).an_x4_sw_sp0_an_page_decr_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_SET(r,d) (r).an_x4_sw_sp0_an_page_decr_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_GET(r) (r).an_x4_sw_sp0_an_page_decr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET(r) ((((r).an_x4_sw_sp0_an_page_decr_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET(r) (((r).an_x4_sw_sp0_an_page_decr_sts[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET(r,f) (r).an_x4_sw_sp0_an_page_decr_sts[0]=(((r).an_x4_sw_sp0_an_page_decr_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_AN_PAGE_DECR_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp0_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp0_an_page_decr_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp0_an_page_decr_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_an_page_decr_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_t AN_X4_SW_SP0_AN_PAGE_DECR_STSr_t;
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_CLR
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET
#define AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET
#define READ_AN_X4_SW_SP0_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_PAGE_DECR_STSr
#define WRITE_AN_X4_SW_SP0_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_PAGE_DECR_STSr
#define MODIFY_AN_X4_SW_SP0_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_PAGE_DECR_STSr
#define READLN_AN_X4_SW_SP0_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_PAGE_DECR_STSr
#define WRITELN_AN_X4_SW_SP0_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_PAGE_DECR_STSr
#define WRITEALL_AN_X4_SW_SP0_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_PAGE_DECR_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_PAGE_DECR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc28b
 * DESC:     AN ABILITY RESOLUTION INFORMATION
 * SIZE:     32
 * FIELDS:
 *     AN_HCD_SWITCH_TO_CL37 HCD an_hcd_switch_to_cl37
 *     AN_HCD_HIGIG2    HCD Hi-Gig II ability
 *     AN_HCD_CL72      HCD training ability
 *     AN_HCD_FEC       HCD forward-error correction ability
 *     AN_HCD_SPEED     HCD speed
 *     AN_HCD_PAUSE     HCD Pause Ability[11:10]00 - None01 - TX (from LD to LP)10 - RX (from LP to LD)11 - TX/RX (symmetrical)
 *     AN_HCD_DUPLEX    HCD full-duplex ability
 *     AN_ST_RESOLUTION_ERR No common speed or No common Duplex settings or Selector is wrong
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr (0x0000c28b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_an_abil_resolution_sts[1];
	uint32_t _an_x4_sw_sp0_an_abil_resolution_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_CLR(r) (r).an_x4_sw_sp0_an_abil_resolution_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_SET(r,d) (r).an_x4_sw_sp0_an_abil_resolution_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_GET(r) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET(r) ((((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET(r) ((((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) >> 12) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET(r) ((((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) >> 4) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET(r) ((((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET(r) ((((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET(r) ((((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET(r) (((r).an_x4_sw_sp0_an_abil_resolution_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET(r,f) (r).an_x4_sw_sp0_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp0_an_abil_resolution_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp0_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp0_an_abil_resolution_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp0_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_an_abil_resolution_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_t AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_t;
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_CLR
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET
#define AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET
#define READ_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr
#define WRITE_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr
#define MODIFY_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr
#define READLN_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr
#define WRITELN_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr
#define WRITEALL_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_ABIL_RESOLUTION_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_AN_MISC_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc28c
 * DESC:     MISCILLANEOUS AN STATUS
 * SIZE:     32
 * FIELDS:
 *     PD_HCD_KX4_OR_KX Speed status for PD attempt0: KX4, 1: KX
 *     PD_IN_PROGRESS   Currently Parallel detect is active
 *     AN_FAIL_COUNT    Number of AN retries due to AN failureSaturate, Clear on AN Restart
 *     AN_ACTIVE        Auto-neg in progress
 *     PD_COMPLETED     Parallel detect process is
 *     REMOTE_FAULT_IN_BASE_PAGE Remote fault indicated in AN base pageClear on AN Restart
 *     AN_RETRY_COUNT   Number of AN retried for any reasonSaturate, Clear on AN Restart
 *     AN_COMPLETE      
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr (0x0000c28c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_AN_MISC_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_an_misc_sts[1];
	uint32_t _an_x4_sw_sp0_an_misc_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_CLR(r) (r).an_x4_sw_sp0_an_misc_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_SET(r,d) (r).an_x4_sw_sp0_an_misc_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_GET(r) (r).an_x4_sw_sp0_an_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_COMPLETEf_GET(r) ((((r).an_x4_sw_sp0_an_misc_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_COMPLETEf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_RETRY_COUNTf_GET(r) ((((r).an_x4_sw_sp0_an_misc_sts[0]) >> 9) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_RETRY_COUNTf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET(r) ((((r).an_x4_sw_sp0_an_misc_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp0_an_misc_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_ACTIVEf_GET(r) ((((r).an_x4_sw_sp0_an_misc_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_ACTIVEf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_FAIL_COUNTf_GET(r) ((((r).an_x4_sw_sp0_an_misc_sts[0]) >> 2) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_FAIL_COUNTf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_IN_PROGRESSf_GET(r) ((((r).an_x4_sw_sp0_an_misc_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_IN_PROGRESSf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET(r) (((r).an_x4_sw_sp0_an_misc_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET(r,f) (r).an_x4_sw_sp0_an_misc_sts[0]=(((r).an_x4_sw_sp0_an_misc_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_AN_MISC_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr,(_r._an_x4_sw_sp0_an_misc_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr,(_r._an_x4_sw_sp0_an_misc_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr,(_r._an_x4_sw_sp0_an_misc_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_misc_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_misc_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_an_misc_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_AN_MISC_STSr BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr
#define AN_X4_SW_SP0_AN_MISC_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_t AN_X4_SW_SP0_AN_MISC_STSr_t;
#define AN_X4_SW_SP0_AN_MISC_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_CLR
#define AN_X4_SW_SP0_AN_MISC_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_COMPLETEf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_COMPLETEf_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_RETRY_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_RETRY_COUNTf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_RETRY_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_RETRY_COUNTf_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_PD_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_COMPLETEDf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_PD_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_COMPLETEDf_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_ACTIVEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_ACTIVEf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_ACTIVEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_ACTIVEf_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_FAIL_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_FAIL_COUNTf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_AN_FAIL_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_AN_FAIL_COUNTf_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_PD_IN_PROGRESSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_IN_PROGRESSf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_PD_IN_PROGRESSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_IN_PROGRESSf_SET
#define AN_X4_SW_SP0_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET
#define AN_X4_SW_SP0_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET
#define READ_AN_X4_SW_SP0_AN_MISC_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_MISC_STSr
#define WRITE_AN_X4_SW_SP0_AN_MISC_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_MISC_STSr
#define MODIFY_AN_X4_SW_SP0_AN_MISC_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_MISC_STSr
#define READLN_AN_X4_SW_SP0_AN_MISC_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_MISC_STSr
#define WRITELN_AN_X4_SW_SP0_AN_MISC_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_MISC_STSr
#define WRITEALL_AN_X4_SW_SP0_AN_MISC_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_MISC_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_MISC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_TLA_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc28d
 * DESC:     TLA SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS TLA Lane sequencer fsm latched statusClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr (0x0000c28d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_TLA_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_tla_sequencer_sts[1];
	uint32_t _an_x4_sw_sp0_tla_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp0_tla_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp0_tla_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp0_tla_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET(r) (((r).an_x4_sw_sp0_tla_sequencer_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET(r,f) (r).an_x4_sw_sp0_tla_sequencer_sts[0]=(((r).an_x4_sw_sp0_tla_sequencer_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_TLA_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp0_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp0_tla_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp0_tla_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_tla_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr
#define AN_X4_SW_SP0_TLA_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_t AN_X4_SW_SP0_TLA_SEQUENCER_STSr_t;
#define AN_X4_SW_SP0_TLA_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP0_TLA_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_SET
#define AN_X4_SW_SP0_TLA_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_GET
#define AN_X4_SW_SP0_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET
#define AN_X4_SW_SP0_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET
#define READ_AN_X4_SW_SP0_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_TLA_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP0_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_TLA_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP0_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_TLA_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP0_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_TLA_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP0_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_TLA_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP0_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_TLA_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_TLA_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGE
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP0
 * REGADDR:  0xc28e
 * DESC:     AN SEQUENCER UNEXPECTED PAGE
 * SIZE:     32
 * FIELDS:
 *     SEQ_UNEXPECTED_PAGE First unexpected page received
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr (0x0000c28e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGE.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp0_an_seq_unexpected_page[1];
	uint32_t _an_x4_sw_sp0_an_seq_unexpected_page;
} BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_CLR(r) (r).an_x4_sw_sp0_an_seq_unexpected_page[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SET(r,d) (r).an_x4_sw_sp0_an_seq_unexpected_page[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_GET(r) (r).an_x4_sw_sp0_an_seq_unexpected_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET(r) (((r).an_x4_sw_sp0_an_seq_unexpected_page[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET(r,f) (r).an_x4_sw_sp0_an_seq_unexpected_page[0]=(((r).an_x4_sw_sp0_an_seq_unexpected_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGE.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp0_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp0_an_seq_unexpected_page)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp0_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp0_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp0_an_seq_unexpected_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr
#define AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_t AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_t;
#define AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_CLR
#define AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SET
#define AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_GET
#define AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET
#define AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET
#define READ_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READ_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr
#define WRITE_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr
#define MODIFY_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr
#define READLN_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr
#define WRITELN_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr
#define WRITEALL_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP0_AN_SEQ_UNEXPECTED_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_LD_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc290
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_2_PAGE_DATA LOCAL DEVICE PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r (0x0000c290 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_LD_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_ld_page2[1];
	uint32_t _an_x4_sw_sp1_ld_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_CLR(r) (r).an_x4_sw_sp1_ld_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_SET(r,d) (r).an_x4_sw_sp1_ld_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_GET(r) (r).an_x4_sw_sp1_ld_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp1_ld_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp1_ld_page2[0]=(((r).an_x4_sw_sp1_ld_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_LD_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r,(_r._an_x4_sw_sp1_ld_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r,(_r._an_x4_sw_sp1_ld_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r,(_r._an_x4_sw_sp1_ld_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_ld_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_LD_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r
#define AN_X4_SW_SP1_LD_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_t AN_X4_SW_SP1_LD_PAGE2r_t;
#define AN_X4_SW_SP1_LD_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_CLR
#define AN_X4_SW_SP1_LD_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_SET
#define AN_X4_SW_SP1_LD_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_GET
#define AN_X4_SW_SP1_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP1_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP1_LD_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_PAGE2r
#define WRITE_AN_X4_SW_SP1_LD_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_PAGE2r
#define MODIFY_AN_X4_SW_SP1_LD_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_PAGE2r
#define READLN_AN_X4_SW_SP1_LD_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_PAGE2r
#define WRITELN_AN_X4_SW_SP1_LD_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_PAGE2r
#define WRITEALL_AN_X4_SW_SP1_LD_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_LD_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc291
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_1_PAGE_DATA LOCAL DEVICE PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r (0x0000c291 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_LD_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_ld_page1[1];
	uint32_t _an_x4_sw_sp1_ld_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_CLR(r) (r).an_x4_sw_sp1_ld_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_SET(r,d) (r).an_x4_sw_sp1_ld_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_GET(r) (r).an_x4_sw_sp1_ld_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp1_ld_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp1_ld_page1[0]=(((r).an_x4_sw_sp1_ld_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_LD_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r,(_r._an_x4_sw_sp1_ld_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r,(_r._an_x4_sw_sp1_ld_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r,(_r._an_x4_sw_sp1_ld_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_ld_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_LD_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r
#define AN_X4_SW_SP1_LD_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_t AN_X4_SW_SP1_LD_PAGE1r_t;
#define AN_X4_SW_SP1_LD_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_CLR
#define AN_X4_SW_SP1_LD_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_SET
#define AN_X4_SW_SP1_LD_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_GET
#define AN_X4_SW_SP1_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP1_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP1_LD_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_PAGE1r
#define WRITE_AN_X4_SW_SP1_LD_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_PAGE1r
#define MODIFY_AN_X4_SW_SP1_LD_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_PAGE1r
#define READLN_AN_X4_SW_SP1_LD_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_PAGE1r
#define WRITELN_AN_X4_SW_SP1_LD_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_PAGE1r
#define WRITEALL_AN_X4_SW_SP1_LD_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_LD_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc292
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_0_PAGE_DATA LOCAL DEVICE PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r (0x0000c292 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_LD_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_ld_page0[1];
	uint32_t _an_x4_sw_sp1_ld_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_CLR(r) (r).an_x4_sw_sp1_ld_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_SET(r,d) (r).an_x4_sw_sp1_ld_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_GET(r) (r).an_x4_sw_sp1_ld_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp1_ld_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp1_ld_page0[0]=(((r).an_x4_sw_sp1_ld_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_LD_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r,(_r._an_x4_sw_sp1_ld_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r,(_r._an_x4_sw_sp1_ld_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r,(_r._an_x4_sw_sp1_ld_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_ld_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_LD_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r
#define AN_X4_SW_SP1_LD_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_t AN_X4_SW_SP1_LD_PAGE0r_t;
#define AN_X4_SW_SP1_LD_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_CLR
#define AN_X4_SW_SP1_LD_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_SET
#define AN_X4_SW_SP1_LD_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_GET
#define AN_X4_SW_SP1_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP1_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP1_LD_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_PAGE0r
#define WRITE_AN_X4_SW_SP1_LD_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_PAGE0r
#define MODIFY_AN_X4_SW_SP1_LD_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_PAGE0r
#define READLN_AN_X4_SW_SP1_LD_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_PAGE0r
#define WRITELN_AN_X4_SW_SP1_LD_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_PAGE0r
#define WRITEALL_AN_X4_SW_SP1_LD_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_LP_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc293
 * DESC:     LINK PARNTER SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_2_PAGE_DATA LINK PARTNER PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r (0x0000c293 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_LP_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_lp_page2[1];
	uint32_t _an_x4_sw_sp1_lp_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_CLR(r) (r).an_x4_sw_sp1_lp_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_SET(r,d) (r).an_x4_sw_sp1_lp_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_GET(r) (r).an_x4_sw_sp1_lp_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp1_lp_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp1_lp_page2[0]=(((r).an_x4_sw_sp1_lp_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_LP_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r,(_r._an_x4_sw_sp1_lp_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r,(_r._an_x4_sw_sp1_lp_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r,(_r._an_x4_sw_sp1_lp_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_lp_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_lp_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_lp_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_LP_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r
#define AN_X4_SW_SP1_LP_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_t AN_X4_SW_SP1_LP_PAGE2r_t;
#define AN_X4_SW_SP1_LP_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_CLR
#define AN_X4_SW_SP1_LP_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_SET
#define AN_X4_SW_SP1_LP_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_GET
#define AN_X4_SW_SP1_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP1_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP1_LP_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LP_PAGE2r
#define WRITE_AN_X4_SW_SP1_LP_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LP_PAGE2r
#define MODIFY_AN_X4_SW_SP1_LP_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LP_PAGE2r
#define READLN_AN_X4_SW_SP1_LP_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LP_PAGE2r
#define WRITELN_AN_X4_SW_SP1_LP_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LP_PAGE2r
#define WRITEALL_AN_X4_SW_SP1_LP_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LP_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_LP_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc294
 * DESC:     LINK PARNTER SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_1_PAGE_DATA LINK PARTNER PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r (0x0000c294 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_LP_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_lp_page1[1];
	uint32_t _an_x4_sw_sp1_lp_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_CLR(r) (r).an_x4_sw_sp1_lp_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_SET(r,d) (r).an_x4_sw_sp1_lp_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_GET(r) (r).an_x4_sw_sp1_lp_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp1_lp_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp1_lp_page1[0]=(((r).an_x4_sw_sp1_lp_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_LP_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r,(_r._an_x4_sw_sp1_lp_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r,(_r._an_x4_sw_sp1_lp_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r,(_r._an_x4_sw_sp1_lp_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_lp_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_lp_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_lp_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_LP_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r
#define AN_X4_SW_SP1_LP_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_t AN_X4_SW_SP1_LP_PAGE1r_t;
#define AN_X4_SW_SP1_LP_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_CLR
#define AN_X4_SW_SP1_LP_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_SET
#define AN_X4_SW_SP1_LP_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_GET
#define AN_X4_SW_SP1_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP1_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP1_LP_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LP_PAGE1r
#define WRITE_AN_X4_SW_SP1_LP_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LP_PAGE1r
#define MODIFY_AN_X4_SW_SP1_LP_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LP_PAGE1r
#define READLN_AN_X4_SW_SP1_LP_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LP_PAGE1r
#define WRITELN_AN_X4_SW_SP1_LP_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LP_PAGE1r
#define WRITEALL_AN_X4_SW_SP1_LP_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LP_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_LP_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc295
 * DESC:     LINK PARNTER SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_0_PAGE_DATA LINK PARTNER PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r (0x0000c295 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_LP_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_lp_page0[1];
	uint32_t _an_x4_sw_sp1_lp_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_CLR(r) (r).an_x4_sw_sp1_lp_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_SET(r,d) (r).an_x4_sw_sp1_lp_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_GET(r) (r).an_x4_sw_sp1_lp_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp1_lp_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp1_lp_page0[0]=(((r).an_x4_sw_sp1_lp_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_LP_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r,(_r._an_x4_sw_sp1_lp_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r,(_r._an_x4_sw_sp1_lp_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r,(_r._an_x4_sw_sp1_lp_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_lp_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_lp_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_lp_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_LP_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r
#define AN_X4_SW_SP1_LP_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_t AN_X4_SW_SP1_LP_PAGE0r_t;
#define AN_X4_SW_SP1_LP_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_CLR
#define AN_X4_SW_SP1_LP_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_SET
#define AN_X4_SW_SP1_LP_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_GET
#define AN_X4_SW_SP1_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP1_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP1_LP_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LP_PAGE0r
#define WRITE_AN_X4_SW_SP1_LP_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LP_PAGE0r
#define MODIFY_AN_X4_SW_SP1_LP_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LP_PAGE0r
#define READLN_AN_X4_SW_SP1_LP_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LP_PAGE0r
#define WRITELN_AN_X4_SW_SP1_LP_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LP_PAGE0r
#define WRITEALL_AN_X4_SW_SP1_LP_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LP_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_LP_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_SW_CTL_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc296
 * DESC:     SW CONTROL STATUS INFORMATION
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS1 TLA Lane sequencer fsm latched status cont.Clear on read of tla_ln_seq_status register
 *     PD_CL37_COMPLETED Parallel detect process has selected cl37 and it was completed.
 *     LP_STATUS_VALID  Set by HW, Clear on Read of lp_page_0
 *     LD_CONTROL_VALID Set by SW write to ld_page_0, Cleared when HW transfers the ld_page's
 *     AN_COMPLETED_SW  Software control page sequence. All page exchanges have completed
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr (0x0000c296 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_SW_CTL_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_sw_ctl_sts[1];
	uint32_t _an_x4_sw_sp1_sw_ctl_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_CLR(r) (r).an_x4_sw_sp1_sw_ctl_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_SET(r,d) (r).an_x4_sw_sp1_sw_ctl_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_GET(r) (r).an_x4_sw_sp1_sw_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_AN_COMPLETED_SWf_GET(r) ((((r).an_x4_sw_sp1_sw_ctl_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_AN_COMPLETED_SWf_SET(r,f) (r).an_x4_sw_sp1_sw_ctl_sts[0]=(((r).an_x4_sw_sp1_sw_ctl_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LD_CONTROL_VALIDf_GET(r) ((((r).an_x4_sw_sp1_sw_ctl_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LD_CONTROL_VALIDf_SET(r,f) (r).an_x4_sw_sp1_sw_ctl_sts[0]=(((r).an_x4_sw_sp1_sw_ctl_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LP_STATUS_VALIDf_GET(r) ((((r).an_x4_sw_sp1_sw_ctl_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LP_STATUS_VALIDf_SET(r,f) (r).an_x4_sw_sp1_sw_ctl_sts[0]=(((r).an_x4_sw_sp1_sw_ctl_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp1_sw_ctl_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp1_sw_ctl_sts[0]=(((r).an_x4_sw_sp1_sw_ctl_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET(r) (((r).an_x4_sw_sp1_sw_ctl_sts[0]) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET(r,f) (r).an_x4_sw_sp1_sw_ctl_sts[0]=(((r).an_x4_sw_sp1_sw_ctl_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_SW_CTL_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr,(_r._an_x4_sw_sp1_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr,(_r._an_x4_sw_sp1_sw_ctl_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr,(_r._an_x4_sw_sp1_sw_ctl_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_sw_ctl_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_SW_CTL_STSr BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr
#define AN_X4_SW_SP1_SW_CTL_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_t AN_X4_SW_SP1_SW_CTL_STSr_t;
#define AN_X4_SW_SP1_SW_CTL_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_CLR
#define AN_X4_SW_SP1_SW_CTL_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_SET
#define AN_X4_SW_SP1_SW_CTL_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_GET
#define AN_X4_SW_SP1_SW_CTL_STSr_AN_COMPLETED_SWf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_AN_COMPLETED_SWf_GET
#define AN_X4_SW_SP1_SW_CTL_STSr_AN_COMPLETED_SWf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_AN_COMPLETED_SWf_SET
#define AN_X4_SW_SP1_SW_CTL_STSr_LD_CONTROL_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LD_CONTROL_VALIDf_GET
#define AN_X4_SW_SP1_SW_CTL_STSr_LD_CONTROL_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LD_CONTROL_VALIDf_SET
#define AN_X4_SW_SP1_SW_CTL_STSr_LP_STATUS_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LP_STATUS_VALIDf_GET
#define AN_X4_SW_SP1_SW_CTL_STSr_LP_STATUS_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_LP_STATUS_VALIDf_SET
#define AN_X4_SW_SP1_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET
#define AN_X4_SW_SP1_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET
#define AN_X4_SW_SP1_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET
#define AN_X4_SW_SP1_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET
#define READ_AN_X4_SW_SP1_SW_CTL_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_SW_CTL_STSr
#define WRITE_AN_X4_SW_SP1_SW_CTL_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_SW_CTL_STSr
#define MODIFY_AN_X4_SW_SP1_SW_CTL_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_SW_CTL_STSr
#define READLN_AN_X4_SW_SP1_SW_CTL_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_SW_CTL_STSr
#define WRITELN_AN_X4_SW_SP1_SW_CTL_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_SW_CTL_STSr
#define WRITEALL_AN_X4_SW_SP1_SW_CTL_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_SW_CTL_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_SW_CTL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_LD_CTL
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc297
 * DESC:     LOCAL DEVICE CONTROLS
 * SIZE:     32
 * FIELDS:
 *     SW_HCD           Indicates HW does not perform HCD
 *     SW_AN            Indicates SW managed AN
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr (0x0000c297 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_LD_CTL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_ld_ctl[1];
	uint32_t _an_x4_sw_sp1_ld_ctl;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_CLR(r) (r).an_x4_sw_sp1_ld_ctl[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SET(r,d) (r).an_x4_sw_sp1_ld_ctl[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_GET(r) (r).an_x4_sw_sp1_ld_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_ANf_GET(r) ((((r).an_x4_sw_sp1_ld_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_ANf_SET(r,f) (r).an_x4_sw_sp1_ld_ctl[0]=(((r).an_x4_sw_sp1_ld_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_HCDf_GET(r) (((r).an_x4_sw_sp1_ld_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_HCDf_SET(r,f) (r).an_x4_sw_sp1_ld_ctl[0]=(((r).an_x4_sw_sp1_ld_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_LD_CTL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr,(_r._an_x4_sw_sp1_ld_ctl))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr,(_r._an_x4_sw_sp1_ld_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr,(_r._an_x4_sw_sp1_ld_ctl))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_ctl))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_ld_ctl))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_ld_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_LD_CTLr BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr
#define AN_X4_SW_SP1_LD_CTLr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_t AN_X4_SW_SP1_LD_CTLr_t;
#define AN_X4_SW_SP1_LD_CTLr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_CLR
#define AN_X4_SW_SP1_LD_CTLr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SET
#define AN_X4_SW_SP1_LD_CTLr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_GET
#define AN_X4_SW_SP1_LD_CTLr_SW_ANf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_ANf_GET
#define AN_X4_SW_SP1_LD_CTLr_SW_ANf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_ANf_SET
#define AN_X4_SW_SP1_LD_CTLr_SW_HCDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_HCDf_GET
#define AN_X4_SW_SP1_LD_CTLr_SW_HCDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr_SW_HCDf_SET
#define READ_AN_X4_SW_SP1_LD_CTLr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_LD_CTLr
#define WRITE_AN_X4_SW_SP1_LD_CTLr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_LD_CTLr
#define MODIFY_AN_X4_SW_SP1_LD_CTLr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_LD_CTLr
#define READLN_AN_X4_SW_SP1_LD_CTLr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_LD_CTLr
#define WRITELN_AN_X4_SW_SP1_LD_CTLr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_LD_CTLr
#define WRITEALL_AN_X4_SW_SP1_LD_CTLr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_LD_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_LD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc298
 * DESC:     AN PAGE SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CL73_COMPLETE CL73 auto-neg is complete
 *     AN_ST_CL37_COMPLETE CL37 auto-neg is completeClear on read
 *     AN_ST_RX_NP_TOGGLE_ERR Received auto-neg next page without T togglingClear on read
 *     AN_ST_RX_INVALID_SEQ Received invalid auto-neg page sequenceClear on read
 *     AN_ST_RX_UP_OUI_MATCH Received auto-neg MPS-5 OUI matchClear on read
 *     AN_ST_RX_UP_OUI_MISMATCH Received auto-neg MPS-5 OUI mismatchClear on read
 *     AN_ST_RX_UP_3    Received auto-neg unformatted page 3Clear on read
 *     AN_ST_RX_MP_MISMATCH Received mismatching auto-neg message pageClear on read
 *     AN_ST_RX_MP_OVER1G Received auto-neg message page 1024 (Over1G Message)Clear on read
 *     AN_ST_RX_MP_OUI  Received auto-neg message page 5 (Organizationally Unique Identifier Message)Clear on read
 *     AN_ST_RX_MP_NULL Received auto-neg message page 1 (Null Message)Clear on read
 *     AN_ST_RX_NP      Received auto-neg next pageClear on read
 *     AN_ST_RX_BP      Received auto-neg base pageClear on read
 *     AN_ST_RX_SGMII_MISMATCH Received non-SGMII page when in SGMII auto-neg modeClear on read
 *     AN_ST_HP_MODE    In Hewlett-Packard auto-neg modeClear on read
 *     AN_ST_SGMII_MODE In Cisco SGMII auto-neg modeClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr (0x0000c298 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_an_page_sequencer_sts[1];
	uint32_t _an_x4_sw_sp1_an_page_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp1_an_page_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp1_an_page_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET(r) ((((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET(r) (((r).an_x4_sw_sp1_an_page_sequencer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET(r,f) (r).an_x4_sw_sp1_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp1_an_page_sequencer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp1_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp1_an_page_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp1_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_an_page_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_t AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_t;
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET
#define AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET
#define READ_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc299
 * DESC:     AN PAGE EXCHANGER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CONFIG_RESTART Received auto-neg restart (0) page
 *     AN_ST_IDLE_DETECT Entered auto-neg IDLE_DETECT stateClear on read
 *     AN_ST_DISABLE_LINK Entered auto-neg DISABLE_LINK stateClear on read
 *     AN_ST_ERROR_STATE Entered auto-neg ERROR stateClear on read
 *     AN_ST_AN_ENABLE  Entered auto-neg AN_ENABLE stateClear on read
 *     AN_ST_ABILITY_DETECT Entered auto-neg ABILITY_DETECT stateClear on read
 *     AN_ST_ACK_DETECT Entered auto-neg ACKNOWLEDGE_DETECT stateClear on read
 *     AN_ST_COMPLETE_ACK Entered auto-neg COMPLETE_ACKNOWLEDGE stateClear on read
 *     AN_ST_CONSISTENCY_MISMATCH Auto-neg consistency mismatch detectedClear on read
 *     AN_ST_CONFIG_NONZERO Page Exchanger Received non-zero configuration ordered setClear on read
 *     AN_ST_RESTART    Page Exchanger entered AN_RESTART stateClear on read
 *     AN_ST_AN_GOOD_CHECK Page Exchanger entered AN_GOOD_CHECK stateClear on read
 *     AN_ST_LINK_OK    Page Exchanger entered LINK_OK stateClear on read
 *     AN_ST_NEXT_PAGE_WAIT Page Exchanger entered NEXT_PAGE_WAIT stateClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr (0x0000c299 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_an_page_exchangeer_sts[1];
	uint32_t _an_x4_sw_sp1_an_page_exchangeer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_CLR(r) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_SET(r,d) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_GET(r) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET(r) ((((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET(r) (((r).an_x4_sw_sp1_an_page_exchangeer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET(r,f) (r).an_x4_sw_sp1_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp1_an_page_exchangeer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp1_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp1_an_page_exchangeer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp1_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_an_page_exchangeer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_t AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_t;
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_CLR
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET
#define AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET
#define READ_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr
#define WRITE_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr
#define MODIFY_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr
#define READLN_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr
#define WRITELN_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr
#define WRITEALL_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_EXCHANGEER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_AN_PAGE_DECR_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc29a
 * DESC:     AN PAGE DECODER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_RX_ST_STATE   DME Receive State
 *     AN_RX_ST_RUDI_INVALID Received invalid ordered setClear on read
 *     AN_RX_ST_RUDI_CONFIG Received configuration ordered setClear on read
 *     AN_RX_ST_RUDI_IDLE Received idle ordered setClear on read
 *     AN_RX_ST_PAGE    Valid DME page receivedClear on read
 *     AN_RX_ST_MV_PAIR DME Delimiter detectedClear on read
 *     AN_RX_ST_CLK_TRANS_MISS Missing DME clock transition detectedClear on read
 *     AN_RX_ST_PAGE_TOO_LONG A CL73 DME page longer than the maximum specified by cl73_page_test_max_timer was detectedClear on read
 *     AN_RX_ST_PAGE_TOO_SHORT A CL73 DME page shorter than the  minimum specified by cl73_page_test_min_timer was detectedClear on read
 *     AN_RX_ST_PULSE_TOO_LONG Too long DME pulse detectedDuration - minimum 35 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_SHORT Too short DME pulse detectedDuration - 2 to 4 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_MODERATE Too moderate DME pulse detectedDuration - 19 to 29 samples. Each sample 0.4nsClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr (0x0000c29a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_AN_PAGE_DECR_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_an_page_decr_sts[1];
	uint32_t _an_x4_sw_sp1_an_page_decr_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_CLR(r) (r).an_x4_sw_sp1_an_page_decr_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_SET(r,d) (r).an_x4_sw_sp1_an_page_decr_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_GET(r) (r).an_x4_sw_sp1_an_page_decr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET(r) ((((r).an_x4_sw_sp1_an_page_decr_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET(r) (((r).an_x4_sw_sp1_an_page_decr_sts[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET(r,f) (r).an_x4_sw_sp1_an_page_decr_sts[0]=(((r).an_x4_sw_sp1_an_page_decr_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_AN_PAGE_DECR_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp1_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp1_an_page_decr_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp1_an_page_decr_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_an_page_decr_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_t AN_X4_SW_SP1_AN_PAGE_DECR_STSr_t;
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_CLR
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET
#define AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET
#define READ_AN_X4_SW_SP1_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_PAGE_DECR_STSr
#define WRITE_AN_X4_SW_SP1_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_PAGE_DECR_STSr
#define MODIFY_AN_X4_SW_SP1_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_PAGE_DECR_STSr
#define READLN_AN_X4_SW_SP1_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_PAGE_DECR_STSr
#define WRITELN_AN_X4_SW_SP1_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_PAGE_DECR_STSr
#define WRITEALL_AN_X4_SW_SP1_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_PAGE_DECR_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_PAGE_DECR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc29b
 * DESC:     AN ABILITY RESOLUTION INFORMATION
 * SIZE:     32
 * FIELDS:
 *     AN_HCD_SWITCH_TO_CL37 HCD an_hcd_switch_to_cl37
 *     AN_HCD_HIGIG2    HCD Hi-Gig II ability
 *     AN_HCD_CL72      HCD training ability
 *     AN_HCD_FEC       HCD forward-error correction ability
 *     AN_HCD_SPEED     HCD speed
 *     AN_HCD_PAUSE     HCD Pause Ability[11:10]00 - None01 - TX (from LD to LP)10 - RX (from LP to LD)11 - TX/RX (symmetrical)
 *     AN_HCD_DUPLEX    HCD full-duplex ability
 *     AN_ST_RESOLUTION_ERR No common speed or No common Duplex settings or Selector is wrong
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr (0x0000c29b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_an_abil_resolution_sts[1];
	uint32_t _an_x4_sw_sp1_an_abil_resolution_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_CLR(r) (r).an_x4_sw_sp1_an_abil_resolution_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_SET(r,d) (r).an_x4_sw_sp1_an_abil_resolution_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_GET(r) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET(r) ((((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET(r) ((((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) >> 12) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET(r) ((((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) >> 4) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET(r) ((((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET(r) ((((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET(r) ((((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET(r) (((r).an_x4_sw_sp1_an_abil_resolution_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET(r,f) (r).an_x4_sw_sp1_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp1_an_abil_resolution_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp1_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp1_an_abil_resolution_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp1_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_an_abil_resolution_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_t AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_t;
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_CLR
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET
#define AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET
#define READ_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr
#define WRITE_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr
#define MODIFY_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr
#define READLN_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr
#define WRITELN_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr
#define WRITEALL_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_ABIL_RESOLUTION_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_AN_MISC_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc29c
 * DESC:     MISCILLANEOUS AN STATUS
 * SIZE:     32
 * FIELDS:
 *     PD_HCD_KX4_OR_KX Speed status for PD attempt0: KX4, 1: KX
 *     PD_IN_PROGRESS   Currently Parallel detect is active
 *     AN_FAIL_COUNT    Number of AN retries due to AN failureSaturate, Clear on AN Restart
 *     AN_ACTIVE        Auto-neg in progress
 *     PD_COMPLETED     Parallel detect process is
 *     REMOTE_FAULT_IN_BASE_PAGE Remote fault indicated in AN base pageClear on AN Restart
 *     AN_RETRY_COUNT   Number of AN retried for any reasonSaturate, Clear on AN Restart
 *     AN_COMPLETE      
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr (0x0000c29c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_AN_MISC_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_an_misc_sts[1];
	uint32_t _an_x4_sw_sp1_an_misc_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_CLR(r) (r).an_x4_sw_sp1_an_misc_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_SET(r,d) (r).an_x4_sw_sp1_an_misc_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_GET(r) (r).an_x4_sw_sp1_an_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_COMPLETEf_GET(r) ((((r).an_x4_sw_sp1_an_misc_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_COMPLETEf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_RETRY_COUNTf_GET(r) ((((r).an_x4_sw_sp1_an_misc_sts[0]) >> 9) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_RETRY_COUNTf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET(r) ((((r).an_x4_sw_sp1_an_misc_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp1_an_misc_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_ACTIVEf_GET(r) ((((r).an_x4_sw_sp1_an_misc_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_ACTIVEf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_FAIL_COUNTf_GET(r) ((((r).an_x4_sw_sp1_an_misc_sts[0]) >> 2) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_FAIL_COUNTf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_IN_PROGRESSf_GET(r) ((((r).an_x4_sw_sp1_an_misc_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_IN_PROGRESSf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET(r) (((r).an_x4_sw_sp1_an_misc_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET(r,f) (r).an_x4_sw_sp1_an_misc_sts[0]=(((r).an_x4_sw_sp1_an_misc_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_AN_MISC_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr,(_r._an_x4_sw_sp1_an_misc_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr,(_r._an_x4_sw_sp1_an_misc_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr,(_r._an_x4_sw_sp1_an_misc_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_misc_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_misc_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_an_misc_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_AN_MISC_STSr BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr
#define AN_X4_SW_SP1_AN_MISC_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_t AN_X4_SW_SP1_AN_MISC_STSr_t;
#define AN_X4_SW_SP1_AN_MISC_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_CLR
#define AN_X4_SW_SP1_AN_MISC_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_COMPLETEf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_COMPLETEf_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_RETRY_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_RETRY_COUNTf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_RETRY_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_RETRY_COUNTf_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_PD_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_COMPLETEDf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_PD_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_COMPLETEDf_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_ACTIVEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_ACTIVEf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_ACTIVEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_ACTIVEf_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_FAIL_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_FAIL_COUNTf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_AN_FAIL_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_AN_FAIL_COUNTf_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_PD_IN_PROGRESSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_IN_PROGRESSf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_PD_IN_PROGRESSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_IN_PROGRESSf_SET
#define AN_X4_SW_SP1_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET
#define AN_X4_SW_SP1_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET
#define READ_AN_X4_SW_SP1_AN_MISC_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_MISC_STSr
#define WRITE_AN_X4_SW_SP1_AN_MISC_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_MISC_STSr
#define MODIFY_AN_X4_SW_SP1_AN_MISC_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_MISC_STSr
#define READLN_AN_X4_SW_SP1_AN_MISC_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_MISC_STSr
#define WRITELN_AN_X4_SW_SP1_AN_MISC_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_MISC_STSr
#define WRITEALL_AN_X4_SW_SP1_AN_MISC_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_MISC_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_MISC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_TLA_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc29d
 * DESC:     TLA SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS TLA Lane sequencer fsm latched statusClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr (0x0000c29d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_TLA_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_tla_sequencer_sts[1];
	uint32_t _an_x4_sw_sp1_tla_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp1_tla_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp1_tla_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp1_tla_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET(r) (((r).an_x4_sw_sp1_tla_sequencer_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET(r,f) (r).an_x4_sw_sp1_tla_sequencer_sts[0]=(((r).an_x4_sw_sp1_tla_sequencer_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_TLA_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp1_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp1_tla_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp1_tla_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_tla_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr
#define AN_X4_SW_SP1_TLA_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_t AN_X4_SW_SP1_TLA_SEQUENCER_STSr_t;
#define AN_X4_SW_SP1_TLA_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP1_TLA_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_SET
#define AN_X4_SW_SP1_TLA_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_GET
#define AN_X4_SW_SP1_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET
#define AN_X4_SW_SP1_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET
#define READ_AN_X4_SW_SP1_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_TLA_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP1_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_TLA_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP1_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_TLA_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP1_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_TLA_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP1_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_TLA_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP1_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_TLA_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_TLA_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGE
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP1
 * REGADDR:  0xc29e
 * DESC:     AN SEQUENCER UNEXPECTED PAGE
 * SIZE:     32
 * FIELDS:
 *     SEQ_UNEXPECTED_PAGE First unexpected page received
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr (0x0000c29e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGE.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp1_an_seq_unexpected_page[1];
	uint32_t _an_x4_sw_sp1_an_seq_unexpected_page;
} BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_CLR(r) (r).an_x4_sw_sp1_an_seq_unexpected_page[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SET(r,d) (r).an_x4_sw_sp1_an_seq_unexpected_page[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_GET(r) (r).an_x4_sw_sp1_an_seq_unexpected_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET(r) (((r).an_x4_sw_sp1_an_seq_unexpected_page[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET(r,f) (r).an_x4_sw_sp1_an_seq_unexpected_page[0]=(((r).an_x4_sw_sp1_an_seq_unexpected_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGE.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp1_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp1_an_seq_unexpected_page)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp1_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp1_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp1_an_seq_unexpected_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr
#define AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_t AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_t;
#define AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_CLR
#define AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SET
#define AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_GET
#define AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET
#define AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET
#define READ_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READ_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr
#define WRITE_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr
#define MODIFY_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr
#define READLN_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr
#define WRITELN_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr
#define WRITEALL_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP1_AN_SEQ_UNEXPECTED_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_LD_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a0
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_2_PAGE_DATA LOCAL DEVICE PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r (0x0000c2a0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_LD_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_ld_page2[1];
	uint32_t _an_x4_sw_sp2_ld_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_CLR(r) (r).an_x4_sw_sp2_ld_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_SET(r,d) (r).an_x4_sw_sp2_ld_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_GET(r) (r).an_x4_sw_sp2_ld_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp2_ld_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp2_ld_page2[0]=(((r).an_x4_sw_sp2_ld_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_LD_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r,(_r._an_x4_sw_sp2_ld_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r,(_r._an_x4_sw_sp2_ld_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r,(_r._an_x4_sw_sp2_ld_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_ld_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_LD_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r
#define AN_X4_SW_SP2_LD_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_t AN_X4_SW_SP2_LD_PAGE2r_t;
#define AN_X4_SW_SP2_LD_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_CLR
#define AN_X4_SW_SP2_LD_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_SET
#define AN_X4_SW_SP2_LD_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_GET
#define AN_X4_SW_SP2_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP2_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP2_LD_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_PAGE2r
#define WRITE_AN_X4_SW_SP2_LD_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_PAGE2r
#define MODIFY_AN_X4_SW_SP2_LD_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_PAGE2r
#define READLN_AN_X4_SW_SP2_LD_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_PAGE2r
#define WRITELN_AN_X4_SW_SP2_LD_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_PAGE2r
#define WRITEALL_AN_X4_SW_SP2_LD_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_LD_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a1
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_1_PAGE_DATA LOCAL DEVICE PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r (0x0000c2a1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_LD_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_ld_page1[1];
	uint32_t _an_x4_sw_sp2_ld_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_CLR(r) (r).an_x4_sw_sp2_ld_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_SET(r,d) (r).an_x4_sw_sp2_ld_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_GET(r) (r).an_x4_sw_sp2_ld_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp2_ld_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp2_ld_page1[0]=(((r).an_x4_sw_sp2_ld_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_LD_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r,(_r._an_x4_sw_sp2_ld_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r,(_r._an_x4_sw_sp2_ld_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r,(_r._an_x4_sw_sp2_ld_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_ld_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_LD_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r
#define AN_X4_SW_SP2_LD_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_t AN_X4_SW_SP2_LD_PAGE1r_t;
#define AN_X4_SW_SP2_LD_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_CLR
#define AN_X4_SW_SP2_LD_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_SET
#define AN_X4_SW_SP2_LD_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_GET
#define AN_X4_SW_SP2_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP2_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP2_LD_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_PAGE1r
#define WRITE_AN_X4_SW_SP2_LD_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_PAGE1r
#define MODIFY_AN_X4_SW_SP2_LD_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_PAGE1r
#define READLN_AN_X4_SW_SP2_LD_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_PAGE1r
#define WRITELN_AN_X4_SW_SP2_LD_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_PAGE1r
#define WRITEALL_AN_X4_SW_SP2_LD_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_LD_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a2
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_0_PAGE_DATA LOCAL DEVICE PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r (0x0000c2a2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_LD_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_ld_page0[1];
	uint32_t _an_x4_sw_sp2_ld_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_CLR(r) (r).an_x4_sw_sp2_ld_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_SET(r,d) (r).an_x4_sw_sp2_ld_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_GET(r) (r).an_x4_sw_sp2_ld_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp2_ld_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp2_ld_page0[0]=(((r).an_x4_sw_sp2_ld_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_LD_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r,(_r._an_x4_sw_sp2_ld_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r,(_r._an_x4_sw_sp2_ld_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r,(_r._an_x4_sw_sp2_ld_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_ld_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_LD_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r
#define AN_X4_SW_SP2_LD_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_t AN_X4_SW_SP2_LD_PAGE0r_t;
#define AN_X4_SW_SP2_LD_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_CLR
#define AN_X4_SW_SP2_LD_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_SET
#define AN_X4_SW_SP2_LD_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_GET
#define AN_X4_SW_SP2_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP2_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP2_LD_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_PAGE0r
#define WRITE_AN_X4_SW_SP2_LD_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_PAGE0r
#define MODIFY_AN_X4_SW_SP2_LD_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_PAGE0r
#define READLN_AN_X4_SW_SP2_LD_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_PAGE0r
#define WRITELN_AN_X4_SW_SP2_LD_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_PAGE0r
#define WRITEALL_AN_X4_SW_SP2_LD_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_LP_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a3
 * DESC:     LINK PARNTER SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_2_PAGE_DATA LINK PARTNER PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r (0x0000c2a3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_LP_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_lp_page2[1];
	uint32_t _an_x4_sw_sp2_lp_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_CLR(r) (r).an_x4_sw_sp2_lp_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_SET(r,d) (r).an_x4_sw_sp2_lp_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_GET(r) (r).an_x4_sw_sp2_lp_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp2_lp_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp2_lp_page2[0]=(((r).an_x4_sw_sp2_lp_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_LP_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r,(_r._an_x4_sw_sp2_lp_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r,(_r._an_x4_sw_sp2_lp_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r,(_r._an_x4_sw_sp2_lp_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_lp_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_lp_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_lp_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_LP_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r
#define AN_X4_SW_SP2_LP_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_t AN_X4_SW_SP2_LP_PAGE2r_t;
#define AN_X4_SW_SP2_LP_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_CLR
#define AN_X4_SW_SP2_LP_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_SET
#define AN_X4_SW_SP2_LP_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_GET
#define AN_X4_SW_SP2_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP2_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP2_LP_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LP_PAGE2r
#define WRITE_AN_X4_SW_SP2_LP_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LP_PAGE2r
#define MODIFY_AN_X4_SW_SP2_LP_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LP_PAGE2r
#define READLN_AN_X4_SW_SP2_LP_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LP_PAGE2r
#define WRITELN_AN_X4_SW_SP2_LP_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LP_PAGE2r
#define WRITEALL_AN_X4_SW_SP2_LP_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LP_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_LP_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a4
 * DESC:     LINK PARNTER SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_1_PAGE_DATA LINK PARTNER PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r (0x0000c2a4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_LP_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_lp_page1[1];
	uint32_t _an_x4_sw_sp2_lp_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_CLR(r) (r).an_x4_sw_sp2_lp_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_SET(r,d) (r).an_x4_sw_sp2_lp_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_GET(r) (r).an_x4_sw_sp2_lp_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp2_lp_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp2_lp_page1[0]=(((r).an_x4_sw_sp2_lp_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_LP_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r,(_r._an_x4_sw_sp2_lp_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r,(_r._an_x4_sw_sp2_lp_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r,(_r._an_x4_sw_sp2_lp_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_lp_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_lp_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_lp_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_LP_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r
#define AN_X4_SW_SP2_LP_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_t AN_X4_SW_SP2_LP_PAGE1r_t;
#define AN_X4_SW_SP2_LP_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_CLR
#define AN_X4_SW_SP2_LP_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_SET
#define AN_X4_SW_SP2_LP_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_GET
#define AN_X4_SW_SP2_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP2_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP2_LP_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LP_PAGE1r
#define WRITE_AN_X4_SW_SP2_LP_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LP_PAGE1r
#define MODIFY_AN_X4_SW_SP2_LP_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LP_PAGE1r
#define READLN_AN_X4_SW_SP2_LP_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LP_PAGE1r
#define WRITELN_AN_X4_SW_SP2_LP_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LP_PAGE1r
#define WRITEALL_AN_X4_SW_SP2_LP_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LP_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_LP_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a5
 * DESC:     LINK PARNTER SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_0_PAGE_DATA LINK PARTNER PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r (0x0000c2a5 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_LP_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_lp_page0[1];
	uint32_t _an_x4_sw_sp2_lp_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_CLR(r) (r).an_x4_sw_sp2_lp_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_SET(r,d) (r).an_x4_sw_sp2_lp_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_GET(r) (r).an_x4_sw_sp2_lp_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp2_lp_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp2_lp_page0[0]=(((r).an_x4_sw_sp2_lp_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_LP_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r,(_r._an_x4_sw_sp2_lp_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r,(_r._an_x4_sw_sp2_lp_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r,(_r._an_x4_sw_sp2_lp_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_lp_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_lp_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_lp_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_LP_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r
#define AN_X4_SW_SP2_LP_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_t AN_X4_SW_SP2_LP_PAGE0r_t;
#define AN_X4_SW_SP2_LP_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_CLR
#define AN_X4_SW_SP2_LP_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_SET
#define AN_X4_SW_SP2_LP_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_GET
#define AN_X4_SW_SP2_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP2_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP2_LP_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LP_PAGE0r
#define WRITE_AN_X4_SW_SP2_LP_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LP_PAGE0r
#define MODIFY_AN_X4_SW_SP2_LP_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LP_PAGE0r
#define READLN_AN_X4_SW_SP2_LP_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LP_PAGE0r
#define WRITELN_AN_X4_SW_SP2_LP_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LP_PAGE0r
#define WRITEALL_AN_X4_SW_SP2_LP_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LP_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_LP_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_SW_CTL_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a6
 * DESC:     SW CONTROL STATUS INFORMATION
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS1 TLA Lane sequencer fsm latched status cont.Clear on read of tla_ln_seq_status register
 *     PD_CL37_COMPLETED Parallel detect process has selected cl37 and it was completed.
 *     LP_STATUS_VALID  Set by HW, Clear on Read of lp_page_0
 *     LD_CONTROL_VALID Set by SW write to ld_page_0, Cleared when HW transfers the ld_page's
 *     AN_COMPLETED_SW  Software control page sequence. All page exchanges have completed
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr (0x0000c2a6 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_SW_CTL_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_sw_ctl_sts[1];
	uint32_t _an_x4_sw_sp2_sw_ctl_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_CLR(r) (r).an_x4_sw_sp2_sw_ctl_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_SET(r,d) (r).an_x4_sw_sp2_sw_ctl_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_GET(r) (r).an_x4_sw_sp2_sw_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_AN_COMPLETED_SWf_GET(r) ((((r).an_x4_sw_sp2_sw_ctl_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_AN_COMPLETED_SWf_SET(r,f) (r).an_x4_sw_sp2_sw_ctl_sts[0]=(((r).an_x4_sw_sp2_sw_ctl_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LD_CONTROL_VALIDf_GET(r) ((((r).an_x4_sw_sp2_sw_ctl_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LD_CONTROL_VALIDf_SET(r,f) (r).an_x4_sw_sp2_sw_ctl_sts[0]=(((r).an_x4_sw_sp2_sw_ctl_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LP_STATUS_VALIDf_GET(r) ((((r).an_x4_sw_sp2_sw_ctl_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LP_STATUS_VALIDf_SET(r,f) (r).an_x4_sw_sp2_sw_ctl_sts[0]=(((r).an_x4_sw_sp2_sw_ctl_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp2_sw_ctl_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp2_sw_ctl_sts[0]=(((r).an_x4_sw_sp2_sw_ctl_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET(r) (((r).an_x4_sw_sp2_sw_ctl_sts[0]) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET(r,f) (r).an_x4_sw_sp2_sw_ctl_sts[0]=(((r).an_x4_sw_sp2_sw_ctl_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_SW_CTL_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr,(_r._an_x4_sw_sp2_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr,(_r._an_x4_sw_sp2_sw_ctl_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr,(_r._an_x4_sw_sp2_sw_ctl_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_sw_ctl_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_SW_CTL_STSr BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr
#define AN_X4_SW_SP2_SW_CTL_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_t AN_X4_SW_SP2_SW_CTL_STSr_t;
#define AN_X4_SW_SP2_SW_CTL_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_CLR
#define AN_X4_SW_SP2_SW_CTL_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_SET
#define AN_X4_SW_SP2_SW_CTL_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_GET
#define AN_X4_SW_SP2_SW_CTL_STSr_AN_COMPLETED_SWf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_AN_COMPLETED_SWf_GET
#define AN_X4_SW_SP2_SW_CTL_STSr_AN_COMPLETED_SWf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_AN_COMPLETED_SWf_SET
#define AN_X4_SW_SP2_SW_CTL_STSr_LD_CONTROL_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LD_CONTROL_VALIDf_GET
#define AN_X4_SW_SP2_SW_CTL_STSr_LD_CONTROL_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LD_CONTROL_VALIDf_SET
#define AN_X4_SW_SP2_SW_CTL_STSr_LP_STATUS_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LP_STATUS_VALIDf_GET
#define AN_X4_SW_SP2_SW_CTL_STSr_LP_STATUS_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_LP_STATUS_VALIDf_SET
#define AN_X4_SW_SP2_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET
#define AN_X4_SW_SP2_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET
#define AN_X4_SW_SP2_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET
#define AN_X4_SW_SP2_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET
#define READ_AN_X4_SW_SP2_SW_CTL_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_SW_CTL_STSr
#define WRITE_AN_X4_SW_SP2_SW_CTL_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_SW_CTL_STSr
#define MODIFY_AN_X4_SW_SP2_SW_CTL_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_SW_CTL_STSr
#define READLN_AN_X4_SW_SP2_SW_CTL_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_SW_CTL_STSr
#define WRITELN_AN_X4_SW_SP2_SW_CTL_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_SW_CTL_STSr
#define WRITEALL_AN_X4_SW_SP2_SW_CTL_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_SW_CTL_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_SW_CTL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_LD_CTL
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a7
 * DESC:     LOCAL DEVICE CONTROLS
 * SIZE:     32
 * FIELDS:
 *     SW_HCD           Indicates HW does not perform HCD
 *     SW_AN            Indicates SW managed AN
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr (0x0000c2a7 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_LD_CTL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_ld_ctl[1];
	uint32_t _an_x4_sw_sp2_ld_ctl;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_CLR(r) (r).an_x4_sw_sp2_ld_ctl[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SET(r,d) (r).an_x4_sw_sp2_ld_ctl[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_GET(r) (r).an_x4_sw_sp2_ld_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_ANf_GET(r) ((((r).an_x4_sw_sp2_ld_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_ANf_SET(r,f) (r).an_x4_sw_sp2_ld_ctl[0]=(((r).an_x4_sw_sp2_ld_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_HCDf_GET(r) (((r).an_x4_sw_sp2_ld_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_HCDf_SET(r,f) (r).an_x4_sw_sp2_ld_ctl[0]=(((r).an_x4_sw_sp2_ld_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_LD_CTL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr,(_r._an_x4_sw_sp2_ld_ctl))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr,(_r._an_x4_sw_sp2_ld_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr,(_r._an_x4_sw_sp2_ld_ctl))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_ctl))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_ld_ctl))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_ld_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_LD_CTLr BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr
#define AN_X4_SW_SP2_LD_CTLr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_t AN_X4_SW_SP2_LD_CTLr_t;
#define AN_X4_SW_SP2_LD_CTLr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_CLR
#define AN_X4_SW_SP2_LD_CTLr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SET
#define AN_X4_SW_SP2_LD_CTLr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_GET
#define AN_X4_SW_SP2_LD_CTLr_SW_ANf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_ANf_GET
#define AN_X4_SW_SP2_LD_CTLr_SW_ANf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_ANf_SET
#define AN_X4_SW_SP2_LD_CTLr_SW_HCDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_HCDf_GET
#define AN_X4_SW_SP2_LD_CTLr_SW_HCDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr_SW_HCDf_SET
#define READ_AN_X4_SW_SP2_LD_CTLr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_LD_CTLr
#define WRITE_AN_X4_SW_SP2_LD_CTLr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_LD_CTLr
#define MODIFY_AN_X4_SW_SP2_LD_CTLr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_LD_CTLr
#define READLN_AN_X4_SW_SP2_LD_CTLr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_LD_CTLr
#define WRITELN_AN_X4_SW_SP2_LD_CTLr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_LD_CTLr
#define WRITEALL_AN_X4_SW_SP2_LD_CTLr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_LD_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_LD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a8
 * DESC:     AN PAGE SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CL73_COMPLETE CL73 auto-neg is complete
 *     AN_ST_CL37_COMPLETE CL37 auto-neg is completeClear on read
 *     AN_ST_RX_NP_TOGGLE_ERR Received auto-neg next page without T togglingClear on read
 *     AN_ST_RX_INVALID_SEQ Received invalid auto-neg page sequenceClear on read
 *     AN_ST_RX_UP_OUI_MATCH Received auto-neg MPS-5 OUI matchClear on read
 *     AN_ST_RX_UP_OUI_MISMATCH Received auto-neg MPS-5 OUI mismatchClear on read
 *     AN_ST_RX_UP_3    Received auto-neg unformatted page 3Clear on read
 *     AN_ST_RX_MP_MISMATCH Received mismatching auto-neg message pageClear on read
 *     AN_ST_RX_MP_OVER1G Received auto-neg message page 1024 (Over1G Message)Clear on read
 *     AN_ST_RX_MP_OUI  Received auto-neg message page 5 (Organizationally Unique Identifier Message)Clear on read
 *     AN_ST_RX_MP_NULL Received auto-neg message page 1 (Null Message)Clear on read
 *     AN_ST_RX_NP      Received auto-neg next pageClear on read
 *     AN_ST_RX_BP      Received auto-neg base pageClear on read
 *     AN_ST_RX_SGMII_MISMATCH Received non-SGMII page when in SGMII auto-neg modeClear on read
 *     AN_ST_HP_MODE    In Hewlett-Packard auto-neg modeClear on read
 *     AN_ST_SGMII_MODE In Cisco SGMII auto-neg modeClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr (0x0000c2a8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_an_page_sequencer_sts[1];
	uint32_t _an_x4_sw_sp2_an_page_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp2_an_page_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp2_an_page_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET(r) ((((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET(r) (((r).an_x4_sw_sp2_an_page_sequencer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET(r,f) (r).an_x4_sw_sp2_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp2_an_page_sequencer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp2_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp2_an_page_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp2_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_an_page_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_t AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_t;
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET
#define AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET
#define READ_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2a9
 * DESC:     AN PAGE EXCHANGER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CONFIG_RESTART Received auto-neg restart (0) page
 *     AN_ST_IDLE_DETECT Entered auto-neg IDLE_DETECT stateClear on read
 *     AN_ST_DISABLE_LINK Entered auto-neg DISABLE_LINK stateClear on read
 *     AN_ST_ERROR_STATE Entered auto-neg ERROR stateClear on read
 *     AN_ST_AN_ENABLE  Entered auto-neg AN_ENABLE stateClear on read
 *     AN_ST_ABILITY_DETECT Entered auto-neg ABILITY_DETECT stateClear on read
 *     AN_ST_ACK_DETECT Entered auto-neg ACKNOWLEDGE_DETECT stateClear on read
 *     AN_ST_COMPLETE_ACK Entered auto-neg COMPLETE_ACKNOWLEDGE stateClear on read
 *     AN_ST_CONSISTENCY_MISMATCH Auto-neg consistency mismatch detectedClear on read
 *     AN_ST_CONFIG_NONZERO Page Exchanger Received non-zero configuration ordered setClear on read
 *     AN_ST_RESTART    Page Exchanger entered AN_RESTART stateClear on read
 *     AN_ST_AN_GOOD_CHECK Page Exchanger entered AN_GOOD_CHECK stateClear on read
 *     AN_ST_LINK_OK    Page Exchanger entered LINK_OK stateClear on read
 *     AN_ST_NEXT_PAGE_WAIT Page Exchanger entered NEXT_PAGE_WAIT stateClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr (0x0000c2a9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_an_page_exchangeer_sts[1];
	uint32_t _an_x4_sw_sp2_an_page_exchangeer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_CLR(r) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_SET(r,d) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_GET(r) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET(r) ((((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET(r) (((r).an_x4_sw_sp2_an_page_exchangeer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET(r,f) (r).an_x4_sw_sp2_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp2_an_page_exchangeer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp2_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp2_an_page_exchangeer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp2_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_an_page_exchangeer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_t AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_t;
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_CLR
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET
#define AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET
#define READ_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr
#define WRITE_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr
#define MODIFY_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr
#define READLN_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr
#define WRITELN_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr
#define WRITEALL_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_EXCHANGEER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_AN_PAGE_DECR_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2aa
 * DESC:     AN PAGE DECODER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_RX_ST_STATE   DME Receive State
 *     AN_RX_ST_RUDI_INVALID Received invalid ordered setClear on read
 *     AN_RX_ST_RUDI_CONFIG Received configuration ordered setClear on read
 *     AN_RX_ST_RUDI_IDLE Received idle ordered setClear on read
 *     AN_RX_ST_PAGE    Valid DME page receivedClear on read
 *     AN_RX_ST_MV_PAIR DME Delimiter detectedClear on read
 *     AN_RX_ST_CLK_TRANS_MISS Missing DME clock transition detectedClear on read
 *     AN_RX_ST_PAGE_TOO_LONG A CL73 DME page longer than the maximum specified by cl73_page_test_max_timer was detectedClear on read
 *     AN_RX_ST_PAGE_TOO_SHORT A CL73 DME page shorter than the  minimum specified by cl73_page_test_min_timer was detectedClear on read
 *     AN_RX_ST_PULSE_TOO_LONG Too long DME pulse detectedDuration - minimum 35 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_SHORT Too short DME pulse detectedDuration - 2 to 4 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_MODERATE Too moderate DME pulse detectedDuration - 19 to 29 samples. Each sample 0.4nsClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr (0x0000c2aa | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_AN_PAGE_DECR_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_an_page_decr_sts[1];
	uint32_t _an_x4_sw_sp2_an_page_decr_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_CLR(r) (r).an_x4_sw_sp2_an_page_decr_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_SET(r,d) (r).an_x4_sw_sp2_an_page_decr_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_GET(r) (r).an_x4_sw_sp2_an_page_decr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET(r) ((((r).an_x4_sw_sp2_an_page_decr_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET(r) (((r).an_x4_sw_sp2_an_page_decr_sts[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET(r,f) (r).an_x4_sw_sp2_an_page_decr_sts[0]=(((r).an_x4_sw_sp2_an_page_decr_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_AN_PAGE_DECR_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp2_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp2_an_page_decr_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp2_an_page_decr_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_an_page_decr_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_t AN_X4_SW_SP2_AN_PAGE_DECR_STSr_t;
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_CLR
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET
#define AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET
#define READ_AN_X4_SW_SP2_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_PAGE_DECR_STSr
#define WRITE_AN_X4_SW_SP2_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_PAGE_DECR_STSr
#define MODIFY_AN_X4_SW_SP2_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_PAGE_DECR_STSr
#define READLN_AN_X4_SW_SP2_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_PAGE_DECR_STSr
#define WRITELN_AN_X4_SW_SP2_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_PAGE_DECR_STSr
#define WRITEALL_AN_X4_SW_SP2_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_PAGE_DECR_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_PAGE_DECR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2ab
 * DESC:     AN ABILITY RESOLUTION INFORMATION
 * SIZE:     32
 * FIELDS:
 *     AN_HCD_SWITCH_TO_CL37 HCD an_hcd_switch_to_cl37
 *     AN_HCD_HIGIG2    HCD Hi-Gig II ability
 *     AN_HCD_CL72      HCD training ability
 *     AN_HCD_FEC       HCD forward-error correction ability
 *     AN_HCD_SPEED     HCD speed
 *     AN_HCD_PAUSE     HCD Pause Ability[11:10]00 - None01 - TX (from LD to LP)10 - RX (from LP to LD)11 - TX/RX (symmetrical)
 *     AN_HCD_DUPLEX    HCD full-duplex ability
 *     AN_ST_RESOLUTION_ERR No common speed or No common Duplex settings or Selector is wrong
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr (0x0000c2ab | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_an_abil_resolution_sts[1];
	uint32_t _an_x4_sw_sp2_an_abil_resolution_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_CLR(r) (r).an_x4_sw_sp2_an_abil_resolution_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_SET(r,d) (r).an_x4_sw_sp2_an_abil_resolution_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_GET(r) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET(r) ((((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET(r) ((((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) >> 12) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET(r) ((((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) >> 4) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET(r) ((((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET(r) ((((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET(r) ((((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET(r) (((r).an_x4_sw_sp2_an_abil_resolution_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET(r,f) (r).an_x4_sw_sp2_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp2_an_abil_resolution_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp2_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp2_an_abil_resolution_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp2_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_an_abil_resolution_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_t AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_t;
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_CLR
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET
#define AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET
#define READ_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr
#define WRITE_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr
#define MODIFY_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr
#define READLN_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr
#define WRITELN_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr
#define WRITEALL_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_ABIL_RESOLUTION_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_AN_MISC_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2ac
 * DESC:     MISCILLANEOUS AN STATUS
 * SIZE:     32
 * FIELDS:
 *     PD_HCD_KX4_OR_KX Speed status for PD attempt0: KX4, 1: KX
 *     PD_IN_PROGRESS   Currently Parallel detect is active
 *     AN_FAIL_COUNT    Number of AN retries due to AN failureSaturate, Clear on AN Restart
 *     AN_ACTIVE        Auto-neg in progress
 *     PD_COMPLETED     Parallel detect process is
 *     REMOTE_FAULT_IN_BASE_PAGE Remote fault indicated in AN base pageClear on AN Restart
 *     AN_RETRY_COUNT   Number of AN retried for any reasonSaturate, Clear on AN Restart
 *     AN_COMPLETE      
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr (0x0000c2ac | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_AN_MISC_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_an_misc_sts[1];
	uint32_t _an_x4_sw_sp2_an_misc_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_CLR(r) (r).an_x4_sw_sp2_an_misc_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_SET(r,d) (r).an_x4_sw_sp2_an_misc_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_GET(r) (r).an_x4_sw_sp2_an_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_COMPLETEf_GET(r) ((((r).an_x4_sw_sp2_an_misc_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_COMPLETEf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_RETRY_COUNTf_GET(r) ((((r).an_x4_sw_sp2_an_misc_sts[0]) >> 9) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_RETRY_COUNTf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET(r) ((((r).an_x4_sw_sp2_an_misc_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp2_an_misc_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_ACTIVEf_GET(r) ((((r).an_x4_sw_sp2_an_misc_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_ACTIVEf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_FAIL_COUNTf_GET(r) ((((r).an_x4_sw_sp2_an_misc_sts[0]) >> 2) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_FAIL_COUNTf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_IN_PROGRESSf_GET(r) ((((r).an_x4_sw_sp2_an_misc_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_IN_PROGRESSf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET(r) (((r).an_x4_sw_sp2_an_misc_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET(r,f) (r).an_x4_sw_sp2_an_misc_sts[0]=(((r).an_x4_sw_sp2_an_misc_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_AN_MISC_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr,(_r._an_x4_sw_sp2_an_misc_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr,(_r._an_x4_sw_sp2_an_misc_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr,(_r._an_x4_sw_sp2_an_misc_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_misc_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_misc_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_an_misc_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_AN_MISC_STSr BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr
#define AN_X4_SW_SP2_AN_MISC_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_t AN_X4_SW_SP2_AN_MISC_STSr_t;
#define AN_X4_SW_SP2_AN_MISC_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_CLR
#define AN_X4_SW_SP2_AN_MISC_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_COMPLETEf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_COMPLETEf_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_RETRY_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_RETRY_COUNTf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_RETRY_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_RETRY_COUNTf_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_PD_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_COMPLETEDf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_PD_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_COMPLETEDf_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_ACTIVEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_ACTIVEf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_ACTIVEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_ACTIVEf_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_FAIL_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_FAIL_COUNTf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_AN_FAIL_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_AN_FAIL_COUNTf_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_PD_IN_PROGRESSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_IN_PROGRESSf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_PD_IN_PROGRESSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_IN_PROGRESSf_SET
#define AN_X4_SW_SP2_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET
#define AN_X4_SW_SP2_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET
#define READ_AN_X4_SW_SP2_AN_MISC_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_MISC_STSr
#define WRITE_AN_X4_SW_SP2_AN_MISC_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_MISC_STSr
#define MODIFY_AN_X4_SW_SP2_AN_MISC_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_MISC_STSr
#define READLN_AN_X4_SW_SP2_AN_MISC_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_MISC_STSr
#define WRITELN_AN_X4_SW_SP2_AN_MISC_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_MISC_STSr
#define WRITEALL_AN_X4_SW_SP2_AN_MISC_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_MISC_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_MISC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_TLA_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2ad
 * DESC:     TLA SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS TLA Lane sequencer fsm latched statusClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr (0x0000c2ad | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_TLA_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_tla_sequencer_sts[1];
	uint32_t _an_x4_sw_sp2_tla_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp2_tla_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp2_tla_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp2_tla_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET(r) (((r).an_x4_sw_sp2_tla_sequencer_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET(r,f) (r).an_x4_sw_sp2_tla_sequencer_sts[0]=(((r).an_x4_sw_sp2_tla_sequencer_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_TLA_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp2_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp2_tla_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp2_tla_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_tla_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr
#define AN_X4_SW_SP2_TLA_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_t AN_X4_SW_SP2_TLA_SEQUENCER_STSr_t;
#define AN_X4_SW_SP2_TLA_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP2_TLA_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_SET
#define AN_X4_SW_SP2_TLA_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_GET
#define AN_X4_SW_SP2_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET
#define AN_X4_SW_SP2_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET
#define READ_AN_X4_SW_SP2_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_TLA_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP2_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_TLA_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP2_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_TLA_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP2_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_TLA_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP2_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_TLA_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP2_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_TLA_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_TLA_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGE
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP2
 * REGADDR:  0xc2ae
 * DESC:     AN SEQUENCER UNEXPECTED PAGE
 * SIZE:     32
 * FIELDS:
 *     SEQ_UNEXPECTED_PAGE First unexpected page received
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr (0x0000c2ae | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGE.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp2_an_seq_unexpected_page[1];
	uint32_t _an_x4_sw_sp2_an_seq_unexpected_page;
} BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_CLR(r) (r).an_x4_sw_sp2_an_seq_unexpected_page[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SET(r,d) (r).an_x4_sw_sp2_an_seq_unexpected_page[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_GET(r) (r).an_x4_sw_sp2_an_seq_unexpected_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET(r) (((r).an_x4_sw_sp2_an_seq_unexpected_page[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET(r,f) (r).an_x4_sw_sp2_an_seq_unexpected_page[0]=(((r).an_x4_sw_sp2_an_seq_unexpected_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGE.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp2_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp2_an_seq_unexpected_page)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp2_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp2_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp2_an_seq_unexpected_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr
#define AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_t AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_t;
#define AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_CLR
#define AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SET
#define AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_GET
#define AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET
#define AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET
#define READ_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READ_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr
#define WRITE_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr
#define MODIFY_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr
#define READLN_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr
#define WRITELN_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr
#define WRITEALL_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP2_AN_SEQ_UNEXPECTED_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_LD_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b0
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_2_PAGE_DATA LOCAL DEVICE PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r (0x0000c2b0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_LD_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_ld_page2[1];
	uint32_t _an_x4_sw_sp3_ld_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_CLR(r) (r).an_x4_sw_sp3_ld_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_SET(r,d) (r).an_x4_sw_sp3_ld_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_GET(r) (r).an_x4_sw_sp3_ld_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp3_ld_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp3_ld_page2[0]=(((r).an_x4_sw_sp3_ld_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_LD_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r,(_r._an_x4_sw_sp3_ld_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r,(_r._an_x4_sw_sp3_ld_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r,(_r._an_x4_sw_sp3_ld_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_ld_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_LD_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r
#define AN_X4_SW_SP3_LD_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_t AN_X4_SW_SP3_LD_PAGE2r_t;
#define AN_X4_SW_SP3_LD_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_CLR
#define AN_X4_SW_SP3_LD_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_SET
#define AN_X4_SW_SP3_LD_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_GET
#define AN_X4_SW_SP3_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP3_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP3_LD_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_PAGE2r
#define WRITE_AN_X4_SW_SP3_LD_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_PAGE2r
#define MODIFY_AN_X4_SW_SP3_LD_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_PAGE2r
#define READLN_AN_X4_SW_SP3_LD_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_PAGE2r
#define WRITELN_AN_X4_SW_SP3_LD_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_PAGE2r
#define WRITEALL_AN_X4_SW_SP3_LD_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_LD_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b1
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_1_PAGE_DATA LOCAL DEVICE PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r (0x0000c2b1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_LD_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_ld_page1[1];
	uint32_t _an_x4_sw_sp3_ld_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_CLR(r) (r).an_x4_sw_sp3_ld_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_SET(r,d) (r).an_x4_sw_sp3_ld_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_GET(r) (r).an_x4_sw_sp3_ld_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp3_ld_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp3_ld_page1[0]=(((r).an_x4_sw_sp3_ld_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_LD_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r,(_r._an_x4_sw_sp3_ld_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r,(_r._an_x4_sw_sp3_ld_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r,(_r._an_x4_sw_sp3_ld_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_ld_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_LD_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r
#define AN_X4_SW_SP3_LD_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_t AN_X4_SW_SP3_LD_PAGE1r_t;
#define AN_X4_SW_SP3_LD_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_CLR
#define AN_X4_SW_SP3_LD_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_SET
#define AN_X4_SW_SP3_LD_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_GET
#define AN_X4_SW_SP3_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP3_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP3_LD_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_PAGE1r
#define WRITE_AN_X4_SW_SP3_LD_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_PAGE1r
#define MODIFY_AN_X4_SW_SP3_LD_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_PAGE1r
#define READLN_AN_X4_SW_SP3_LD_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_PAGE1r
#define WRITELN_AN_X4_SW_SP3_LD_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_PAGE1r
#define WRITEALL_AN_X4_SW_SP3_LD_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_LD_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b2
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LD_PAGE_0_PAGE_DATA LOCAL DEVICE PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r (0x0000c2b2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_LD_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_ld_page0[1];
	uint32_t _an_x4_sw_sp3_ld_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_CLR(r) (r).an_x4_sw_sp3_ld_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_SET(r,d) (r).an_x4_sw_sp3_ld_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_GET(r) (r).an_x4_sw_sp3_ld_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp3_ld_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp3_ld_page0[0]=(((r).an_x4_sw_sp3_ld_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_LD_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r,(_r._an_x4_sw_sp3_ld_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r,(_r._an_x4_sw_sp3_ld_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r,(_r._an_x4_sw_sp3_ld_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_ld_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_LD_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r
#define AN_X4_SW_SP3_LD_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_t AN_X4_SW_SP3_LD_PAGE0r_t;
#define AN_X4_SW_SP3_LD_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_CLR
#define AN_X4_SW_SP3_LD_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_SET
#define AN_X4_SW_SP3_LD_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_GET
#define AN_X4_SW_SP3_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP3_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP3_LD_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_PAGE0r
#define WRITE_AN_X4_SW_SP3_LD_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_PAGE0r
#define MODIFY_AN_X4_SW_SP3_LD_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_PAGE0r
#define READLN_AN_X4_SW_SP3_LD_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_PAGE0r
#define WRITELN_AN_X4_SW_SP3_LD_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_PAGE0r
#define WRITEALL_AN_X4_SW_SP3_LD_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_LP_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b3
 * DESC:     LINK PARNTER SW CONTROL PAGE 2
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_2_PAGE_DATA LINK PARTNER PAGE 2 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r (0x0000c2b3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_LP_PAGE2.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_lp_page2[1];
	uint32_t _an_x4_sw_sp3_lp_page2;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_CLR(r) (r).an_x4_sw_sp3_lp_page2[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_SET(r,d) (r).an_x4_sw_sp3_lp_page2[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_GET(r) (r).an_x4_sw_sp3_lp_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp3_lp_page2[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp3_lp_page2[0]=(((r).an_x4_sw_sp3_lp_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_LP_PAGE2.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r,(_r._an_x4_sw_sp3_lp_page2))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r,(_r._an_x4_sw_sp3_lp_page2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r,(_r._an_x4_sw_sp3_lp_page2))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_lp_page2))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LP_PAGE2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_lp_page2))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LP_PAGE2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_lp_page2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_LP_PAGE2r BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r
#define AN_X4_SW_SP3_LP_PAGE2r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_t AN_X4_SW_SP3_LP_PAGE2r_t;
#define AN_X4_SW_SP3_LP_PAGE2r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_CLR
#define AN_X4_SW_SP3_LP_PAGE2r_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_SET
#define AN_X4_SW_SP3_LP_PAGE2r_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_GET
#define AN_X4_SW_SP3_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET
#define AN_X4_SW_SP3_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP3_LP_PAGE2r BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LP_PAGE2r
#define WRITE_AN_X4_SW_SP3_LP_PAGE2r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LP_PAGE2r
#define MODIFY_AN_X4_SW_SP3_LP_PAGE2r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LP_PAGE2r
#define READLN_AN_X4_SW_SP3_LP_PAGE2r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LP_PAGE2r
#define WRITELN_AN_X4_SW_SP3_LP_PAGE2r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LP_PAGE2r
#define WRITEALL_AN_X4_SW_SP3_LP_PAGE2r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LP_PAGE2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_LP_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b4
 * DESC:     LINK PARNTER SW CONTROL PAGE 1
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_1_PAGE_DATA LINK PARTNER PAGE 1 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r (0x0000c2b4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_LP_PAGE1.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_lp_page1[1];
	uint32_t _an_x4_sw_sp3_lp_page1;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_CLR(r) (r).an_x4_sw_sp3_lp_page1[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_SET(r,d) (r).an_x4_sw_sp3_lp_page1[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_GET(r) (r).an_x4_sw_sp3_lp_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp3_lp_page1[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp3_lp_page1[0]=(((r).an_x4_sw_sp3_lp_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_LP_PAGE1.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r,(_r._an_x4_sw_sp3_lp_page1))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r,(_r._an_x4_sw_sp3_lp_page1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r,(_r._an_x4_sw_sp3_lp_page1))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_lp_page1))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LP_PAGE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_lp_page1))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LP_PAGE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_lp_page1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_LP_PAGE1r BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r
#define AN_X4_SW_SP3_LP_PAGE1r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_t AN_X4_SW_SP3_LP_PAGE1r_t;
#define AN_X4_SW_SP3_LP_PAGE1r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_CLR
#define AN_X4_SW_SP3_LP_PAGE1r_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_SET
#define AN_X4_SW_SP3_LP_PAGE1r_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_GET
#define AN_X4_SW_SP3_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET
#define AN_X4_SW_SP3_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP3_LP_PAGE1r BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LP_PAGE1r
#define WRITE_AN_X4_SW_SP3_LP_PAGE1r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LP_PAGE1r
#define MODIFY_AN_X4_SW_SP3_LP_PAGE1r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LP_PAGE1r
#define READLN_AN_X4_SW_SP3_LP_PAGE1r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LP_PAGE1r
#define WRITELN_AN_X4_SW_SP3_LP_PAGE1r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LP_PAGE1r
#define WRITEALL_AN_X4_SW_SP3_LP_PAGE1r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LP_PAGE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_LP_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b5
 * DESC:     LINK PARNTER SW CONTROL PAGE 0
 * SIZE:     32
 * FIELDS:
 *     LP_PAGE_0_PAGE_DATA LINK PARTNER PAGE 0 FIELD
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r (0x0000c2b5 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_LP_PAGE0.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_lp_page0[1];
	uint32_t _an_x4_sw_sp3_lp_page0;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_CLR(r) (r).an_x4_sw_sp3_lp_page0[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_SET(r,d) (r).an_x4_sw_sp3_lp_page0[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_GET(r) (r).an_x4_sw_sp3_lp_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_sw_sp3_lp_page0[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_sw_sp3_lp_page0[0]=(((r).an_x4_sw_sp3_lp_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_LP_PAGE0.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r,(_r._an_x4_sw_sp3_lp_page0))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r,(_r._an_x4_sw_sp3_lp_page0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r,(_r._an_x4_sw_sp3_lp_page0))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_lp_page0))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LP_PAGE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_lp_page0))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LP_PAGE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_lp_page0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_LP_PAGE0r BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r
#define AN_X4_SW_SP3_LP_PAGE0r_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_t AN_X4_SW_SP3_LP_PAGE0r_t;
#define AN_X4_SW_SP3_LP_PAGE0r_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_CLR
#define AN_X4_SW_SP3_LP_PAGE0r_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_SET
#define AN_X4_SW_SP3_LP_PAGE0r_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_GET
#define AN_X4_SW_SP3_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET
#define AN_X4_SW_SP3_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_SW_SP3_LP_PAGE0r BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LP_PAGE0r
#define WRITE_AN_X4_SW_SP3_LP_PAGE0r BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LP_PAGE0r
#define MODIFY_AN_X4_SW_SP3_LP_PAGE0r BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LP_PAGE0r
#define READLN_AN_X4_SW_SP3_LP_PAGE0r BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LP_PAGE0r
#define WRITELN_AN_X4_SW_SP3_LP_PAGE0r BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LP_PAGE0r
#define WRITEALL_AN_X4_SW_SP3_LP_PAGE0r BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LP_PAGE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_LP_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_SW_CTL_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b6
 * DESC:     SW CONTROL STATUS INFORMATION
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS1 TLA Lane sequencer fsm latched status cont.Clear on read of tla_ln_seq_status register
 *     PD_CL37_COMPLETED Parallel detect process has selected cl37 and it was completed.
 *     LP_STATUS_VALID  Set by HW, Clear on Read of lp_page_0
 *     LD_CONTROL_VALID Set by SW write to ld_page_0, Cleared when HW transfers the ld_page's
 *     AN_COMPLETED_SW  Software control page sequence. All page exchanges have completed
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr (0x0000c2b6 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_SW_CTL_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_sw_ctl_sts[1];
	uint32_t _an_x4_sw_sp3_sw_ctl_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_CLR(r) (r).an_x4_sw_sp3_sw_ctl_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_SET(r,d) (r).an_x4_sw_sp3_sw_ctl_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_GET(r) (r).an_x4_sw_sp3_sw_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_AN_COMPLETED_SWf_GET(r) ((((r).an_x4_sw_sp3_sw_ctl_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_AN_COMPLETED_SWf_SET(r,f) (r).an_x4_sw_sp3_sw_ctl_sts[0]=(((r).an_x4_sw_sp3_sw_ctl_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LD_CONTROL_VALIDf_GET(r) ((((r).an_x4_sw_sp3_sw_ctl_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LD_CONTROL_VALIDf_SET(r,f) (r).an_x4_sw_sp3_sw_ctl_sts[0]=(((r).an_x4_sw_sp3_sw_ctl_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LP_STATUS_VALIDf_GET(r) ((((r).an_x4_sw_sp3_sw_ctl_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LP_STATUS_VALIDf_SET(r,f) (r).an_x4_sw_sp3_sw_ctl_sts[0]=(((r).an_x4_sw_sp3_sw_ctl_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp3_sw_ctl_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp3_sw_ctl_sts[0]=(((r).an_x4_sw_sp3_sw_ctl_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET(r) (((r).an_x4_sw_sp3_sw_ctl_sts[0]) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET(r,f) (r).an_x4_sw_sp3_sw_ctl_sts[0]=(((r).an_x4_sw_sp3_sw_ctl_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_SW_CTL_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr,(_r._an_x4_sw_sp3_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr,(_r._an_x4_sw_sp3_sw_ctl_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr,(_r._an_x4_sw_sp3_sw_ctl_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_SW_CTL_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_sw_ctl_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_SW_CTL_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_sw_ctl_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_SW_CTL_STSr BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr
#define AN_X4_SW_SP3_SW_CTL_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_t AN_X4_SW_SP3_SW_CTL_STSr_t;
#define AN_X4_SW_SP3_SW_CTL_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_CLR
#define AN_X4_SW_SP3_SW_CTL_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_SET
#define AN_X4_SW_SP3_SW_CTL_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_GET
#define AN_X4_SW_SP3_SW_CTL_STSr_AN_COMPLETED_SWf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_AN_COMPLETED_SWf_GET
#define AN_X4_SW_SP3_SW_CTL_STSr_AN_COMPLETED_SWf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_AN_COMPLETED_SWf_SET
#define AN_X4_SW_SP3_SW_CTL_STSr_LD_CONTROL_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LD_CONTROL_VALIDf_GET
#define AN_X4_SW_SP3_SW_CTL_STSr_LD_CONTROL_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LD_CONTROL_VALIDf_SET
#define AN_X4_SW_SP3_SW_CTL_STSr_LP_STATUS_VALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LP_STATUS_VALIDf_GET
#define AN_X4_SW_SP3_SW_CTL_STSr_LP_STATUS_VALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_LP_STATUS_VALIDf_SET
#define AN_X4_SW_SP3_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET
#define AN_X4_SW_SP3_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET
#define AN_X4_SW_SP3_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET
#define AN_X4_SW_SP3_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET
#define READ_AN_X4_SW_SP3_SW_CTL_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_SW_CTL_STSr
#define WRITE_AN_X4_SW_SP3_SW_CTL_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_SW_CTL_STSr
#define MODIFY_AN_X4_SW_SP3_SW_CTL_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_SW_CTL_STSr
#define READLN_AN_X4_SW_SP3_SW_CTL_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_SW_CTL_STSr
#define WRITELN_AN_X4_SW_SP3_SW_CTL_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_SW_CTL_STSr
#define WRITEALL_AN_X4_SW_SP3_SW_CTL_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_SW_CTL_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_SW_CTL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_LD_CTL
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b7
 * DESC:     LOCAL DEVICE CONTROLS
 * SIZE:     32
 * FIELDS:
 *     SW_HCD           Indicates HW does not perform HCD
 *     SW_AN            Indicates SW managed AN
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr (0x0000c2b7 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_LD_CTL.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_ld_ctl[1];
	uint32_t _an_x4_sw_sp3_ld_ctl;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_CLR(r) (r).an_x4_sw_sp3_ld_ctl[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SET(r,d) (r).an_x4_sw_sp3_ld_ctl[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_GET(r) (r).an_x4_sw_sp3_ld_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_ANf_GET(r) ((((r).an_x4_sw_sp3_ld_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_ANf_SET(r,f) (r).an_x4_sw_sp3_ld_ctl[0]=(((r).an_x4_sw_sp3_ld_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_HCDf_GET(r) (((r).an_x4_sw_sp3_ld_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_HCDf_SET(r,f) (r).an_x4_sw_sp3_ld_ctl[0]=(((r).an_x4_sw_sp3_ld_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_LD_CTL.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr,(_r._an_x4_sw_sp3_ld_ctl))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr,(_r._an_x4_sw_sp3_ld_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr,(_r._an_x4_sw_sp3_ld_ctl))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_ctl))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_ld_ctl))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_ld_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_LD_CTLr BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr
#define AN_X4_SW_SP3_LD_CTLr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_t AN_X4_SW_SP3_LD_CTLr_t;
#define AN_X4_SW_SP3_LD_CTLr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_CLR
#define AN_X4_SW_SP3_LD_CTLr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SET
#define AN_X4_SW_SP3_LD_CTLr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_GET
#define AN_X4_SW_SP3_LD_CTLr_SW_ANf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_ANf_GET
#define AN_X4_SW_SP3_LD_CTLr_SW_ANf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_ANf_SET
#define AN_X4_SW_SP3_LD_CTLr_SW_HCDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_HCDf_GET
#define AN_X4_SW_SP3_LD_CTLr_SW_HCDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr_SW_HCDf_SET
#define READ_AN_X4_SW_SP3_LD_CTLr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_LD_CTLr
#define WRITE_AN_X4_SW_SP3_LD_CTLr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_LD_CTLr
#define MODIFY_AN_X4_SW_SP3_LD_CTLr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_LD_CTLr
#define READLN_AN_X4_SW_SP3_LD_CTLr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_LD_CTLr
#define WRITELN_AN_X4_SW_SP3_LD_CTLr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_LD_CTLr
#define WRITEALL_AN_X4_SW_SP3_LD_CTLr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_LD_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_LD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b8
 * DESC:     AN PAGE SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CL73_COMPLETE CL73 auto-neg is complete
 *     AN_ST_CL37_COMPLETE CL37 auto-neg is completeClear on read
 *     AN_ST_RX_NP_TOGGLE_ERR Received auto-neg next page without T togglingClear on read
 *     AN_ST_RX_INVALID_SEQ Received invalid auto-neg page sequenceClear on read
 *     AN_ST_RX_UP_OUI_MATCH Received auto-neg MPS-5 OUI matchClear on read
 *     AN_ST_RX_UP_OUI_MISMATCH Received auto-neg MPS-5 OUI mismatchClear on read
 *     AN_ST_RX_UP_3    Received auto-neg unformatted page 3Clear on read
 *     AN_ST_RX_MP_MISMATCH Received mismatching auto-neg message pageClear on read
 *     AN_ST_RX_MP_OVER1G Received auto-neg message page 1024 (Over1G Message)Clear on read
 *     AN_ST_RX_MP_OUI  Received auto-neg message page 5 (Organizationally Unique Identifier Message)Clear on read
 *     AN_ST_RX_MP_NULL Received auto-neg message page 1 (Null Message)Clear on read
 *     AN_ST_RX_NP      Received auto-neg next pageClear on read
 *     AN_ST_RX_BP      Received auto-neg base pageClear on read
 *     AN_ST_RX_SGMII_MISMATCH Received non-SGMII page when in SGMII auto-neg modeClear on read
 *     AN_ST_HP_MODE    In Hewlett-Packard auto-neg modeClear on read
 *     AN_ST_SGMII_MODE In Cisco SGMII auto-neg modeClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr (0x0000c2b8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_an_page_sequencer_sts[1];
	uint32_t _an_x4_sw_sp3_an_page_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp3_an_page_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp3_an_page_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET(r) ((((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET(r) (((r).an_x4_sw_sp3_an_page_sequencer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET(r,f) (r).an_x4_sw_sp3_an_page_sequencer_sts[0]=(((r).an_x4_sw_sp3_an_page_sequencer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp3_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp3_an_page_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_sw_sp3_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_page_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_an_page_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_t AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_t;
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET
#define AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET
#define READ_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2b9
 * DESC:     AN PAGE EXCHANGER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_ST_CONFIG_RESTART Received auto-neg restart (0) page
 *     AN_ST_IDLE_DETECT Entered auto-neg IDLE_DETECT stateClear on read
 *     AN_ST_DISABLE_LINK Entered auto-neg DISABLE_LINK stateClear on read
 *     AN_ST_ERROR_STATE Entered auto-neg ERROR stateClear on read
 *     AN_ST_AN_ENABLE  Entered auto-neg AN_ENABLE stateClear on read
 *     AN_ST_ABILITY_DETECT Entered auto-neg ABILITY_DETECT stateClear on read
 *     AN_ST_ACK_DETECT Entered auto-neg ACKNOWLEDGE_DETECT stateClear on read
 *     AN_ST_COMPLETE_ACK Entered auto-neg COMPLETE_ACKNOWLEDGE stateClear on read
 *     AN_ST_CONSISTENCY_MISMATCH Auto-neg consistency mismatch detectedClear on read
 *     AN_ST_CONFIG_NONZERO Page Exchanger Received non-zero configuration ordered setClear on read
 *     AN_ST_RESTART    Page Exchanger entered AN_RESTART stateClear on read
 *     AN_ST_AN_GOOD_CHECK Page Exchanger entered AN_GOOD_CHECK stateClear on read
 *     AN_ST_LINK_OK    Page Exchanger entered LINK_OK stateClear on read
 *     AN_ST_NEXT_PAGE_WAIT Page Exchanger entered NEXT_PAGE_WAIT stateClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr (0x0000c2b9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_an_page_exchangeer_sts[1];
	uint32_t _an_x4_sw_sp3_an_page_exchangeer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_CLR(r) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_SET(r,d) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_GET(r) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET(r) ((((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET(r) (((r).an_x4_sw_sp3_an_page_exchangeer_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET(r,f) (r).an_x4_sw_sp3_an_page_exchangeer_sts[0]=(((r).an_x4_sw_sp3_an_page_exchangeer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp3_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp3_an_page_exchangeer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_sw_sp3_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_page_exchangeer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_an_page_exchangeer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_t AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_t;
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_CLR
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET
#define AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET
#define READ_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr
#define WRITE_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr
#define MODIFY_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr
#define READLN_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr
#define WRITELN_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr
#define WRITEALL_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_EXCHANGEER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_AN_PAGE_DECR_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2ba
 * DESC:     AN PAGE DECODER STATUS
 * SIZE:     32
 * FIELDS:
 *     AN_RX_ST_STATE   DME Receive State
 *     AN_RX_ST_RUDI_INVALID Received invalid ordered setClear on read
 *     AN_RX_ST_RUDI_CONFIG Received configuration ordered setClear on read
 *     AN_RX_ST_RUDI_IDLE Received idle ordered setClear on read
 *     AN_RX_ST_PAGE    Valid DME page receivedClear on read
 *     AN_RX_ST_MV_PAIR DME Delimiter detectedClear on read
 *     AN_RX_ST_CLK_TRANS_MISS Missing DME clock transition detectedClear on read
 *     AN_RX_ST_PAGE_TOO_LONG A CL73 DME page longer than the maximum specified by cl73_page_test_max_timer was detectedClear on read
 *     AN_RX_ST_PAGE_TOO_SHORT A CL73 DME page shorter than the  minimum specified by cl73_page_test_min_timer was detectedClear on read
 *     AN_RX_ST_PULSE_TOO_LONG Too long DME pulse detectedDuration - minimum 35 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_SHORT Too short DME pulse detectedDuration - 2 to 4 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_MODERATE Too moderate DME pulse detectedDuration - 19 to 29 samples. Each sample 0.4nsClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr (0x0000c2ba | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_AN_PAGE_DECR_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_an_page_decr_sts[1];
	uint32_t _an_x4_sw_sp3_an_page_decr_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_CLR(r) (r).an_x4_sw_sp3_an_page_decr_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_SET(r,d) (r).an_x4_sw_sp3_an_page_decr_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_GET(r) (r).an_x4_sw_sp3_an_page_decr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET(r) ((((r).an_x4_sw_sp3_an_page_decr_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET(r) (((r).an_x4_sw_sp3_an_page_decr_sts[0]) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET(r,f) (r).an_x4_sw_sp3_an_page_decr_sts[0]=(((r).an_x4_sw_sp3_an_page_decr_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_AN_PAGE_DECR_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp3_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp3_an_page_decr_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr,(_r._an_x4_sw_sp3_an_page_decr_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_PAGE_DECR_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_page_decr_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_PAGE_DECR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_an_page_decr_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_t AN_X4_SW_SP3_AN_PAGE_DECR_STSr_t;
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_CLR
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET
#define AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET
#define READ_AN_X4_SW_SP3_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_PAGE_DECR_STSr
#define WRITE_AN_X4_SW_SP3_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_PAGE_DECR_STSr
#define MODIFY_AN_X4_SW_SP3_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_PAGE_DECR_STSr
#define READLN_AN_X4_SW_SP3_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_PAGE_DECR_STSr
#define WRITELN_AN_X4_SW_SP3_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_PAGE_DECR_STSr
#define WRITEALL_AN_X4_SW_SP3_AN_PAGE_DECR_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_PAGE_DECR_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_PAGE_DECR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2bb
 * DESC:     AN ABILITY RESOLUTION INFORMATION
 * SIZE:     32
 * FIELDS:
 *     AN_HCD_SWITCH_TO_CL37 HCD an_hcd_switch_to_cl37
 *     AN_HCD_HIGIG2    HCD Hi-Gig II ability
 *     AN_HCD_CL72      HCD training ability
 *     AN_HCD_FEC       HCD forward-error correction ability
 *     AN_HCD_SPEED     HCD speed
 *     AN_HCD_PAUSE     HCD Pause Ability[11:10]00 - None01 - TX (from LD to LP)10 - RX (from LP to LD)11 - TX/RX (symmetrical)
 *     AN_HCD_DUPLEX    HCD full-duplex ability
 *     AN_ST_RESOLUTION_ERR No common speed or No common Duplex settings or Selector is wrong
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr (0x0000c2bb | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_an_abil_resolution_sts[1];
	uint32_t _an_x4_sw_sp3_an_abil_resolution_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_CLR(r) (r).an_x4_sw_sp3_an_abil_resolution_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_SET(r,d) (r).an_x4_sw_sp3_an_abil_resolution_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_GET(r) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET(r) ((((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET(r) ((((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) >> 12) & 0x3)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET(r) ((((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) >> 4) & 0xff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET(r) ((((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET(r) ((((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET(r) ((((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET(r) (((r).an_x4_sw_sp3_an_abil_resolution_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET(r,f) (r).an_x4_sw_sp3_an_abil_resolution_sts[0]=(((r).an_x4_sw_sp3_an_abil_resolution_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp3_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp3_an_abil_resolution_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_sw_sp3_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_abil_resolution_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_an_abil_resolution_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_t AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_t;
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_CLR
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET
#define AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET
#define READ_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr
#define WRITE_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr
#define MODIFY_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr
#define READLN_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr
#define WRITELN_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr
#define WRITEALL_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_ABIL_RESOLUTION_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_AN_MISC_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2bc
 * DESC:     MISCILLANEOUS AN STATUS
 * SIZE:     32
 * FIELDS:
 *     PD_HCD_KX4_OR_KX Speed status for PD attempt0: KX4, 1: KX
 *     PD_IN_PROGRESS   Currently Parallel detect is active
 *     AN_FAIL_COUNT    Number of AN retries due to AN failureSaturate, Clear on AN Restart
 *     AN_ACTIVE        Auto-neg in progress
 *     PD_COMPLETED     Parallel detect process is
 *     REMOTE_FAULT_IN_BASE_PAGE Remote fault indicated in AN base pageClear on AN Restart
 *     AN_RETRY_COUNT   Number of AN retried for any reasonSaturate, Clear on AN Restart
 *     AN_COMPLETE      
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr (0x0000c2bc | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_AN_MISC_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_an_misc_sts[1];
	uint32_t _an_x4_sw_sp3_an_misc_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_CLR(r) (r).an_x4_sw_sp3_an_misc_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_SET(r,d) (r).an_x4_sw_sp3_an_misc_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_GET(r) (r).an_x4_sw_sp3_an_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_COMPLETEf_GET(r) ((((r).an_x4_sw_sp3_an_misc_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_COMPLETEf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_RETRY_COUNTf_GET(r) ((((r).an_x4_sw_sp3_an_misc_sts[0]) >> 9) & 0x3f)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_RETRY_COUNTf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET(r) ((((r).an_x4_sw_sp3_an_misc_sts[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_COMPLETEDf_GET(r) ((((r).an_x4_sw_sp3_an_misc_sts[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_COMPLETEDf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_ACTIVEf_GET(r) ((((r).an_x4_sw_sp3_an_misc_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_ACTIVEf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_FAIL_COUNTf_GET(r) ((((r).an_x4_sw_sp3_an_misc_sts[0]) >> 2) & 0xf)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_FAIL_COUNTf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_IN_PROGRESSf_GET(r) ((((r).an_x4_sw_sp3_an_misc_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_IN_PROGRESSf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET(r) (((r).an_x4_sw_sp3_an_misc_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET(r,f) (r).an_x4_sw_sp3_an_misc_sts[0]=(((r).an_x4_sw_sp3_an_misc_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_AN_MISC_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr,(_r._an_x4_sw_sp3_an_misc_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr,(_r._an_x4_sw_sp3_an_misc_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr,(_r._an_x4_sw_sp3_an_misc_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_misc_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_MISC_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_misc_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_MISC_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_an_misc_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_AN_MISC_STSr BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr
#define AN_X4_SW_SP3_AN_MISC_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_t AN_X4_SW_SP3_AN_MISC_STSr_t;
#define AN_X4_SW_SP3_AN_MISC_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_CLR
#define AN_X4_SW_SP3_AN_MISC_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_COMPLETEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_COMPLETEf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_COMPLETEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_COMPLETEf_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_RETRY_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_RETRY_COUNTf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_RETRY_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_RETRY_COUNTf_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_PD_COMPLETEDf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_COMPLETEDf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_PD_COMPLETEDf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_COMPLETEDf_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_ACTIVEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_ACTIVEf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_ACTIVEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_ACTIVEf_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_FAIL_COUNTf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_FAIL_COUNTf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_AN_FAIL_COUNTf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_AN_FAIL_COUNTf_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_PD_IN_PROGRESSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_IN_PROGRESSf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_PD_IN_PROGRESSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_IN_PROGRESSf_SET
#define AN_X4_SW_SP3_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET
#define AN_X4_SW_SP3_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET
#define READ_AN_X4_SW_SP3_AN_MISC_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_MISC_STSr
#define WRITE_AN_X4_SW_SP3_AN_MISC_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_MISC_STSr
#define MODIFY_AN_X4_SW_SP3_AN_MISC_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_MISC_STSr
#define READLN_AN_X4_SW_SP3_AN_MISC_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_MISC_STSr
#define WRITELN_AN_X4_SW_SP3_AN_MISC_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_MISC_STSr
#define WRITEALL_AN_X4_SW_SP3_AN_MISC_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_MISC_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_MISC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_TLA_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2bd
 * DESC:     TLA SEQUENCER STATUS
 * SIZE:     32
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS TLA Lane sequencer fsm latched statusClear on read
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr (0x0000c2bd | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_TLA_SEQUENCER_STS.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_tla_sequencer_sts[1];
	uint32_t _an_x4_sw_sp3_tla_sequencer_sts;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_CLR(r) (r).an_x4_sw_sp3_tla_sequencer_sts[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_SET(r,d) (r).an_x4_sw_sp3_tla_sequencer_sts[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_GET(r) (r).an_x4_sw_sp3_tla_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET(r) (((r).an_x4_sw_sp3_tla_sequencer_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET(r,f) (r).an_x4_sw_sp3_tla_sequencer_sts[0]=(((r).an_x4_sw_sp3_tla_sequencer_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_TLA_SEQUENCER_STS.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp3_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp3_tla_sequencer_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr,(_r._an_x4_sw_sp3_tla_sequencer_sts))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_TLA_SEQUENCER_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_tla_sequencer_sts))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_TLA_SEQUENCER_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_tla_sequencer_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr
#define AN_X4_SW_SP3_TLA_SEQUENCER_STSr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_t AN_X4_SW_SP3_TLA_SEQUENCER_STSr_t;
#define AN_X4_SW_SP3_TLA_SEQUENCER_STSr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_CLR
#define AN_X4_SW_SP3_TLA_SEQUENCER_STSr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_SET
#define AN_X4_SW_SP3_TLA_SEQUENCER_STSr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_GET
#define AN_X4_SW_SP3_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET
#define AN_X4_SW_SP3_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET
#define READ_AN_X4_SW_SP3_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_TLA_SEQUENCER_STSr
#define WRITE_AN_X4_SW_SP3_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_TLA_SEQUENCER_STSr
#define MODIFY_AN_X4_SW_SP3_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_TLA_SEQUENCER_STSr
#define READLN_AN_X4_SW_SP3_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_TLA_SEQUENCER_STSr
#define WRITELN_AN_X4_SW_SP3_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_TLA_SEQUENCER_STSr
#define WRITEALL_AN_X4_SW_SP3_TLA_SEQUENCER_STSr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_TLA_SEQUENCER_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_TLA_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGE
 * BLOCKS:   AN_X4_SW_MANAGEMENT_SP3
 * REGADDR:  0xc2be
 * DESC:     AN SEQUENCER UNEXPECTED PAGE
 * SIZE:     32
 * FIELDS:
 *     SEQ_UNEXPECTED_PAGE First unexpected page received
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr (0x0000c2be | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGE.
 */
typedef union BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_sp3_an_seq_unexpected_page[1];
	uint32_t _an_x4_sw_sp3_an_seq_unexpected_page;
} BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_t;

#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_CLR(r) (r).an_x4_sw_sp3_an_seq_unexpected_page[0] = 0
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SET(r,d) (r).an_x4_sw_sp3_an_seq_unexpected_page[0] = d
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_GET(r) (r).an_x4_sw_sp3_an_seq_unexpected_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET(r) (((r).an_x4_sw_sp3_an_seq_unexpected_page[0]) & 0xffff)
#define BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET(r,f) (r).an_x4_sw_sp3_an_seq_unexpected_page[0]=(((r).an_x4_sw_sp3_an_seq_unexpected_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGE.
 */
#define BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp3_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp3_an_seq_unexpected_page)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_sw_sp3_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_sp3_an_seq_unexpected_page))
#define BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_sp3_an_seq_unexpected_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr
#define AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SIZE BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SIZE
typedef BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_t AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_t;
#define AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_CLR BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_CLR
#define AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SET
#define AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_GET
#define AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET
#define AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET
#define READ_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READ_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr
#define WRITE_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITE_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr
#define MODIFY_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_MODIFY_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr
#define READLN_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_READLN_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr
#define WRITELN_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITELN_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr
#define WRITEALL_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr BCMI_QTC_XGXS_WRITEALL_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AN_X4_SW_SP3_AN_SEQ_UNEXPECTED_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP0_TXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP0
 * REGADDR:  0xc300
 * DESC:     TX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of transmited packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in txpktcnt_L register.This register has to be read first for values in the txpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur (0x0000c300 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP0_TXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp0_txpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp0_txpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp0_txpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp0_txpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp0_txpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_TXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp0_txpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_TXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp0_txpktcnt_u[0]=(((r).pkt_ctrs_x4_sp0_txpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP0_TXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp0_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp0_txpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp0_txpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp0_txpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP0_TXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur
#define PKT_CTRS_X4_SP0_TXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_t PKT_CTRS_X4_SP0_TXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP0_TXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP0_TXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP0_TXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP0_TXPKTCNT_Ur_TXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_TXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP0_TXPKTCNT_Ur_TXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur_TXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP0_TXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_TXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP0_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_TXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP0_TXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_TXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP0_TXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_TXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP0_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_TXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP0_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_TXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP0_TXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP0
 * REGADDR:  0xc301
 * DESC:     TX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of transmited packets counter.The value is sampled on read from txpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr (0x0000c301 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP0_TXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp0_txpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp0_txpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp0_txpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp0_txpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp0_txpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_TXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp0_txpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_TXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp0_txpktcnt_l[0]=(((r).pkt_ctrs_x4_sp0_txpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP0_TXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp0_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp0_txpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp0_txpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp0_txpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP0_TXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr
#define PKT_CTRS_X4_SP0_TXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_t PKT_CTRS_X4_SP0_TXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP0_TXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP0_TXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP0_TXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP0_TXPKTCNT_Lr_TXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_TXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP0_TXPKTCNT_Lr_TXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr_TXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP0_TXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_TXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP0_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_TXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP0_TXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_TXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP0_TXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_TXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP0_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_TXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP0_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_TXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_TXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP0_RXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP0
 * REGADDR:  0xc302
 * DESC:     RX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of received packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in rxpktcnt_L register.This register has to be read first for values in the rxpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur (0x0000c302 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP0_RXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp0_rxpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp0_rxpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp0_rxpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp0_rxpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp0_rxpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_RXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp0_rxpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_RXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp0_rxpktcnt_u[0]=(((r).pkt_ctrs_x4_sp0_rxpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP0_RXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp0_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp0_rxpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp0_rxpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp0_rxpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP0_RXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur
#define PKT_CTRS_X4_SP0_RXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_t PKT_CTRS_X4_SP0_RXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP0_RXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP0_RXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP0_RXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP0_RXPKTCNT_Ur_RXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_RXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP0_RXPKTCNT_Ur_RXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur_RXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP0_RXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_RXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP0_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_RXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP0_RXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_RXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP0_RXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_RXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP0_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_RXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP0_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_RXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP0_RXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP0
 * REGADDR:  0xc303
 * DESC:     RX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of received packets counter.The value is sampled on read from rxpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr (0x0000c303 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP0_RXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp0_rxpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp0_rxpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp0_rxpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp0_rxpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp0_rxpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_RXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp0_rxpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_RXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp0_rxpktcnt_l[0]=(((r).pkt_ctrs_x4_sp0_rxpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP0_RXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp0_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp0_rxpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp0_rxpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp0_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp0_rxpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP0_RXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr
#define PKT_CTRS_X4_SP0_RXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_t PKT_CTRS_X4_SP0_RXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP0_RXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP0_RXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP0_RXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP0_RXPKTCNT_Lr_RXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_RXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP0_RXPKTCNT_Lr_RXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr_RXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP0_RXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP0_RXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP0_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP0_RXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP0_RXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP0_RXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP0_RXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP0_RXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP0_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP0_RXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP0_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP0_RXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP0_RXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP1_TXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP1
 * REGADDR:  0xc310
 * DESC:     TX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of transmited packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in txpktcnt_L register.This register has to be read first for values in the txpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur (0x0000c310 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP1_TXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp1_txpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp1_txpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp1_txpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp1_txpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp1_txpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_TXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp1_txpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_TXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp1_txpktcnt_u[0]=(((r).pkt_ctrs_x4_sp1_txpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP1_TXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp1_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp1_txpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp1_txpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp1_txpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP1_TXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur
#define PKT_CTRS_X4_SP1_TXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_t PKT_CTRS_X4_SP1_TXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP1_TXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP1_TXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP1_TXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP1_TXPKTCNT_Ur_TXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_TXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP1_TXPKTCNT_Ur_TXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur_TXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP1_TXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_TXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP1_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_TXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP1_TXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_TXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP1_TXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_TXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP1_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_TXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP1_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_TXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP1_TXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP1
 * REGADDR:  0xc311
 * DESC:     TX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of transmited packets counter.The value is sampled on read from txpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr (0x0000c311 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP1_TXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp1_txpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp1_txpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp1_txpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp1_txpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp1_txpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_TXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp1_txpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_TXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp1_txpktcnt_l[0]=(((r).pkt_ctrs_x4_sp1_txpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP1_TXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp1_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp1_txpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp1_txpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp1_txpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP1_TXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr
#define PKT_CTRS_X4_SP1_TXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_t PKT_CTRS_X4_SP1_TXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP1_TXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP1_TXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP1_TXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP1_TXPKTCNT_Lr_TXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_TXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP1_TXPKTCNT_Lr_TXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr_TXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP1_TXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_TXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP1_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_TXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP1_TXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_TXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP1_TXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_TXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP1_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_TXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP1_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_TXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_TXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP1_RXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP1
 * REGADDR:  0xc312
 * DESC:     RX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of received packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in rxpktcnt_L register.This register has to be read first for values in the rxpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur (0x0000c312 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP1_RXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp1_rxpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp1_rxpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp1_rxpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp1_rxpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp1_rxpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_RXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp1_rxpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_RXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp1_rxpktcnt_u[0]=(((r).pkt_ctrs_x4_sp1_rxpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP1_RXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp1_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp1_rxpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp1_rxpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp1_rxpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP1_RXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur
#define PKT_CTRS_X4_SP1_RXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_t PKT_CTRS_X4_SP1_RXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP1_RXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP1_RXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP1_RXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP1_RXPKTCNT_Ur_RXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_RXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP1_RXPKTCNT_Ur_RXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur_RXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP1_RXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_RXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP1_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_RXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP1_RXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_RXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP1_RXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_RXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP1_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_RXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP1_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_RXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP1_RXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP1
 * REGADDR:  0xc313
 * DESC:     RX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of received packets counter.The value is sampled on read from rxpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr (0x0000c313 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP1_RXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp1_rxpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp1_rxpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp1_rxpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp1_rxpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp1_rxpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_RXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp1_rxpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_RXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp1_rxpktcnt_l[0]=(((r).pkt_ctrs_x4_sp1_rxpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP1_RXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp1_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp1_rxpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp1_rxpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp1_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp1_rxpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP1_RXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr
#define PKT_CTRS_X4_SP1_RXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_t PKT_CTRS_X4_SP1_RXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP1_RXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP1_RXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP1_RXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP1_RXPKTCNT_Lr_RXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_RXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP1_RXPKTCNT_Lr_RXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr_RXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP1_RXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP1_RXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP1_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP1_RXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP1_RXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP1_RXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP1_RXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP1_RXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP1_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP1_RXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP1_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP1_RXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP1_RXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP2_TXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP2
 * REGADDR:  0xc320
 * DESC:     TX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of transmited packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in txpktcnt_L register.This register has to be read first for values in the txpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur (0x0000c320 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP2_TXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp2_txpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp2_txpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp2_txpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp2_txpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp2_txpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_TXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp2_txpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_TXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp2_txpktcnt_u[0]=(((r).pkt_ctrs_x4_sp2_txpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP2_TXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp2_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp2_txpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp2_txpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp2_txpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP2_TXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur
#define PKT_CTRS_X4_SP2_TXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_t PKT_CTRS_X4_SP2_TXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP2_TXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP2_TXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP2_TXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP2_TXPKTCNT_Ur_TXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_TXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP2_TXPKTCNT_Ur_TXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur_TXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP2_TXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_TXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP2_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_TXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP2_TXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_TXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP2_TXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_TXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP2_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_TXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP2_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_TXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP2_TXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP2
 * REGADDR:  0xc321
 * DESC:     TX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of transmited packets counter.The value is sampled on read from txpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr (0x0000c321 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP2_TXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp2_txpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp2_txpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp2_txpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp2_txpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp2_txpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_TXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp2_txpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_TXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp2_txpktcnt_l[0]=(((r).pkt_ctrs_x4_sp2_txpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP2_TXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp2_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp2_txpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp2_txpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp2_txpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP2_TXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr
#define PKT_CTRS_X4_SP2_TXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_t PKT_CTRS_X4_SP2_TXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP2_TXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP2_TXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP2_TXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP2_TXPKTCNT_Lr_TXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_TXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP2_TXPKTCNT_Lr_TXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr_TXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP2_TXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_TXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP2_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_TXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP2_TXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_TXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP2_TXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_TXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP2_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_TXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP2_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_TXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_TXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP2_RXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP2
 * REGADDR:  0xc322
 * DESC:     RX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of received packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in rxpktcnt_L register.This register has to be read first for values in the rxpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur (0x0000c322 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP2_RXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp2_rxpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp2_rxpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp2_rxpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp2_rxpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp2_rxpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_RXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp2_rxpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_RXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp2_rxpktcnt_u[0]=(((r).pkt_ctrs_x4_sp2_rxpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP2_RXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp2_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp2_rxpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp2_rxpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp2_rxpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP2_RXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur
#define PKT_CTRS_X4_SP2_RXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_t PKT_CTRS_X4_SP2_RXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP2_RXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP2_RXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP2_RXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP2_RXPKTCNT_Ur_RXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_RXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP2_RXPKTCNT_Ur_RXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur_RXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP2_RXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_RXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP2_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_RXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP2_RXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_RXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP2_RXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_RXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP2_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_RXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP2_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_RXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP2_RXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP2
 * REGADDR:  0xc323
 * DESC:     RX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of received packets counter.The value is sampled on read from rxpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr (0x0000c323 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP2_RXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp2_rxpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp2_rxpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp2_rxpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp2_rxpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp2_rxpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_RXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp2_rxpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_RXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp2_rxpktcnt_l[0]=(((r).pkt_ctrs_x4_sp2_rxpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP2_RXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp2_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp2_rxpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp2_rxpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp2_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp2_rxpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP2_RXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr
#define PKT_CTRS_X4_SP2_RXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_t PKT_CTRS_X4_SP2_RXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP2_RXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP2_RXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP2_RXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP2_RXPKTCNT_Lr_RXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_RXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP2_RXPKTCNT_Lr_RXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr_RXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP2_RXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP2_RXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP2_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP2_RXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP2_RXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP2_RXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP2_RXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP2_RXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP2_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP2_RXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP2_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP2_RXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP2_RXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP3_TXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP3
 * REGADDR:  0xc330
 * DESC:     TX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of transmited packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in txpktcnt_L register.This register has to be read first for values in the txpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur (0x0000c330 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP3_TXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp3_txpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp3_txpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp3_txpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp3_txpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp3_txpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_TXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp3_txpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_TXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp3_txpktcnt_u[0]=(((r).pkt_ctrs_x4_sp3_txpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP3_TXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp3_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp3_txpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp3_txpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_TXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_txpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_TXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp3_txpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP3_TXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur
#define PKT_CTRS_X4_SP3_TXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_t PKT_CTRS_X4_SP3_TXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP3_TXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP3_TXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP3_TXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP3_TXPKTCNT_Ur_TXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_TXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP3_TXPKTCNT_Ur_TXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur_TXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP3_TXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_TXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP3_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_TXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP3_TXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_TXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP3_TXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_TXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP3_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_TXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP3_TXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_TXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP3_TXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP3
 * REGADDR:  0xc331
 * DESC:     TX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     TXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of transmited packets counter.The value is sampled on read from txpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr (0x0000c331 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP3_TXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp3_txpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp3_txpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp3_txpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp3_txpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp3_txpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_TXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp3_txpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_TXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp3_txpktcnt_l[0]=(((r).pkt_ctrs_x4_sp3_txpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP3_TXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp3_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp3_txpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp3_txpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_TXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_txpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_TXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp3_txpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP3_TXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr
#define PKT_CTRS_X4_SP3_TXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_t PKT_CTRS_X4_SP3_TXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP3_TXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP3_TXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP3_TXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP3_TXPKTCNT_Lr_TXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_TXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP3_TXPKTCNT_Lr_TXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr_TXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP3_TXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_TXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP3_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_TXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP3_TXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_TXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP3_TXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_TXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP3_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_TXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP3_TXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_TXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_TXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP3_RXPKTCNT_U
 * BLOCKS:   PACKET_COUNTERS_X4_SP3
 * REGADDR:  0xc332
 * DESC:     RX Packet Count Upper Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of received packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in rxpktcnt_L register.This register has to be read first for values in the rxpktcnt_L to be updated.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur (0x0000c332 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP3_RXPKTCNT_U.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp3_rxpktcnt_u[1];
	uint32_t _pkt_ctrs_x4_sp3_rxpktcnt_u;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_CLR(r) (r).pkt_ctrs_x4_sp3_rxpktcnt_u[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_SET(r,d) (r).pkt_ctrs_x4_sp3_rxpktcnt_u[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_GET(r) (r).pkt_ctrs_x4_sp3_rxpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_RXPKTCNT_Uf_GET(r) (((r).pkt_ctrs_x4_sp3_rxpktcnt_u[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_RXPKTCNT_Uf_SET(r,f) (r).pkt_ctrs_x4_sp3_rxpktcnt_u[0]=(((r).pkt_ctrs_x4_sp3_rxpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP3_RXPKTCNT_U.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp3_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp3_rxpktcnt_u)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur,(_r._pkt_ctrs_x4_sp3_rxpktcnt_u))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_RXPKTCNT_Ur(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_rxpktcnt_u))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_RXPKTCNT_Ur(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp3_rxpktcnt_u))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP3_RXPKTCNT_Ur BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur
#define PKT_CTRS_X4_SP3_RXPKTCNT_Ur_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_t PKT_CTRS_X4_SP3_RXPKTCNT_Ur_t;
#define PKT_CTRS_X4_SP3_RXPKTCNT_Ur_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_CLR
#define PKT_CTRS_X4_SP3_RXPKTCNT_Ur_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_SET
#define PKT_CTRS_X4_SP3_RXPKTCNT_Ur_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_GET
#define PKT_CTRS_X4_SP3_RXPKTCNT_Ur_RXPKTCNT_Uf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_RXPKTCNT_Uf_GET
#define PKT_CTRS_X4_SP3_RXPKTCNT_Ur_RXPKTCNT_Uf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur_RXPKTCNT_Uf_SET
#define READ_PKT_CTRS_X4_SP3_RXPKTCNT_Ur BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_RXPKTCNT_Ur
#define WRITE_PKT_CTRS_X4_SP3_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_RXPKTCNT_Ur
#define MODIFY_PKT_CTRS_X4_SP3_RXPKTCNT_Ur BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_RXPKTCNT_Ur
#define READLN_PKT_CTRS_X4_SP3_RXPKTCNT_Ur BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_RXPKTCNT_Ur
#define WRITELN_PKT_CTRS_X4_SP3_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_RXPKTCNT_Ur
#define WRITEALL_PKT_CTRS_X4_SP3_RXPKTCNT_Ur BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_RXPKTCNT_Ur

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Ur'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PKT_CTRS_X4_SP3_RXPKTCNT_L
 * BLOCKS:   PACKET_COUNTERS_X4_SP3
 * REGADDR:  0xc333
 * DESC:     RX Packet Count Lower Register
 * SIZE:     32
 * FIELDS:
 *     RXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of received packets counter.The value is sampled on read from rxpktcnt_U.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr (0x0000c333 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program PKT_CTRS_X4_SP3_RXPKTCNT_L.
 */
typedef union BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t pkt_ctrs_x4_sp3_rxpktcnt_l[1];
	uint32_t _pkt_ctrs_x4_sp3_rxpktcnt_l;
} BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_t;

#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_CLR(r) (r).pkt_ctrs_x4_sp3_rxpktcnt_l[0] = 0
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_SET(r,d) (r).pkt_ctrs_x4_sp3_rxpktcnt_l[0] = d
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_GET(r) (r).pkt_ctrs_x4_sp3_rxpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_RXPKTCNT_Lf_GET(r) (((r).pkt_ctrs_x4_sp3_rxpktcnt_l[0]) & 0xffff)
#define BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_RXPKTCNT_Lf_SET(r,f) (r).pkt_ctrs_x4_sp3_rxpktcnt_l[0]=(((r).pkt_ctrs_x4_sp3_rxpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PKT_CTRS_X4_SP3_RXPKTCNT_L.
 */
#define BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp3_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp3_rxpktcnt_l)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr,(_r._pkt_ctrs_x4_sp3_rxpktcnt_l))
#define BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_RXPKTCNT_Lr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pkt_ctrs_x4_sp3_rxpktcnt_l))
#define BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_RXPKTCNT_Lr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pkt_ctrs_x4_sp3_rxpktcnt_l))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PKT_CTRS_X4_SP3_RXPKTCNT_Lr BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr
#define PKT_CTRS_X4_SP3_RXPKTCNT_Lr_SIZE BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_SIZE
typedef BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_t PKT_CTRS_X4_SP3_RXPKTCNT_Lr_t;
#define PKT_CTRS_X4_SP3_RXPKTCNT_Lr_CLR BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_CLR
#define PKT_CTRS_X4_SP3_RXPKTCNT_Lr_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_SET
#define PKT_CTRS_X4_SP3_RXPKTCNT_Lr_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_GET
#define PKT_CTRS_X4_SP3_RXPKTCNT_Lr_RXPKTCNT_Lf_GET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_RXPKTCNT_Lf_GET
#define PKT_CTRS_X4_SP3_RXPKTCNT_Lr_RXPKTCNT_Lf_SET BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr_RXPKTCNT_Lf_SET
#define READ_PKT_CTRS_X4_SP3_RXPKTCNT_Lr BCMI_QTC_XGXS_READ_PKT_CTRS_X4_SP3_RXPKTCNT_Lr
#define WRITE_PKT_CTRS_X4_SP3_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITE_PKT_CTRS_X4_SP3_RXPKTCNT_Lr
#define MODIFY_PKT_CTRS_X4_SP3_RXPKTCNT_Lr BCMI_QTC_XGXS_MODIFY_PKT_CTRS_X4_SP3_RXPKTCNT_Lr
#define READLN_PKT_CTRS_X4_SP3_RXPKTCNT_Lr BCMI_QTC_XGXS_READLN_PKT_CTRS_X4_SP3_RXPKTCNT_Lr
#define WRITELN_PKT_CTRS_X4_SP3_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITELN_PKT_CTRS_X4_SP3_RXPKTCNT_Lr
#define WRITEALL_PKT_CTRS_X4_SP3_RXPKTCNT_Lr BCMI_QTC_XGXS_WRITEALL_PKT_CTRS_X4_SP3_RXPKTCNT_Lr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PKT_CTRS_X4_SP3_RXPKTCNT_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SPARE0
 * BLOCKS:   SPARE
 * REGADDR:  0xc34a
 * DESC:     spare 0 register
 * SIZE:     32
 * FIELDS:
 *     SPARE0           
 */
#define BCMI_QTC_XGXS_SPARE0r (0x0000c34a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SPARE0r_SIZE 4

/*
 * This structure should be used to declare and program SPARE0.
 */
typedef union BCMI_QTC_XGXS_SPARE0r_s {
	uint32_t v[1];
	uint32_t spare0[1];
	uint32_t _spare0;
} BCMI_QTC_XGXS_SPARE0r_t;

#define BCMI_QTC_XGXS_SPARE0r_CLR(r) (r).spare0[0] = 0
#define BCMI_QTC_XGXS_SPARE0r_SET(r,d) (r).spare0[0] = d
#define BCMI_QTC_XGXS_SPARE0r_GET(r) (r).spare0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SPARE0r_SPARE0f_GET(r) (((r).spare0[0]) & 0xff)
#define BCMI_QTC_XGXS_SPARE0r_SPARE0f_SET(r,f) (r).spare0[0]=(((r).spare0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SPARE0.
 */
#define BCMI_QTC_XGXS_READ_SPARE0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SPARE0r,(_r._spare0))
#define BCMI_QTC_XGXS_WRITE_SPARE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE0r,(_r._spare0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SPARE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE0r,(_r._spare0))
#define BCMI_QTC_XGXS_READLN_SPARE0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare0))
#define BCMI_QTC_XGXS_WRITELN_SPARE0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare0))
#define BCMI_QTC_XGXS_WRITEALL_SPARE0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._spare0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE0r BCMI_QTC_XGXS_SPARE0r
#define SPARE0r_SIZE BCMI_QTC_XGXS_SPARE0r_SIZE
typedef BCMI_QTC_XGXS_SPARE0r_t SPARE0r_t;
#define SPARE0r_CLR BCMI_QTC_XGXS_SPARE0r_CLR
#define SPARE0r_SET BCMI_QTC_XGXS_SPARE0r_SET
#define SPARE0r_GET BCMI_QTC_XGXS_SPARE0r_GET
#define SPARE0r_SPARE0f_GET BCMI_QTC_XGXS_SPARE0r_SPARE0f_GET
#define SPARE0r_SPARE0f_SET BCMI_QTC_XGXS_SPARE0r_SPARE0f_SET
#define READ_SPARE0r BCMI_QTC_XGXS_READ_SPARE0r
#define WRITE_SPARE0r BCMI_QTC_XGXS_WRITE_SPARE0r
#define MODIFY_SPARE0r BCMI_QTC_XGXS_MODIFY_SPARE0r
#define READLN_SPARE0r BCMI_QTC_XGXS_READLN_SPARE0r
#define WRITELN_SPARE0r BCMI_QTC_XGXS_WRITELN_SPARE0r
#define WRITEALL_SPARE0r BCMI_QTC_XGXS_WRITEALL_SPARE0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SPARE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SPARE1
 * BLOCKS:   SPARE
 * REGADDR:  0xc34b
 * DESC:     spare 1 register
 * SIZE:     32
 * FIELDS:
 *     SPARE1           
 */
#define BCMI_QTC_XGXS_SPARE1r (0x0000c34b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SPARE1r_SIZE 4

/*
 * This structure should be used to declare and program SPARE1.
 */
typedef union BCMI_QTC_XGXS_SPARE1r_s {
	uint32_t v[1];
	uint32_t spare1[1];
	uint32_t _spare1;
} BCMI_QTC_XGXS_SPARE1r_t;

#define BCMI_QTC_XGXS_SPARE1r_CLR(r) (r).spare1[0] = 0
#define BCMI_QTC_XGXS_SPARE1r_SET(r,d) (r).spare1[0] = d
#define BCMI_QTC_XGXS_SPARE1r_GET(r) (r).spare1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SPARE1r_SPARE1f_GET(r) (((r).spare1[0]) & 0xff)
#define BCMI_QTC_XGXS_SPARE1r_SPARE1f_SET(r,f) (r).spare1[0]=(((r).spare1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access SPARE1.
 */
#define BCMI_QTC_XGXS_READ_SPARE1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SPARE1r,(_r._spare1))
#define BCMI_QTC_XGXS_WRITE_SPARE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE1r,(_r._spare1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SPARE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE1r,(_r._spare1))
#define BCMI_QTC_XGXS_READLN_SPARE1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare1))
#define BCMI_QTC_XGXS_WRITELN_SPARE1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare1))
#define BCMI_QTC_XGXS_WRITEALL_SPARE1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._spare1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SPARE1r BCMI_QTC_XGXS_SPARE1r
#define SPARE1r_SIZE BCMI_QTC_XGXS_SPARE1r_SIZE
typedef BCMI_QTC_XGXS_SPARE1r_t SPARE1r_t;
#define SPARE1r_CLR BCMI_QTC_XGXS_SPARE1r_CLR
#define SPARE1r_SET BCMI_QTC_XGXS_SPARE1r_SET
#define SPARE1r_GET BCMI_QTC_XGXS_SPARE1r_GET
#define SPARE1r_SPARE1f_GET BCMI_QTC_XGXS_SPARE1r_SPARE1f_GET
#define SPARE1r_SPARE1f_SET BCMI_QTC_XGXS_SPARE1r_SPARE1f_SET
#define READ_SPARE1r BCMI_QTC_XGXS_READ_SPARE1r
#define WRITE_SPARE1r BCMI_QTC_XGXS_WRITE_SPARE1r
#define MODIFY_SPARE1r BCMI_QTC_XGXS_MODIFY_SPARE1r
#define READLN_SPARE1r BCMI_QTC_XGXS_READLN_SPARE1r
#define WRITELN_SPARE1r BCMI_QTC_XGXS_WRITELN_SPARE1r
#define WRITEALL_SPARE1r BCMI_QTC_XGXS_WRITEALL_SPARE1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SPARE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  ACC_CTL
 * BLOCKS:   MDIO_CL22_IEEE_COM
 * REGADDR:  0x000d
 * DEVAD:    1
 * DESC:     MMD_access_control
 * SIZE:     32
 * FIELDS:
 *     MDIO_DEVAD       Device address
 *     MDIO_FUNCTION    00 = address01 = data, no post increment10 = data, post increment on reads and write11 = data, post increment on writes only
 */
#define BCMI_QTC_XGXS_ACC_CTLr (0x0001000d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_ACC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ACC_CTL.
 */
typedef union BCMI_QTC_XGXS_ACC_CTLr_s {
	uint32_t v[1];
	uint32_t acc_ctl[1];
	uint32_t _acc_ctl;
} BCMI_QTC_XGXS_ACC_CTLr_t;

#define BCMI_QTC_XGXS_ACC_CTLr_CLR(r) (r).acc_ctl[0] = 0
#define BCMI_QTC_XGXS_ACC_CTLr_SET(r,d) (r).acc_ctl[0] = d
#define BCMI_QTC_XGXS_ACC_CTLr_GET(r) (r).acc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_ACC_CTLr_MDIO_FUNCTIONf_GET(r) ((((r).acc_ctl[0]) >> 14) & 0x3)
#define BCMI_QTC_XGXS_ACC_CTLr_MDIO_FUNCTIONf_SET(r,f) (r).acc_ctl[0]=(((r).acc_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_QTC_XGXS_ACC_CTLr_MDIO_DEVADf_GET(r) (((r).acc_ctl[0]) & 0x1f)
#define BCMI_QTC_XGXS_ACC_CTLr_MDIO_DEVADf_SET(r,f) (r).acc_ctl[0]=(((r).acc_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access ACC_CTL.
 */
#define BCMI_QTC_XGXS_READ_ACC_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_ACC_CTLr,(_r._acc_ctl))
#define BCMI_QTC_XGXS_WRITE_ACC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_CTLr,(_r._acc_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_ACC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_CTLr,(_r._acc_ctl))
#define BCMI_QTC_XGXS_READLN_ACC_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_ctl))
#define BCMI_QTC_XGXS_WRITELN_ACC_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_ctl))
#define BCMI_QTC_XGXS_WRITEALL_ACC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._acc_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACC_CTLr BCMI_QTC_XGXS_ACC_CTLr
#define ACC_CTLr_SIZE BCMI_QTC_XGXS_ACC_CTLr_SIZE
typedef BCMI_QTC_XGXS_ACC_CTLr_t ACC_CTLr_t;
#define ACC_CTLr_CLR BCMI_QTC_XGXS_ACC_CTLr_CLR
#define ACC_CTLr_SET BCMI_QTC_XGXS_ACC_CTLr_SET
#define ACC_CTLr_GET BCMI_QTC_XGXS_ACC_CTLr_GET
#define ACC_CTLr_MDIO_FUNCTIONf_GET BCMI_QTC_XGXS_ACC_CTLr_MDIO_FUNCTIONf_GET
#define ACC_CTLr_MDIO_FUNCTIONf_SET BCMI_QTC_XGXS_ACC_CTLr_MDIO_FUNCTIONf_SET
#define ACC_CTLr_MDIO_DEVADf_GET BCMI_QTC_XGXS_ACC_CTLr_MDIO_DEVADf_GET
#define ACC_CTLr_MDIO_DEVADf_SET BCMI_QTC_XGXS_ACC_CTLr_MDIO_DEVADf_SET
#define READ_ACC_CTLr BCMI_QTC_XGXS_READ_ACC_CTLr
#define WRITE_ACC_CTLr BCMI_QTC_XGXS_WRITE_ACC_CTLr
#define MODIFY_ACC_CTLr BCMI_QTC_XGXS_MODIFY_ACC_CTLr
#define READLN_ACC_CTLr BCMI_QTC_XGXS_READLN_ACC_CTLr
#define WRITELN_ACC_CTLr BCMI_QTC_XGXS_WRITELN_ACC_CTLr
#define WRITEALL_ACC_CTLr BCMI_QTC_XGXS_WRITEALL_ACC_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_ACC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  ACC_ADDR_DATA
 * BLOCKS:   MDIO_CL22_IEEE_COM
 * REGADDR:  0x000e
 * DEVAD:    1
 * DESC:     MMD_access_addr_data
 * SIZE:     32
 * FIELDS:
 *     MDIO_ADDR_DATA   If function field in PMD access control register is set to 00then this is the address register. Otherwise it is the data register
 */
#define BCMI_QTC_XGXS_ACC_ADDR_DATAr (0x0001000e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_ACC_ADDR_DATAr_SIZE 4

/*
 * This structure should be used to declare and program ACC_ADDR_DATA.
 */
typedef union BCMI_QTC_XGXS_ACC_ADDR_DATAr_s {
	uint32_t v[1];
	uint32_t acc_addr_data[1];
	uint32_t _acc_addr_data;
} BCMI_QTC_XGXS_ACC_ADDR_DATAr_t;

#define BCMI_QTC_XGXS_ACC_ADDR_DATAr_CLR(r) (r).acc_addr_data[0] = 0
#define BCMI_QTC_XGXS_ACC_ADDR_DATAr_SET(r,d) (r).acc_addr_data[0] = d
#define BCMI_QTC_XGXS_ACC_ADDR_DATAr_GET(r) (r).acc_addr_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET(r) (((r).acc_addr_data[0]) & 0xffff)
#define BCMI_QTC_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET(r,f) (r).acc_addr_data[0]=(((r).acc_addr_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access ACC_ADDR_DATA.
 */
#define BCMI_QTC_XGXS_READ_ACC_ADDR_DATAr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data))
#define BCMI_QTC_XGXS_WRITE_ACC_ADDR_DATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_ACC_ADDR_DATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data))
#define BCMI_QTC_XGXS_READLN_ACC_ADDR_DATAr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_addr_data))
#define BCMI_QTC_XGXS_WRITELN_ACC_ADDR_DATAr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_addr_data))
#define BCMI_QTC_XGXS_WRITEALL_ACC_ADDR_DATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._acc_addr_data))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define ACC_ADDR_DATAr BCMI_QTC_XGXS_ACC_ADDR_DATAr
#define ACC_ADDR_DATAr_SIZE BCMI_QTC_XGXS_ACC_ADDR_DATAr_SIZE
typedef BCMI_QTC_XGXS_ACC_ADDR_DATAr_t ACC_ADDR_DATAr_t;
#define ACC_ADDR_DATAr_CLR BCMI_QTC_XGXS_ACC_ADDR_DATAr_CLR
#define ACC_ADDR_DATAr_SET BCMI_QTC_XGXS_ACC_ADDR_DATAr_SET
#define ACC_ADDR_DATAr_GET BCMI_QTC_XGXS_ACC_ADDR_DATAr_GET
#define ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET BCMI_QTC_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET
#define ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET BCMI_QTC_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET
#define READ_ACC_ADDR_DATAr BCMI_QTC_XGXS_READ_ACC_ADDR_DATAr
#define WRITE_ACC_ADDR_DATAr BCMI_QTC_XGXS_WRITE_ACC_ADDR_DATAr
#define MODIFY_ACC_ADDR_DATAr BCMI_QTC_XGXS_MODIFY_ACC_ADDR_DATAr
#define READLN_ACC_ADDR_DATAr BCMI_QTC_XGXS_READLN_ACC_ADDR_DATAr
#define WRITELN_ACC_ADDR_DATAr BCMI_QTC_XGXS_WRITELN_ACC_ADDR_DATAr
#define WRITEALL_ACC_ADDR_DATAr BCMI_QTC_XGXS_WRITEALL_ACC_ADDR_DATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_ACC_ADDR_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXBASE_R_PMD_CTL
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x0096
 * DEVAD:    1
 * DESC:     BASE-R PMD control register 150
 * SIZE:     32
 * FIELDS:
 *     CL72_IEEE_RESTART_TRAINING 1 = Restart 10GBASE-KR cl72 training0 = Normal operation(self clearing)
 *     CL72_IEEE_TRAINING_ENABLE 1 = Enable the 10GBASE-KR start-up protocol0 = Disable the 10GBASE-KR start-up protocol
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr (0x00010096 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXBASE_R_PMD_CTL.
 */
typedef union BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_s {
	uint32_t v[1];
	uint32_t cl72_txbase_r_pmd_ctl[1];
	uint32_t _cl72_txbase_r_pmd_ctl;
} BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_t;

#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CLR(r) (r).cl72_txbase_r_pmd_ctl[0] = 0
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_SET(r,d) (r).cl72_txbase_r_pmd_ctl[0] = d
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_GET(r) (r).cl72_txbase_r_pmd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_GET(r) ((((r).cl72_txbase_r_pmd_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_SET(r,f) (r).cl72_txbase_r_pmd_ctl[0]=(((r).cl72_txbase_r_pmd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_GET(r) (((r).cl72_txbase_r_pmd_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_SET(r,f) (r).cl72_txbase_r_pmd_ctl[0]=(((r).cl72_txbase_r_pmd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL72_TXBASE_R_PMD_CTL.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXBASE_R_PMD_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr,(_r._cl72_txbase_r_pmd_ctl))
#define BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_PMD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr,(_r._cl72_txbase_r_pmd_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_PMD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr,(_r._cl72_txbase_r_pmd_ctl))
#define BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_PMD_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_pmd_ctl))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_PMD_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_pmd_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_PMD_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txbase_r_pmd_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXBASE_R_PMD_CTLr BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr
#define CL72_TXBASE_R_PMD_CTLr_SIZE BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_t CL72_TXBASE_R_PMD_CTLr_t;
#define CL72_TXBASE_R_PMD_CTLr_CLR BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CLR
#define CL72_TXBASE_R_PMD_CTLr_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_SET
#define CL72_TXBASE_R_PMD_CTLr_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_GET
#define CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_GET
#define CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_SET
#define CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_GET
#define CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_SET
#define READ_CL72_TXBASE_R_PMD_CTLr BCMI_QTC_XGXS_READ_CL72_TXBASE_R_PMD_CTLr
#define WRITE_CL72_TXBASE_R_PMD_CTLr BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_PMD_CTLr
#define MODIFY_CL72_TXBASE_R_PMD_CTLr BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_PMD_CTLr
#define READLN_CL72_TXBASE_R_PMD_CTLr BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_PMD_CTLr
#define WRITELN_CL72_TXBASE_R_PMD_CTLr BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_PMD_CTLr
#define WRITEALL_CL72_TXBASE_R_PMD_CTLr BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_PMD_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXBASE_R_PMD_STS
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x0097
 * DEVAD:    1
 * DESC:     BASE-R PMD status register 151
 * SIZE:     32
 * FIELDS:
 *     CL72_IEEE_RECEIVER_STATUS 1 = Receiver trained and ready to receive data0 = Receiver training
 *     CL72_IEEE_FRAME_LOCK 1 = Training frame delineation detected0 = Training frame delineation not detected
 *     CL72_IEEE_TRAINING_STATUS 1 = Start-up protocol in progress0 = Start-up protocol complete
 *     CL72_IEEE_TRAINING_FAILURE 1 = Training failure has been detected0 = Training failure has not been detected
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr (0x00010097 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXBASE_R_PMD_STS.
 */
typedef union BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_s {
	uint32_t v[1];
	uint32_t cl72_txbase_r_pmd_sts[1];
	uint32_t _cl72_txbase_r_pmd_sts;
} BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_t;

#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CLR(r) (r).cl72_txbase_r_pmd_sts[0] = 0
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_SET(r,d) (r).cl72_txbase_r_pmd_sts[0] = d
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_GET(r) (r).cl72_txbase_r_pmd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_GET(r) ((((r).cl72_txbase_r_pmd_sts[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_SET(r,f) (r).cl72_txbase_r_pmd_sts[0]=(((r).cl72_txbase_r_pmd_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_GET(r) ((((r).cl72_txbase_r_pmd_sts[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_SET(r,f) (r).cl72_txbase_r_pmd_sts[0]=(((r).cl72_txbase_r_pmd_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_GET(r) ((((r).cl72_txbase_r_pmd_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_SET(r,f) (r).cl72_txbase_r_pmd_sts[0]=(((r).cl72_txbase_r_pmd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_GET(r) (((r).cl72_txbase_r_pmd_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_SET(r,f) (r).cl72_txbase_r_pmd_sts[0]=(((r).cl72_txbase_r_pmd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL72_TXBASE_R_PMD_STS.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXBASE_R_PMD_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr,(_r._cl72_txbase_r_pmd_sts))
#define BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_PMD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr,(_r._cl72_txbase_r_pmd_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_PMD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr,(_r._cl72_txbase_r_pmd_sts))
#define BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_PMD_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_pmd_sts))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_PMD_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_pmd_sts))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_PMD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txbase_r_pmd_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXBASE_R_PMD_STSr BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr
#define CL72_TXBASE_R_PMD_STSr_SIZE BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_t CL72_TXBASE_R_PMD_STSr_t;
#define CL72_TXBASE_R_PMD_STSr_CLR BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CLR
#define CL72_TXBASE_R_PMD_STSr_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_SET
#define CL72_TXBASE_R_PMD_STSr_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_GET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_GET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_SET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_GET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_SET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_GET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_SET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_GET
#define CL72_TXBASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_SET
#define READ_CL72_TXBASE_R_PMD_STSr BCMI_QTC_XGXS_READ_CL72_TXBASE_R_PMD_STSr
#define WRITE_CL72_TXBASE_R_PMD_STSr BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_PMD_STSr
#define MODIFY_CL72_TXBASE_R_PMD_STSr BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_PMD_STSr
#define READLN_CL72_TXBASE_R_PMD_STSr BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_PMD_STSr
#define WRITELN_CL72_TXBASE_R_PMD_STSr BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_PMD_STSr
#define WRITEALL_CL72_TXBASE_R_PMD_STSr BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_PMD_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXBASE_R_PMD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXBASE_R_LP_COEFF_UPD
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x0098
 * DEVAD:    1
 * DESC:     BASE-R LP coeff update register 152
 * SIZE:     32
 * FIELDS:
 *     CL72_IEEE_LP_COEFF_UPDATE This register reflects the first 16-bit Word of the training framemost recently recieived from the Link PartnerThis register is not writeable when cl72 training is disabled asindicated in the IEEE spec.15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr (0x00010098 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXBASE_R_LP_COEFF_UPD.
 */
typedef union BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl72_txbase_r_lp_coeff_upd[1];
	uint32_t _cl72_txbase_r_lp_coeff_upd;
} BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_t;

#define BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_CLR(r) (r).cl72_txbase_r_lp_coeff_upd[0] = 0
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_SET(r,d) (r).cl72_txbase_r_lp_coeff_upd[0] = d
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_GET(r) (r).cl72_txbase_r_lp_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_GET(r) (((r).cl72_txbase_r_lp_coeff_upd[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_SET(r,f) (r).cl72_txbase_r_lp_coeff_upd[0]=(((r).cl72_txbase_r_lp_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_TXBASE_R_LP_COEFF_UPD.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXBASE_R_LP_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr,(_r._cl72_txbase_r_lp_coeff_upd))
#define BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_LP_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr,(_r._cl72_txbase_r_lp_coeff_upd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_LP_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr,(_r._cl72_txbase_r_lp_coeff_upd))
#define BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_LP_COEFF_UPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_lp_coeff_upd))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_LP_COEFF_UPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_lp_coeff_upd))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_LP_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txbase_r_lp_coeff_upd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXBASE_R_LP_COEFF_UPDr BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr
#define CL72_TXBASE_R_LP_COEFF_UPDr_SIZE BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_t CL72_TXBASE_R_LP_COEFF_UPDr_t;
#define CL72_TXBASE_R_LP_COEFF_UPDr_CLR BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_CLR
#define CL72_TXBASE_R_LP_COEFF_UPDr_SET BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_SET
#define CL72_TXBASE_R_LP_COEFF_UPDr_GET BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_GET
#define CL72_TXBASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_GET
#define CL72_TXBASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_SET
#define READ_CL72_TXBASE_R_LP_COEFF_UPDr BCMI_QTC_XGXS_READ_CL72_TXBASE_R_LP_COEFF_UPDr
#define WRITE_CL72_TXBASE_R_LP_COEFF_UPDr BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_LP_COEFF_UPDr
#define MODIFY_CL72_TXBASE_R_LP_COEFF_UPDr BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_LP_COEFF_UPDr
#define READLN_CL72_TXBASE_R_LP_COEFF_UPDr BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_LP_COEFF_UPDr
#define WRITELN_CL72_TXBASE_R_LP_COEFF_UPDr BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_LP_COEFF_UPDr
#define WRITEALL_CL72_TXBASE_R_LP_COEFF_UPDr BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_LP_COEFF_UPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXBASE_R_LP_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_RXBASE_R_LD_STS_REP
 * BLOCKS:   CL72_IEEE_RX
 * REGADDR:  0x0099
 * DEVAD:    1
 * DESC:     BASE-R LP status report register 153
 * SIZE:     32
 * FIELDS:
 *     CL72_IEEE_LP_STATUS_REPORT This register reflects the second 16-bit Word of the training framemost recently recieived from the Link Partner15   Receiver Ready1 =  The LP receiver has determined that training iscomplete and is prepared to receive data0 =  The LP receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 */
#define BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr (0x00010099 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL72_RXBASE_R_LD_STS_REP.
 */
typedef union BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl72_rxbase_r_ld_sts_rep[1];
	uint32_t _cl72_rxbase_r_ld_sts_rep;
} BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_t;

#define BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_CLR(r) (r).cl72_rxbase_r_ld_sts_rep[0] = 0
#define BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_SET(r,d) (r).cl72_rxbase_r_ld_sts_rep[0] = d
#define BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_GET(r) (r).cl72_rxbase_r_ld_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_GET(r) (((r).cl72_rxbase_r_ld_sts_rep[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_SET(r,f) (r).cl72_rxbase_r_ld_sts_rep[0]=(((r).cl72_rxbase_r_ld_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_RXBASE_R_LD_STS_REP.
 */
#define BCMI_QTC_XGXS_READ_CL72_RXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr,(_r._cl72_rxbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_WRITE_CL72_RXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr,(_r._cl72_rxbase_r_ld_sts_rep)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_RXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr,(_r._cl72_rxbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_READLN_CL72_RXBASE_R_LD_STS_REPr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_WRITELN_CL72_RXBASE_R_LD_STS_REPr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_WRITEALL_CL72_RXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_rxbase_r_ld_sts_rep))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_RXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr
#define CL72_RXBASE_R_LD_STS_REPr_SIZE BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_SIZE
typedef BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_t CL72_RXBASE_R_LD_STS_REPr_t;
#define CL72_RXBASE_R_LD_STS_REPr_CLR BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_CLR
#define CL72_RXBASE_R_LD_STS_REPr_SET BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_SET
#define CL72_RXBASE_R_LD_STS_REPr_GET BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_GET
#define CL72_RXBASE_R_LD_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_GET BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_GET
#define CL72_RXBASE_R_LD_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_SET BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_SET
#define READ_CL72_RXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_READ_CL72_RXBASE_R_LD_STS_REPr
#define WRITE_CL72_RXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_WRITE_CL72_RXBASE_R_LD_STS_REPr
#define MODIFY_CL72_RXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_MODIFY_CL72_RXBASE_R_LD_STS_REPr
#define READLN_CL72_RXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_READLN_CL72_RXBASE_R_LD_STS_REPr
#define WRITELN_CL72_RXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_WRITELN_CL72_RXBASE_R_LD_STS_REPr
#define WRITEALL_CL72_RXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_WRITEALL_CL72_RXBASE_R_LD_STS_REPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_RXBASE_R_LD_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXBASE_R_LD_COEFF_UPD
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x009a
 * DEVAD:    1
 * DESC:     BASE-R LD coeff update register 154
 * SIZE:     32
 * FIELDS:
 *     CL72_IEEE_LD_COEFF_UPDATE This register reflects the first 16-bit Word of the outgoing training framesent by the Local Device15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr (0x0001009a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXBASE_R_LD_COEFF_UPD.
 */
typedef union BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl72_txbase_r_ld_coeff_upd[1];
	uint32_t _cl72_txbase_r_ld_coeff_upd;
} BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_t;

#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_CLR(r) (r).cl72_txbase_r_ld_coeff_upd[0] = 0
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_SET(r,d) (r).cl72_txbase_r_ld_coeff_upd[0] = d
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_GET(r) (r).cl72_txbase_r_ld_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_GET(r) (((r).cl72_txbase_r_ld_coeff_upd[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_SET(r,f) (r).cl72_txbase_r_ld_coeff_upd[0]=(((r).cl72_txbase_r_ld_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_TXBASE_R_LD_COEFF_UPD.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXBASE_R_LD_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr,(_r._cl72_txbase_r_ld_coeff_upd))
#define BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_LD_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr,(_r._cl72_txbase_r_ld_coeff_upd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_LD_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr,(_r._cl72_txbase_r_ld_coeff_upd))
#define BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_LD_COEFF_UPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_ld_coeff_upd))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_LD_COEFF_UPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_ld_coeff_upd))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_LD_COEFF_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txbase_r_ld_coeff_upd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXBASE_R_LD_COEFF_UPDr BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr
#define CL72_TXBASE_R_LD_COEFF_UPDr_SIZE BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_t CL72_TXBASE_R_LD_COEFF_UPDr_t;
#define CL72_TXBASE_R_LD_COEFF_UPDr_CLR BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_CLR
#define CL72_TXBASE_R_LD_COEFF_UPDr_SET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_SET
#define CL72_TXBASE_R_LD_COEFF_UPDr_GET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_GET
#define CL72_TXBASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_GET
#define CL72_TXBASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_SET
#define READ_CL72_TXBASE_R_LD_COEFF_UPDr BCMI_QTC_XGXS_READ_CL72_TXBASE_R_LD_COEFF_UPDr
#define WRITE_CL72_TXBASE_R_LD_COEFF_UPDr BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_LD_COEFF_UPDr
#define MODIFY_CL72_TXBASE_R_LD_COEFF_UPDr BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_LD_COEFF_UPDr
#define READLN_CL72_TXBASE_R_LD_COEFF_UPDr BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_LD_COEFF_UPDr
#define WRITELN_CL72_TXBASE_R_LD_COEFF_UPDr BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_LD_COEFF_UPDr
#define WRITEALL_CL72_TXBASE_R_LD_COEFF_UPDr BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_LD_COEFF_UPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXBASE_R_LD_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXBASE_R_LD_STS_REP
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x009b
 * DEVAD:    1
 * DESC:     BASE-R LD status report register 155
 * SIZE:     32
 * FIELDS:
 *     CL72_IEEE_LD_STATUS_REPORT This register reflects the second 16-bit Word of the outgoing training framesent by the Local Device15   Receiver Ready1 =  The LD receiver has determined that training iscomplete and is prepared to receive data0 =  The LD receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr (0x0001009b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXBASE_R_LD_STS_REP.
 */
typedef union BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl72_txbase_r_ld_sts_rep[1];
	uint32_t _cl72_txbase_r_ld_sts_rep;
} BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_t;

#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_CLR(r) (r).cl72_txbase_r_ld_sts_rep[0] = 0
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_SET(r,d) (r).cl72_txbase_r_ld_sts_rep[0] = d
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_GET(r) (r).cl72_txbase_r_ld_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_GET(r) (((r).cl72_txbase_r_ld_sts_rep[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_SET(r,f) (r).cl72_txbase_r_ld_sts_rep[0]=(((r).cl72_txbase_r_ld_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_TXBASE_R_LD_STS_REP.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr,(_r._cl72_txbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr,(_r._cl72_txbase_r_ld_sts_rep)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr,(_r._cl72_txbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_LD_STS_REPr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_LD_STS_REPr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txbase_r_ld_sts_rep))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_LD_STS_REPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txbase_r_ld_sts_rep))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr
#define CL72_TXBASE_R_LD_STS_REPr_SIZE BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_t CL72_TXBASE_R_LD_STS_REPr_t;
#define CL72_TXBASE_R_LD_STS_REPr_CLR BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_CLR
#define CL72_TXBASE_R_LD_STS_REPr_SET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_SET
#define CL72_TXBASE_R_LD_STS_REPr_GET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_GET
#define CL72_TXBASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_GET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_GET
#define CL72_TXBASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_SET BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_SET
#define READ_CL72_TXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_READ_CL72_TXBASE_R_LD_STS_REPr
#define WRITE_CL72_TXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_WRITE_CL72_TXBASE_R_LD_STS_REPr
#define MODIFY_CL72_TXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_MODIFY_CL72_TXBASE_R_LD_STS_REPr
#define READLN_CL72_TXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_READLN_CL72_TXBASE_R_LD_STS_REPr
#define WRITELN_CL72_TXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_WRITELN_CL72_TXBASE_R_LD_STS_REPr
#define WRITEALL_CL72_TXBASE_R_LD_STS_REPr BCMI_QTC_XGXS_WRITEALL_CL72_TXBASE_R_LD_STS_REPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXBASE_R_LD_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_CDR_CTL0
 * BLOCKS:   DSC_A
 * REGADDR:  0xd001
 * DEVAD:    1
 * DESC:     CDR Control 0
 * SIZE:     32
 * FIELDS:
 *     CDR_PHASE_SAT_CTRL 0:(+-12), 1:(+-10)
 *     BR_PD_EN         0: (refer to os_all_edges) 1: use 011/100 patterns
 *     CDR_FREQ_EN      1: 2nd order loop output to contribute
 *     CDR_INTEG_REG_CLR clear integ register
 *     CDR_PHASE_ERR_FRZ 1: override phase error to be 0
 *     CDR_INTEG_SAT_SEL 0:(-24576, 24575), 1:(-16384, 16383)
 *     CDR_FREQ_OVERRIDE_EN 1:override integ register with cdr_freq_override_val
 *     CDR_LM_THR_SEL   cdr lock monitor looks for integ reg to be within sat level - (cdr_lm_thr_sel +1)*512 in magnitude
 */
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r (0x0001d001 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL0.
 */
typedef union BCMI_QTC_XGXS_DSC_CDR_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl0[1];
	uint32_t _dsc_cdr_ctl0;
} BCMI_QTC_XGXS_DSC_CDR_CTL0r_t;

#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CLR(r) (r).dsc_cdr_ctl0[0] = 0
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_SET(r,d) (r).dsc_cdr_ctl0[0] = d
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_GET(r) (r).dsc_cdr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 8) & 0x7)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_GET(r) (((r).dsc_cdr_ctl0[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL0.
 */
#define BCMI_QTC_XGXS_READ_DSC_CDR_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_QTC_XGXS_WRITE_DSC_CDR_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_CDR_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_QTC_XGXS_READLN_DSC_CDR_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_QTC_XGXS_WRITELN_DSC_CDR_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_DSC_CDR_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL0r BCMI_QTC_XGXS_DSC_CDR_CTL0r
#define DSC_CDR_CTL0r_SIZE BCMI_QTC_XGXS_DSC_CDR_CTL0r_SIZE
typedef BCMI_QTC_XGXS_DSC_CDR_CTL0r_t DSC_CDR_CTL0r_t;
#define DSC_CDR_CTL0r_CLR BCMI_QTC_XGXS_DSC_CDR_CTL0r_CLR
#define DSC_CDR_CTL0r_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_SET
#define DSC_CDR_CTL0r_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_GET
#define DSC_CDR_CTL0r_CDR_LM_THR_SELf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_GET
#define DSC_CDR_CTL0r_CDR_LM_THR_SELf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET
#define DSC_CDR_CTL0r_BR_PD_ENf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET
#define DSC_CDR_CTL0r_BR_PD_ENf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET
#define DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_GET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_GET
#define DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_SET BCMI_QTC_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_SET
#define READ_DSC_CDR_CTL0r BCMI_QTC_XGXS_READ_DSC_CDR_CTL0r
#define WRITE_DSC_CDR_CTL0r BCMI_QTC_XGXS_WRITE_DSC_CDR_CTL0r
#define MODIFY_DSC_CDR_CTL0r BCMI_QTC_XGXS_MODIFY_DSC_CDR_CTL0r
#define READLN_DSC_CDR_CTL0r BCMI_QTC_XGXS_READLN_DSC_CDR_CTL0r
#define WRITELN_DSC_CDR_CTL0r BCMI_QTC_XGXS_WRITELN_DSC_CDR_CTL0r
#define WRITEALL_DSC_CDR_CTL0r BCMI_QTC_XGXS_WRITEALL_DSC_CDR_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_CDR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_CDR_CTL1
 * BLOCKS:   DSC_A
 * REGADDR:  0xd002
 * DEVAD:    1
 * DESC:     CDR Control 1
 * SIZE:     32
 * FIELDS:
 *     CDR_FREQ_OVERRIDE_VAL Override value for the second order integrator
 */
#define BCMI_QTC_XGXS_DSC_CDR_CTL1r (0x0001d002 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_CDR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL1.
 */
typedef union BCMI_QTC_XGXS_DSC_CDR_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl1[1];
	uint32_t _dsc_cdr_ctl1;
} BCMI_QTC_XGXS_DSC_CDR_CTL1r_t;

#define BCMI_QTC_XGXS_DSC_CDR_CTL1r_CLR(r) (r).dsc_cdr_ctl1[0] = 0
#define BCMI_QTC_XGXS_DSC_CDR_CTL1r_SET(r,d) (r).dsc_cdr_ctl1[0] = d
#define BCMI_QTC_XGXS_DSC_CDR_CTL1r_GET(r) (r).dsc_cdr_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET(r) (((r).dsc_cdr_ctl1[0]) & 0xffff)
#define BCMI_QTC_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL1.
 */
#define BCMI_QTC_XGXS_READ_DSC_CDR_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_QTC_XGXS_WRITE_DSC_CDR_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_CDR_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_QTC_XGXS_READLN_DSC_CDR_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_QTC_XGXS_WRITELN_DSC_CDR_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_DSC_CDR_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL1r BCMI_QTC_XGXS_DSC_CDR_CTL1r
#define DSC_CDR_CTL1r_SIZE BCMI_QTC_XGXS_DSC_CDR_CTL1r_SIZE
typedef BCMI_QTC_XGXS_DSC_CDR_CTL1r_t DSC_CDR_CTL1r_t;
#define DSC_CDR_CTL1r_CLR BCMI_QTC_XGXS_DSC_CDR_CTL1r_CLR
#define DSC_CDR_CTL1r_SET BCMI_QTC_XGXS_DSC_CDR_CTL1r_SET
#define DSC_CDR_CTL1r_GET BCMI_QTC_XGXS_DSC_CDR_CTL1r_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET BCMI_QTC_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET BCMI_QTC_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET
#define READ_DSC_CDR_CTL1r BCMI_QTC_XGXS_READ_DSC_CDR_CTL1r
#define WRITE_DSC_CDR_CTL1r BCMI_QTC_XGXS_WRITE_DSC_CDR_CTL1r
#define MODIFY_DSC_CDR_CTL1r BCMI_QTC_XGXS_MODIFY_DSC_CDR_CTL1r
#define READLN_DSC_CDR_CTL1r BCMI_QTC_XGXS_READLN_DSC_CDR_CTL1r
#define WRITELN_DSC_CDR_CTL1r BCMI_QTC_XGXS_WRITELN_DSC_CDR_CTL1r
#define WRITEALL_DSC_CDR_CTL1r BCMI_QTC_XGXS_WRITEALL_DSC_CDR_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_CDR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_CDR_CTL2
 * BLOCKS:   DSC_A
 * REGADDR:  0xd003
 * DEVAD:    1
 * DESC:     CDR Control 2
 * SIZE:     32
 * FIELDS:
 *     CDR_ZERO_POLARITY inverts the zero information before the phase detector
 *     PHASE_ERR_OFFSET_MULT_2 Multiplies the phase error offset by 2
 *     PATTERN_SEL      13:101 (if br, 100); 12:010 (if br, 011); 11:110; 10:001
 *     OSX2P_PHERR_GAIN in > osx2 modes, the phase error is multiplied by 2^{0,1,2,3}
 */
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r (0x0001d003 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL2.
 */
typedef union BCMI_QTC_XGXS_DSC_CDR_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl2[1];
	uint32_t _dsc_cdr_ctl2;
} BCMI_QTC_XGXS_DSC_CDR_CTL2r_t;

#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_CLR(r) (r).dsc_cdr_ctl2[0] = 0
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_SET(r,d) (r).dsc_cdr_ctl2[0] = d
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_GET(r) (r).dsc_cdr_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_GET(r) (((r).dsc_cdr_ctl2[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL2.
 */
#define BCMI_QTC_XGXS_READ_DSC_CDR_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_QTC_XGXS_WRITE_DSC_CDR_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_CDR_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_QTC_XGXS_READLN_DSC_CDR_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_QTC_XGXS_WRITELN_DSC_CDR_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_DSC_CDR_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL2r BCMI_QTC_XGXS_DSC_CDR_CTL2r
#define DSC_CDR_CTL2r_SIZE BCMI_QTC_XGXS_DSC_CDR_CTL2r_SIZE
typedef BCMI_QTC_XGXS_DSC_CDR_CTL2r_t DSC_CDR_CTL2r_t;
#define DSC_CDR_CTL2r_CLR BCMI_QTC_XGXS_DSC_CDR_CTL2r_CLR
#define DSC_CDR_CTL2r_SET BCMI_QTC_XGXS_DSC_CDR_CTL2r_SET
#define DSC_CDR_CTL2r_GET BCMI_QTC_XGXS_DSC_CDR_CTL2r_GET
#define DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_GET BCMI_QTC_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_GET
#define DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_SET BCMI_QTC_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_SET
#define DSC_CDR_CTL2r_PATTERN_SELf_GET BCMI_QTC_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_GET
#define DSC_CDR_CTL2r_PATTERN_SELf_SET BCMI_QTC_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_SET
#define DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_GET BCMI_QTC_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_GET
#define DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_SET BCMI_QTC_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_SET
#define DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_GET BCMI_QTC_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_GET
#define DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_SET BCMI_QTC_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_SET
#define READ_DSC_CDR_CTL2r BCMI_QTC_XGXS_READ_DSC_CDR_CTL2r
#define WRITE_DSC_CDR_CTL2r BCMI_QTC_XGXS_WRITE_DSC_CDR_CTL2r
#define MODIFY_DSC_CDR_CTL2r BCMI_QTC_XGXS_MODIFY_DSC_CDR_CTL2r
#define READLN_DSC_CDR_CTL2r BCMI_QTC_XGXS_READLN_DSC_CDR_CTL2r
#define WRITELN_DSC_CDR_CTL2r BCMI_QTC_XGXS_WRITELN_DSC_CDR_CTL2r
#define WRITEALL_DSC_CDR_CTL2r BCMI_QTC_XGXS_WRITEALL_DSC_CDR_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_CDR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_RX_PI_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd004
 * DEVAD:    1
 * DESC:     RX PI control
 * SIZE:     32
 * FIELDS:
 *     RX_PI_PHASE_STEP_CNT # of steps to adjust
 *     RX_PI_MANUAL_STROBE strobe performs a manual override for a specified # of cycles (self clearing)
 *     RX_PI_PHASE_STEP_DIR 0: left shift, 1: right shift
 *     RX_PI_MANUAL_MODE 0: normal, 1:disconnect all PI's from CDR when enabled
 *     RX_PI_SLICERS_EN bit-vector representing which PI's to adjust: [0] d, [1] p1, [2] m1,
 *     RX_PI_MANUAL_RESET active high reset signal which initializes the pi
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr (0x0001d004 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_RX_PI_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_ctl[1];
	uint32_t _dsc_rx_pi_ctl;
} BCMI_QTC_XGXS_DSC_RX_PI_CTLr_t;

#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_CLR(r) (r).dsc_rx_pi_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_SET(r,d) (r).dsc_rx_pi_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_GET(r) (r).dsc_rx_pi_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 12) & 0x7)
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET(r) (((r).dsc_rx_pi_ctl[0]) & 0x7f)
#define BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access DSC_RX_PI_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_RX_PI_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_RX_PI_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CTLr BCMI_QTC_XGXS_DSC_RX_PI_CTLr
#define DSC_RX_PI_CTLr_SIZE BCMI_QTC_XGXS_DSC_RX_PI_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_RX_PI_CTLr_t DSC_RX_PI_CTLr_t;
#define DSC_RX_PI_CTLr_CLR BCMI_QTC_XGXS_DSC_RX_PI_CTLr_CLR
#define DSC_RX_PI_CTLr_SET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_SET
#define DSC_RX_PI_CTLr_GET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_GET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_SET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_SET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET BCMI_QTC_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET
#define READ_DSC_RX_PI_CTLr BCMI_QTC_XGXS_READ_DSC_RX_PI_CTLr
#define WRITE_DSC_RX_PI_CTLr BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CTLr
#define MODIFY_DSC_RX_PI_CTLr BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CTLr
#define READLN_DSC_RX_PI_CTLr BCMI_QTC_XGXS_READLN_DSC_RX_PI_CTLr
#define WRITELN_DSC_RX_PI_CTLr BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CTLr
#define WRITEALL_DSC_RX_PI_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_RX_PI_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_CDR_STS_INTEG
 * BLOCKS:   DSC_A
 * REGADDR:  0xd005
 * DEVAD:    1
 * DESC:     CDR Status Integ Reg
 * SIZE:     32
 * FIELDS:
 *     CDR_INTEG_REG    CDR Integ register value.
 */
#define BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr (0x0001d005 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_INTEG.
 */
typedef union BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_integ[1];
	uint32_t _dsc_cdr_sts_integ;
} BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_t;

#define BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_CLR(r) (r).dsc_cdr_sts_integ[0] = 0
#define BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_SET(r,d) (r).dsc_cdr_sts_integ[0] = d
#define BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_GET(r) (r).dsc_cdr_sts_integ[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET(r) (((r).dsc_cdr_sts_integ[0]) & 0xffff)
#define BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET(r,f) (r).dsc_cdr_sts_integ[0]=(((r).dsc_cdr_sts_integ[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access DSC_CDR_STS_INTEG.
 */
#define BCMI_QTC_XGXS_READ_DSC_CDR_STS_INTEGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_QTC_XGXS_WRITE_DSC_CDR_STS_INTEGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_CDR_STS_INTEGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_QTC_XGXS_READLN_DSC_CDR_STS_INTEGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_QTC_XGXS_WRITELN_DSC_CDR_STS_INTEGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_QTC_XGXS_WRITEALL_DSC_CDR_STS_INTEGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_integ))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_INTEGr BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr
#define DSC_CDR_STS_INTEGr_SIZE BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_SIZE
typedef BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_t DSC_CDR_STS_INTEGr_t;
#define DSC_CDR_STS_INTEGr_CLR BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_CLR
#define DSC_CDR_STS_INTEGr_SET BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_SET
#define DSC_CDR_STS_INTEGr_GET BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET
#define READ_DSC_CDR_STS_INTEGr BCMI_QTC_XGXS_READ_DSC_CDR_STS_INTEGr
#define WRITE_DSC_CDR_STS_INTEGr BCMI_QTC_XGXS_WRITE_DSC_CDR_STS_INTEGr
#define MODIFY_DSC_CDR_STS_INTEGr BCMI_QTC_XGXS_MODIFY_DSC_CDR_STS_INTEGr
#define READLN_DSC_CDR_STS_INTEGr BCMI_QTC_XGXS_READLN_DSC_CDR_STS_INTEGr
#define WRITELN_DSC_CDR_STS_INTEGr BCMI_QTC_XGXS_WRITELN_DSC_CDR_STS_INTEGr
#define WRITEALL_DSC_CDR_STS_INTEGr BCMI_QTC_XGXS_WRITEALL_DSC_CDR_STS_INTEGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_CDR_STS_INTEGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_CDR_STS_PHASE_ERR
 * BLOCKS:   DSC_A
 * REGADDR:  0xd006
 * DEVAD:    1
 * DESC:     CDR Status phase err
 * SIZE:     32
 * FIELDS:
 *     CDR_PHASE_ERR    CDR Phase Error value. gained, saturated post-freeze phase error.For all OS modes.
 *     CDR_LM_OUTOFLOCK CDR Lock Monitor loss of lock (1 implies a potential loss of lock). This bit sets itself on register read.And if the cdr_integ_reg is within bounds it clears itself in the next cycle from which it detects within bounds. Note: Set on readThe valid bounds on the cdr_integ_reg are programmed using cdr_lm_thr_selHas more meaning after rx_dsc_lock is asserted.
 */
#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr (0x0001d006 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_PHASE_ERR.
 */
typedef union BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_phase_err[1];
	uint32_t _dsc_cdr_sts_phase_err;
} BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_t;

#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR(r) (r).dsc_cdr_sts_phase_err[0] = 0
#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_SET(r,d) (r).dsc_cdr_sts_phase_err[0] = d
#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_GET(r) (r).dsc_cdr_sts_phase_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_GET(r) ((((r).dsc_cdr_sts_phase_err[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_GET(r) (((r).dsc_cdr_sts_phase_err[0]) & 0x1f)
#define BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DSC_CDR_STS_PHASE_ERR.
 */
#define BCMI_QTC_XGXS_READ_DSC_CDR_STS_PHASE_ERRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_QTC_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_QTC_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_QTC_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_QTC_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_phase_err))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_PHASE_ERRr BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr
#define DSC_CDR_STS_PHASE_ERRr_SIZE BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE
typedef BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_t DSC_CDR_STS_PHASE_ERRr_t;
#define DSC_CDR_STS_PHASE_ERRr_CLR BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR
#define DSC_CDR_STS_PHASE_ERRr_SET BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_SET
#define DSC_CDR_STS_PHASE_ERRr_GET BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_GET BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_SET BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_LM_OUTOFLOCKf_SET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_GET BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_SET BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_SET
#define READ_DSC_CDR_STS_PHASE_ERRr BCMI_QTC_XGXS_READ_DSC_CDR_STS_PHASE_ERRr
#define WRITE_DSC_CDR_STS_PHASE_ERRr BCMI_QTC_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr
#define MODIFY_DSC_CDR_STS_PHASE_ERRr BCMI_QTC_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr
#define READLN_DSC_CDR_STS_PHASE_ERRr BCMI_QTC_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr
#define WRITELN_DSC_CDR_STS_PHASE_ERRr BCMI_QTC_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr
#define WRITEALL_DSC_CDR_STS_PHASE_ERRr BCMI_QTC_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_CDR_STS_PHASE_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_D
 * BLOCKS:   DSC_A
 * REGADDR:  0xd007
 * DEVAD:    1
 * DESC:     Rx PI {P1, D}
 * SIZE:     32
 * FIELDS:
 *     CNT_BIN_D_DREG   Slicer D location
 *     CNT_BIN_P1_DREG  Slicer P1 locationThis read is duplicated here, so that the entire 15 bits if read at a time,the difference between d and p1 can be calculated, which is not possible with single reads without freezing the CDR
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr (0x0001d007 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_D.
 */
typedef union BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_d[1];
	uint32_t _dsc_rx_pi_cnt_bin_d;
} BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_t;

#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR(r) (r).dsc_rx_pi_cnt_bin_d[0] = 0
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET(r,d) (r).dsc_rx_pi_cnt_bin_d[0] = d
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET(r) (r).dsc_rx_pi_cnt_bin_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_GET(r) ((((r).dsc_rx_pi_cnt_bin_d[0]) >> 8) & 0x7f)
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_GET(r) (((r).dsc_rx_pi_cnt_bin_d[0]) & 0x7f)
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_D.
 */
#define BCMI_QTC_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_QTC_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_d))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Dr BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr
#define DSC_RX_PI_CNT_BIN_Dr_SIZE BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE
typedef BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_t DSC_RX_PI_CNT_BIN_Dr_t;
#define DSC_RX_PI_CNT_BIN_Dr_CLR BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR
#define DSC_RX_PI_CNT_BIN_Dr_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET
#define DSC_RX_PI_CNT_BIN_Dr_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_SET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_SET
#define READ_DSC_RX_PI_CNT_BIN_Dr BCMI_QTC_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr
#define WRITE_DSC_RX_PI_CNT_BIN_Dr BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr
#define MODIFY_DSC_RX_PI_CNT_BIN_Dr BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr
#define READLN_DSC_RX_PI_CNT_BIN_Dr BCMI_QTC_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr
#define WRITELN_DSC_RX_PI_CNT_BIN_Dr BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Dr BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_P
 * BLOCKS:   DSC_A
 * REGADDR:  0xd008
 * DEVAD:    1
 * DESC:     Rx PI {M1, P1}
 * SIZE:     32
 * FIELDS:
 *     CNT_BIN_P1_PREG  Slicer P1 location
 *     CNT_BIN_M1_PREG  Slicer M1 locationSee note for cnt_bin_p1_dreg in rx_pi_cnt_bin_d
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr (0x0001d008 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_P.
 */
typedef union BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_p[1];
	uint32_t _dsc_rx_pi_cnt_bin_p;
} BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_t;

#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR(r) (r).dsc_rx_pi_cnt_bin_p[0] = 0
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET(r,d) (r).dsc_rx_pi_cnt_bin_p[0] = d
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET(r) (r).dsc_rx_pi_cnt_bin_p[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_GET(r) ((((r).dsc_rx_pi_cnt_bin_p[0]) >> 8) & 0x7f)
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_GET(r) (((r).dsc_rx_pi_cnt_bin_p[0]) & 0x7f)
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_P.
 */
#define BCMI_QTC_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_QTC_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_p))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Pr BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr
#define DSC_RX_PI_CNT_BIN_Pr_SIZE BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE
typedef BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_t DSC_RX_PI_CNT_BIN_Pr_t;
#define DSC_RX_PI_CNT_BIN_Pr_CLR BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR
#define DSC_RX_PI_CNT_BIN_Pr_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET
#define DSC_RX_PI_CNT_BIN_Pr_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_SET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_SET
#define READ_DSC_RX_PI_CNT_BIN_Pr BCMI_QTC_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr
#define WRITE_DSC_RX_PI_CNT_BIN_Pr BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr
#define MODIFY_DSC_RX_PI_CNT_BIN_Pr BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr
#define READLN_DSC_RX_PI_CNT_BIN_Pr BCMI_QTC_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr
#define WRITELN_DSC_RX_PI_CNT_BIN_Pr BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Pr BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Pr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_M
 * BLOCKS:   DSC_A
 * REGADDR:  0xd009
 * DEVAD:    1
 * DESC:     Rx PI {D, M1}
 * SIZE:     32
 * FIELDS:
 *     CNT_BIN_M1_MREG  Slicer M1 location
 *     CNT_BIN_D_MREG   Slicer D locationSee note for cnt_bin_p1_dreg in rx_pi_cnt_bin_d
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr (0x0001d009 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_M.
 */
typedef union BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_m[1];
	uint32_t _dsc_rx_pi_cnt_bin_m;
} BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_t;

#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CLR(r) (r).dsc_rx_pi_cnt_bin_m[0] = 0
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_SET(r,d) (r).dsc_rx_pi_cnt_bin_m[0] = d
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_GET(r) (r).dsc_rx_pi_cnt_bin_m[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_GET(r) ((((r).dsc_rx_pi_cnt_bin_m[0]) >> 8) & 0x7f)
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_m[0]=(((r).dsc_rx_pi_cnt_bin_m[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_GET(r) (((r).dsc_rx_pi_cnt_bin_m[0]) & 0x7f)
#define BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_m[0]=(((r).dsc_rx_pi_cnt_bin_m[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_M.
 */
#define BCMI_QTC_XGXS_READ_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr,(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr,(_r._dsc_rx_pi_cnt_bin_m)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr,(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_QTC_XGXS_READLN_DSC_RX_PI_CNT_BIN_Mr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Mr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_m))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Mr BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr
#define DSC_RX_PI_CNT_BIN_Mr_SIZE BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_SIZE
typedef BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_t DSC_RX_PI_CNT_BIN_Mr_t;
#define DSC_RX_PI_CNT_BIN_Mr_CLR BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CLR
#define DSC_RX_PI_CNT_BIN_Mr_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_SET
#define DSC_RX_PI_CNT_BIN_Mr_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_GET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_GET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_SET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_GET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_GET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_SET BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_SET
#define READ_DSC_RX_PI_CNT_BIN_Mr BCMI_QTC_XGXS_READ_DSC_RX_PI_CNT_BIN_Mr
#define WRITE_DSC_RX_PI_CNT_BIN_Mr BCMI_QTC_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Mr
#define MODIFY_DSC_RX_PI_CNT_BIN_Mr BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Mr
#define READLN_DSC_RX_PI_CNT_BIN_Mr BCMI_QTC_XGXS_READLN_DSC_RX_PI_CNT_BIN_Mr
#define WRITELN_DSC_RX_PI_CNT_BIN_Mr BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Mr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Mr BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Mr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_RX_PI_CNT_BIN_Mr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_RX_PI_DIFF_BIN
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00a
 * DEVAD:    1
 * DESC:     Rx PI {D-P1, D-M1}
 * SIZE:     32
 * FIELDS:
 *     CNT_D_MINUS_M1   Slicer D minus M1
 *     CNT_D_MINUS_P1   Slicer D minus P1
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr (0x0001d00a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_DIFF_BIN.
 */
typedef union BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_diff_bin[1];
	uint32_t _dsc_rx_pi_diff_bin;
} BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_t;

#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CLR(r) (r).dsc_rx_pi_diff_bin[0] = 0
#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_SET(r,d) (r).dsc_rx_pi_diff_bin[0] = d
#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_GET(r) (r).dsc_rx_pi_diff_bin[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_GET(r) ((((r).dsc_rx_pi_diff_bin[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_SET(r,f) (r).dsc_rx_pi_diff_bin[0]=(((r).dsc_rx_pi_diff_bin[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_GET(r) (((r).dsc_rx_pi_diff_bin[0]) & 0xff)
#define BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_SET(r,f) (r).dsc_rx_pi_diff_bin[0]=(((r).dsc_rx_pi_diff_bin[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access DSC_RX_PI_DIFF_BIN.
 */
#define BCMI_QTC_XGXS_READ_DSC_RX_PI_DIFF_BINr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr,(_r._dsc_rx_pi_diff_bin))
#define BCMI_QTC_XGXS_WRITE_DSC_RX_PI_DIFF_BINr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr,(_r._dsc_rx_pi_diff_bin)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_DIFF_BINr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr,(_r._dsc_rx_pi_diff_bin))
#define BCMI_QTC_XGXS_READLN_DSC_RX_PI_DIFF_BINr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_diff_bin))
#define BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_DIFF_BINr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_diff_bin))
#define BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_DIFF_BINr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_diff_bin))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_DIFF_BINr BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr
#define DSC_RX_PI_DIFF_BINr_SIZE BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_SIZE
typedef BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_t DSC_RX_PI_DIFF_BINr_t;
#define DSC_RX_PI_DIFF_BINr_CLR BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CLR
#define DSC_RX_PI_DIFF_BINr_SET BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_SET
#define DSC_RX_PI_DIFF_BINr_GET BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_GET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_GET BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_GET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_SET BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_SET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_GET BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_GET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_SET BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_SET
#define READ_DSC_RX_PI_DIFF_BINr BCMI_QTC_XGXS_READ_DSC_RX_PI_DIFF_BINr
#define WRITE_DSC_RX_PI_DIFF_BINr BCMI_QTC_XGXS_WRITE_DSC_RX_PI_DIFF_BINr
#define MODIFY_DSC_RX_PI_DIFF_BINr BCMI_QTC_XGXS_MODIFY_DSC_RX_PI_DIFF_BINr
#define READLN_DSC_RX_PI_DIFF_BINr BCMI_QTC_XGXS_READLN_DSC_RX_PI_DIFF_BINr
#define WRITELN_DSC_RX_PI_DIFF_BINr BCMI_QTC_XGXS_WRITELN_DSC_RX_PI_DIFF_BINr
#define WRITEALL_DSC_RX_PI_DIFF_BINr BCMI_QTC_XGXS_WRITEALL_DSC_RX_PI_DIFF_BINr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_RX_PI_DIFF_BINr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_CTL5
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00b
 * DEVAD:    1
 * DESC:     training sum control 5
 * SIZE:     32
 * FIELDS:
 *     SEND_LMS_TO_PCS  When 1, this muxes p1_err into cdr_pcs_data, and swaps the p1_err and data buses into the training sum
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r (0x0001d00b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL5.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl5[1];
	uint32_t _dsc_trnsum_ctl5;
} BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_CLR(r) (r).dsc_trnsum_ctl5[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SET(r,d) (r).dsc_trnsum_ctl5[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_GET(r) (r).dsc_trnsum_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SEND_LMS_TO_PCSf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SEND_LMS_TO_PCSf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))

/*
 * These macros can be used to access DSC_TRNSUM_CTL5.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r,(_r._dsc_trnsum_ctl5))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r,(_r._dsc_trnsum_ctl5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r,(_r._dsc_trnsum_ctl5))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl5))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl5))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL5r BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r
#define DSC_TRNSUM_CTL5r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_t DSC_TRNSUM_CTL5r_t;
#define DSC_TRNSUM_CTL5r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_CLR
#define DSC_TRNSUM_CTL5r_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SET
#define DSC_TRNSUM_CTL5r_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_GET
#define DSC_TRNSUM_CTL5r_SEND_LMS_TO_PCSf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SEND_LMS_TO_PCSf_GET
#define DSC_TRNSUM_CTL5r_SEND_LMS_TO_PCSf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r_SEND_LMS_TO_PCSf_SET
#define READ_DSC_TRNSUM_CTL5r BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL5r
#define WRITE_DSC_TRNSUM_CTL5r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL5r
#define MODIFY_DSC_TRNSUM_CTL5r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL5r
#define READLN_DSC_TRNSUM_CTL5r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL5r
#define WRITELN_DSC_TRNSUM_CTL5r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL5r
#define WRITEALL_DSC_TRNSUM_CTL5r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_UC_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00d
 * DEVAD:    1
 * DESC:     DSC uC Control
 * SIZE:     32
 * FIELDS:
 *     UC_DSC_GP_UC_REQ gp_uc request
 *     UC_DSC_ERROR_FOUND Error Found.
 *     UC_DSC_READY_FOR_CMD Ready for command.
 *     UC_DSC_SUPP_INFO Supplemental information.
 */
#define BCMI_QTC_XGXS_DSC_UC_CTLr (0x0001d00d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_UC_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_UC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_uc_ctl[1];
	uint32_t _dsc_uc_ctl;
} BCMI_QTC_XGXS_DSC_UC_CTLr_t;

#define BCMI_QTC_XGXS_DSC_UC_CTLr_CLR(r) (r).dsc_uc_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_UC_CTLr_SET(r,d) (r).dsc_uc_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_UC_CTLr_GET(r) (r).dsc_uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET(r) ((((r).dsc_uc_ctl[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET(r) (((r).dsc_uc_ctl[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_UC_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_UC_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_UC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_UC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_UC_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_UC_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_UC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_uc_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_UC_CTLr BCMI_QTC_XGXS_DSC_UC_CTLr
#define DSC_UC_CTLr_SIZE BCMI_QTC_XGXS_DSC_UC_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_UC_CTLr_t DSC_UC_CTLr_t;
#define DSC_UC_CTLr_CLR BCMI_QTC_XGXS_DSC_UC_CTLr_CLR
#define DSC_UC_CTLr_SET BCMI_QTC_XGXS_DSC_UC_CTLr_SET
#define DSC_UC_CTLr_GET BCMI_QTC_XGXS_DSC_UC_CTLr_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET BCMI_QTC_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET
#define READ_DSC_UC_CTLr BCMI_QTC_XGXS_READ_DSC_UC_CTLr
#define WRITE_DSC_UC_CTLr BCMI_QTC_XGXS_WRITE_DSC_UC_CTLr
#define MODIFY_DSC_UC_CTLr BCMI_QTC_XGXS_MODIFY_DSC_UC_CTLr
#define READLN_DSC_UC_CTLr BCMI_QTC_XGXS_READLN_DSC_UC_CTLr
#define WRITELN_DSC_UC_CTLr BCMI_QTC_XGXS_WRITELN_DSC_UC_CTLr
#define WRITEALL_DSC_UC_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_UC_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_UC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SCRATCH
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00e
 * DEVAD:    1
 * DESC:     DSC uC Control
 * SIZE:     32
 * FIELDS:
 *     UC_DSC_SCRATCH   DSC scratch register.
 */
#define BCMI_QTC_XGXS_DSC_SCRATCHr (0x0001d00e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SCRATCHr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SCRATCH.
 */
typedef union BCMI_QTC_XGXS_DSC_SCRATCHr_s {
	uint32_t v[1];
	uint32_t dsc_scratch[1];
	uint32_t _dsc_scratch;
} BCMI_QTC_XGXS_DSC_SCRATCHr_t;

#define BCMI_QTC_XGXS_DSC_SCRATCHr_CLR(r) (r).dsc_scratch[0] = 0
#define BCMI_QTC_XGXS_DSC_SCRATCHr_SET(r,d) (r).dsc_scratch[0] = d
#define BCMI_QTC_XGXS_DSC_SCRATCHr_GET(r) (r).dsc_scratch[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET(r) (((r).dsc_scratch[0]) & 0xffff)
#define BCMI_QTC_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET(r,f) (r).dsc_scratch[0]=(((r).dsc_scratch[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access DSC_SCRATCH.
 */
#define BCMI_QTC_XGXS_READ_DSC_SCRATCHr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_QTC_XGXS_WRITE_DSC_SCRATCHr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SCRATCHr,(_r._dsc_scratch)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SCRATCHr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_QTC_XGXS_READLN_DSC_SCRATCHr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_QTC_XGXS_WRITELN_DSC_SCRATCHr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SCRATCHr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_scratch))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SCRATCHr BCMI_QTC_XGXS_DSC_SCRATCHr
#define DSC_SCRATCHr_SIZE BCMI_QTC_XGXS_DSC_SCRATCHr_SIZE
typedef BCMI_QTC_XGXS_DSC_SCRATCHr_t DSC_SCRATCHr_t;
#define DSC_SCRATCHr_CLR BCMI_QTC_XGXS_DSC_SCRATCHr_CLR
#define DSC_SCRATCHr_SET BCMI_QTC_XGXS_DSC_SCRATCHr_SET
#define DSC_SCRATCHr_GET BCMI_QTC_XGXS_DSC_SCRATCHr_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_GET BCMI_QTC_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_SET BCMI_QTC_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET
#define READ_DSC_SCRATCHr BCMI_QTC_XGXS_READ_DSC_SCRATCHr
#define WRITE_DSC_SCRATCHr BCMI_QTC_XGXS_WRITE_DSC_SCRATCHr
#define MODIFY_DSC_SCRATCHr BCMI_QTC_XGXS_MODIFY_DSC_SCRATCHr
#define READLN_DSC_SCRATCHr BCMI_QTC_XGXS_READLN_DSC_SCRATCHr
#define WRITELN_DSC_SCRATCHr BCMI_QTC_XGXS_WRITELN_DSC_SCRATCHr
#define WRITEALL_DSC_SCRATCHr BCMI_QTC_XGXS_WRITEALL_DSC_SCRATCHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SCRATCHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL0
 * BLOCKS:   DSC_B
 * REGADDR:  0xd010
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 0
 * SIZE:     32
 * FIELDS:
 *     EEE_MODE_EN      1'b1 will enable the EEE mode.
 *     EEE_QUIET_RX_AFE_PWRDWN_VAL 1'b1 will enable the RX AFE powerdown in EEE_QUIET mode.
 *     IGNORE_RX_MODE   If set to 1'b1 then pmd_rx_mode input will be ignored in DSC SM.
 *     CL72_TIMER_EN    If enabled to 1'b1 then LFSR is loaded with 0x01CD else it is loaded with 0x1C1E for all non-EEE and non-MEASURE states.
 *     UC_TUNE_EN       uc_tune_en is used to move in and out of UC_TUNE state. Look for DSC SM state diagram for more details.
 *     HW_TUNE_EN       Should be 1'b1 along with uc_tune_en==1'b1 to move from UC_TUNE to HW_TUNE state.  This is a self-clear register bit.
 *     UC_TRNSUM_EN     1'b1 will move the state from UC_TUNE to MEASURE. This is a self-clear register bit.
 *     EEE_MEASURE_EN   1'b1 Enables the measurement during EEE_MEASURE.
 *     UC_ACK_DSC_EEE_DONE 1'b1 will enable the EEE_DONE to DONE transition. This is a self-clear bit.
 *     UC_ACK_DSC_RESET 1'b1 will enable the RESET to CONFIG transition. This is a self-clear bit.
 *     UC_ACK_DSC_RESTART 1'b1 will enable the RESTART to CONFIG transition. This is a self-clear bit.
 *     UC_ACK_DSC_CONFIG 1'b1 will enable the CONFIG to WAIT_FOR_SIG transition. This is a self-clear bit.
 *     SET_MEAS_INCOMPLETE 1'b1 will force meas_incomplete to be 1'b1 to start a new measurement in EEE mode. This is a self-clear bit.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL0r (0x0001d010 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL0.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl0[1];
	uint32_t _dsc_sm_ctl0;
} BCMI_QTC_XGXS_DSC_SM_CTL0r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL0r_CLR(r) (r).dsc_sm_ctl0[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_SET(r,d) (r).dsc_sm_ctl0[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_GET(r) (r).dsc_sm_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESETf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESETf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access DSC_SM_CTL0.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL0r BCMI_QTC_XGXS_DSC_SM_CTL0r
#define DSC_SM_CTL0r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL0r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL0r_t DSC_SM_CTL0r_t;
#define DSC_SM_CTL0r_CLR BCMI_QTC_XGXS_DSC_SM_CTL0r_CLR
#define DSC_SM_CTL0r_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_SET
#define DSC_SM_CTL0r_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESETf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESETf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESETf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESETf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET
#define DSC_SM_CTL0r_UC_TRNSUM_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_GET
#define DSC_SM_CTL0r_UC_TRNSUM_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_SET
#define DSC_SM_CTL0r_HW_TUNE_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET
#define DSC_SM_CTL0r_HW_TUNE_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET
#define DSC_SM_CTL0r_UC_TUNE_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET
#define DSC_SM_CTL0r_UC_TUNE_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET
#define DSC_SM_CTL0r_EEE_MODE_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET
#define DSC_SM_CTL0r_EEE_MODE_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET
#define READ_DSC_SM_CTL0r BCMI_QTC_XGXS_READ_DSC_SM_CTL0r
#define WRITE_DSC_SM_CTL0r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL0r
#define MODIFY_DSC_SM_CTL0r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL0r
#define READLN_DSC_SM_CTL0r BCMI_QTC_XGXS_READLN_DSC_SM_CTL0r
#define WRITELN_DSC_SM_CTL0r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL0r
#define WRITEALL_DSC_SM_CTL0r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL1
 * BLOCKS:   DSC_B
 * REGADDR:  0xd011
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 1
 * SIZE:     32
 * FIELDS:
 *     RX_DSC_LOCK_FRC  rx_dsc_lock force.
 *     RX_DSC_LOCK_FRC_VAL rx_dsc_lock force value.
 *     DSC_CLR_FRC      DSC clear force.
 *     DSC_CLR_FRC_VAL  DSC clear force value.
 *     TRNSUM_FRZ_FRC   Training Sum freeze force.
 *     TRNSUM_FRZ_FRC_VAL raining Sum freeze force value.
 *     TIMER_DONE_FRC   Can be forced to 1'b1 which will disable the H/W timer in HW_TUNE and MEASURE states.
 *     TIMER_DONE_FRC_VAL If timer_done_frc is set to 1'b1 and DSC SM is in HW_TUNE or MEASURE states then setting this bit to 1 will move the state to next state.
 *     FREQ_UPD_EN_FRC  Frequency update force.
 *     FREQ_UPD_EN_FRC_VAL Frequency update force value.
 *     CDR_FRZ_FRC      CDR Freeze force.
 *     CDR_FRZ_FRC_VAL  CDR Freeze force value.
 *     TRNSUM_CLR_FRC   Training Sum freeze force.
 *     TRNSUM_CLR_FRC_VAL raining Sum freeze force value.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL1r (0x0001d011 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL1.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl1[1];
	uint32_t _dsc_sm_ctl1;
} BCMI_QTC_XGXS_DSC_SM_CTL1r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL1r_CLR(r) (r).dsc_sm_ctl1[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_SET(r,d) (r).dsc_sm_ctl1[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_GET(r) (r).dsc_sm_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET(r) (((r).dsc_sm_ctl1[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL1.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL1r BCMI_QTC_XGXS_DSC_SM_CTL1r
#define DSC_SM_CTL1r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL1r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL1r_t DSC_SM_CTL1r_t;
#define DSC_SM_CTL1r_CLR BCMI_QTC_XGXS_DSC_SM_CTL1r_CLR
#define DSC_SM_CTL1r_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_SET
#define DSC_SM_CTL1r_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET BCMI_QTC_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET
#define READ_DSC_SM_CTL1r BCMI_QTC_XGXS_READ_DSC_SM_CTL1r
#define WRITE_DSC_SM_CTL1r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL1r
#define MODIFY_DSC_SM_CTL1r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL1r
#define READLN_DSC_SM_CTL1r BCMI_QTC_XGXS_READLN_DSC_SM_CTL1r
#define WRITELN_DSC_SM_CTL1r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL1r
#define WRITEALL_DSC_SM_CTL1r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL2
 * BLOCKS:   DSC_B
 * REGADDR:  0xd012
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 2
 * SIZE:     32
 * FIELDS:
 *     EEE_LFSR_CNT     LFSR timer start value for all EEE timers except EEE_MEASURE.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL2r (0x0001d012 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL2.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl2[1];
	uint32_t _dsc_sm_ctl2;
} BCMI_QTC_XGXS_DSC_SM_CTL2r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL2r_CLR(r) (r).dsc_sm_ctl2[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL2r_SET(r,d) (r).dsc_sm_ctl2[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL2r_GET(r) (r).dsc_sm_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl2[0]) & 0x1fff)
#define BCMI_QTC_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl2[0]=(((r).dsc_sm_ctl2[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access DSC_SM_CTL2.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL2r BCMI_QTC_XGXS_DSC_SM_CTL2r
#define DSC_SM_CTL2r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL2r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL2r_t DSC_SM_CTL2r_t;
#define DSC_SM_CTL2r_CLR BCMI_QTC_XGXS_DSC_SM_CTL2r_CLR
#define DSC_SM_CTL2r_SET BCMI_QTC_XGXS_DSC_SM_CTL2r_SET
#define DSC_SM_CTL2r_GET BCMI_QTC_XGXS_DSC_SM_CTL2r_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_GET BCMI_QTC_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_SET BCMI_QTC_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL2r BCMI_QTC_XGXS_READ_DSC_SM_CTL2r
#define WRITE_DSC_SM_CTL2r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL2r
#define MODIFY_DSC_SM_CTL2r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL2r
#define READLN_DSC_SM_CTL2r BCMI_QTC_XGXS_READLN_DSC_SM_CTL2r
#define WRITELN_DSC_SM_CTL2r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL2r
#define WRITEALL_DSC_SM_CTL2r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL3
 * BLOCKS:   DSC_B
 * REGADDR:  0xd013
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 3
 * SIZE:     32
 * FIELDS:
 *     MEASURE_LFSR_CNT LFSR timer start value for MEASURE and EEE_MEASURE state timers.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL3r (0x0001d013 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL3.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl3[1];
	uint32_t _dsc_sm_ctl3;
} BCMI_QTC_XGXS_DSC_SM_CTL3r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL3r_CLR(r) (r).dsc_sm_ctl3[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL3r_SET(r,d) (r).dsc_sm_ctl3[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL3r_GET(r) (r).dsc_sm_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl3[0]) & 0x1fff)
#define BCMI_QTC_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl3[0]=(((r).dsc_sm_ctl3[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (8191 << 16)

/*
 * These macros can be used to access DSC_SM_CTL3.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL3r BCMI_QTC_XGXS_DSC_SM_CTL3r
#define DSC_SM_CTL3r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL3r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL3r_t DSC_SM_CTL3r_t;
#define DSC_SM_CTL3r_CLR BCMI_QTC_XGXS_DSC_SM_CTL3r_CLR
#define DSC_SM_CTL3r_SET BCMI_QTC_XGXS_DSC_SM_CTL3r_SET
#define DSC_SM_CTL3r_GET BCMI_QTC_XGXS_DSC_SM_CTL3r_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET BCMI_QTC_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET BCMI_QTC_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL3r BCMI_QTC_XGXS_READ_DSC_SM_CTL3r
#define WRITE_DSC_SM_CTL3r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL3r
#define MODIFY_DSC_SM_CTL3r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL3r
#define READLN_DSC_SM_CTL3r BCMI_QTC_XGXS_READLN_DSC_SM_CTL3r
#define WRITELN_DSC_SM_CTL3r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL3r
#define WRITEALL_DSC_SM_CTL3r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL4
 * BLOCKS:   DSC_B
 * REGADDR:  0xd014
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 4
 * SIZE:     32
 * FIELDS:
 *     ACQ_CDR_TIMEOUT  Defines timeout value for the ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     CDR_SETTLE_TIMEOUT Defines timeout value for the CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     HW_TUNE_TIMEOUT  Defines timeout value for the HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL4r (0x0001d014 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL4.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl4[1];
	uint32_t _dsc_sm_ctl4;
} BCMI_QTC_XGXS_DSC_SM_CTL4r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL4r_CLR(r) (r).dsc_sm_ctl4[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_SET(r,d) (r).dsc_sm_ctl4[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_GET(r) (r).dsc_sm_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 10) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 5) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET(r) (((r).dsc_sm_ctl4[0]) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DSC_SM_CTL4.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL4r BCMI_QTC_XGXS_DSC_SM_CTL4r
#define DSC_SM_CTL4r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL4r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL4r_t DSC_SM_CTL4r_t;
#define DSC_SM_CTL4r_CLR BCMI_QTC_XGXS_DSC_SM_CTL4r_CLR
#define DSC_SM_CTL4r_SET BCMI_QTC_XGXS_DSC_SM_CTL4r_SET
#define DSC_SM_CTL4r_GET BCMI_QTC_XGXS_DSC_SM_CTL4r_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET
#define READ_DSC_SM_CTL4r BCMI_QTC_XGXS_READ_DSC_SM_CTL4r
#define WRITE_DSC_SM_CTL4r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL4r
#define MODIFY_DSC_SM_CTL4r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL4r
#define READLN_DSC_SM_CTL4r BCMI_QTC_XGXS_READLN_DSC_SM_CTL4r
#define WRITELN_DSC_SM_CTL4r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL4r
#define WRITEALL_DSC_SM_CTL4r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL5
 * BLOCKS:   DSC_B
 * REGADDR:  0xd015
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 5
 * SIZE:     32
 * FIELDS:
 *     MEASURE_TIMEOUT  Defines timeout value for the MEASURE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ACQ_CDR_TIMEOUT Defines timeout value for the EEE_ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_CDR_SETTLE_TIMEOUT Defines timeout value for the EEE_CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL5r (0x0001d015 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL5.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl5[1];
	uint32_t _dsc_sm_ctl5;
} BCMI_QTC_XGXS_DSC_SM_CTL5r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL5r_CLR(r) (r).dsc_sm_ctl5[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_SET(r,d) (r).dsc_sm_ctl5[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_GET(r) (r).dsc_sm_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 10) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 5) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl5[0]) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DSC_SM_CTL5.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL5r BCMI_QTC_XGXS_DSC_SM_CTL5r
#define DSC_SM_CTL5r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL5r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL5r_t DSC_SM_CTL5r_t;
#define DSC_SM_CTL5r_CLR BCMI_QTC_XGXS_DSC_SM_CTL5r_CLR
#define DSC_SM_CTL5r_SET BCMI_QTC_XGXS_DSC_SM_CTL5r_SET
#define DSC_SM_CTL5r_GET BCMI_QTC_XGXS_DSC_SM_CTL5r_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET
#define READ_DSC_SM_CTL5r BCMI_QTC_XGXS_READ_DSC_SM_CTL5r
#define WRITE_DSC_SM_CTL5r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL5r
#define MODIFY_DSC_SM_CTL5r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL5r
#define READLN_DSC_SM_CTL5r BCMI_QTC_XGXS_READLN_DSC_SM_CTL5r
#define WRITELN_DSC_SM_CTL5r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL5r
#define WRITEALL_DSC_SM_CTL5r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL6
 * BLOCKS:   DSC_B
 * REGADDR:  0xd016
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 6
 * SIZE:     32
 * FIELDS:
 *     EEE_HW_TUNE_TIMEOUT Defines timeout value for the EEE_HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ANA_PWR_TIMEOUT Defines timeout value for the EEE_ANA_PWR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL6r (0x0001d016 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL6.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL6r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl6[1];
	uint32_t _dsc_sm_ctl6;
} BCMI_QTC_XGXS_DSC_SM_CTL6r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL6r_CLR(r) (r).dsc_sm_ctl6[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL6r_SET(r,d) (r).dsc_sm_ctl6[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL6r_GET(r) (r).dsc_sm_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl6[0]) >> 10) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl6[0]) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DSC_SM_CTL6.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL6r BCMI_QTC_XGXS_DSC_SM_CTL6r
#define DSC_SM_CTL6r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL6r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL6r_t DSC_SM_CTL6r_t;
#define DSC_SM_CTL6r_CLR BCMI_QTC_XGXS_DSC_SM_CTL6r_CLR
#define DSC_SM_CTL6r_SET BCMI_QTC_XGXS_DSC_SM_CTL6r_SET
#define DSC_SM_CTL6r_GET BCMI_QTC_XGXS_DSC_SM_CTL6r_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET BCMI_QTC_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET
#define READ_DSC_SM_CTL6r BCMI_QTC_XGXS_READ_DSC_SM_CTL6r
#define WRITE_DSC_SM_CTL6r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL6r
#define MODIFY_DSC_SM_CTL6r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL6r
#define READLN_DSC_SM_CTL6r BCMI_QTC_XGXS_READLN_DSC_SM_CTL6r
#define WRITELN_DSC_SM_CTL6r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL6r
#define WRITEALL_DSC_SM_CTL6r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL7
 * BLOCKS:   DSC_B
 * REGADDR:  0xd017
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 7
 * SIZE:     32
 * FIELDS:
 *     CDR_BWSEL_INTEG_ACQCDR CDR Integ Bandwidth select for ACQ_CDR state.{0->4} <=> 2^{0->4}. {13,14,15} <=> {2^{-3,-2,-1}}.
 *     CDR_BWSEL_INTEG_EEE_ACQCDR CDR Integ Bandwidth select for EEE_ACQ_CDR state.{0->4} <=> 2^{0->4}. {13,14,15} <=> {2^{-3,-2,-1}}.
 *     CDR_BWSEL_INTEG_NORM CDR Integ Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0->4} <=> 2^{0->4}. {13,14,15} <=> {2^{-3,-2,-1}}.
 *     CDR_BWSEL_PROP_ACQCDR CDR Proportional Bandwidth select for ACQ_CDR state.{0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 *     CDR_BWSEL_PROP_NORM CDR Proportional Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL7r (0x0001d017 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL7.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL7r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl7[1];
	uint32_t _dsc_sm_ctl7;
} BCMI_QTC_XGXS_DSC_SM_CTL7r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CLR(r) (r).dsc_sm_ctl7[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_SET(r,d) (r).dsc_sm_ctl7[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_GET(r) (r).dsc_sm_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 14) & 0x3)
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 12) & 0x3)
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET(r) (((r).dsc_sm_ctl7[0]) & 0xf)
#define BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access DSC_SM_CTL7.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL7r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL7r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL7r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL7r BCMI_QTC_XGXS_DSC_SM_CTL7r
#define DSC_SM_CTL7r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL7r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL7r_t DSC_SM_CTL7r_t;
#define DSC_SM_CTL7r_CLR BCMI_QTC_XGXS_DSC_SM_CTL7r_CLR
#define DSC_SM_CTL7r_SET BCMI_QTC_XGXS_DSC_SM_CTL7r_SET
#define DSC_SM_CTL7r_GET BCMI_QTC_XGXS_DSC_SM_CTL7r_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET BCMI_QTC_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET
#define READ_DSC_SM_CTL7r BCMI_QTC_XGXS_READ_DSC_SM_CTL7r
#define WRITE_DSC_SM_CTL7r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL7r
#define MODIFY_DSC_SM_CTL7r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL7r
#define READLN_DSC_SM_CTL7r BCMI_QTC_XGXS_READLN_DSC_SM_CTL7r
#define WRITELN_DSC_SM_CTL7r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL7r
#define WRITEALL_DSC_SM_CTL7r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL8
 * BLOCKS:   DSC_B
 * REGADDR:  0xd018
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 8
 * SIZE:     32
 * FIELDS:
 *     PHASE_ERR_OFFSET Phase Error Offset for non-EEE_ACQ_CDR states. Signed value. Valid range is -8 to 7. This translates to either -8/2 to 7/2 or -8/4 to 7/4, depending on how rg_phase_err_offset_mult_2 is set. By default is is -8/4 to 7/4 adding into VCO reg.
 *     EEE_PHASE_ERR_OFFSET Phase Error Offset for EEE_ACQ_CDR state. Signed value. Valid range is -8 to 7.
 *     PHASE_ERR_OFFSET_EN Phase Error Offset Enable for non-EEE_ACQ_CDR states.
 *     EEE_PHASE_ERR_OFFSET_EN Phase Error Offset Enable for EEE_ACQ_CDR state.
 *     CDR_BWSEL_PROP_EEE_ACQCDR CDR Proportional Bandwidth select for EEE_ACQ_CDR state.{0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL8r (0x0001d018 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL8.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL8r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl8[1];
	uint32_t _dsc_sm_ctl8;
} BCMI_QTC_XGXS_DSC_SM_CTL8r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL8r_CLR(r) (r).dsc_sm_ctl8[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_SET(r,d) (r).dsc_sm_ctl8[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_GET(r) (r).dsc_sm_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 14) & 0x3)
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET(r) (((r).dsc_sm_ctl8[0]) & 0xf)
#define BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access DSC_SM_CTL8.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL8r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL8r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL8r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl8))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL8r BCMI_QTC_XGXS_DSC_SM_CTL8r
#define DSC_SM_CTL8r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL8r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL8r_t DSC_SM_CTL8r_t;
#define DSC_SM_CTL8r_CLR BCMI_QTC_XGXS_DSC_SM_CTL8r_CLR
#define DSC_SM_CTL8r_SET BCMI_QTC_XGXS_DSC_SM_CTL8r_SET
#define DSC_SM_CTL8r_GET BCMI_QTC_XGXS_DSC_SM_CTL8r_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET BCMI_QTC_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET BCMI_QTC_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET BCMI_QTC_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET BCMI_QTC_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET
#define READ_DSC_SM_CTL8r BCMI_QTC_XGXS_READ_DSC_SM_CTL8r
#define WRITE_DSC_SM_CTL8r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL8r
#define MODIFY_DSC_SM_CTL8r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL8r
#define READLN_DSC_SM_CTL8r BCMI_QTC_XGXS_READLN_DSC_SM_CTL8r
#define WRITELN_DSC_SM_CTL8r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL8r
#define WRITEALL_DSC_SM_CTL8r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL8r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_CTL9
 * BLOCKS:   DSC_B
 * REGADDR:  0xd019
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 9
 * SIZE:     32
 * FIELDS:
 *     RX_RESTART_PMD   1'b1 will reset the DSC SM into RESTART state. This is a self-clear register bit.
 *     RX_RESTART_PMD_HOLD 1'b1 will reset the DSC SM into RESTART state and HOLD it there until set to 1'b0.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL9r (0x0001d019 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL9.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_CTL9r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl9[1];
	uint32_t _dsc_sm_ctl9;
} BCMI_QTC_XGXS_DSC_SM_CTL9r_t;

#define BCMI_QTC_XGXS_DSC_SM_CTL9r_CLR(r) (r).dsc_sm_ctl9[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_CTL9r_SET(r,d) (r).dsc_sm_ctl9[0] = d
#define BCMI_QTC_XGXS_DSC_SM_CTL9r_GET(r) (r).dsc_sm_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET(r) ((((r).dsc_sm_ctl9[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET(r) (((r).dsc_sm_ctl9[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL9.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_CTL9r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_CTL9r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL9r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_QTC_XGXS_READLN_DSC_SM_CTL9r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL9r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL9r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl9))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL9r BCMI_QTC_XGXS_DSC_SM_CTL9r
#define DSC_SM_CTL9r_SIZE BCMI_QTC_XGXS_DSC_SM_CTL9r_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_CTL9r_t DSC_SM_CTL9r_t;
#define DSC_SM_CTL9r_CLR BCMI_QTC_XGXS_DSC_SM_CTL9r_CLR
#define DSC_SM_CTL9r_SET BCMI_QTC_XGXS_DSC_SM_CTL9r_SET
#define DSC_SM_CTL9r_GET BCMI_QTC_XGXS_DSC_SM_CTL9r_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_GET BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_SET BCMI_QTC_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET
#define READ_DSC_SM_CTL9r BCMI_QTC_XGXS_READ_DSC_SM_CTL9r
#define WRITE_DSC_SM_CTL9r BCMI_QTC_XGXS_WRITE_DSC_SM_CTL9r
#define MODIFY_DSC_SM_CTL9r BCMI_QTC_XGXS_MODIFY_DSC_SM_CTL9r
#define READLN_DSC_SM_CTL9r BCMI_QTC_XGXS_READLN_DSC_SM_CTL9r
#define WRITELN_DSC_SM_CTL9r BCMI_QTC_XGXS_WRITELN_DSC_SM_CTL9r
#define WRITEALL_DSC_SM_CTL9r BCMI_QTC_XGXS_WRITEALL_DSC_SM_CTL9r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_STS_DSC_LOCK
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01a
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE DSC_LOCK STATUS
 * SIZE:     32
 * FIELDS:
 *     RX_DSC_LOCK      1 indicates that DSC is locked.
 *     MEAS_INCOMPLETE  1 indicates that measurement is incomplete. 0 indicates that measurement is complete.
 *     EEE_MEASURE_CNT  Indicates the eee_measure_cnt status. This is a debug register.
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr (0x0001d01a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_LOCK.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_lock[1];
	uint32_t _dsc_sm_sts_dsc_lock;
} BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_t;

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_CLR(r) (r).dsc_sm_sts_dsc_lock[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_SET(r,d) (r).dsc_sm_sts_dsc_lock[0] = d
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_GET(r) (r).dsc_sm_sts_dsc_lock[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 7) & 0x1ff)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET(r) (((r).dsc_sm_sts_dsc_lock[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_LOCK.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_LOCKr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_lock))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_LOCKr BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr
#define DSC_SM_STS_DSC_LOCKr_SIZE BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_t DSC_SM_STS_DSC_LOCKr_t;
#define DSC_SM_STS_DSC_LOCKr_CLR BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_CLR
#define DSC_SM_STS_DSC_LOCKr_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_SET
#define DSC_SM_STS_DSC_LOCKr_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET
#define READ_DSC_SM_STS_DSC_LOCKr BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_LOCKr
#define WRITE_DSC_SM_STS_DSC_LOCKr BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr
#define MODIFY_DSC_SM_STS_DSC_LOCKr BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr
#define READLN_DSC_SM_STS_DSC_LOCKr BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_LOCKr
#define WRITELN_DSC_SM_STS_DSC_LOCKr BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr
#define WRITEALL_DSC_SM_STS_DSC_LOCKr BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_STS_DSC_LOCKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_ONE_HOT
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01b
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS ONE HOT
 * SIZE:     32
 * FIELDS:
 *     DSC_STATE_ONE_HOT Sticky one-hot coded states. These registers are cleared on read.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr (0x0001d01b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_ONE_HOT.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_one_hot;
} BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t;

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_one_hot[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_one_hot[0] = d
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_one_hot[0]) & 0x3ff)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_one_hot[0]=(((r).dsc_sm_sts_dsc_st_one_hot[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (1023 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_ONE_HOT.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_one_hot))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t DSC_SM_STS_DSC_ST_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_ONE_HOTr_CLR BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_EEE_ONE_HOT
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01c
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS EEE ONE HOT
 * SIZE:     32
 * FIELDS:
 *     DSC_STATE_EEE_ONE_HOT Sticky one-hot coded EEE state . These registers are cleared on read.EEE_QUIET       =  0EEE_ANA_PWR     =  1EEE_ACQ_CDR     =  2EEE_CDR_SETTLE  =  3EEE_HW_TUNE     =  4EEE_MEASURE     =  5EEE_DONE        =  6
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr (0x0001d01c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_eee_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_eee_one_hot;
} BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = d
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_eee_one_hot[0]) & 0x7f)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]=(((r).dsc_sm_sts_dsc_st_eee_one_hot[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_eee_one_hot))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_STS_RESTART
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01d
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS RESTART
 * SIZE:     32
 * FIELDS:
 *     RESTART_PI_EXT_MODE Indicates when SM moves to RESTART state due to enabling of RX_PI external control (i.e. digital loopback enable). This is clear on read.
 *     RESTART_SIGDET   Indicates when SM moves to RESTART state due to sigdet==0 and eee_mode_en register is 1'b0. This is clear on read.
 *     RESTART_PMD_RESTART Indicates when SM moves to RESTART state due to assertion of pmd_restart to 1'b1. This is clear on read.
 *     EEE_QUIET_FROM_EEE_STATES Indicates when SM moves from any EEE states to EEE_QUIET state. This is clear on read.
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr (0x0001d01d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_RESTART.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_restart[1];
	uint32_t _dsc_sm_sts_restart;
} BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_t;

#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_CLR(r) (r).dsc_sm_sts_restart[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_SET(r,d) (r).dsc_sm_sts_restart[0] = d
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_GET(r) (r).dsc_sm_sts_restart[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET(r) (((r).dsc_sm_sts_restart[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_RESTART.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_STS_RESTARTr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_STS_RESTARTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_RESTARTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_QTC_XGXS_READLN_DSC_SM_STS_RESTARTr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_RESTARTr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_RESTARTr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_restart))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_RESTARTr BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr
#define DSC_SM_STS_RESTARTr_SIZE BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_t DSC_SM_STS_RESTARTr_t;
#define DSC_SM_STS_RESTARTr_CLR BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_CLR
#define DSC_SM_STS_RESTARTr_SET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_SET
#define DSC_SM_STS_RESTARTr_GET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET
#define READ_DSC_SM_STS_RESTARTr BCMI_QTC_XGXS_READ_DSC_SM_STS_RESTARTr
#define WRITE_DSC_SM_STS_RESTARTr BCMI_QTC_XGXS_WRITE_DSC_SM_STS_RESTARTr
#define MODIFY_DSC_SM_STS_RESTARTr BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_RESTARTr
#define READLN_DSC_SM_STS_RESTARTr BCMI_QTC_XGXS_READLN_DSC_SM_STS_RESTARTr
#define WRITELN_DSC_SM_STS_RESTARTr BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_RESTARTr
#define WRITEALL_DSC_SM_STS_RESTARTr BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_RESTARTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_STS_RESTARTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01e
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS
 * SIZE:     32
 * FIELDS:
 *     DSC_SM_SCRATCH   4 LSB bits of dsc_scratch
 *     DSC_SM_READY_FOR_CMD Ready for Command.
 *     DSC_SM_GP_UC_REQ gp_uc_req.
 *     DSC_STATE        Live DSC SM state. Following are the state encodings.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9EEE_QUIET       =  10EEE_ANA_PWR     =  11EEE_ACQ_CDR     =  12EEE_CDR_SETTLE  =  13EEE_HW_TUNE     =  14EEE_MEASURE     =  15EEE_DONE        =  16
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr (0x0001d01e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST.
 */
typedef union BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st[1];
	uint32_t _dsc_sm_sts_dsc_st;
} BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_t;

#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_CLR(r) (r).dsc_sm_sts_dsc_st[0] = 0
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_SET(r,d) (r).dsc_sm_sts_dsc_st[0] = d
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_GET(r) (r).dsc_sm_sts_dsc_st[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 11) & 0x1f)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 5) & 0x3f)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET(r) (((r).dsc_sm_sts_dsc_st[0]) & 0xf)
#define BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST.
 */
#define BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_STr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_STr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_STr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_STr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_STr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_STr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_STr BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr
#define DSC_SM_STS_DSC_STr_SIZE BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_SIZE
typedef BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_t DSC_SM_STS_DSC_STr_t;
#define DSC_SM_STS_DSC_STr_CLR BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_CLR
#define DSC_SM_STS_DSC_STr_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_SET
#define DSC_SM_STS_DSC_STr_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET
#define READ_DSC_SM_STS_DSC_STr BCMI_QTC_XGXS_READ_DSC_SM_STS_DSC_STr
#define WRITE_DSC_SM_STS_DSC_STr BCMI_QTC_XGXS_WRITE_DSC_SM_STS_DSC_STr
#define MODIFY_DSC_SM_STS_DSC_STr BCMI_QTC_XGXS_MODIFY_DSC_SM_STS_DSC_STr
#define READLN_DSC_SM_STS_DSC_STr BCMI_QTC_XGXS_READLN_DSC_SM_STS_DSC_STr
#define WRITELN_DSC_SM_STS_DSC_STr BCMI_QTC_XGXS_WRITELN_DSC_SM_STS_DSC_STr
#define WRITEALL_DSC_SM_STS_DSC_STr BCMI_QTC_XGXS_WRITEALL_DSC_SM_STS_DSC_STr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_SM_STS_DSC_STr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_COMMON_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd020
 * DEVAD:    1
 * DESC:     DFE Common Control
 * SIZE:     32
 * FIELDS:
 *     DFE_UPDATE_GAIN  *1 or *2 on the updates to the tap
 *     DFE_ALLOW_SIMULT Allow simulatenous change for the cmn tap as well as either odd/even tap controls
 *     DFE_ACC_HYS_EN   Enables hysteresis behavior in the accumulator
 */
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr (0x0001d020 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_COMMON_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_common_ctl[1];
	uint32_t _dsc_dfe_common_ctl;
} BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_CLR(r) (r).dsc_dfe_common_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_SET(r,d) (r).dsc_dfe_common_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_GET(r) (r).dsc_dfe_common_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access DSC_DFE_COMMON_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_COMMON_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr,(_r._dsc_dfe_common_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_COMMON_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr,(_r._dsc_dfe_common_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_COMMON_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr,(_r._dsc_dfe_common_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_COMMON_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_common_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_COMMON_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_common_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_COMMON_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_common_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_COMMON_CTLr BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr
#define DSC_DFE_COMMON_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_t DSC_DFE_COMMON_CTLr_t;
#define DSC_DFE_COMMON_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_CLR
#define DSC_DFE_COMMON_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_SET
#define DSC_DFE_COMMON_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_GET
#define DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_GET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_GET
#define DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_SET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_SET
#define DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_GET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_GET
#define DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_SET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_SET
#define DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_GET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_GET
#define DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_SET BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_SET
#define READ_DSC_DFE_COMMON_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_COMMON_CTLr
#define WRITE_DSC_DFE_COMMON_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_COMMON_CTLr
#define MODIFY_DSC_DFE_COMMON_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_COMMON_CTLr
#define READLN_DSC_DFE_COMMON_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_COMMON_CTLr
#define WRITELN_DSC_DFE_COMMON_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_COMMON_CTLr
#define WRITEALL_DSC_DFE_COMMON_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_COMMON_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_COMMON_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_1_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd021
 * DEVAD:    1
 * DESC:     DFE 1 Control
 * SIZE:     32
 * FIELDS:
 *     DFE_1_ACC_CLR    clears the dfe_1_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_1_CMN_ONLY   both even and odd errors are summed and apply only to cmn tap - not to the evn and odd taps
 *     DFE_1_INV_P1     invert p1
 *     DFE_1_INV_M1     invert m1
 *     DFE_1_ERR_GAIN   error scaled by 2^dfe_1_err_gain
 *     DFE_1_GRADIENT_INVERT invert the gradient
 *     DFE_1_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_1_EN         Enables the tap for adaptive eq
 */
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr (0x0001d021 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_1_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_1_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_1_ctl[1];
	uint32_t _dsc_dfe_1_ctl;
} BCMI_QTC_XGXS_DSC_DFE_1_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_CLR(r) (r).dsc_dfe_1_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_SET(r,d) (r).dsc_dfe_1_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_GET(r) (r).dsc_dfe_1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 13) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_GET(r) (((r).dsc_dfe_1_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_DFE_1_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_1_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_1_CTLr,(_r._dsc_dfe_1_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_CTLr,(_r._dsc_dfe_1_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_CTLr,(_r._dsc_dfe_1_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_1_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_1_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_1_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_1_CTLr BCMI_QTC_XGXS_DSC_DFE_1_CTLr
#define DSC_DFE_1_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_1_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_1_CTLr_t DSC_DFE_1_CTLr_t;
#define DSC_DFE_1_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_1_CTLr_CLR
#define DSC_DFE_1_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_SET
#define DSC_DFE_1_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_GET
#define DSC_DFE_1_CTLr_DFE_1_ENf_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_GET
#define DSC_DFE_1_CTLr_DFE_1_ENf_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_SET
#define DSC_DFE_1_CTLr_DFE_1_ERR_SELf_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_GET
#define DSC_DFE_1_CTLr_DFE_1_ERR_SELf_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_SET
#define DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_GET
#define DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_SET
#define DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_GET
#define DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_SET
#define DSC_DFE_1_CTLr_DFE_1_INV_M1f_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_GET
#define DSC_DFE_1_CTLr_DFE_1_INV_M1f_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_SET
#define DSC_DFE_1_CTLr_DFE_1_INV_P1f_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_GET
#define DSC_DFE_1_CTLr_DFE_1_INV_P1f_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_SET
#define DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_GET
#define DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_SET
#define DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_GET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_GET
#define DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_SET BCMI_QTC_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_SET
#define READ_DSC_DFE_1_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_1_CTLr
#define WRITE_DSC_DFE_1_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_1_CTLr
#define MODIFY_DSC_DFE_1_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_1_CTLr
#define READLN_DSC_DFE_1_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_1_CTLr
#define WRITELN_DSC_DFE_1_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_1_CTLr
#define WRITEALL_DSC_DFE_1_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_1_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_1_PAT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd022
 * DEVAD:    1
 * DESC:     DFE 1 Pat Control
 * SIZE:     32
 * FIELDS:
 *     DFE_1_PATTERN    pattern
 *     DFE_1_PATTERN_BIT_EN pattern bit mask
 */
#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr (0x0001d022 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_1_PAT_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_1_pat_ctl[1];
	uint32_t _dsc_dfe_1_pat_ctl;
} BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_CLR(r) (r).dsc_dfe_1_pat_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_SET(r,d) (r).dsc_dfe_1_pat_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_GET(r) (r).dsc_dfe_1_pat_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERN_BIT_ENf_GET(r) ((((r).dsc_dfe_1_pat_ctl[0]) >> 8) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERN_BIT_ENf_SET(r,f) (r).dsc_dfe_1_pat_ctl[0]=(((r).dsc_dfe_1_pat_ctl[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERNf_GET(r) (((r).dsc_dfe_1_pat_ctl[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERNf_SET(r,f) (r).dsc_dfe_1_pat_ctl[0]=(((r).dsc_dfe_1_pat_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_DFE_1_PAT_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_1_PAT_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr,(_r._dsc_dfe_1_pat_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_1_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr,(_r._dsc_dfe_1_pat_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_1_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr,(_r._dsc_dfe_1_pat_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_1_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_pat_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_1_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_pat_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_1_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_1_pat_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_1_PAT_CTLr BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr
#define DSC_DFE_1_PAT_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_t DSC_DFE_1_PAT_CTLr_t;
#define DSC_DFE_1_PAT_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_CLR
#define DSC_DFE_1_PAT_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_SET
#define DSC_DFE_1_PAT_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_GET
#define DSC_DFE_1_PAT_CTLr_DFE_1_PATTERN_BIT_ENf_GET BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERN_BIT_ENf_GET
#define DSC_DFE_1_PAT_CTLr_DFE_1_PATTERN_BIT_ENf_SET BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERN_BIT_ENf_SET
#define DSC_DFE_1_PAT_CTLr_DFE_1_PATTERNf_GET BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERNf_GET
#define DSC_DFE_1_PAT_CTLr_DFE_1_PATTERNf_SET BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr_DFE_1_PATTERNf_SET
#define READ_DSC_DFE_1_PAT_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_1_PAT_CTLr
#define WRITE_DSC_DFE_1_PAT_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_1_PAT_CTLr
#define MODIFY_DSC_DFE_1_PAT_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_1_PAT_CTLr
#define READLN_DSC_DFE_1_PAT_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_1_PAT_CTLr
#define WRITELN_DSC_DFE_1_PAT_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_1_PAT_CTLr
#define WRITEALL_DSC_DFE_1_PAT_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_1_PAT_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_1_PAT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_2_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd023
 * DEVAD:    1
 * DESC:     DFE 2 Control
 * SIZE:     32
 * FIELDS:
 *     DFE_2_ACC_CLR    clears the dfe_2_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_2_CMN_ONLY   both even and odd errors are summed and apply only to cmn tap - not to the evn and odd taps
 *     DFE_2_INV_P1     invert p1
 *     DFE_2_INV_M1     invert m1
 *     DFE_2_ERR_GAIN   error scaled by 2^dfe_2_err_gain
 *     DFE_2_GRADIENT_INVERT invert the gradient
 *     DFE_2_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_2_EN         Enables the tap for adaptive eq
 */
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr (0x0001d023 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_2_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_2_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_2_ctl[1];
	uint32_t _dsc_dfe_2_ctl;
} BCMI_QTC_XGXS_DSC_DFE_2_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_CLR(r) (r).dsc_dfe_2_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_SET(r,d) (r).dsc_dfe_2_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_GET(r) (r).dsc_dfe_2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 13) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_GET(r) (((r).dsc_dfe_2_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_DFE_2_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_2_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_2_CTLr,(_r._dsc_dfe_2_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_2_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_CTLr,(_r._dsc_dfe_2_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_2_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_CTLr,(_r._dsc_dfe_2_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_2_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_2_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_2_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_2_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_2_CTLr BCMI_QTC_XGXS_DSC_DFE_2_CTLr
#define DSC_DFE_2_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_2_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_2_CTLr_t DSC_DFE_2_CTLr_t;
#define DSC_DFE_2_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_2_CTLr_CLR
#define DSC_DFE_2_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_SET
#define DSC_DFE_2_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_GET
#define DSC_DFE_2_CTLr_DFE_2_ENf_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_GET
#define DSC_DFE_2_CTLr_DFE_2_ENf_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_SET
#define DSC_DFE_2_CTLr_DFE_2_ERR_SELf_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_GET
#define DSC_DFE_2_CTLr_DFE_2_ERR_SELf_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_SET
#define DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_GET
#define DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_SET
#define DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_GET
#define DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_SET
#define DSC_DFE_2_CTLr_DFE_2_INV_M1f_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_GET
#define DSC_DFE_2_CTLr_DFE_2_INV_M1f_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_SET
#define DSC_DFE_2_CTLr_DFE_2_INV_P1f_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_GET
#define DSC_DFE_2_CTLr_DFE_2_INV_P1f_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_SET
#define DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_GET
#define DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_SET
#define DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_GET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_GET
#define DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_SET BCMI_QTC_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_SET
#define READ_DSC_DFE_2_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_2_CTLr
#define WRITE_DSC_DFE_2_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_2_CTLr
#define MODIFY_DSC_DFE_2_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_2_CTLr
#define READLN_DSC_DFE_2_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_2_CTLr
#define WRITELN_DSC_DFE_2_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_2_CTLr
#define WRITEALL_DSC_DFE_2_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_2_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_2_PAT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd024
 * DEVAD:    1
 * DESC:     DFE 2 Pat Control
 * SIZE:     32
 * FIELDS:
 *     DFE_2_PATTERN    pattern
 *     DFE_2_PATTERN_BIT_EN pattern bit mask
 */
#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr (0x0001d024 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_2_PAT_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_2_pat_ctl[1];
	uint32_t _dsc_dfe_2_pat_ctl;
} BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_CLR(r) (r).dsc_dfe_2_pat_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_SET(r,d) (r).dsc_dfe_2_pat_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_GET(r) (r).dsc_dfe_2_pat_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERN_BIT_ENf_GET(r) ((((r).dsc_dfe_2_pat_ctl[0]) >> 8) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERN_BIT_ENf_SET(r,f) (r).dsc_dfe_2_pat_ctl[0]=(((r).dsc_dfe_2_pat_ctl[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERNf_GET(r) (((r).dsc_dfe_2_pat_ctl[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERNf_SET(r,f) (r).dsc_dfe_2_pat_ctl[0]=(((r).dsc_dfe_2_pat_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_DFE_2_PAT_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_2_PAT_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr,(_r._dsc_dfe_2_pat_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_2_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr,(_r._dsc_dfe_2_pat_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_2_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr,(_r._dsc_dfe_2_pat_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_2_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_pat_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_2_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_pat_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_2_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_2_pat_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_2_PAT_CTLr BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr
#define DSC_DFE_2_PAT_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_t DSC_DFE_2_PAT_CTLr_t;
#define DSC_DFE_2_PAT_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_CLR
#define DSC_DFE_2_PAT_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_SET
#define DSC_DFE_2_PAT_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_GET
#define DSC_DFE_2_PAT_CTLr_DFE_2_PATTERN_BIT_ENf_GET BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERN_BIT_ENf_GET
#define DSC_DFE_2_PAT_CTLr_DFE_2_PATTERN_BIT_ENf_SET BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERN_BIT_ENf_SET
#define DSC_DFE_2_PAT_CTLr_DFE_2_PATTERNf_GET BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERNf_GET
#define DSC_DFE_2_PAT_CTLr_DFE_2_PATTERNf_SET BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr_DFE_2_PATTERNf_SET
#define READ_DSC_DFE_2_PAT_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_2_PAT_CTLr
#define WRITE_DSC_DFE_2_PAT_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_2_PAT_CTLr
#define MODIFY_DSC_DFE_2_PAT_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_2_PAT_CTLr
#define READLN_DSC_DFE_2_PAT_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_2_PAT_CTLr
#define WRITELN_DSC_DFE_2_PAT_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_2_PAT_CTLr
#define WRITEALL_DSC_DFE_2_PAT_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_2_PAT_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_2_PAT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_3_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd025
 * DEVAD:    1
 * DESC:     DFE 3 Control
 * SIZE:     32
 * FIELDS:
 *     DFE_3_ACC_CLR    clears the dfe_3_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_3_INV_P1     invert p1
 *     DFE_3_INV_M1     invert m1
 *     DFE_3_ERR_GAIN   error scaled by 2^dfe_3_err_gain
 *     DFE_3_GRADIENT_INVERT invert the gradient
 *     DFE_3_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_3_EN         Enables the tap for adaptive eq
 */
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr (0x0001d025 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_3_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_3_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_3_ctl[1];
	uint32_t _dsc_dfe_3_ctl;
} BCMI_QTC_XGXS_DSC_DFE_3_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_CLR(r) (r).dsc_dfe_3_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_SET(r,d) (r).dsc_dfe_3_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_GET(r) (r).dsc_dfe_3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 13) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_GET(r) (((r).dsc_dfe_3_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_DFE_3_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_3_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_3_CTLr,(_r._dsc_dfe_3_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_3_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_CTLr,(_r._dsc_dfe_3_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_3_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_CTLr,(_r._dsc_dfe_3_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_3_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_3_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_3_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_3_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_3_CTLr BCMI_QTC_XGXS_DSC_DFE_3_CTLr
#define DSC_DFE_3_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_3_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_3_CTLr_t DSC_DFE_3_CTLr_t;
#define DSC_DFE_3_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_3_CTLr_CLR
#define DSC_DFE_3_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_SET
#define DSC_DFE_3_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_GET
#define DSC_DFE_3_CTLr_DFE_3_ENf_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_GET
#define DSC_DFE_3_CTLr_DFE_3_ENf_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_SET
#define DSC_DFE_3_CTLr_DFE_3_ERR_SELf_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_GET
#define DSC_DFE_3_CTLr_DFE_3_ERR_SELf_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_SET
#define DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_GET
#define DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_SET
#define DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_GET
#define DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_SET
#define DSC_DFE_3_CTLr_DFE_3_INV_M1f_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_GET
#define DSC_DFE_3_CTLr_DFE_3_INV_M1f_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_SET
#define DSC_DFE_3_CTLr_DFE_3_INV_P1f_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_GET
#define DSC_DFE_3_CTLr_DFE_3_INV_P1f_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_SET
#define DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_GET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_GET
#define DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_SET BCMI_QTC_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_SET
#define READ_DSC_DFE_3_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_3_CTLr
#define WRITE_DSC_DFE_3_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_3_CTLr
#define MODIFY_DSC_DFE_3_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_3_CTLr
#define READLN_DSC_DFE_3_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_3_CTLr
#define WRITELN_DSC_DFE_3_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_3_CTLr
#define WRITEALL_DSC_DFE_3_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_3_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_3_PAT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd026
 * DEVAD:    1
 * DESC:     DFE 3 Pat Control
 * SIZE:     32
 * FIELDS:
 *     DFE_3_PATTERN    pattern
 *     DFE_3_PATTERN_BIT_EN pattern bit mask
 */
#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr (0x0001d026 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_3_PAT_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_3_pat_ctl[1];
	uint32_t _dsc_dfe_3_pat_ctl;
} BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_CLR(r) (r).dsc_dfe_3_pat_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_SET(r,d) (r).dsc_dfe_3_pat_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_GET(r) (r).dsc_dfe_3_pat_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERN_BIT_ENf_GET(r) ((((r).dsc_dfe_3_pat_ctl[0]) >> 8) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERN_BIT_ENf_SET(r,f) (r).dsc_dfe_3_pat_ctl[0]=(((r).dsc_dfe_3_pat_ctl[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERNf_GET(r) (((r).dsc_dfe_3_pat_ctl[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERNf_SET(r,f) (r).dsc_dfe_3_pat_ctl[0]=(((r).dsc_dfe_3_pat_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_DFE_3_PAT_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_3_PAT_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr,(_r._dsc_dfe_3_pat_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_3_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr,(_r._dsc_dfe_3_pat_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_3_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr,(_r._dsc_dfe_3_pat_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_3_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_pat_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_3_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_pat_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_3_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_3_pat_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_3_PAT_CTLr BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr
#define DSC_DFE_3_PAT_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_t DSC_DFE_3_PAT_CTLr_t;
#define DSC_DFE_3_PAT_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_CLR
#define DSC_DFE_3_PAT_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_SET
#define DSC_DFE_3_PAT_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_GET
#define DSC_DFE_3_PAT_CTLr_DFE_3_PATTERN_BIT_ENf_GET BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERN_BIT_ENf_GET
#define DSC_DFE_3_PAT_CTLr_DFE_3_PATTERN_BIT_ENf_SET BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERN_BIT_ENf_SET
#define DSC_DFE_3_PAT_CTLr_DFE_3_PATTERNf_GET BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERNf_GET
#define DSC_DFE_3_PAT_CTLr_DFE_3_PATTERNf_SET BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr_DFE_3_PATTERNf_SET
#define READ_DSC_DFE_3_PAT_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_3_PAT_CTLr
#define WRITE_DSC_DFE_3_PAT_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_3_PAT_CTLr
#define MODIFY_DSC_DFE_3_PAT_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_3_PAT_CTLr
#define READLN_DSC_DFE_3_PAT_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_3_PAT_CTLr
#define WRITELN_DSC_DFE_3_PAT_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_3_PAT_CTLr
#define WRITEALL_DSC_DFE_3_PAT_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_3_PAT_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_3_PAT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_4_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd027
 * DEVAD:    1
 * DESC:     DFE 4 Control
 * SIZE:     32
 * FIELDS:
 *     DFE_4_ACC_CLR    clears the dfe_4_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_4_INV_P1     invert p1
 *     DFE_4_INV_M1     invert m1
 *     DFE_4_ERR_GAIN   error scaled by 2^dfe_4_err_gain
 *     DFE_4_GRADIENT_INVERT invert the gradient
 *     DFE_4_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_4_EN         Enables the tap for adaptive eq
 */
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr (0x0001d027 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_4_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_4_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_4_ctl[1];
	uint32_t _dsc_dfe_4_ctl;
} BCMI_QTC_XGXS_DSC_DFE_4_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_CLR(r) (r).dsc_dfe_4_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_SET(r,d) (r).dsc_dfe_4_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_GET(r) (r).dsc_dfe_4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 13) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_GET(r) (((r).dsc_dfe_4_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_DFE_4_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_4_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_4_CTLr,(_r._dsc_dfe_4_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_CTLr,(_r._dsc_dfe_4_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_CTLr,(_r._dsc_dfe_4_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_4_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_4_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_4_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_4_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_4_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_4_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_4_CTLr BCMI_QTC_XGXS_DSC_DFE_4_CTLr
#define DSC_DFE_4_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_4_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_4_CTLr_t DSC_DFE_4_CTLr_t;
#define DSC_DFE_4_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_4_CTLr_CLR
#define DSC_DFE_4_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_SET
#define DSC_DFE_4_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_GET
#define DSC_DFE_4_CTLr_DFE_4_ENf_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_GET
#define DSC_DFE_4_CTLr_DFE_4_ENf_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_SET
#define DSC_DFE_4_CTLr_DFE_4_ERR_SELf_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_GET
#define DSC_DFE_4_CTLr_DFE_4_ERR_SELf_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_SET
#define DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_GET
#define DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_SET
#define DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_GET
#define DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_SET
#define DSC_DFE_4_CTLr_DFE_4_INV_M1f_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_GET
#define DSC_DFE_4_CTLr_DFE_4_INV_M1f_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_SET
#define DSC_DFE_4_CTLr_DFE_4_INV_P1f_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_GET
#define DSC_DFE_4_CTLr_DFE_4_INV_P1f_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_SET
#define DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_GET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_GET
#define DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_SET BCMI_QTC_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_SET
#define READ_DSC_DFE_4_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_4_CTLr
#define WRITE_DSC_DFE_4_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_4_CTLr
#define MODIFY_DSC_DFE_4_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_4_CTLr
#define READLN_DSC_DFE_4_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_4_CTLr
#define WRITELN_DSC_DFE_4_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_4_CTLr
#define WRITEALL_DSC_DFE_4_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_4_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_4_PAT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd028
 * DEVAD:    1
 * DESC:     DFE 4 Pat Control
 * SIZE:     32
 * FIELDS:
 *     DFE_4_PATTERN    pattern
 *     DFE_4_PATTERN_BIT_EN pattern bit mask
 */
#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr (0x0001d028 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_4_PAT_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_4_pat_ctl[1];
	uint32_t _dsc_dfe_4_pat_ctl;
} BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_CLR(r) (r).dsc_dfe_4_pat_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_SET(r,d) (r).dsc_dfe_4_pat_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_GET(r) (r).dsc_dfe_4_pat_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERN_BIT_ENf_GET(r) ((((r).dsc_dfe_4_pat_ctl[0]) >> 8) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERN_BIT_ENf_SET(r,f) (r).dsc_dfe_4_pat_ctl[0]=(((r).dsc_dfe_4_pat_ctl[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERNf_GET(r) (((r).dsc_dfe_4_pat_ctl[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERNf_SET(r,f) (r).dsc_dfe_4_pat_ctl[0]=(((r).dsc_dfe_4_pat_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_DFE_4_PAT_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_4_PAT_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr,(_r._dsc_dfe_4_pat_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_4_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr,(_r._dsc_dfe_4_pat_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_4_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr,(_r._dsc_dfe_4_pat_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_4_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_4_pat_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_4_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_4_pat_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_4_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_4_pat_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_4_PAT_CTLr BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr
#define DSC_DFE_4_PAT_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_t DSC_DFE_4_PAT_CTLr_t;
#define DSC_DFE_4_PAT_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_CLR
#define DSC_DFE_4_PAT_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_SET
#define DSC_DFE_4_PAT_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_GET
#define DSC_DFE_4_PAT_CTLr_DFE_4_PATTERN_BIT_ENf_GET BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERN_BIT_ENf_GET
#define DSC_DFE_4_PAT_CTLr_DFE_4_PATTERN_BIT_ENf_SET BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERN_BIT_ENf_SET
#define DSC_DFE_4_PAT_CTLr_DFE_4_PATTERNf_GET BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERNf_GET
#define DSC_DFE_4_PAT_CTLr_DFE_4_PATTERNf_SET BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr_DFE_4_PATTERNf_SET
#define READ_DSC_DFE_4_PAT_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_4_PAT_CTLr
#define WRITE_DSC_DFE_4_PAT_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_4_PAT_CTLr
#define MODIFY_DSC_DFE_4_PAT_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_4_PAT_CTLr
#define READLN_DSC_DFE_4_PAT_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_4_PAT_CTLr
#define WRITELN_DSC_DFE_4_PAT_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_4_PAT_CTLr
#define WRITEALL_DSC_DFE_4_PAT_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_4_PAT_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_4_PAT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_5_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd029
 * DEVAD:    1
 * DESC:     DFE 5 Control
 * SIZE:     32
 * FIELDS:
 *     DFE_5_ACC_CLR    clears the dfe_5_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_5_INV_P1     invert p1
 *     DFE_5_INV_M1     invert m1
 *     DFE_5_ERR_GAIN   error scaled by 2^dfe_5_err_gain
 *     DFE_5_GRADIENT_INVERT invert the gradient
 *     DFE_5_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_5_EN         Enables the tap for adaptive eq
 */
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr (0x0001d029 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_5_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_5_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_5_ctl[1];
	uint32_t _dsc_dfe_5_ctl;
} BCMI_QTC_XGXS_DSC_DFE_5_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_CLR(r) (r).dsc_dfe_5_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_SET(r,d) (r).dsc_dfe_5_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_GET(r) (r).dsc_dfe_5_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 13) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_GET(r) (((r).dsc_dfe_5_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_DFE_5_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_5_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_5_CTLr,(_r._dsc_dfe_5_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_5_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_CTLr,(_r._dsc_dfe_5_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_5_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_CTLr,(_r._dsc_dfe_5_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_5_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_5_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_5_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_5_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_5_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_5_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_5_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_5_CTLr BCMI_QTC_XGXS_DSC_DFE_5_CTLr
#define DSC_DFE_5_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_5_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_5_CTLr_t DSC_DFE_5_CTLr_t;
#define DSC_DFE_5_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_5_CTLr_CLR
#define DSC_DFE_5_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_SET
#define DSC_DFE_5_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_GET
#define DSC_DFE_5_CTLr_DFE_5_ENf_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_GET
#define DSC_DFE_5_CTLr_DFE_5_ENf_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_SET
#define DSC_DFE_5_CTLr_DFE_5_ERR_SELf_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_GET
#define DSC_DFE_5_CTLr_DFE_5_ERR_SELf_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_SET
#define DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_GET
#define DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_SET
#define DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_GET
#define DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_SET
#define DSC_DFE_5_CTLr_DFE_5_INV_M1f_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_GET
#define DSC_DFE_5_CTLr_DFE_5_INV_M1f_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_SET
#define DSC_DFE_5_CTLr_DFE_5_INV_P1f_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_GET
#define DSC_DFE_5_CTLr_DFE_5_INV_P1f_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_SET
#define DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_GET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_GET
#define DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_SET BCMI_QTC_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_SET
#define READ_DSC_DFE_5_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_5_CTLr
#define WRITE_DSC_DFE_5_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_5_CTLr
#define MODIFY_DSC_DFE_5_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_5_CTLr
#define READLN_DSC_DFE_5_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_5_CTLr
#define WRITELN_DSC_DFE_5_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_5_CTLr
#define WRITEALL_DSC_DFE_5_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_5_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_5_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_5_PAT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02a
 * DEVAD:    1
 * DESC:     DFE 5 Pat Control
 * SIZE:     32
 * FIELDS:
 *     DFE_5_PATTERN    pattern
 *     DFE_5_PATTERN_BIT_EN pattern bit mask
 */
#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr (0x0001d02a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_5_PAT_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_5_pat_ctl[1];
	uint32_t _dsc_dfe_5_pat_ctl;
} BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_t;

#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_CLR(r) (r).dsc_dfe_5_pat_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_SET(r,d) (r).dsc_dfe_5_pat_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_GET(r) (r).dsc_dfe_5_pat_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERN_BIT_ENf_GET(r) ((((r).dsc_dfe_5_pat_ctl[0]) >> 8) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERN_BIT_ENf_SET(r,f) (r).dsc_dfe_5_pat_ctl[0]=(((r).dsc_dfe_5_pat_ctl[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERNf_GET(r) (((r).dsc_dfe_5_pat_ctl[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERNf_SET(r,f) (r).dsc_dfe_5_pat_ctl[0]=(((r).dsc_dfe_5_pat_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_DFE_5_PAT_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_5_PAT_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr,(_r._dsc_dfe_5_pat_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_5_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr,(_r._dsc_dfe_5_pat_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_5_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr,(_r._dsc_dfe_5_pat_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_5_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_5_pat_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_5_PAT_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_5_pat_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_5_PAT_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_5_pat_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_5_PAT_CTLr BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr
#define DSC_DFE_5_PAT_CTLr_SIZE BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_t DSC_DFE_5_PAT_CTLr_t;
#define DSC_DFE_5_PAT_CTLr_CLR BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_CLR
#define DSC_DFE_5_PAT_CTLr_SET BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_SET
#define DSC_DFE_5_PAT_CTLr_GET BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_GET
#define DSC_DFE_5_PAT_CTLr_DFE_5_PATTERN_BIT_ENf_GET BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERN_BIT_ENf_GET
#define DSC_DFE_5_PAT_CTLr_DFE_5_PATTERN_BIT_ENf_SET BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERN_BIT_ENf_SET
#define DSC_DFE_5_PAT_CTLr_DFE_5_PATTERNf_GET BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERNf_GET
#define DSC_DFE_5_PAT_CTLr_DFE_5_PATTERNf_SET BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr_DFE_5_PATTERNf_SET
#define READ_DSC_DFE_5_PAT_CTLr BCMI_QTC_XGXS_READ_DSC_DFE_5_PAT_CTLr
#define WRITE_DSC_DFE_5_PAT_CTLr BCMI_QTC_XGXS_WRITE_DSC_DFE_5_PAT_CTLr
#define MODIFY_DSC_DFE_5_PAT_CTLr BCMI_QTC_XGXS_MODIFY_DSC_DFE_5_PAT_CTLr
#define READLN_DSC_DFE_5_PAT_CTLr BCMI_QTC_XGXS_READLN_DSC_DFE_5_PAT_CTLr
#define WRITELN_DSC_DFE_5_PAT_CTLr BCMI_QTC_XGXS_WRITELN_DSC_DFE_5_PAT_CTLr
#define WRITEALL_DSC_DFE_5_PAT_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_5_PAT_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_5_PAT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_VGA_OVRR
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02b
 * DEVAD:    1
 * DESC:     DFE Overrude
 * SIZE:     32
 * FIELDS:
 *     DFE_VGA_WRITE_VAL override value (lower applicable bits used)vga: When  dfe_vga_write_tapsel is selected for vga (0), dfe_vga_write_val[8:3] are use for the analog port. These should be within 0-45 for valid operationp1_eyediag: When dfe_vga_write_tapsel is selected for eyediag, dfe_vga_write_val[8:3] are used to drive the analog control port.
 *     DFE_VGA_WRITE_TAPSEL 'h0 = common vga - 8bit write; upper 6 bits get translated to codes on vga_ctrl and vga3_ctrl"'h{1,2,3} = {tap 1 cmn, odd, evn}; {4,5,6,a,b} = {tap 2 cmn, odd, evn, sign even, sign odd}'h{7,8,9} = dfe tap 3 ,4, 5'hd = p1_eyediag'he = vga_ctrl direct write. vga_tablemap_disable should be set'h10 = vga3_ctrl direct write. vga_tablemap_disable should be set
 *     DFE_VGA_WRITE_EN a 1 on this enables the firmware to write the tap valuesFirst set valid values on dfe_vga_write_tapsel and dfe_vga_write_val and then set this self clear bit to 1Self Clearing
 */
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr (0x0001d02b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_VGA_OVRR.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_vga_ovrr[1];
	uint32_t _dsc_dfe_vga_ovrr;
} BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_t;

#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_CLR(r) (r).dsc_dfe_vga_ovrr[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_SET(r,d) (r).dsc_dfe_vga_ovrr[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_GET(r) (r).dsc_dfe_vga_ovrr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_ENf_GET(r) ((((r).dsc_dfe_vga_ovrr[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_ENf_SET(r,f) (r).dsc_dfe_vga_ovrr[0]=(((r).dsc_dfe_vga_ovrr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_TAPSELf_GET(r) ((((r).dsc_dfe_vga_ovrr[0]) >> 9) & 0x1f)
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_TAPSELf_SET(r,f) (r).dsc_dfe_vga_ovrr[0]=(((r).dsc_dfe_vga_ovrr[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_VALf_GET(r) (((r).dsc_dfe_vga_ovrr[0]) & 0x1ff)
#define BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_VALf_SET(r,f) (r).dsc_dfe_vga_ovrr[0]=(((r).dsc_dfe_vga_ovrr[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (511 << 16)

/*
 * These macros can be used to access DSC_DFE_VGA_OVRR.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_VGA_OVRRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr,(_r._dsc_dfe_vga_ovrr))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_VGA_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr,(_r._dsc_dfe_vga_ovrr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_VGA_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr,(_r._dsc_dfe_vga_ovrr))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_VGA_OVRRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_vga_ovrr))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_VGA_OVRRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_vga_ovrr))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_VGA_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_vga_ovrr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_VGA_OVRRr BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr
#define DSC_DFE_VGA_OVRRr_SIZE BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_t DSC_DFE_VGA_OVRRr_t;
#define DSC_DFE_VGA_OVRRr_CLR BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_CLR
#define DSC_DFE_VGA_OVRRr_SET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_SET
#define DSC_DFE_VGA_OVRRr_GET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_GET
#define DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_ENf_GET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_ENf_GET
#define DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_ENf_SET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_ENf_SET
#define DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_TAPSELf_GET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_TAPSELf_GET
#define DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_TAPSELf_SET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_TAPSELf_SET
#define DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_VALf_GET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_VALf_GET
#define DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_VALf_SET BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr_DFE_VGA_WRITE_VALf_SET
#define READ_DSC_DFE_VGA_OVRRr BCMI_QTC_XGXS_READ_DSC_DFE_VGA_OVRRr
#define WRITE_DSC_DFE_VGA_OVRRr BCMI_QTC_XGXS_WRITE_DSC_DFE_VGA_OVRRr
#define MODIFY_DSC_DFE_VGA_OVRRr BCMI_QTC_XGXS_MODIFY_DSC_DFE_VGA_OVRRr
#define READLN_DSC_DFE_VGA_OVRRr BCMI_QTC_XGXS_READLN_DSC_DFE_VGA_OVRRr
#define WRITELN_DSC_DFE_VGA_OVRRr BCMI_QTC_XGXS_WRITELN_DSC_DFE_VGA_OVRRr
#define WRITEALL_DSC_DFE_VGA_OVRRr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_VGA_OVRRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_VGA_OVRRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_VGA_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02c
 * DEVAD:    1
 * DESC:     VGA Control
 * SIZE:     32
 * FIELDS:
 *     VGA_P1_ACC_CLR   clears the vga and p1 related accumulators and intermediate stagesbut not the final tap values which interface to the analog.
 *     VGA_ACC_HYS_EN   enables hysteresis on vga accumulators
 *     VGA_TABLEMAP_DISABLE disables the vga_sum from being translated to vga_ctrl and vga3_ctrlThis should be set to 1 when vga_ctrl and vga3_ctrl are written using register access.
 *     VGA_UPDATE_GAIN  vga update gain *1,2,4,8
 *     VGA_INV_P1       invert p1
 *     VGA_INV_M1       invert m1
 *     VGA_ERR_GAIN     error scaled by 2^vga_err_gain
 *     VGA_P1_GRADIENT_INVERT invert the gradient of the inc/dec going into the vga accumulators
 *     VGA_ERR_SEL      00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     VGA_EN           Enables the tap for adaptive eq
 */
#define BCMI_QTC_XGXS_DSC_VGA_CTLr (0x0001d02c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_VGA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_VGA_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_vga_ctl[1];
	uint32_t _dsc_vga_ctl;
} BCMI_QTC_XGXS_DSC_VGA_CTLr_t;

#define BCMI_QTC_XGXS_DSC_VGA_CTLr_CLR(r) (r).dsc_vga_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_SET(r,d) (r).dsc_vga_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_GET(r) (r).dsc_vga_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ENf_GET(r) ((((r).dsc_vga_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ENf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_GET(r) ((((r).dsc_vga_ctl[0]) >> 13) & 0x3)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_GET(r) ((((r).dsc_vga_ctl[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_GET(r) ((((r).dsc_vga_ctl[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_GET(r) ((((r).dsc_vga_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_GET(r) ((((r).dsc_vga_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_GET(r) ((((r).dsc_vga_ctl[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_TABLEMAP_DISABLEf_GET(r) ((((r).dsc_vga_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_TABLEMAP_DISABLEf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_GET(r) ((((r).dsc_vga_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_GET(r) (((r).dsc_vga_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_VGA_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_VGA_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_CTLr,(_r._dsc_vga_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_VGA_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_CTLr,(_r._dsc_vga_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_VGA_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_CTLr,(_r._dsc_vga_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_VGA_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_VGA_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_VGA_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_CTLr BCMI_QTC_XGXS_DSC_VGA_CTLr
#define DSC_VGA_CTLr_SIZE BCMI_QTC_XGXS_DSC_VGA_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_VGA_CTLr_t DSC_VGA_CTLr_t;
#define DSC_VGA_CTLr_CLR BCMI_QTC_XGXS_DSC_VGA_CTLr_CLR
#define DSC_VGA_CTLr_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_SET
#define DSC_VGA_CTLr_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_GET
#define DSC_VGA_CTLr_VGA_ENf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ENf_GET
#define DSC_VGA_CTLr_VGA_ENf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ENf_SET
#define DSC_VGA_CTLr_VGA_ERR_SELf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_GET
#define DSC_VGA_CTLr_VGA_ERR_SELf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_SET
#define DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_GET
#define DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_SET
#define DSC_VGA_CTLr_VGA_ERR_GAINf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_GET
#define DSC_VGA_CTLr_VGA_ERR_GAINf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_SET
#define DSC_VGA_CTLr_VGA_INV_M1f_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_GET
#define DSC_VGA_CTLr_VGA_INV_M1f_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_SET
#define DSC_VGA_CTLr_VGA_INV_P1f_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_GET
#define DSC_VGA_CTLr_VGA_INV_P1f_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_SET
#define DSC_VGA_CTLr_VGA_UPDATE_GAINf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_GET
#define DSC_VGA_CTLr_VGA_UPDATE_GAINf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_SET
#define DSC_VGA_CTLr_VGA_TABLEMAP_DISABLEf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_TABLEMAP_DISABLEf_GET
#define DSC_VGA_CTLr_VGA_TABLEMAP_DISABLEf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_TABLEMAP_DISABLEf_SET
#define DSC_VGA_CTLr_VGA_ACC_HYS_ENf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_GET
#define DSC_VGA_CTLr_VGA_ACC_HYS_ENf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_SET
#define DSC_VGA_CTLr_VGA_P1_ACC_CLRf_GET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_GET
#define DSC_VGA_CTLr_VGA_P1_ACC_CLRf_SET BCMI_QTC_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_SET
#define READ_DSC_VGA_CTLr BCMI_QTC_XGXS_READ_DSC_VGA_CTLr
#define WRITE_DSC_VGA_CTLr BCMI_QTC_XGXS_WRITE_DSC_VGA_CTLr
#define MODIFY_DSC_VGA_CTLr BCMI_QTC_XGXS_MODIFY_DSC_VGA_CTLr
#define READLN_DSC_VGA_CTLr BCMI_QTC_XGXS_READLN_DSC_VGA_CTLr
#define WRITELN_DSC_VGA_CTLr BCMI_QTC_XGXS_WRITELN_DSC_VGA_CTLr
#define WRITEALL_DSC_VGA_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_VGA_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_VGA_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_VGA_PAT_EYEDIAG_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02d
 * DEVAD:    1
 * DESC:     VGA Pat and P1 Eye Diag Control
 * SIZE:     32
 * FIELDS:
 *     VGA_PATTERN      pattern
 *     VGA_PATTERN_BIT_EN pattern bit mask
 *     P1_EYEDIAG_EN    enable p1 eye diag
 */
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr (0x0001d02d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_PAT_EYEDIAG_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_vga_pat_eyediag_ctl[1];
	uint32_t _dsc_vga_pat_eyediag_ctl;
} BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_t;

#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_CLR(r) (r).dsc_vga_pat_eyediag_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SET(r,d) (r).dsc_vga_pat_eyediag_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_GET(r) (r).dsc_vga_pat_eyediag_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_GET(r) ((((r).dsc_vga_pat_eyediag_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_SET(r,f) (r).dsc_vga_pat_eyediag_ctl[0]=(((r).dsc_vga_pat_eyediag_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_GET(r) ((((r).dsc_vga_pat_eyediag_ctl[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_SET(r,f) (r).dsc_vga_pat_eyediag_ctl[0]=(((r).dsc_vga_pat_eyediag_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_GET(r) (((r).dsc_vga_pat_eyediag_ctl[0]) & 0xf)
#define BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_SET(r,f) (r).dsc_vga_pat_eyediag_ctl[0]=(((r).dsc_vga_pat_eyediag_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access DSC_VGA_PAT_EYEDIAG_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr,(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr,(_r._dsc_vga_pat_eyediag_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr,(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_pat_eyediag_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_PAT_EYEDIAG_CTLr BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr
#define DSC_VGA_PAT_EYEDIAG_CTLr_SIZE BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_t DSC_VGA_PAT_EYEDIAG_CTLr_t;
#define DSC_VGA_PAT_EYEDIAG_CTLr_CLR BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_CLR
#define DSC_VGA_PAT_EYEDIAG_CTLr_SET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SET
#define DSC_VGA_PAT_EYEDIAG_CTLr_GET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_GET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_SET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_SET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_GET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_SET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_SET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_GET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_SET BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_SET
#define READ_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_QTC_XGXS_READ_DSC_VGA_PAT_EYEDIAG_CTLr
#define WRITE_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_QTC_XGXS_WRITE_DSC_VGA_PAT_EYEDIAG_CTLr
#define MODIFY_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_QTC_XGXS_MODIFY_DSC_VGA_PAT_EYEDIAG_CTLr
#define READLN_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_QTC_XGXS_READLN_DSC_VGA_PAT_EYEDIAG_CTLr
#define WRITELN_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_QTC_XGXS_WRITELN_DSC_VGA_PAT_EYEDIAG_CTLr
#define WRITEALL_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_VGA_PAT_EYEDIAG_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_P1_FRAC_OFFS_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02e
 * DEVAD:    1
 * DESC:     P1 Fractional Offset Control
 * SIZE:     32
 * FIELDS:
 *     P1_OFFSET        range is from -64 to +63. It is mapped to -64/64 to 63/64 error which gets added into the accumulator path. This adds into the +20 to -20 range error signal.
 *     P1_OFFSET_EN     Enables the Delta Sigma Fractional Offset hardware
 *     P1_OFF_3LEVELQ_EN This enables the 3 level quantizer when set +1/-1/0. Else the quantizer is 2 level +1/-1
 */
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr (0x0001d02e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_P1_FRAC_OFFS_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_p1_frac_offs_ctl[1];
	uint32_t _dsc_p1_frac_offs_ctl;
} BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_t;

#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_CLR(r) (r).dsc_p1_frac_offs_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_SET(r,d) (r).dsc_p1_frac_offs_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_GET(r) (r).dsc_p1_frac_offs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_GET(r) ((((r).dsc_p1_frac_offs_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_SET(r,f) (r).dsc_p1_frac_offs_ctl[0]=(((r).dsc_p1_frac_offs_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_GET(r) ((((r).dsc_p1_frac_offs_ctl[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_SET(r,f) (r).dsc_p1_frac_offs_ctl[0]=(((r).dsc_p1_frac_offs_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_GET(r) (((r).dsc_p1_frac_offs_ctl[0]) & 0x7f)
#define BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_SET(r,f) (r).dsc_p1_frac_offs_ctl[0]=(((r).dsc_p1_frac_offs_ctl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access DSC_P1_FRAC_OFFS_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr,(_r._dsc_p1_frac_offs_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr,(_r._dsc_p1_frac_offs_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr,(_r._dsc_p1_frac_offs_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_P1_FRAC_OFFS_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_p1_frac_offs_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_P1_FRAC_OFFS_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_p1_frac_offs_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_p1_frac_offs_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_P1_FRAC_OFFS_CTLr BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr
#define DSC_P1_FRAC_OFFS_CTLr_SIZE BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_t DSC_P1_FRAC_OFFS_CTLr_t;
#define DSC_P1_FRAC_OFFS_CTLr_CLR BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_CLR
#define DSC_P1_FRAC_OFFS_CTLr_SET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_SET
#define DSC_P1_FRAC_OFFS_CTLr_GET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_GET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_SET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_SET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_GET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_SET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_SET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_GET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_SET BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_SET
#define READ_DSC_P1_FRAC_OFFS_CTLr BCMI_QTC_XGXS_READ_DSC_P1_FRAC_OFFS_CTLr
#define WRITE_DSC_P1_FRAC_OFFS_CTLr BCMI_QTC_XGXS_WRITE_DSC_P1_FRAC_OFFS_CTLr
#define MODIFY_DSC_P1_FRAC_OFFS_CTLr BCMI_QTC_XGXS_MODIFY_DSC_P1_FRAC_OFFS_CTLr
#define READLN_DSC_P1_FRAC_OFFS_CTLr BCMI_QTC_XGXS_READLN_DSC_P1_FRAC_OFFS_CTLr
#define WRITELN_DSC_P1_FRAC_OFFS_CTLr BCMI_QTC_XGXS_WRITELN_DSC_P1_FRAC_OFFS_CTLr
#define WRITEALL_DSC_P1_FRAC_OFFS_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_P1_FRAC_OFFS_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_P1_FRAC_OFFS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_CTL1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd030
 * DEVAD:    1
 * DESC:     Trnsum Ctl 1
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_TAP_RANGE_SEL 0: -2 to 5; 1: 6 to 13; 2: 14 to 21; 3: all 1s are selected as data
 *     CDR_QPHASE_MULT_EN enables qphase weighting
 *     TRNSUM_EYE_CLOSURE_EN when 1'b1, condition is anded with data!=emux
 *     TRNSUM_GAIN      training sum error values get *1,2,4,8 or 2^{trnsum_gain}
 *     TRNSUM_PATTERN_FULL_CHECK_OFF training only enabled for bits 2 and 13
 *     TRNSUM_INV_PATTERN_EN when 1'b1, the pattern is randomly inverted for pattern match
 *     TRNSUM_RANDOM_TAPSEL_DISABLE disables random tap selection
 *     TRNSUM_ERR_SEL   0: emux = d?p1:m1, 1: 1'b1, 2:m1, 3:p1, 4: d1=d?p1:~m1
 *     TRNSUM_EN        enable training sum
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r (0x0001d030 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL1.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl1[1];
	uint32_t _dsc_trnsum_ctl1;
} BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_CLR(r) (r).dsc_trnsum_ctl1[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_SET(r,d) (r).dsc_trnsum_ctl1[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_GET(r) (r).dsc_trnsum_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 12) & 0x7)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 2) & 0x3)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))

/*
 * These macros can be used to access DSC_TRNSUM_CTL1.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r,(_r._dsc_trnsum_ctl1))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r,(_r._dsc_trnsum_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r,(_r._dsc_trnsum_ctl1))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl1))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL1r BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r
#define DSC_TRNSUM_CTL1r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_t DSC_TRNSUM_CTL1r_t;
#define DSC_TRNSUM_CTL1r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_CLR
#define DSC_TRNSUM_CTL1r_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_SET
#define DSC_TRNSUM_CTL1r_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_ENf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_ENf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_GAINf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_GAINf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_SET
#define DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_GET
#define DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_SET
#define READ_DSC_TRNSUM_CTL1r BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL1r
#define WRITE_DSC_TRNSUM_CTL1r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL1r
#define MODIFY_DSC_TRNSUM_CTL1r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL1r
#define READLN_DSC_TRNSUM_CTL1r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL1r
#define WRITELN_DSC_TRNSUM_CTL1r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL1r
#define WRITEALL_DSC_TRNSUM_CTL1r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_CTL2
 * BLOCKS:   DSC_D
 * REGADDR:  0xd031
 * DEVAD:    1
 * DESC:     Trnsum Ctl 2
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_PATTERN_BIT_EN trnsum pattern mask
 *     TRNSUM_PATTERN   trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r (0x0001d031 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL2.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl2[1];
	uint32_t _dsc_trnsum_ctl2;
} BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_CLR(r) (r).dsc_trnsum_ctl2[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_SET(r,d) (r).dsc_trnsum_ctl2[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_GET(r) (r).dsc_trnsum_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET(r) (((r).dsc_trnsum_ctl2[0]) & 0xff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL2.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl2))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL2r BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r
#define DSC_TRNSUM_CTL2r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_t DSC_TRNSUM_CTL2r_t;
#define DSC_TRNSUM_CTL2r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_CLR
#define DSC_TRNSUM_CTL2r_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_SET
#define DSC_TRNSUM_CTL2r_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET
#define READ_DSC_TRNSUM_CTL2r BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL2r
#define WRITE_DSC_TRNSUM_CTL2r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL2r
#define MODIFY_DSC_TRNSUM_CTL2r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL2r
#define READLN_DSC_TRNSUM_CTL2r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL2r
#define WRITELN_DSC_TRNSUM_CTL2r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL2r
#define WRITEALL_DSC_TRNSUM_CTL2r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_CTL3
 * BLOCKS:   DSC_D
 * REGADDR:  0xd032
 * DEVAD:    1
 * DESC:     Trnsum Ctl 3
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_TAP_SIGN  trnsum tap sign
 *     TRNSUM_TAP_EN    trnsum tap enable
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r (0x0001d032 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL3.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl3[1];
	uint32_t _dsc_trnsum_ctl3;
} BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_CLR(r) (r).dsc_trnsum_ctl3[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_SET(r,d) (r).dsc_trnsum_ctl3[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_GET(r) (r).dsc_trnsum_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_GET(r) ((((r).dsc_trnsum_ctl3[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_SET(r,f) (r).dsc_trnsum_ctl3[0]=(((r).dsc_trnsum_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_GET(r) (((r).dsc_trnsum_ctl3[0]) & 0xff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_SET(r,f) (r).dsc_trnsum_ctl3[0]=(((r).dsc_trnsum_ctl3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL3.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r,(_r._dsc_trnsum_ctl3))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r,(_r._dsc_trnsum_ctl3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r,(_r._dsc_trnsum_ctl3))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl3))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl3))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL3r BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r
#define DSC_TRNSUM_CTL3r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_t DSC_TRNSUM_CTL3r_t;
#define DSC_TRNSUM_CTL3r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_CLR
#define DSC_TRNSUM_CTL3r_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_SET
#define DSC_TRNSUM_CTL3r_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_GET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_GET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_SET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_GET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_SET
#define READ_DSC_TRNSUM_CTL3r BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL3r
#define WRITE_DSC_TRNSUM_CTL3r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL3r
#define MODIFY_DSC_TRNSUM_CTL3r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL3r
#define READLN_DSC_TRNSUM_CTL3r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL3r
#define WRITELN_DSC_TRNSUM_CTL3r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL3r
#define WRITEALL_DSC_TRNSUM_CTL3r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_CTL4
 * BLOCKS:   DSC_D
 * REGADDR:  0xd033
 * DEVAD:    1
 * DESC:     Trnsum Ctl 4
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_UNSIGNED_CORR when 1; and !trnsum_unsigned_flip, correlated error after XOR {0,1} becomes signed {2'b00,2'b01}
 *     TRNSUM_UNSIGNED_FLIP when 1 along with trnsum_unsigned_corr, {0,1} - {2'b01, 2'b00}
 *     TDR_BIT_SEL      tdr bit select: range is 0 to 19
 *     TDR_TRNSUM_EN    enables the tdr feature
 *     TDR_CYCLE_SEL    the cycle counter wraps at this number
 *     TDR_CYCLE_BIN    valid range: from 0 to tdr_cycle_sel; this cycle the tdr is enabled on bit indicated by tdr_bit_sel
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r (0x0001d033 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL4.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl4[1];
	uint32_t _dsc_trnsum_ctl4;
} BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_CLR(r) (r).dsc_trnsum_ctl4[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_SET(r,d) (r).dsc_trnsum_ctl4[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_GET(r) (r).dsc_trnsum_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 2) & 0x1f)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2)) | (31 << (16 + 2))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_GET(r) (((r).dsc_trnsum_ctl4[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL4.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r,(_r._dsc_trnsum_ctl4))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r,(_r._dsc_trnsum_ctl4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r,(_r._dsc_trnsum_ctl4))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl4))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl4))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL4r BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r
#define DSC_TRNSUM_CTL4r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_t DSC_TRNSUM_CTL4r_t;
#define DSC_TRNSUM_CTL4r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_CLR
#define DSC_TRNSUM_CTL4r_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_SET
#define DSC_TRNSUM_CTL4r_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_GET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_GET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_SET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_GET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_SET
#define DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_GET
#define DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_SET
#define DSC_TRNSUM_CTL4r_TDR_BIT_SELf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_GET
#define DSC_TRNSUM_CTL4r_TDR_BIT_SELf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_SET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_GET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_SET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_GET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_GET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_SET BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_SET
#define READ_DSC_TRNSUM_CTL4r BCMI_QTC_XGXS_READ_DSC_TRNSUM_CTL4r
#define WRITE_DSC_TRNSUM_CTL4r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_CTL4r
#define MODIFY_DSC_TRNSUM_CTL4r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_CTL4r
#define READLN_DSC_TRNSUM_CTL4r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_CTL4r
#define WRITELN_DSC_TRNSUM_CTL4r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_CTL4r
#define WRITEALL_DSC_TRNSUM_CTL4r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_CTL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_STS1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd034
 * DEVAD:    1
 * DESC:     Trnsum Status 1
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_E_HIGH    trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS1r (0x0001d034 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS1.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts1[1];
	uint32_t _dsc_trnsum_sts1;
} BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_CLR(r) (r).dsc_trnsum_sts1[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_SET(r,d) (r).dsc_trnsum_sts1[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_GET(r) (r).dsc_trnsum_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_GET(r) (((r).dsc_trnsum_sts1[0]) & 0xffff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_SET(r,f) (r).dsc_trnsum_sts1[0]=(((r).dsc_trnsum_sts1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS1.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS1r,(_r._dsc_trnsum_sts1))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS1r,(_r._dsc_trnsum_sts1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS1r,(_r._dsc_trnsum_sts1))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts1))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts1))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS1r BCMI_QTC_XGXS_DSC_TRNSUM_STS1r
#define DSC_TRNSUM_STS1r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_t DSC_TRNSUM_STS1r_t;
#define DSC_TRNSUM_STS1r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_CLR
#define DSC_TRNSUM_STS1r_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_SET
#define DSC_TRNSUM_STS1r_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_GET
#define DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_GET
#define DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_SET
#define READ_DSC_TRNSUM_STS1r BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS1r
#define WRITE_DSC_TRNSUM_STS1r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS1r
#define MODIFY_DSC_TRNSUM_STS1r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS1r
#define READLN_DSC_TRNSUM_STS1r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS1r
#define WRITELN_DSC_TRNSUM_STS1r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS1r
#define WRITEALL_DSC_TRNSUM_STS1r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_STS2
 * BLOCKS:   DSC_D
 * REGADDR:  0xd035
 * DEVAD:    1
 * DESC:     Trnsum Status 2
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_E_LOW     trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS2r (0x0001d035 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS2.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts2[1];
	uint32_t _dsc_trnsum_sts2;
} BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_CLR(r) (r).dsc_trnsum_sts2[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_SET(r,d) (r).dsc_trnsum_sts2[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_GET(r) (r).dsc_trnsum_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_GET(r) (((r).dsc_trnsum_sts2[0]) & 0xff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_SET(r,f) (r).dsc_trnsum_sts2[0]=(((r).dsc_trnsum_sts2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS2.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS2r,(_r._dsc_trnsum_sts2))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS2r,(_r._dsc_trnsum_sts2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS2r,(_r._dsc_trnsum_sts2))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts2))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts2))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS2r BCMI_QTC_XGXS_DSC_TRNSUM_STS2r
#define DSC_TRNSUM_STS2r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_t DSC_TRNSUM_STS2r_t;
#define DSC_TRNSUM_STS2r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_CLR
#define DSC_TRNSUM_STS2r_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_SET
#define DSC_TRNSUM_STS2r_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_GET
#define DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_GET
#define DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_SET
#define READ_DSC_TRNSUM_STS2r BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS2r
#define WRITE_DSC_TRNSUM_STS2r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS2r
#define MODIFY_DSC_TRNSUM_STS2r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS2r
#define READLN_DSC_TRNSUM_STS2r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS2r
#define WRITELN_DSC_TRNSUM_STS2r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS2r
#define WRITEALL_DSC_TRNSUM_STS2r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_STS3
 * BLOCKS:   DSC_D
 * REGADDR:  0xd036
 * DEVAD:    1
 * DESC:     Trnsum Status 3
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_O_HIGH    trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS3r (0x0001d036 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS3.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts3[1];
	uint32_t _dsc_trnsum_sts3;
} BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_CLR(r) (r).dsc_trnsum_sts3[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_SET(r,d) (r).dsc_trnsum_sts3[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_GET(r) (r).dsc_trnsum_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_GET(r) (((r).dsc_trnsum_sts3[0]) & 0xffff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_SET(r,f) (r).dsc_trnsum_sts3[0]=(((r).dsc_trnsum_sts3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS3.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS3r,(_r._dsc_trnsum_sts3))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS3r,(_r._dsc_trnsum_sts3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS3r,(_r._dsc_trnsum_sts3))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts3))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts3))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS3r BCMI_QTC_XGXS_DSC_TRNSUM_STS3r
#define DSC_TRNSUM_STS3r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_t DSC_TRNSUM_STS3r_t;
#define DSC_TRNSUM_STS3r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_CLR
#define DSC_TRNSUM_STS3r_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_SET
#define DSC_TRNSUM_STS3r_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_GET
#define DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_GET
#define DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_SET
#define READ_DSC_TRNSUM_STS3r BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS3r
#define WRITE_DSC_TRNSUM_STS3r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS3r
#define MODIFY_DSC_TRNSUM_STS3r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS3r
#define READLN_DSC_TRNSUM_STS3r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS3r
#define WRITELN_DSC_TRNSUM_STS3r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS3r
#define WRITEALL_DSC_TRNSUM_STS3r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_STS4
 * BLOCKS:   DSC_D
 * REGADDR:  0xd037
 * DEVAD:    1
 * DESC:     Trnsum Status 4
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_O_LOW     trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS4r (0x0001d037 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS4.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts4[1];
	uint32_t _dsc_trnsum_sts4;
} BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_CLR(r) (r).dsc_trnsum_sts4[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_SET(r,d) (r).dsc_trnsum_sts4[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_GET(r) (r).dsc_trnsum_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_GET(r) (((r).dsc_trnsum_sts4[0]) & 0xff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_SET(r,f) (r).dsc_trnsum_sts4[0]=(((r).dsc_trnsum_sts4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS4.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS4r,(_r._dsc_trnsum_sts4))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS4r,(_r._dsc_trnsum_sts4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS4r,(_r._dsc_trnsum_sts4))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts4))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts4))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS4r BCMI_QTC_XGXS_DSC_TRNSUM_STS4r
#define DSC_TRNSUM_STS4r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_t DSC_TRNSUM_STS4r_t;
#define DSC_TRNSUM_STS4r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_CLR
#define DSC_TRNSUM_STS4r_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_SET
#define DSC_TRNSUM_STS4r_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_GET
#define DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_GET
#define DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_SET
#define READ_DSC_TRNSUM_STS4r BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS4r
#define WRITE_DSC_TRNSUM_STS4r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS4r
#define MODIFY_DSC_TRNSUM_STS4r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS4r
#define READLN_DSC_TRNSUM_STS4r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS4r
#define WRITELN_DSC_TRNSUM_STS4r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS4r
#define WRITEALL_DSC_TRNSUM_STS4r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_STS5
 * BLOCKS:   DSC_D
 * REGADDR:  0xd038
 * DEVAD:    1
 * DESC:     Trnsum Status 5
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_HIGH      trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS5r (0x0001d038 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS5.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts5[1];
	uint32_t _dsc_trnsum_sts5;
} BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_CLR(r) (r).dsc_trnsum_sts5[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_SET(r,d) (r).dsc_trnsum_sts5[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_GET(r) (r).dsc_trnsum_sts5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_GET(r) (((r).dsc_trnsum_sts5[0]) & 0xffff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_SET(r,f) (r).dsc_trnsum_sts5[0]=(((r).dsc_trnsum_sts5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS5.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS5r,(_r._dsc_trnsum_sts5))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS5r,(_r._dsc_trnsum_sts5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS5r,(_r._dsc_trnsum_sts5))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts5))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts5))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS5r BCMI_QTC_XGXS_DSC_TRNSUM_STS5r
#define DSC_TRNSUM_STS5r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_t DSC_TRNSUM_STS5r_t;
#define DSC_TRNSUM_STS5r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_CLR
#define DSC_TRNSUM_STS5r_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_SET
#define DSC_TRNSUM_STS5r_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_GET
#define DSC_TRNSUM_STS5r_TRNSUM_HIGHf_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_GET
#define DSC_TRNSUM_STS5r_TRNSUM_HIGHf_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_SET
#define READ_DSC_TRNSUM_STS5r BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS5r
#define WRITE_DSC_TRNSUM_STS5r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS5r
#define MODIFY_DSC_TRNSUM_STS5r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS5r
#define READLN_DSC_TRNSUM_STS5r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS5r
#define WRITELN_DSC_TRNSUM_STS5r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS5r
#define WRITEALL_DSC_TRNSUM_STS5r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_STS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_TRNSUM_STS6
 * BLOCKS:   DSC_D
 * REGADDR:  0xd039
 * DEVAD:    1
 * DESC:     Trnsum Status 6
 * SIZE:     32
 * FIELDS:
 *     TRNSUM_LOW       trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS6r (0x0001d039 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS6.
 */
typedef union BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts6[1];
	uint32_t _dsc_trnsum_sts6;
} BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_t;

#define BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_CLR(r) (r).dsc_trnsum_sts6[0] = 0
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_SET(r,d) (r).dsc_trnsum_sts6[0] = d
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_GET(r) (r).dsc_trnsum_sts6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_GET(r) (((r).dsc_trnsum_sts6[0]) & 0x3ff)
#define BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_SET(r,f) (r).dsc_trnsum_sts6[0]=(((r).dsc_trnsum_sts6[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (1023 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS6.
 */
#define BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS6r,(_r._dsc_trnsum_sts6))
#define BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS6r,(_r._dsc_trnsum_sts6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS6r,(_r._dsc_trnsum_sts6))
#define BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts6))
#define BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts6))
#define BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_TRNSUM_STS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS6r BCMI_QTC_XGXS_DSC_TRNSUM_STS6r
#define DSC_TRNSUM_STS6r_SIZE BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_SIZE
typedef BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_t DSC_TRNSUM_STS6r_t;
#define DSC_TRNSUM_STS6r_CLR BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_CLR
#define DSC_TRNSUM_STS6r_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_SET
#define DSC_TRNSUM_STS6r_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_GET
#define DSC_TRNSUM_STS6r_TRNSUM_LOWf_GET BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_GET
#define DSC_TRNSUM_STS6r_TRNSUM_LOWf_SET BCMI_QTC_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_SET
#define READ_DSC_TRNSUM_STS6r BCMI_QTC_XGXS_READ_DSC_TRNSUM_STS6r
#define WRITE_DSC_TRNSUM_STS6r BCMI_QTC_XGXS_WRITE_DSC_TRNSUM_STS6r
#define MODIFY_DSC_TRNSUM_STS6r BCMI_QTC_XGXS_MODIFY_DSC_TRNSUM_STS6r
#define READLN_DSC_TRNSUM_STS6r BCMI_QTC_XGXS_READLN_DSC_TRNSUM_STS6r
#define WRITELN_DSC_TRNSUM_STS6r BCMI_QTC_XGXS_WRITELN_DSC_TRNSUM_STS6r
#define WRITEALL_DSC_TRNSUM_STS6r BCMI_QTC_XGXS_WRITEALL_DSC_TRNSUM_STS6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_TRNSUM_STS6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_VGA_P1EYEDIAG_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03a
 * DEVAD:    1
 * DESC:     VGA status
 * SIZE:     32
 * FIELDS:
 *     VGA_BIN          vga status
 *     P1_EYEDIAG_BIN   p1 eyediag status
 */
#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr (0x0001d03a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_P1EYEDIAG_STS.
 */
typedef union BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_p1eyediag_sts[1];
	uint32_t _dsc_vga_p1eyediag_sts;
} BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_t;

#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_CLR(r) (r).dsc_vga_p1eyediag_sts[0] = 0
#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_SET(r,d) (r).dsc_vga_p1eyediag_sts[0] = d
#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_GET(r) (r).dsc_vga_p1eyediag_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_GET(r) ((((r).dsc_vga_p1eyediag_sts[0]) >> 8) & 0x3f)
#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_SET(r,f) (r).dsc_vga_p1eyediag_sts[0]=(((r).dsc_vga_p1eyediag_sts[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_GET(r) (((r).dsc_vga_p1eyediag_sts[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_SET(r,f) (r).dsc_vga_p1eyediag_sts[0]=(((r).dsc_vga_p1eyediag_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_VGA_P1EYEDIAG_STS.
 */
#define BCMI_QTC_XGXS_READ_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr,(_r._dsc_vga_p1eyediag_sts))
#define BCMI_QTC_XGXS_WRITE_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr,(_r._dsc_vga_p1eyediag_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr,(_r._dsc_vga_p1eyediag_sts))
#define BCMI_QTC_XGXS_READLN_DSC_VGA_P1EYEDIAG_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_p1eyediag_sts))
#define BCMI_QTC_XGXS_WRITELN_DSC_VGA_P1EYEDIAG_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_p1eyediag_sts))
#define BCMI_QTC_XGXS_WRITEALL_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_p1eyediag_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_P1EYEDIAG_STSr BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr
#define DSC_VGA_P1EYEDIAG_STSr_SIZE BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_SIZE
typedef BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_t DSC_VGA_P1EYEDIAG_STSr_t;
#define DSC_VGA_P1EYEDIAG_STSr_CLR BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_CLR
#define DSC_VGA_P1EYEDIAG_STSr_SET BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_SET
#define DSC_VGA_P1EYEDIAG_STSr_GET BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_GET
#define DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_GET BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_GET
#define DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_SET BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_SET
#define DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_GET BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_GET
#define DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_SET BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_SET
#define READ_DSC_VGA_P1EYEDIAG_STSr BCMI_QTC_XGXS_READ_DSC_VGA_P1EYEDIAG_STSr
#define WRITE_DSC_VGA_P1EYEDIAG_STSr BCMI_QTC_XGXS_WRITE_DSC_VGA_P1EYEDIAG_STSr
#define MODIFY_DSC_VGA_P1EYEDIAG_STSr BCMI_QTC_XGXS_MODIFY_DSC_VGA_P1EYEDIAG_STSr
#define READLN_DSC_VGA_P1EYEDIAG_STSr BCMI_QTC_XGXS_READLN_DSC_VGA_P1EYEDIAG_STSr
#define WRITELN_DSC_VGA_P1EYEDIAG_STSr BCMI_QTC_XGXS_WRITELN_DSC_VGA_P1EYEDIAG_STSr
#define WRITEALL_DSC_VGA_P1EYEDIAG_STSr BCMI_QTC_XGXS_WRITEALL_DSC_VGA_P1EYEDIAG_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_VGA_P1EYEDIAG_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_1_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03b
 * DEVAD:    1
 * DESC:     DFE 1 status
 * SIZE:     32
 * FIELDS:
 *     DFE_1_CMN        dfe 1 cmn tap
 *     DFE_1_O          dfe1 odd tap
 *     DFE_1_E          dfe1 even tap
 *     DFE_1_WANTS_NEGATIVE dfe1 wants negative
 */
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr (0x0001d03b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_1_STS.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_1_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_1_sts[1];
	uint32_t _dsc_dfe_1_sts;
} BCMI_QTC_XGXS_DSC_DFE_1_STSr_t;

#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_CLR(r) (r).dsc_dfe_1_sts[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_SET(r,d) (r).dsc_dfe_1_sts[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_GET(r) (r).dsc_dfe_1_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_GET(r) ((((r).dsc_dfe_1_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_GET(r) ((((r).dsc_dfe_1_sts[0]) >> 11) & 0x7)
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Of_GET(r) ((((r).dsc_dfe_1_sts[0]) >> 8) & 0x7)
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Of_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_GET(r) (((r).dsc_dfe_1_sts[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_DFE_1_STS.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_1_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_1_STSr,(_r._dsc_dfe_1_sts))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_1_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_STSr,(_r._dsc_dfe_1_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_1_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_STSr,(_r._dsc_dfe_1_sts))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_1_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_1_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_sts))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_1_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_sts))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_1_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_1_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_1_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_1_STSr BCMI_QTC_XGXS_DSC_DFE_1_STSr
#define DSC_DFE_1_STSr_SIZE BCMI_QTC_XGXS_DSC_DFE_1_STSr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_1_STSr_t DSC_DFE_1_STSr_t;
#define DSC_DFE_1_STSr_CLR BCMI_QTC_XGXS_DSC_DFE_1_STSr_CLR
#define DSC_DFE_1_STSr_SET BCMI_QTC_XGXS_DSC_DFE_1_STSr_SET
#define DSC_DFE_1_STSr_GET BCMI_QTC_XGXS_DSC_DFE_1_STSr_GET
#define DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_GET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_GET
#define DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_SET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_SET
#define DSC_DFE_1_STSr_DFE_1_Ef_GET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_GET
#define DSC_DFE_1_STSr_DFE_1_Ef_SET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_SET
#define DSC_DFE_1_STSr_DFE_1_Of_GET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Of_GET
#define DSC_DFE_1_STSr_DFE_1_Of_SET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_Of_SET
#define DSC_DFE_1_STSr_DFE_1_CMNf_GET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_GET
#define DSC_DFE_1_STSr_DFE_1_CMNf_SET BCMI_QTC_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_SET
#define READ_DSC_DFE_1_STSr BCMI_QTC_XGXS_READ_DSC_DFE_1_STSr
#define WRITE_DSC_DFE_1_STSr BCMI_QTC_XGXS_WRITE_DSC_DFE_1_STSr
#define MODIFY_DSC_DFE_1_STSr BCMI_QTC_XGXS_MODIFY_DSC_DFE_1_STSr
#define READLN_DSC_DFE_1_STSr BCMI_QTC_XGXS_READLN_DSC_DFE_1_STSr
#define WRITELN_DSC_DFE_1_STSr BCMI_QTC_XGXS_WRITELN_DSC_DFE_1_STSr
#define WRITEALL_DSC_DFE_1_STSr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_1_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_1_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_2_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03c
 * DEVAD:    1
 * DESC:     DFE 2 status
 * SIZE:     32
 * FIELDS:
 *     DFE_2_CMN        trnsum pattern
 *     DFE_2_SO         dfe 2 tap sign odd
 *     DFE_2_SE         dfe 2 tap sign even
 *     DFE_2_O          trnsum pattern
 *     DFE_2_E          trnsum pattern
 */
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr (0x0001d03c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_2_STS.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_2_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_2_sts[1];
	uint32_t _dsc_dfe_2_sts;
} BCMI_QTC_XGXS_DSC_DFE_2_STSr_t;

#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_CLR(r) (r).dsc_dfe_2_sts[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_SET(r,d) (r).dsc_dfe_2_sts[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_GET(r) (r).dsc_dfe_2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 11) & 0x7)
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Of_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 8) & 0x7)
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Of_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_GET(r) (((r).dsc_dfe_2_sts[0]) & 0x1f)
#define BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DSC_DFE_2_STS.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_2_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_2_STSr,(_r._dsc_dfe_2_sts))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_2_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_STSr,(_r._dsc_dfe_2_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_2_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_STSr,(_r._dsc_dfe_2_sts))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_2_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_sts))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_2_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_sts))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_2_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_2_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_2_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_2_STSr BCMI_QTC_XGXS_DSC_DFE_2_STSr
#define DSC_DFE_2_STSr_SIZE BCMI_QTC_XGXS_DSC_DFE_2_STSr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_2_STSr_t DSC_DFE_2_STSr_t;
#define DSC_DFE_2_STSr_CLR BCMI_QTC_XGXS_DSC_DFE_2_STSr_CLR
#define DSC_DFE_2_STSr_SET BCMI_QTC_XGXS_DSC_DFE_2_STSr_SET
#define DSC_DFE_2_STSr_GET BCMI_QTC_XGXS_DSC_DFE_2_STSr_GET
#define DSC_DFE_2_STSr_DFE_2_Ef_GET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_GET
#define DSC_DFE_2_STSr_DFE_2_Ef_SET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_SET
#define DSC_DFE_2_STSr_DFE_2_Of_GET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Of_GET
#define DSC_DFE_2_STSr_DFE_2_Of_SET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_Of_SET
#define DSC_DFE_2_STSr_DFE_2_SEf_GET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_GET
#define DSC_DFE_2_STSr_DFE_2_SEf_SET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_SET
#define DSC_DFE_2_STSr_DFE_2_SOf_GET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_GET
#define DSC_DFE_2_STSr_DFE_2_SOf_SET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_SET
#define DSC_DFE_2_STSr_DFE_2_CMNf_GET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_GET
#define DSC_DFE_2_STSr_DFE_2_CMNf_SET BCMI_QTC_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_SET
#define READ_DSC_DFE_2_STSr BCMI_QTC_XGXS_READ_DSC_DFE_2_STSr
#define WRITE_DSC_DFE_2_STSr BCMI_QTC_XGXS_WRITE_DSC_DFE_2_STSr
#define MODIFY_DSC_DFE_2_STSr BCMI_QTC_XGXS_MODIFY_DSC_DFE_2_STSr
#define READLN_DSC_DFE_2_STSr BCMI_QTC_XGXS_READLN_DSC_DFE_2_STSr
#define WRITELN_DSC_DFE_2_STSr BCMI_QTC_XGXS_WRITELN_DSC_DFE_2_STSr
#define WRITEALL_DSC_DFE_2_STSr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_2_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DFE_3_4_5_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03d
 * DEVAD:    1
 * DESC:     DFE 3,4,5 status
 * SIZE:     32
 * FIELDS:
 *     DFE_3_CMN        dfe 3 tap value
 *     DFE_4_CMN        dfe 4 tap value
 *     DFE_5_CMN        dfe 5 tap value
 */
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr (0x0001d03d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_3_4_5_STS.
 */
typedef union BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_3_4_5_sts[1];
	uint32_t _dsc_dfe_3_4_5_sts;
} BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_t;

#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_CLR(r) (r).dsc_dfe_3_4_5_sts[0] = 0
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_SET(r,d) (r).dsc_dfe_3_4_5_sts[0] = d
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_GET(r) (r).dsc_dfe_3_4_5_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_GET(r) ((((r).dsc_dfe_3_4_5_sts[0]) >> 11) & 0x1f)
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_SET(r,f) (r).dsc_dfe_3_4_5_sts[0]=(((r).dsc_dfe_3_4_5_sts[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_GET(r) ((((r).dsc_dfe_3_4_5_sts[0]) >> 6) & 0x1f)
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_SET(r,f) (r).dsc_dfe_3_4_5_sts[0]=(((r).dsc_dfe_3_4_5_sts[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_GET(r) (((r).dsc_dfe_3_4_5_sts[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_SET(r,f) (r).dsc_dfe_3_4_5_sts[0]=(((r).dsc_dfe_3_4_5_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_DFE_3_4_5_STS.
 */
#define BCMI_QTC_XGXS_READ_DSC_DFE_3_4_5_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr,(_r._dsc_dfe_3_4_5_sts))
#define BCMI_QTC_XGXS_WRITE_DSC_DFE_3_4_5_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr,(_r._dsc_dfe_3_4_5_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DFE_3_4_5_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr,(_r._dsc_dfe_3_4_5_sts))
#define BCMI_QTC_XGXS_READLN_DSC_DFE_3_4_5_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_4_5_sts))
#define BCMI_QTC_XGXS_WRITELN_DSC_DFE_3_4_5_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_4_5_sts))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DFE_3_4_5_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_3_4_5_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_3_4_5_STSr BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr
#define DSC_DFE_3_4_5_STSr_SIZE BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_SIZE
typedef BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_t DSC_DFE_3_4_5_STSr_t;
#define DSC_DFE_3_4_5_STSr_CLR BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_CLR
#define DSC_DFE_3_4_5_STSr_SET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_SET
#define DSC_DFE_3_4_5_STSr_GET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_GET
#define DSC_DFE_3_4_5_STSr_DFE_5_CMNf_GET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_GET
#define DSC_DFE_3_4_5_STSr_DFE_5_CMNf_SET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_SET
#define DSC_DFE_3_4_5_STSr_DFE_4_CMNf_GET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_GET
#define DSC_DFE_3_4_5_STSr_DFE_4_CMNf_SET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_SET
#define DSC_DFE_3_4_5_STSr_DFE_3_CMNf_GET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_GET
#define DSC_DFE_3_4_5_STSr_DFE_3_CMNf_SET BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_SET
#define READ_DSC_DFE_3_4_5_STSr BCMI_QTC_XGXS_READ_DSC_DFE_3_4_5_STSr
#define WRITE_DSC_DFE_3_4_5_STSr BCMI_QTC_XGXS_WRITE_DSC_DFE_3_4_5_STSr
#define MODIFY_DSC_DFE_3_4_5_STSr BCMI_QTC_XGXS_MODIFY_DSC_DFE_3_4_5_STSr
#define READLN_DSC_DFE_3_4_5_STSr BCMI_QTC_XGXS_READLN_DSC_DFE_3_4_5_STSr
#define WRITELN_DSC_DFE_3_4_5_STSr BCMI_QTC_XGXS_WRITELN_DSC_DFE_3_4_5_STSr
#define WRITEALL_DSC_DFE_3_4_5_STSr BCMI_QTC_XGXS_WRITEALL_DSC_DFE_3_4_5_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DFE_3_4_5_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_VGA_TAP_BIN
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03e
 * DEVAD:    1
 * DESC:     VGA binary tap values
 * SIZE:     32
 * FIELDS:
 *     VGA_CTRL_BIN     VGA 1 & 2 ctrl binary value.
 *     VGA3_CTRL_BIN    VGA 3 ctrl binary value.
 */
#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr (0x0001d03e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_TAP_BIN.
 */
typedef union BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_s {
	uint32_t v[1];
	uint32_t dsc_vga_tap_bin[1];
	uint32_t _dsc_vga_tap_bin;
} BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_t;

#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_CLR(r) (r).dsc_vga_tap_bin[0] = 0
#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_SET(r,d) (r).dsc_vga_tap_bin[0] = d
#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_GET(r) (r).dsc_vga_tap_bin[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_GET(r) ((((r).dsc_vga_tap_bin[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_SET(r,f) (r).dsc_vga_tap_bin[0]=(((r).dsc_vga_tap_bin[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA_CTRL_BINf_GET(r) (((r).dsc_vga_tap_bin[0]) & 0x1f)
#define BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA_CTRL_BINf_SET(r,f) (r).dsc_vga_tap_bin[0]=(((r).dsc_vga_tap_bin[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DSC_VGA_TAP_BIN.
 */
#define BCMI_QTC_XGXS_READ_DSC_VGA_TAP_BINr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_TAP_BINr,(_r._dsc_vga_tap_bin))
#define BCMI_QTC_XGXS_WRITE_DSC_VGA_TAP_BINr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_TAP_BINr,(_r._dsc_vga_tap_bin)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_VGA_TAP_BINr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_TAP_BINr,(_r._dsc_vga_tap_bin))
#define BCMI_QTC_XGXS_READLN_DSC_VGA_TAP_BINr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_VGA_TAP_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_tap_bin))
#define BCMI_QTC_XGXS_WRITELN_DSC_VGA_TAP_BINr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_TAP_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_tap_bin))
#define BCMI_QTC_XGXS_WRITEALL_DSC_VGA_TAP_BINr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_VGA_TAP_BINr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_tap_bin))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_TAP_BINr BCMI_QTC_XGXS_DSC_VGA_TAP_BINr
#define DSC_VGA_TAP_BINr_SIZE BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_SIZE
typedef BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_t DSC_VGA_TAP_BINr_t;
#define DSC_VGA_TAP_BINr_CLR BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_CLR
#define DSC_VGA_TAP_BINr_SET BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_SET
#define DSC_VGA_TAP_BINr_GET BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_GET
#define DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_GET BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_GET
#define DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_SET BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_SET
#define DSC_VGA_TAP_BINr_VGA_CTRL_BINf_GET BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA_CTRL_BINf_GET
#define DSC_VGA_TAP_BINr_VGA_CTRL_BINf_SET BCMI_QTC_XGXS_DSC_VGA_TAP_BINr_VGA_CTRL_BINf_SET
#define READ_DSC_VGA_TAP_BINr BCMI_QTC_XGXS_READ_DSC_VGA_TAP_BINr
#define WRITE_DSC_VGA_TAP_BINr BCMI_QTC_XGXS_WRITE_DSC_VGA_TAP_BINr
#define MODIFY_DSC_VGA_TAP_BINr BCMI_QTC_XGXS_MODIFY_DSC_VGA_TAP_BINr
#define READLN_DSC_VGA_TAP_BINr BCMI_QTC_XGXS_READLN_DSC_VGA_TAP_BINr
#define WRITELN_DSC_VGA_TAP_BINr BCMI_QTC_XGXS_WRITELN_DSC_VGA_TAP_BINr
#define WRITEALL_DSC_VGA_TAP_BINr BCMI_QTC_XGXS_WRITEALL_DSC_VGA_TAP_BINr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_VGA_TAP_BINr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_CTL
 * BLOCKS:   DSC_E
 * REGADDR:  0xd040
 * DEVAD:    1
 * DESC:     dsc_e_ctrl
 * SIZE:     32
 * FIELDS:
 *     PD_CH_P1         Power down +1 channel
 *     OFFSET_PD        Power down ananlog DC offsetcancellation DAC.
 *     EN_HGAIN         Enable high gain in DFE summer pathfor non-DFE mode.
 *     P1_THRESH_SEL    P1 slicer target level.0=150mV, 1=250mV
 *     M1_THRESH_ZERO   sets m1 target to 0mV for OS TR
 *     M1_THRESH_SEL    Sets the voltage reference level at theslicer input.00, 125mV; 01, 150mV (default)10, 175mV; 11, 200mV
 *     PF_HIZ           Enable hiz mode for peaking filter,shifts the boost peak to a higher freq.
 *     EN_DFE_CLK       Enable DFE MUX clock.
 *     OFFSET_FASTACQ   This is a spare register connected torx<i>_offset_fastacq port of the AFE butas per the AMS descriptionit is not used for 28nm Eagle AFE.
 */
#define BCMI_QTC_XGXS_DSC_CTLr (0x0001d040 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_ctl[1];
	uint32_t _dsc_ctl;
} BCMI_QTC_XGXS_DSC_CTLr_t;

#define BCMI_QTC_XGXS_DSC_CTLr_CLR(r) (r).dsc_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_CTLr_SET(r,d) (r).dsc_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_CTLr_GET(r) (r).dsc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_CTLr_OFFSET_FASTACQf_GET(r) ((((r).dsc_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_OFFSET_FASTACQf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DSC_CTLr_EN_DFE_CLKf_GET(r) ((((r).dsc_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_EN_DFE_CLKf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DSC_CTLr_PF_HIZf_GET(r) ((((r).dsc_ctl[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_PF_HIZf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_SELf_GET(r) ((((r).dsc_ctl[0]) >> 5) & 0x3)
#define BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_SELf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_ZEROf_GET(r) ((((r).dsc_ctl[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_ZEROf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DSC_CTLr_P1_THRESH_SELf_GET(r) ((((r).dsc_ctl[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_P1_THRESH_SELf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_DSC_CTLr_EN_HGAINf_GET(r) ((((r).dsc_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_EN_HGAINf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_DSC_CTLr_OFFSET_PDf_GET(r) ((((r).dsc_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_OFFSET_PDf_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DSC_CTLr_PD_CH_P1f_GET(r) (((r).dsc_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DSC_CTLr_PD_CH_P1f_SET(r,f) (r).dsc_ctl[0]=(((r).dsc_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DSC_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CTLr,(_r._dsc_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CTLr,(_r._dsc_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CTLr,(_r._dsc_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_CTLr BCMI_QTC_XGXS_DSC_CTLr
#define DSC_CTLr_SIZE BCMI_QTC_XGXS_DSC_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_CTLr_t DSC_CTLr_t;
#define DSC_CTLr_CLR BCMI_QTC_XGXS_DSC_CTLr_CLR
#define DSC_CTLr_SET BCMI_QTC_XGXS_DSC_CTLr_SET
#define DSC_CTLr_GET BCMI_QTC_XGXS_DSC_CTLr_GET
#define DSC_CTLr_OFFSET_FASTACQf_GET BCMI_QTC_XGXS_DSC_CTLr_OFFSET_FASTACQf_GET
#define DSC_CTLr_OFFSET_FASTACQf_SET BCMI_QTC_XGXS_DSC_CTLr_OFFSET_FASTACQf_SET
#define DSC_CTLr_EN_DFE_CLKf_GET BCMI_QTC_XGXS_DSC_CTLr_EN_DFE_CLKf_GET
#define DSC_CTLr_EN_DFE_CLKf_SET BCMI_QTC_XGXS_DSC_CTLr_EN_DFE_CLKf_SET
#define DSC_CTLr_PF_HIZf_GET BCMI_QTC_XGXS_DSC_CTLr_PF_HIZf_GET
#define DSC_CTLr_PF_HIZf_SET BCMI_QTC_XGXS_DSC_CTLr_PF_HIZf_SET
#define DSC_CTLr_M1_THRESH_SELf_GET BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_SELf_GET
#define DSC_CTLr_M1_THRESH_SELf_SET BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_SELf_SET
#define DSC_CTLr_M1_THRESH_ZEROf_GET BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_ZEROf_GET
#define DSC_CTLr_M1_THRESH_ZEROf_SET BCMI_QTC_XGXS_DSC_CTLr_M1_THRESH_ZEROf_SET
#define DSC_CTLr_P1_THRESH_SELf_GET BCMI_QTC_XGXS_DSC_CTLr_P1_THRESH_SELf_GET
#define DSC_CTLr_P1_THRESH_SELf_SET BCMI_QTC_XGXS_DSC_CTLr_P1_THRESH_SELf_SET
#define DSC_CTLr_EN_HGAINf_GET BCMI_QTC_XGXS_DSC_CTLr_EN_HGAINf_GET
#define DSC_CTLr_EN_HGAINf_SET BCMI_QTC_XGXS_DSC_CTLr_EN_HGAINf_SET
#define DSC_CTLr_OFFSET_PDf_GET BCMI_QTC_XGXS_DSC_CTLr_OFFSET_PDf_GET
#define DSC_CTLr_OFFSET_PDf_SET BCMI_QTC_XGXS_DSC_CTLr_OFFSET_PDf_SET
#define DSC_CTLr_PD_CH_P1f_GET BCMI_QTC_XGXS_DSC_CTLr_PD_CH_P1f_GET
#define DSC_CTLr_PD_CH_P1f_SET BCMI_QTC_XGXS_DSC_CTLr_PD_CH_P1f_SET
#define READ_DSC_CTLr BCMI_QTC_XGXS_READ_DSC_CTLr
#define WRITE_DSC_CTLr BCMI_QTC_XGXS_WRITE_DSC_CTLr
#define MODIFY_DSC_CTLr BCMI_QTC_XGXS_MODIFY_DSC_CTLr
#define READLN_DSC_CTLr BCMI_QTC_XGXS_READLN_DSC_CTLr
#define WRITELN_DSC_CTLr BCMI_QTC_XGXS_WRITELN_DSC_CTLr
#define WRITEALL_DSC_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_PF_CTL
 * BLOCKS:   DSC_E
 * REGADDR:  0xd041
 * DEVAD:    1
 * DESC:     dsc_e_pf_ctrl
 * SIZE:     32
 * FIELDS:
 *     PF_CTRL          Peaking filter control, approx 0-8 dB boost in~0.5 dB steps. Gray code
 */
#define BCMI_QTC_XGXS_DSC_PF_CTLr (0x0001d041 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_PF_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_PF_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_PF_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_pf_ctl[1];
	uint32_t _dsc_pf_ctl;
} BCMI_QTC_XGXS_DSC_PF_CTLr_t;

#define BCMI_QTC_XGXS_DSC_PF_CTLr_CLR(r) (r).dsc_pf_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_PF_CTLr_SET(r,d) (r).dsc_pf_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_PF_CTLr_GET(r) (r).dsc_pf_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_PF_CTLr_PF_CTRLf_GET(r) (((r).dsc_pf_ctl[0]) & 0xf)
#define BCMI_QTC_XGXS_DSC_PF_CTLr_PF_CTRLf_SET(r,f) (r).dsc_pf_ctl[0]=(((r).dsc_pf_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access DSC_PF_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_PF_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_PF_CTLr,(_r._dsc_pf_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_PF_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF_CTLr,(_r._dsc_pf_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_PF_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF_CTLr,(_r._dsc_pf_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_PF_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_PF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_pf_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_PF_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_pf_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_PF_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_pf_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_PF_CTLr BCMI_QTC_XGXS_DSC_PF_CTLr
#define DSC_PF_CTLr_SIZE BCMI_QTC_XGXS_DSC_PF_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_PF_CTLr_t DSC_PF_CTLr_t;
#define DSC_PF_CTLr_CLR BCMI_QTC_XGXS_DSC_PF_CTLr_CLR
#define DSC_PF_CTLr_SET BCMI_QTC_XGXS_DSC_PF_CTLr_SET
#define DSC_PF_CTLr_GET BCMI_QTC_XGXS_DSC_PF_CTLr_GET
#define DSC_PF_CTLr_PF_CTRLf_GET BCMI_QTC_XGXS_DSC_PF_CTLr_PF_CTRLf_GET
#define DSC_PF_CTLr_PF_CTRLf_SET BCMI_QTC_XGXS_DSC_PF_CTLr_PF_CTRLf_SET
#define READ_DSC_PF_CTLr BCMI_QTC_XGXS_READ_DSC_PF_CTLr
#define WRITE_DSC_PF_CTLr BCMI_QTC_XGXS_WRITE_DSC_PF_CTLr
#define MODIFY_DSC_PF_CTLr BCMI_QTC_XGXS_MODIFY_DSC_PF_CTLr
#define READLN_DSC_PF_CTLr BCMI_QTC_XGXS_READLN_DSC_PF_CTLr
#define WRITELN_DSC_PF_CTLr BCMI_QTC_XGXS_WRITELN_DSC_PF_CTLr
#define WRITEALL_DSC_PF_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_PF_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_PF_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_PF2_LOWP_CTL
 * BLOCKS:   DSC_E
 * REGADDR:  0xd042
 * DEVAD:    1
 * DESC:     dsc_e_pf2_lowp_ctrl
 * SIZE:     32
 * FIELDS:
 *     PF2_LOWP_CTRL    Low frequency peaking filter, low pass000 (Gray) - min peaking100 (Gray) - max peaking
 */
#define BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr (0x0001d042 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_PF2_LOWP_CTL.
 */
typedef union BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_pf2_lowp_ctl[1];
	uint32_t _dsc_pf2_lowp_ctl;
} BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_t;

#define BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_CLR(r) (r).dsc_pf2_lowp_ctl[0] = 0
#define BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_SET(r,d) (r).dsc_pf2_lowp_ctl[0] = d
#define BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_GET(r) (r).dsc_pf2_lowp_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_GET(r) (((r).dsc_pf2_lowp_ctl[0]) & 0x7)
#define BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_SET(r,f) (r).dsc_pf2_lowp_ctl[0]=(((r).dsc_pf2_lowp_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (7 << 16)

/*
 * These macros can be used to access DSC_PF2_LOWP_CTL.
 */
#define BCMI_QTC_XGXS_READ_DSC_PF2_LOWP_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr,(_r._dsc_pf2_lowp_ctl))
#define BCMI_QTC_XGXS_WRITE_DSC_PF2_LOWP_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr,(_r._dsc_pf2_lowp_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_PF2_LOWP_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr,(_r._dsc_pf2_lowp_ctl))
#define BCMI_QTC_XGXS_READLN_DSC_PF2_LOWP_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_pf2_lowp_ctl))
#define BCMI_QTC_XGXS_WRITELN_DSC_PF2_LOWP_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_pf2_lowp_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DSC_PF2_LOWP_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_pf2_lowp_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_PF2_LOWP_CTLr BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr
#define DSC_PF2_LOWP_CTLr_SIZE BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_SIZE
typedef BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_t DSC_PF2_LOWP_CTLr_t;
#define DSC_PF2_LOWP_CTLr_CLR BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_CLR
#define DSC_PF2_LOWP_CTLr_SET BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_SET
#define DSC_PF2_LOWP_CTLr_GET BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_GET
#define DSC_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_GET BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_GET
#define DSC_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_SET BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_SET
#define READ_DSC_PF2_LOWP_CTLr BCMI_QTC_XGXS_READ_DSC_PF2_LOWP_CTLr
#define WRITE_DSC_PF2_LOWP_CTLr BCMI_QTC_XGXS_WRITE_DSC_PF2_LOWP_CTLr
#define MODIFY_DSC_PF2_LOWP_CTLr BCMI_QTC_XGXS_MODIFY_DSC_PF2_LOWP_CTLr
#define READLN_DSC_PF2_LOWP_CTLr BCMI_QTC_XGXS_READLN_DSC_PF2_LOWP_CTLr
#define WRITELN_DSC_PF2_LOWP_CTLr BCMI_QTC_XGXS_WRITELN_DSC_PF2_LOWP_CTLr
#define WRITEALL_DSC_PF2_LOWP_CTLr BCMI_QTC_XGXS_WRITEALL_DSC_PF2_LOWP_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_PF2_LOWP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_OFFS_ADJ_DATA_ODD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd043
 * DEVAD:    1
 * DESC:     dsc_e_offset_adj_data_odd
 * SIZE:     32
 * FIELDS:
 *     DFE_OFFSET_ADJ_DATA_ODD 
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr (0x0001d043 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_OFFS_ADJ_DATA_ODD.
 */
typedef union BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_s {
	uint32_t v[1];
	uint32_t dsc_offs_adj_data_odd[1];
	uint32_t _dsc_offs_adj_data_odd;
} BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_t;

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_CLR(r) (r).dsc_offs_adj_data_odd[0] = 0
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_SET(r,d) (r).dsc_offs_adj_data_odd[0] = d
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_GET(r) (r).dsc_offs_adj_data_odd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_DFE_OFFSET_ADJ_DATA_ODDf_GET(r) (((r).dsc_offs_adj_data_odd[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_DFE_OFFSET_ADJ_DATA_ODDf_SET(r,f) (r).dsc_offs_adj_data_odd[0]=(((r).dsc_offs_adj_data_odd[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_OFFS_ADJ_DATA_ODD.
 */
#define BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_DATA_ODDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr,(_r._dsc_offs_adj_data_odd))
#define BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_DATA_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr,(_r._dsc_offs_adj_data_odd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_DATA_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr,(_r._dsc_offs_adj_data_odd))
#define BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_DATA_ODDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_data_odd))
#define BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_DATA_ODDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_data_odd))
#define BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_DATA_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_offs_adj_data_odd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_OFFS_ADJ_DATA_ODDr BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr
#define DSC_OFFS_ADJ_DATA_ODDr_SIZE BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_SIZE
typedef BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_t DSC_OFFS_ADJ_DATA_ODDr_t;
#define DSC_OFFS_ADJ_DATA_ODDr_CLR BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_CLR
#define DSC_OFFS_ADJ_DATA_ODDr_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_SET
#define DSC_OFFS_ADJ_DATA_ODDr_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_GET
#define DSC_OFFS_ADJ_DATA_ODDr_DFE_OFFSET_ADJ_DATA_ODDf_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_DFE_OFFSET_ADJ_DATA_ODDf_GET
#define DSC_OFFS_ADJ_DATA_ODDr_DFE_OFFSET_ADJ_DATA_ODDf_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr_DFE_OFFSET_ADJ_DATA_ODDf_SET
#define READ_DSC_OFFS_ADJ_DATA_ODDr BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_DATA_ODDr
#define WRITE_DSC_OFFS_ADJ_DATA_ODDr BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_DATA_ODDr
#define MODIFY_DSC_OFFS_ADJ_DATA_ODDr BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_DATA_ODDr
#define READLN_DSC_OFFS_ADJ_DATA_ODDr BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_DATA_ODDr
#define WRITELN_DSC_OFFS_ADJ_DATA_ODDr BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_DATA_ODDr
#define WRITEALL_DSC_OFFS_ADJ_DATA_ODDr BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_DATA_ODDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_ODDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_OFFS_ADJ_DATA_EVEN
 * BLOCKS:   DSC_E
 * REGADDR:  0xd044
 * DEVAD:    1
 * DESC:     dsc_e_offset_adj_data_even
 * SIZE:     32
 * FIELDS:
 *     DFE_OFFSET_ADJ_DATA_EVEN 
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr (0x0001d044 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_SIZE 4

/*
 * This structure should be used to declare and program DSC_OFFS_ADJ_DATA_EVEN.
 */
typedef union BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_s {
	uint32_t v[1];
	uint32_t dsc_offs_adj_data_even[1];
	uint32_t _dsc_offs_adj_data_even;
} BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_t;

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_CLR(r) (r).dsc_offs_adj_data_even[0] = 0
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_SET(r,d) (r).dsc_offs_adj_data_even[0] = d
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_GET(r) (r).dsc_offs_adj_data_even[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_DFE_OFFSET_ADJ_DATA_EVENf_GET(r) (((r).dsc_offs_adj_data_even[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_DFE_OFFSET_ADJ_DATA_EVENf_SET(r,f) (r).dsc_offs_adj_data_even[0]=(((r).dsc_offs_adj_data_even[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_OFFS_ADJ_DATA_EVEN.
 */
#define BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_DATA_EVENr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr,(_r._dsc_offs_adj_data_even))
#define BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_DATA_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr,(_r._dsc_offs_adj_data_even)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_DATA_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr,(_r._dsc_offs_adj_data_even))
#define BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_DATA_EVENr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_data_even))
#define BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_DATA_EVENr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_data_even))
#define BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_DATA_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_offs_adj_data_even))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_OFFS_ADJ_DATA_EVENr BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr
#define DSC_OFFS_ADJ_DATA_EVENr_SIZE BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_SIZE
typedef BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_t DSC_OFFS_ADJ_DATA_EVENr_t;
#define DSC_OFFS_ADJ_DATA_EVENr_CLR BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_CLR
#define DSC_OFFS_ADJ_DATA_EVENr_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_SET
#define DSC_OFFS_ADJ_DATA_EVENr_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_GET
#define DSC_OFFS_ADJ_DATA_EVENr_DFE_OFFSET_ADJ_DATA_EVENf_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_DFE_OFFSET_ADJ_DATA_EVENf_GET
#define DSC_OFFS_ADJ_DATA_EVENr_DFE_OFFSET_ADJ_DATA_EVENf_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr_DFE_OFFSET_ADJ_DATA_EVENf_SET
#define READ_DSC_OFFS_ADJ_DATA_EVENr BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_DATA_EVENr
#define WRITE_DSC_OFFS_ADJ_DATA_EVENr BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_DATA_EVENr
#define MODIFY_DSC_OFFS_ADJ_DATA_EVENr BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_DATA_EVENr
#define READLN_DSC_OFFS_ADJ_DATA_EVENr BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_DATA_EVENr
#define WRITELN_DSC_OFFS_ADJ_DATA_EVENr BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_DATA_EVENr
#define WRITEALL_DSC_OFFS_ADJ_DATA_EVENr BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_DATA_EVENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_OFFS_ADJ_DATA_EVENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_OFFS_ADJ_P1_ODD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd045
 * DEVAD:    1
 * DESC:     dsc_e_offset_adj_p1_odd
 * SIZE:     32
 * FIELDS:
 *     DFE_OFFSET_ADJ_P1_ODD 
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr (0x0001d045 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_OFFS_ADJ_P1_ODD.
 */
typedef union BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_s {
	uint32_t v[1];
	uint32_t dsc_offs_adj_p1_odd[1];
	uint32_t _dsc_offs_adj_p1_odd;
} BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_t;

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_CLR(r) (r).dsc_offs_adj_p1_odd[0] = 0
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_SET(r,d) (r).dsc_offs_adj_p1_odd[0] = d
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_GET(r) (r).dsc_offs_adj_p1_odd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_DFE_OFFSET_ADJ_P1_ODDf_GET(r) (((r).dsc_offs_adj_p1_odd[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_DFE_OFFSET_ADJ_P1_ODDf_SET(r,f) (r).dsc_offs_adj_p1_odd[0]=(((r).dsc_offs_adj_p1_odd[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_OFFS_ADJ_P1_ODD.
 */
#define BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_P1_ODDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr,(_r._dsc_offs_adj_p1_odd))
#define BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_P1_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr,(_r._dsc_offs_adj_p1_odd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_P1_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr,(_r._dsc_offs_adj_p1_odd))
#define BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_P1_ODDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_p1_odd))
#define BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_P1_ODDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_p1_odd))
#define BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_P1_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_offs_adj_p1_odd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_OFFS_ADJ_P1_ODDr BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr
#define DSC_OFFS_ADJ_P1_ODDr_SIZE BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_SIZE
typedef BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_t DSC_OFFS_ADJ_P1_ODDr_t;
#define DSC_OFFS_ADJ_P1_ODDr_CLR BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_CLR
#define DSC_OFFS_ADJ_P1_ODDr_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_SET
#define DSC_OFFS_ADJ_P1_ODDr_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_GET
#define DSC_OFFS_ADJ_P1_ODDr_DFE_OFFSET_ADJ_P1_ODDf_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_DFE_OFFSET_ADJ_P1_ODDf_GET
#define DSC_OFFS_ADJ_P1_ODDr_DFE_OFFSET_ADJ_P1_ODDf_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr_DFE_OFFSET_ADJ_P1_ODDf_SET
#define READ_DSC_OFFS_ADJ_P1_ODDr BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_P1_ODDr
#define WRITE_DSC_OFFS_ADJ_P1_ODDr BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_P1_ODDr
#define MODIFY_DSC_OFFS_ADJ_P1_ODDr BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_P1_ODDr
#define READLN_DSC_OFFS_ADJ_P1_ODDr BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_P1_ODDr
#define WRITELN_DSC_OFFS_ADJ_P1_ODDr BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_P1_ODDr
#define WRITEALL_DSC_OFFS_ADJ_P1_ODDr BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_P1_ODDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_ODDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_OFFS_ADJ_P1_EVEN
 * BLOCKS:   DSC_E
 * REGADDR:  0xd046
 * DEVAD:    1
 * DESC:     dsc_e_offset_adj_p1_even
 * SIZE:     32
 * FIELDS:
 *     DFE_OFFSET_ADJ_P1_EVEN 
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr (0x0001d046 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_SIZE 4

/*
 * This structure should be used to declare and program DSC_OFFS_ADJ_P1_EVEN.
 */
typedef union BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_s {
	uint32_t v[1];
	uint32_t dsc_offs_adj_p1_even[1];
	uint32_t _dsc_offs_adj_p1_even;
} BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_t;

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_CLR(r) (r).dsc_offs_adj_p1_even[0] = 0
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_SET(r,d) (r).dsc_offs_adj_p1_even[0] = d
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_GET(r) (r).dsc_offs_adj_p1_even[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_DFE_OFFSET_ADJ_P1_EVENf_GET(r) (((r).dsc_offs_adj_p1_even[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_DFE_OFFSET_ADJ_P1_EVENf_SET(r,f) (r).dsc_offs_adj_p1_even[0]=(((r).dsc_offs_adj_p1_even[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_OFFS_ADJ_P1_EVEN.
 */
#define BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_P1_EVENr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr,(_r._dsc_offs_adj_p1_even))
#define BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_P1_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr,(_r._dsc_offs_adj_p1_even)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_P1_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr,(_r._dsc_offs_adj_p1_even))
#define BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_P1_EVENr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_p1_even))
#define BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_P1_EVENr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_p1_even))
#define BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_P1_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_offs_adj_p1_even))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_OFFS_ADJ_P1_EVENr BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr
#define DSC_OFFS_ADJ_P1_EVENr_SIZE BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_SIZE
typedef BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_t DSC_OFFS_ADJ_P1_EVENr_t;
#define DSC_OFFS_ADJ_P1_EVENr_CLR BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_CLR
#define DSC_OFFS_ADJ_P1_EVENr_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_SET
#define DSC_OFFS_ADJ_P1_EVENr_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_GET
#define DSC_OFFS_ADJ_P1_EVENr_DFE_OFFSET_ADJ_P1_EVENf_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_DFE_OFFSET_ADJ_P1_EVENf_GET
#define DSC_OFFS_ADJ_P1_EVENr_DFE_OFFSET_ADJ_P1_EVENf_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr_DFE_OFFSET_ADJ_P1_EVENf_SET
#define READ_DSC_OFFS_ADJ_P1_EVENr BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_P1_EVENr
#define WRITE_DSC_OFFS_ADJ_P1_EVENr BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_P1_EVENr
#define MODIFY_DSC_OFFS_ADJ_P1_EVENr BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_P1_EVENr
#define READLN_DSC_OFFS_ADJ_P1_EVENr BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_P1_EVENr
#define WRITELN_DSC_OFFS_ADJ_P1_EVENr BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_P1_EVENr
#define WRITEALL_DSC_OFFS_ADJ_P1_EVENr BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_P1_EVENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_OFFS_ADJ_P1_EVENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_OFFS_ADJ_M1_ODD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd047
 * DEVAD:    1
 * DESC:     dsc_e_offset_adj_m1_odd
 * SIZE:     32
 * FIELDS:
 *     DFE_OFFSET_ADJ_M1_ODD 
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr (0x0001d047 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_OFFS_ADJ_M1_ODD.
 */
typedef union BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_s {
	uint32_t v[1];
	uint32_t dsc_offs_adj_m1_odd[1];
	uint32_t _dsc_offs_adj_m1_odd;
} BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_t;

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_CLR(r) (r).dsc_offs_adj_m1_odd[0] = 0
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_SET(r,d) (r).dsc_offs_adj_m1_odd[0] = d
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_GET(r) (r).dsc_offs_adj_m1_odd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_DFE_OFFSET_ADJ_M1_ODDf_GET(r) (((r).dsc_offs_adj_m1_odd[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_DFE_OFFSET_ADJ_M1_ODDf_SET(r,f) (r).dsc_offs_adj_m1_odd[0]=(((r).dsc_offs_adj_m1_odd[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_OFFS_ADJ_M1_ODD.
 */
#define BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_M1_ODDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr,(_r._dsc_offs_adj_m1_odd))
#define BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_M1_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr,(_r._dsc_offs_adj_m1_odd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_M1_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr,(_r._dsc_offs_adj_m1_odd))
#define BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_M1_ODDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_m1_odd))
#define BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_M1_ODDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_m1_odd))
#define BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_M1_ODDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_offs_adj_m1_odd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_OFFS_ADJ_M1_ODDr BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr
#define DSC_OFFS_ADJ_M1_ODDr_SIZE BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_SIZE
typedef BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_t DSC_OFFS_ADJ_M1_ODDr_t;
#define DSC_OFFS_ADJ_M1_ODDr_CLR BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_CLR
#define DSC_OFFS_ADJ_M1_ODDr_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_SET
#define DSC_OFFS_ADJ_M1_ODDr_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_GET
#define DSC_OFFS_ADJ_M1_ODDr_DFE_OFFSET_ADJ_M1_ODDf_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_DFE_OFFSET_ADJ_M1_ODDf_GET
#define DSC_OFFS_ADJ_M1_ODDr_DFE_OFFSET_ADJ_M1_ODDf_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr_DFE_OFFSET_ADJ_M1_ODDf_SET
#define READ_DSC_OFFS_ADJ_M1_ODDr BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_M1_ODDr
#define WRITE_DSC_OFFS_ADJ_M1_ODDr BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_M1_ODDr
#define MODIFY_DSC_OFFS_ADJ_M1_ODDr BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_M1_ODDr
#define READLN_DSC_OFFS_ADJ_M1_ODDr BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_M1_ODDr
#define WRITELN_DSC_OFFS_ADJ_M1_ODDr BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_M1_ODDr
#define WRITEALL_DSC_OFFS_ADJ_M1_ODDr BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_M1_ODDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_ODDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_OFFS_ADJ_M1_EVEN
 * BLOCKS:   DSC_E
 * REGADDR:  0xd048
 * DEVAD:    1
 * DESC:     dsc_e_offset_adj_m1_even
 * SIZE:     32
 * FIELDS:
 *     DFE_OFFSET_ADJ_M1_EVEN 
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr (0x0001d048 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_SIZE 4

/*
 * This structure should be used to declare and program DSC_OFFS_ADJ_M1_EVEN.
 */
typedef union BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_s {
	uint32_t v[1];
	uint32_t dsc_offs_adj_m1_even[1];
	uint32_t _dsc_offs_adj_m1_even;
} BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_t;

#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_CLR(r) (r).dsc_offs_adj_m1_even[0] = 0
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_SET(r,d) (r).dsc_offs_adj_m1_even[0] = d
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_GET(r) (r).dsc_offs_adj_m1_even[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_DFE_OFFSET_ADJ_M1_EVENf_GET(r) (((r).dsc_offs_adj_m1_even[0]) & 0x3f)
#define BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_DFE_OFFSET_ADJ_M1_EVENf_SET(r,f) (r).dsc_offs_adj_m1_even[0]=(((r).dsc_offs_adj_m1_even[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DSC_OFFS_ADJ_M1_EVEN.
 */
#define BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_M1_EVENr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr,(_r._dsc_offs_adj_m1_even))
#define BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_M1_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr,(_r._dsc_offs_adj_m1_even)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_M1_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr,(_r._dsc_offs_adj_m1_even))
#define BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_M1_EVENr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_m1_even))
#define BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_M1_EVENr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_offs_adj_m1_even))
#define BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_M1_EVENr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_offs_adj_m1_even))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_OFFS_ADJ_M1_EVENr BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr
#define DSC_OFFS_ADJ_M1_EVENr_SIZE BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_SIZE
typedef BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_t DSC_OFFS_ADJ_M1_EVENr_t;
#define DSC_OFFS_ADJ_M1_EVENr_CLR BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_CLR
#define DSC_OFFS_ADJ_M1_EVENr_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_SET
#define DSC_OFFS_ADJ_M1_EVENr_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_GET
#define DSC_OFFS_ADJ_M1_EVENr_DFE_OFFSET_ADJ_M1_EVENf_GET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_DFE_OFFSET_ADJ_M1_EVENf_GET
#define DSC_OFFS_ADJ_M1_EVENr_DFE_OFFSET_ADJ_M1_EVENf_SET BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr_DFE_OFFSET_ADJ_M1_EVENf_SET
#define READ_DSC_OFFS_ADJ_M1_EVENr BCMI_QTC_XGXS_READ_DSC_OFFS_ADJ_M1_EVENr
#define WRITE_DSC_OFFS_ADJ_M1_EVENr BCMI_QTC_XGXS_WRITE_DSC_OFFS_ADJ_M1_EVENr
#define MODIFY_DSC_OFFS_ADJ_M1_EVENr BCMI_QTC_XGXS_MODIFY_DSC_OFFS_ADJ_M1_EVENr
#define READLN_DSC_OFFS_ADJ_M1_EVENr BCMI_QTC_XGXS_READLN_DSC_OFFS_ADJ_M1_EVENr
#define WRITELN_DSC_OFFS_ADJ_M1_EVENr BCMI_QTC_XGXS_WRITELN_DSC_OFFS_ADJ_M1_EVENr
#define WRITEALL_DSC_OFFS_ADJ_M1_EVENr BCMI_QTC_XGXS_WRITEALL_DSC_OFFS_ADJ_M1_EVENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_OFFS_ADJ_M1_EVENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DSC_DC_OFFS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd049
 * DEVAD:    1
 * DESC:     dsc_e_dc_offset
 * SIZE:     32
 * FIELDS:
 *     DC_OFFSET        RX input DC offset cancellation controlapprox 0.75mV steps (nominal),+/- 50mV range at the EQ output.
 */
#define BCMI_QTC_XGXS_DSC_DC_OFFSr (0x0001d049 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DSC_DC_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS.
 */
typedef union BCMI_QTC_XGXS_DSC_DC_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs[1];
	uint32_t _dsc_dc_offs;
} BCMI_QTC_XGXS_DSC_DC_OFFSr_t;

#define BCMI_QTC_XGXS_DSC_DC_OFFSr_CLR(r) (r).dsc_dc_offs[0] = 0
#define BCMI_QTC_XGXS_DSC_DC_OFFSr_SET(r,d) (r).dsc_dc_offs[0] = d
#define BCMI_QTC_XGXS_DSC_DC_OFFSr_GET(r) (r).dsc_dc_offs[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DSC_DC_OFFSr_DC_OFFSETf_GET(r) (((r).dsc_dc_offs[0]) & 0x7f)
#define BCMI_QTC_XGXS_DSC_DC_OFFSr_DC_OFFSETf_SET(r,f) (r).dsc_dc_offs[0]=(((r).dsc_dc_offs[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access DSC_DC_OFFS.
 */
#define BCMI_QTC_XGXS_READ_DSC_DC_OFFSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DC_OFFSr,(_r._dsc_dc_offs))
#define BCMI_QTC_XGXS_WRITE_DSC_DC_OFFSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DC_OFFSr,(_r._dsc_dc_offs)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DSC_DC_OFFSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DC_OFFSr,(_r._dsc_dc_offs))
#define BCMI_QTC_XGXS_READLN_DSC_DC_OFFSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DSC_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs))
#define BCMI_QTC_XGXS_WRITELN_DSC_DC_OFFSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs))
#define BCMI_QTC_XGXS_WRITEALL_DSC_DC_OFFSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DSC_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dc_offs))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFSr BCMI_QTC_XGXS_DSC_DC_OFFSr
#define DSC_DC_OFFSr_SIZE BCMI_QTC_XGXS_DSC_DC_OFFSr_SIZE
typedef BCMI_QTC_XGXS_DSC_DC_OFFSr_t DSC_DC_OFFSr_t;
#define DSC_DC_OFFSr_CLR BCMI_QTC_XGXS_DSC_DC_OFFSr_CLR
#define DSC_DC_OFFSr_SET BCMI_QTC_XGXS_DSC_DC_OFFSr_SET
#define DSC_DC_OFFSr_GET BCMI_QTC_XGXS_DSC_DC_OFFSr_GET
#define DSC_DC_OFFSr_DC_OFFSETf_GET BCMI_QTC_XGXS_DSC_DC_OFFSr_DC_OFFSETf_GET
#define DSC_DC_OFFSr_DC_OFFSETf_SET BCMI_QTC_XGXS_DSC_DC_OFFSr_DC_OFFSETf_SET
#define READ_DSC_DC_OFFSr BCMI_QTC_XGXS_READ_DSC_DC_OFFSr
#define WRITE_DSC_DC_OFFSr BCMI_QTC_XGXS_WRITE_DSC_DC_OFFSr
#define MODIFY_DSC_DC_OFFSr BCMI_QTC_XGXS_MODIFY_DSC_DC_OFFSr
#define READLN_DSC_DC_OFFSr BCMI_QTC_XGXS_READLN_DSC_DC_OFFSr
#define WRITELN_DSC_DC_OFFSr BCMI_QTC_XGXS_WRITELN_DSC_DC_OFFSr
#define WRITEALL_DSC_DC_OFFSr BCMI_QTC_XGXS_WRITEALL_DSC_DC_OFFSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DSC_DC_OFFSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_RXRCVD_STS
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd050
 * DEVAD:    1
 * DESC:     CL72 Status Report Register
 * SIZE:     32
 * FIELDS:
 *     CL72_RCVD_STATUS_PAGE Link Partner (LP) status registerWhen the Micro's (uC) gpio (input) bit cl72_ready_for_cmdis asserted HIGH, the Micro shall read this registerin order to retrieve the cl72_rcvd_status_page[15:0]word.Refer to standard IEEE802.3ap-2007; Table-72-5 for details
 */
#define BCMI_QTC_XGXS_CL72_RXRCVD_STSr (0x0001d050 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_RXRCVD_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL72_RXRCVD_STS.
 */
typedef union BCMI_QTC_XGXS_CL72_RXRCVD_STSr_s {
	uint32_t v[1];
	uint32_t cl72_rxrcvd_sts[1];
	uint32_t _cl72_rxrcvd_sts;
} BCMI_QTC_XGXS_CL72_RXRCVD_STSr_t;

#define BCMI_QTC_XGXS_CL72_RXRCVD_STSr_CLR(r) (r).cl72_rxrcvd_sts[0] = 0
#define BCMI_QTC_XGXS_CL72_RXRCVD_STSr_SET(r,d) (r).cl72_rxrcvd_sts[0] = d
#define BCMI_QTC_XGXS_CL72_RXRCVD_STSr_GET(r) (r).cl72_rxrcvd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_RXRCVD_STSr_CL72_RCVD_STATUS_PAGEf_GET(r) (((r).cl72_rxrcvd_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_RXRCVD_STSr_CL72_RCVD_STATUS_PAGEf_SET(r,f) (r).cl72_rxrcvd_sts[0]=(((r).cl72_rxrcvd_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_RXRCVD_STS.
 */
#define BCMI_QTC_XGXS_READ_CL72_RXRCVD_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXRCVD_STSr,(_r._cl72_rxrcvd_sts))
#define BCMI_QTC_XGXS_WRITE_CL72_RXRCVD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXRCVD_STSr,(_r._cl72_rxrcvd_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_RXRCVD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXRCVD_STSr,(_r._cl72_rxrcvd_sts))
#define BCMI_QTC_XGXS_READLN_CL72_RXRCVD_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXRCVD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxrcvd_sts))
#define BCMI_QTC_XGXS_WRITELN_CL72_RXRCVD_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXRCVD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxrcvd_sts))
#define BCMI_QTC_XGXS_WRITEALL_CL72_RXRCVD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXRCVD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_rxrcvd_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_RXRCVD_STSr BCMI_QTC_XGXS_CL72_RXRCVD_STSr
#define CL72_RXRCVD_STSr_SIZE BCMI_QTC_XGXS_CL72_RXRCVD_STSr_SIZE
typedef BCMI_QTC_XGXS_CL72_RXRCVD_STSr_t CL72_RXRCVD_STSr_t;
#define CL72_RXRCVD_STSr_CLR BCMI_QTC_XGXS_CL72_RXRCVD_STSr_CLR
#define CL72_RXRCVD_STSr_SET BCMI_QTC_XGXS_CL72_RXRCVD_STSr_SET
#define CL72_RXRCVD_STSr_GET BCMI_QTC_XGXS_CL72_RXRCVD_STSr_GET
#define CL72_RXRCVD_STSr_CL72_RCVD_STATUS_PAGEf_GET BCMI_QTC_XGXS_CL72_RXRCVD_STSr_CL72_RCVD_STATUS_PAGEf_GET
#define CL72_RXRCVD_STSr_CL72_RCVD_STATUS_PAGEf_SET BCMI_QTC_XGXS_CL72_RXRCVD_STSr_CL72_RCVD_STATUS_PAGEf_SET
#define READ_CL72_RXRCVD_STSr BCMI_QTC_XGXS_READ_CL72_RXRCVD_STSr
#define WRITE_CL72_RXRCVD_STSr BCMI_QTC_XGXS_WRITE_CL72_RXRCVD_STSr
#define MODIFY_CL72_RXRCVD_STSr BCMI_QTC_XGXS_MODIFY_CL72_RXRCVD_STSr
#define READLN_CL72_RXRCVD_STSr BCMI_QTC_XGXS_READLN_CL72_RXRCVD_STSr
#define WRITELN_CL72_RXRCVD_STSr BCMI_QTC_XGXS_WRITELN_CL72_RXRCVD_STSr
#define WRITEALL_CL72_RXRCVD_STSr BCMI_QTC_XGXS_WRITEALL_CL72_RXRCVD_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_RXRCVD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_RXMISC1_CTL
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd051
 * DEVAD:    1
 * DESC:     CL72 Miscellaneous_1 Control Register
 * SIZE:     32
 * FIELDS:
 *     CL72_TR_COARSE_LOCK Set to TRUE (1'b1) by the micro when coarse lock to recovered clock has occured.Cl72_pmd, then, proceeds with establishing frame_lock.
 *     CL72_RX_DP_LN_CLK_EN Cl72 Rx datapath lane clock enable0 - disabled1 - enabled
 */
#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr (0x0001d051 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_RXMISC1_CTL.
 */
typedef union BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_s {
	uint32_t v[1];
	uint32_t cl72_rxmisc1_ctl[1];
	uint32_t _cl72_rxmisc1_ctl;
} BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_t;

#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CLR(r) (r).cl72_rxmisc1_ctl[0] = 0
#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_SET(r,d) (r).cl72_rxmisc1_ctl[0] = d
#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_GET(r) (r).cl72_rxmisc1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_RX_DP_LN_CLK_ENf_GET(r) ((((r).cl72_rxmisc1_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_RX_DP_LN_CLK_ENf_SET(r,f) (r).cl72_rxmisc1_ctl[0]=(((r).cl72_rxmisc1_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_TR_COARSE_LOCKf_GET(r) ((((r).cl72_rxmisc1_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_TR_COARSE_LOCKf_SET(r,f) (r).cl72_rxmisc1_ctl[0]=(((r).cl72_rxmisc1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access CL72_RXMISC1_CTL.
 */
#define BCMI_QTC_XGXS_READ_CL72_RXMISC1_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXMISC1_CTLr,(_r._cl72_rxmisc1_ctl))
#define BCMI_QTC_XGXS_WRITE_CL72_RXMISC1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXMISC1_CTLr,(_r._cl72_rxmisc1_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_RXMISC1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXMISC1_CTLr,(_r._cl72_rxmisc1_ctl))
#define BCMI_QTC_XGXS_READLN_CL72_RXMISC1_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXMISC1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxmisc1_ctl))
#define BCMI_QTC_XGXS_WRITELN_CL72_RXMISC1_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXMISC1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxmisc1_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CL72_RXMISC1_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXMISC1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_rxmisc1_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_RXMISC1_CTLr BCMI_QTC_XGXS_CL72_RXMISC1_CTLr
#define CL72_RXMISC1_CTLr_SIZE BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_SIZE
typedef BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_t CL72_RXMISC1_CTLr_t;
#define CL72_RXMISC1_CTLr_CLR BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CLR
#define CL72_RXMISC1_CTLr_SET BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_SET
#define CL72_RXMISC1_CTLr_GET BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_GET
#define CL72_RXMISC1_CTLr_CL72_RX_DP_LN_CLK_ENf_GET BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_RX_DP_LN_CLK_ENf_GET
#define CL72_RXMISC1_CTLr_CL72_RX_DP_LN_CLK_ENf_SET BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_RX_DP_LN_CLK_ENf_SET
#define CL72_RXMISC1_CTLr_CL72_TR_COARSE_LOCKf_GET BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_TR_COARSE_LOCKf_GET
#define CL72_RXMISC1_CTLr_CL72_TR_COARSE_LOCKf_SET BCMI_QTC_XGXS_CL72_RXMISC1_CTLr_CL72_TR_COARSE_LOCKf_SET
#define READ_CL72_RXMISC1_CTLr BCMI_QTC_XGXS_READ_CL72_RXMISC1_CTLr
#define WRITE_CL72_RXMISC1_CTLr BCMI_QTC_XGXS_WRITE_CL72_RXMISC1_CTLr
#define MODIFY_CL72_RXMISC1_CTLr BCMI_QTC_XGXS_MODIFY_CL72_RXMISC1_CTLr
#define READLN_CL72_RXMISC1_CTLr BCMI_QTC_XGXS_READLN_CL72_RXMISC1_CTLr
#define WRITELN_CL72_RXMISC1_CTLr BCMI_QTC_XGXS_WRITELN_CL72_RXMISC1_CTLr
#define WRITEALL_CL72_RXMISC1_CTLr BCMI_QTC_XGXS_WRITEALL_CL72_RXMISC1_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_RXMISC1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_RXDBG2
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd052
 * DEVAD:    1
 * DESC:     CL72 Debug 2 Register
 * SIZE:     32
 * FIELDS:
 *     CL72_GOOD_MARKER_CNT Number of good marker to checkbefore enabling frame lock
 *     CL72_BAD_MARKER_CNT Number of bad marker to checkbefore losing frame lock
 *     CL72_DME_CELL_BOUNDARY_CHK Check for DME cell boundary transitions
 *     CL72_CTRL_FRAME_DLY 0   : dis1-7 : early delay w.r.t cl72 rcvd data (7 vals)8  : sync to cl72 rcvd data9-15 : late delay w.r.t cl72 rcvd data (7 vals)
 *     CL72_STRICT_DME_CHK Check for std. specified dme
 *     CL72_STRICT_MARKER_CHK Check for std. specified marker
 *     CL72_PPM_OFFSET_EN if enabled, cl72 tracks ppm offset of incoming datawhile checking from frame lock, one bit offset ineither direction for every frame (~4384 bits)
 */
#define BCMI_QTC_XGXS_CL72_RXDBG2r (0x0001d052 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_RXDBG2r_SIZE 4

/*
 * This structure should be used to declare and program CL72_RXDBG2.
 */
typedef union BCMI_QTC_XGXS_CL72_RXDBG2r_s {
	uint32_t v[1];
	uint32_t cl72_rxdbg2[1];
	uint32_t _cl72_rxdbg2;
} BCMI_QTC_XGXS_CL72_RXDBG2r_t;

#define BCMI_QTC_XGXS_CL72_RXDBG2r_CLR(r) (r).cl72_rxdbg2[0] = 0
#define BCMI_QTC_XGXS_CL72_RXDBG2r_SET(r,d) (r).cl72_rxdbg2[0] = d
#define BCMI_QTC_XGXS_CL72_RXDBG2r_GET(r) (r).cl72_rxdbg2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_PPM_OFFSET_ENf_GET(r) ((((r).cl72_rxdbg2[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_PPM_OFFSET_ENf_SET(r,f) (r).cl72_rxdbg2[0]=(((r).cl72_rxdbg2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_MARKER_CHKf_GET(r) ((((r).cl72_rxdbg2[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_MARKER_CHKf_SET(r,f) (r).cl72_rxdbg2[0]=(((r).cl72_rxdbg2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_DME_CHKf_GET(r) ((((r).cl72_rxdbg2[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_DME_CHKf_SET(r,f) (r).cl72_rxdbg2[0]=(((r).cl72_rxdbg2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_CTRL_FRAME_DLYf_GET(r) ((((r).cl72_rxdbg2[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_CTRL_FRAME_DLYf_SET(r,f) (r).cl72_rxdbg2[0]=(((r).cl72_rxdbg2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_DME_CELL_BOUNDARY_CHKf_GET(r) ((((r).cl72_rxdbg2[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_DME_CELL_BOUNDARY_CHKf_SET(r,f) (r).cl72_rxdbg2[0]=(((r).cl72_rxdbg2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_BAD_MARKER_CNTf_GET(r) ((((r).cl72_rxdbg2[0]) >> 2) & 0x7)
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_BAD_MARKER_CNTf_SET(r,f) (r).cl72_rxdbg2[0]=(((r).cl72_rxdbg2[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_GOOD_MARKER_CNTf_GET(r) (((r).cl72_rxdbg2[0]) & 0x3)
#define BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_GOOD_MARKER_CNTf_SET(r,f) (r).cl72_rxdbg2[0]=(((r).cl72_rxdbg2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access CL72_RXDBG2.
 */
#define BCMI_QTC_XGXS_READ_CL72_RXDBG2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXDBG2r,(_r._cl72_rxdbg2))
#define BCMI_QTC_XGXS_WRITE_CL72_RXDBG2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXDBG2r,(_r._cl72_rxdbg2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_RXDBG2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXDBG2r,(_r._cl72_rxdbg2))
#define BCMI_QTC_XGXS_READLN_CL72_RXDBG2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXDBG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxdbg2))
#define BCMI_QTC_XGXS_WRITELN_CL72_RXDBG2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXDBG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxdbg2))
#define BCMI_QTC_XGXS_WRITEALL_CL72_RXDBG2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXDBG2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_rxdbg2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_RXDBG2r BCMI_QTC_XGXS_CL72_RXDBG2r
#define CL72_RXDBG2r_SIZE BCMI_QTC_XGXS_CL72_RXDBG2r_SIZE
typedef BCMI_QTC_XGXS_CL72_RXDBG2r_t CL72_RXDBG2r_t;
#define CL72_RXDBG2r_CLR BCMI_QTC_XGXS_CL72_RXDBG2r_CLR
#define CL72_RXDBG2r_SET BCMI_QTC_XGXS_CL72_RXDBG2r_SET
#define CL72_RXDBG2r_GET BCMI_QTC_XGXS_CL72_RXDBG2r_GET
#define CL72_RXDBG2r_CL72_PPM_OFFSET_ENf_GET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_PPM_OFFSET_ENf_GET
#define CL72_RXDBG2r_CL72_PPM_OFFSET_ENf_SET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_PPM_OFFSET_ENf_SET
#define CL72_RXDBG2r_CL72_STRICT_MARKER_CHKf_GET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_MARKER_CHKf_GET
#define CL72_RXDBG2r_CL72_STRICT_MARKER_CHKf_SET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_MARKER_CHKf_SET
#define CL72_RXDBG2r_CL72_STRICT_DME_CHKf_GET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_DME_CHKf_GET
#define CL72_RXDBG2r_CL72_STRICT_DME_CHKf_SET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_STRICT_DME_CHKf_SET
#define CL72_RXDBG2r_CL72_CTRL_FRAME_DLYf_GET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_CTRL_FRAME_DLYf_GET
#define CL72_RXDBG2r_CL72_CTRL_FRAME_DLYf_SET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_CTRL_FRAME_DLYf_SET
#define CL72_RXDBG2r_CL72_DME_CELL_BOUNDARY_CHKf_GET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_DME_CELL_BOUNDARY_CHKf_GET
#define CL72_RXDBG2r_CL72_DME_CELL_BOUNDARY_CHKf_SET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_DME_CELL_BOUNDARY_CHKf_SET
#define CL72_RXDBG2r_CL72_BAD_MARKER_CNTf_GET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_BAD_MARKER_CNTf_GET
#define CL72_RXDBG2r_CL72_BAD_MARKER_CNTf_SET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_BAD_MARKER_CNTf_SET
#define CL72_RXDBG2r_CL72_GOOD_MARKER_CNTf_GET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_GOOD_MARKER_CNTf_GET
#define CL72_RXDBG2r_CL72_GOOD_MARKER_CNTf_SET BCMI_QTC_XGXS_CL72_RXDBG2r_CL72_GOOD_MARKER_CNTf_SET
#define READ_CL72_RXDBG2r BCMI_QTC_XGXS_READ_CL72_RXDBG2r
#define WRITE_CL72_RXDBG2r BCMI_QTC_XGXS_WRITE_CL72_RXDBG2r
#define MODIFY_CL72_RXDBG2r BCMI_QTC_XGXS_MODIFY_CL72_RXDBG2r
#define READLN_CL72_RXDBG2r BCMI_QTC_XGXS_READLN_CL72_RXDBG2r
#define WRITELN_CL72_RXDBG2r BCMI_QTC_XGXS_WRITELN_CL72_RXDBG2r
#define WRITEALL_CL72_RXDBG2r BCMI_QTC_XGXS_WRITEALL_CL72_RXDBG2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_RXDBG2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_RXCL72_LP_CTL_PAGE
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd053
 * DEVAD:    1
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CL72_LP_CONTROL_PAGE Control cage received from the LP
 */
#define BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr (0x0001d053 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL72_RXCL72_LP_CTL_PAGE.
 */
typedef union BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_s {
	uint32_t v[1];
	uint32_t cl72_rxcl72_lp_ctl_page[1];
	uint32_t _cl72_rxcl72_lp_ctl_page;
} BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_t;

#define BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_CLR(r) (r).cl72_rxcl72_lp_ctl_page[0] = 0
#define BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_SET(r,d) (r).cl72_rxcl72_lp_ctl_page[0] = d
#define BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_GET(r) (r).cl72_rxcl72_lp_ctl_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_CL72_LP_CONTROL_PAGEf_GET(r) (((r).cl72_rxcl72_lp_ctl_page[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_CL72_LP_CONTROL_PAGEf_SET(r,f) (r).cl72_rxcl72_lp_ctl_page[0]=(((r).cl72_rxcl72_lp_ctl_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_RXCL72_LP_CTL_PAGE.
 */
#define BCMI_QTC_XGXS_READ_CL72_RXCL72_LP_CTL_PAGEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr,(_r._cl72_rxcl72_lp_ctl_page))
#define BCMI_QTC_XGXS_WRITE_CL72_RXCL72_LP_CTL_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr,(_r._cl72_rxcl72_lp_ctl_page)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_RXCL72_LP_CTL_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr,(_r._cl72_rxcl72_lp_ctl_page))
#define BCMI_QTC_XGXS_READLN_CL72_RXCL72_LP_CTL_PAGEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxcl72_lp_ctl_page))
#define BCMI_QTC_XGXS_WRITELN_CL72_RXCL72_LP_CTL_PAGEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxcl72_lp_ctl_page))
#define BCMI_QTC_XGXS_WRITEALL_CL72_RXCL72_LP_CTL_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_rxcl72_lp_ctl_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_RXCL72_LP_CTL_PAGEr BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr
#define CL72_RXCL72_LP_CTL_PAGEr_SIZE BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_SIZE
typedef BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_t CL72_RXCL72_LP_CTL_PAGEr_t;
#define CL72_RXCL72_LP_CTL_PAGEr_CLR BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_CLR
#define CL72_RXCL72_LP_CTL_PAGEr_SET BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_SET
#define CL72_RXCL72_LP_CTL_PAGEr_GET BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_GET
#define CL72_RXCL72_LP_CTL_PAGEr_CL72_LP_CONTROL_PAGEf_GET BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_CL72_LP_CONTROL_PAGEf_GET
#define CL72_RXCL72_LP_CTL_PAGEr_CL72_LP_CONTROL_PAGEf_SET BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr_CL72_LP_CONTROL_PAGEf_SET
#define READ_CL72_RXCL72_LP_CTL_PAGEr BCMI_QTC_XGXS_READ_CL72_RXCL72_LP_CTL_PAGEr
#define WRITE_CL72_RXCL72_LP_CTL_PAGEr BCMI_QTC_XGXS_WRITE_CL72_RXCL72_LP_CTL_PAGEr
#define MODIFY_CL72_RXCL72_LP_CTL_PAGEr BCMI_QTC_XGXS_MODIFY_CL72_RXCL72_LP_CTL_PAGEr
#define READLN_CL72_RXCL72_LP_CTL_PAGEr BCMI_QTC_XGXS_READLN_CL72_RXCL72_LP_CTL_PAGEr
#define WRITELN_CL72_RXCL72_LP_CTL_PAGEr BCMI_QTC_XGXS_WRITELN_CL72_RXCL72_LP_CTL_PAGEr
#define WRITEALL_CL72_RXCL72_LP_CTL_PAGEr BCMI_QTC_XGXS_WRITEALL_CL72_RXCL72_LP_CTL_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_RXCL72_LP_CTL_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_RXCL72_STS1
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd054
 * DEVAD:    1
 * DESC:     CL72 Status 1 Register
 * SIZE:     32
 * FIELDS:
 *     CL72_SIGNAL_DETECT 1 - CL72 is in SEND_DATA state0 - CL72 is in training state
 */
#define BCMI_QTC_XGXS_CL72_RXCL72_STS1r (0x0001d054 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_RXCL72_STS1r_SIZE 4

/*
 * This structure should be used to declare and program CL72_RXCL72_STS1.
 */
typedef union BCMI_QTC_XGXS_CL72_RXCL72_STS1r_s {
	uint32_t v[1];
	uint32_t cl72_rxcl72_sts1[1];
	uint32_t _cl72_rxcl72_sts1;
} BCMI_QTC_XGXS_CL72_RXCL72_STS1r_t;

#define BCMI_QTC_XGXS_CL72_RXCL72_STS1r_CLR(r) (r).cl72_rxcl72_sts1[0] = 0
#define BCMI_QTC_XGXS_CL72_RXCL72_STS1r_SET(r,d) (r).cl72_rxcl72_sts1[0] = d
#define BCMI_QTC_XGXS_CL72_RXCL72_STS1r_GET(r) (r).cl72_rxcl72_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_RXCL72_STS1r_CL72_SIGNAL_DETECTf_GET(r) (((r).cl72_rxcl72_sts1[0]) & 0x1)
#define BCMI_QTC_XGXS_CL72_RXCL72_STS1r_CL72_SIGNAL_DETECTf_SET(r,f) (r).cl72_rxcl72_sts1[0]=(((r).cl72_rxcl72_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL72_RXCL72_STS1.
 */
#define BCMI_QTC_XGXS_READ_CL72_RXCL72_STS1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXCL72_STS1r,(_r._cl72_rxcl72_sts1))
#define BCMI_QTC_XGXS_WRITE_CL72_RXCL72_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_STS1r,(_r._cl72_rxcl72_sts1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_RXCL72_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_STS1r,(_r._cl72_rxcl72_sts1))
#define BCMI_QTC_XGXS_READLN_CL72_RXCL72_STS1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_RXCL72_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxcl72_sts1))
#define BCMI_QTC_XGXS_WRITELN_CL72_RXCL72_STS1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_rxcl72_sts1))
#define BCMI_QTC_XGXS_WRITEALL_CL72_RXCL72_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_RXCL72_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_rxcl72_sts1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_RXCL72_STS1r BCMI_QTC_XGXS_CL72_RXCL72_STS1r
#define CL72_RXCL72_STS1r_SIZE BCMI_QTC_XGXS_CL72_RXCL72_STS1r_SIZE
typedef BCMI_QTC_XGXS_CL72_RXCL72_STS1r_t CL72_RXCL72_STS1r_t;
#define CL72_RXCL72_STS1r_CLR BCMI_QTC_XGXS_CL72_RXCL72_STS1r_CLR
#define CL72_RXCL72_STS1r_SET BCMI_QTC_XGXS_CL72_RXCL72_STS1r_SET
#define CL72_RXCL72_STS1r_GET BCMI_QTC_XGXS_CL72_RXCL72_STS1r_GET
#define CL72_RXCL72_STS1r_CL72_SIGNAL_DETECTf_GET BCMI_QTC_XGXS_CL72_RXCL72_STS1r_CL72_SIGNAL_DETECTf_GET
#define CL72_RXCL72_STS1r_CL72_SIGNAL_DETECTf_SET BCMI_QTC_XGXS_CL72_RXCL72_STS1r_CL72_SIGNAL_DETECTf_SET
#define READ_CL72_RXCL72_STS1r BCMI_QTC_XGXS_READ_CL72_RXCL72_STS1r
#define WRITE_CL72_RXCL72_STS1r BCMI_QTC_XGXS_WRITE_CL72_RXCL72_STS1r
#define MODIFY_CL72_RXCL72_STS1r BCMI_QTC_XGXS_MODIFY_CL72_RXCL72_STS1r
#define READLN_CL72_RXCL72_STS1r BCMI_QTC_XGXS_READLN_CL72_RXCL72_STS1r
#define WRITELN_CL72_RXCL72_STS1r BCMI_QTC_XGXS_WRITELN_CL72_RXCL72_STS1r
#define WRITEALL_CL72_RXCL72_STS1r BCMI_QTC_XGXS_WRITEALL_CL72_RXCL72_STS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_RXCL72_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXXMT_UPD
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd060
 * DEVAD:    1
 * DESC:     CL72 TX Coefficient Update Register
 * SIZE:     32
 * FIELDS:
 *     CL72_XMT_UPDATE_PAGE Local Device (LD) Coefficient Update registerContains correction information from the local receiverto the link partner transmit equalizer.Bit15   Indicates Micro has written a new value to thiscl72_xmt_update_page registers, and signals thethe cl72_pmd_tx module to process this new command.NOTE: Bit-15 is Reserved per the standard; therefore,it is set to 1'b0 in the transmitted frame.14   Reserved Transmitted as 0, ignored on reception.13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved Transmitted as 0, ignored on reception.5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_QTC_XGXS_CL72_TXXMT_UPDr (0x0001d060 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXXMT_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXXMT_UPD.
 */
typedef union BCMI_QTC_XGXS_CL72_TXXMT_UPDr_s {
	uint32_t v[1];
	uint32_t cl72_txxmt_upd[1];
	uint32_t _cl72_txxmt_upd;
} BCMI_QTC_XGXS_CL72_TXXMT_UPDr_t;

#define BCMI_QTC_XGXS_CL72_TXXMT_UPDr_CLR(r) (r).cl72_txxmt_upd[0] = 0
#define BCMI_QTC_XGXS_CL72_TXXMT_UPDr_SET(r,d) (r).cl72_txxmt_upd[0] = d
#define BCMI_QTC_XGXS_CL72_TXXMT_UPDr_GET(r) (r).cl72_txxmt_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXXMT_UPDr_CL72_XMT_UPDATE_PAGEf_GET(r) (((r).cl72_txxmt_upd[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_TXXMT_UPDr_CL72_XMT_UPDATE_PAGEf_SET(r,f) (r).cl72_txxmt_upd[0]=(((r).cl72_txxmt_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_TXXMT_UPD.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXXMT_UPDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXXMT_UPDr,(_r._cl72_txxmt_upd))
#define BCMI_QTC_XGXS_WRITE_CL72_TXXMT_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXXMT_UPDr,(_r._cl72_txxmt_upd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXXMT_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXXMT_UPDr,(_r._cl72_txxmt_upd))
#define BCMI_QTC_XGXS_READLN_CL72_TXXMT_UPDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXXMT_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txxmt_upd))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXXMT_UPDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXXMT_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txxmt_upd))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXXMT_UPDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXXMT_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txxmt_upd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXXMT_UPDr BCMI_QTC_XGXS_CL72_TXXMT_UPDr
#define CL72_TXXMT_UPDr_SIZE BCMI_QTC_XGXS_CL72_TXXMT_UPDr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXXMT_UPDr_t CL72_TXXMT_UPDr_t;
#define CL72_TXXMT_UPDr_CLR BCMI_QTC_XGXS_CL72_TXXMT_UPDr_CLR
#define CL72_TXXMT_UPDr_SET BCMI_QTC_XGXS_CL72_TXXMT_UPDr_SET
#define CL72_TXXMT_UPDr_GET BCMI_QTC_XGXS_CL72_TXXMT_UPDr_GET
#define CL72_TXXMT_UPDr_CL72_XMT_UPDATE_PAGEf_GET BCMI_QTC_XGXS_CL72_TXXMT_UPDr_CL72_XMT_UPDATE_PAGEf_GET
#define CL72_TXXMT_UPDr_CL72_XMT_UPDATE_PAGEf_SET BCMI_QTC_XGXS_CL72_TXXMT_UPDr_CL72_XMT_UPDATE_PAGEf_SET
#define READ_CL72_TXXMT_UPDr BCMI_QTC_XGXS_READ_CL72_TXXMT_UPDr
#define WRITE_CL72_TXXMT_UPDr BCMI_QTC_XGXS_WRITE_CL72_TXXMT_UPDr
#define MODIFY_CL72_TXXMT_UPDr BCMI_QTC_XGXS_MODIFY_CL72_TXXMT_UPDr
#define READLN_CL72_TXXMT_UPDr BCMI_QTC_XGXS_READLN_CL72_TXXMT_UPDr
#define WRITELN_CL72_TXXMT_UPDr BCMI_QTC_XGXS_WRITELN_CL72_TXXMT_UPDr
#define WRITEALL_CL72_TXXMT_UPDr BCMI_QTC_XGXS_WRITEALL_CL72_TXXMT_UPDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXXMT_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXMISC2_CTL
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd061
 * DEVAD:    1
 * DESC:     CL72 Miscellaneous_2 Control Register
 * SIZE:     32
 * FIELDS:
 *     CL72_RX_TRAINED  Set to TRUE (1'b1) by the micro when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     CL72_SIGNAL_DET_FRC override control for signal detect for cl72
 *     CL72_TX_DP_LN_CLK_EN Cl72 Tx Datapath lane clock enable0 - disabled1 - enabled
 */
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr (0x0001d061 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXMISC2_CTL.
 */
typedef union BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_s {
	uint32_t v[1];
	uint32_t cl72_txmisc2_ctl[1];
	uint32_t _cl72_txmisc2_ctl;
} BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_t;

#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CLR(r) (r).cl72_txmisc2_ctl[0] = 0
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_SET(r,d) (r).cl72_txmisc2_ctl[0] = d
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_GET(r) (r).cl72_txmisc2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_TX_DP_LN_CLK_ENf_GET(r) ((((r).cl72_txmisc2_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_TX_DP_LN_CLK_ENf_SET(r,f) (r).cl72_txmisc2_ctl[0]=(((r).cl72_txmisc2_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_SIGNAL_DET_FRCf_GET(r) ((((r).cl72_txmisc2_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_SIGNAL_DET_FRCf_SET(r,f) (r).cl72_txmisc2_ctl[0]=(((r).cl72_txmisc2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_RX_TRAINEDf_GET(r) (((r).cl72_txmisc2_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_RX_TRAINEDf_SET(r,f) (r).cl72_txmisc2_ctl[0]=(((r).cl72_txmisc2_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL72_TXMISC2_CTL.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXMISC2_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXMISC2_CTLr,(_r._cl72_txmisc2_ctl))
#define BCMI_QTC_XGXS_WRITE_CL72_TXMISC2_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC2_CTLr,(_r._cl72_txmisc2_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXMISC2_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC2_CTLr,(_r._cl72_txmisc2_ctl))
#define BCMI_QTC_XGXS_READLN_CL72_TXMISC2_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXMISC2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txmisc2_ctl))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXMISC2_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txmisc2_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXMISC2_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txmisc2_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXMISC2_CTLr BCMI_QTC_XGXS_CL72_TXMISC2_CTLr
#define CL72_TXMISC2_CTLr_SIZE BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_t CL72_TXMISC2_CTLr_t;
#define CL72_TXMISC2_CTLr_CLR BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CLR
#define CL72_TXMISC2_CTLr_SET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_SET
#define CL72_TXMISC2_CTLr_GET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_GET
#define CL72_TXMISC2_CTLr_CL72_TX_DP_LN_CLK_ENf_GET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_TX_DP_LN_CLK_ENf_GET
#define CL72_TXMISC2_CTLr_CL72_TX_DP_LN_CLK_ENf_SET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_TX_DP_LN_CLK_ENf_SET
#define CL72_TXMISC2_CTLr_CL72_SIGNAL_DET_FRCf_GET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_SIGNAL_DET_FRCf_GET
#define CL72_TXMISC2_CTLr_CL72_SIGNAL_DET_FRCf_SET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_SIGNAL_DET_FRCf_SET
#define CL72_TXMISC2_CTLr_CL72_RX_TRAINEDf_GET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_RX_TRAINEDf_GET
#define CL72_TXMISC2_CTLr_CL72_RX_TRAINEDf_SET BCMI_QTC_XGXS_CL72_TXMISC2_CTLr_CL72_RX_TRAINEDf_SET
#define READ_CL72_TXMISC2_CTLr BCMI_QTC_XGXS_READ_CL72_TXMISC2_CTLr
#define WRITE_CL72_TXMISC2_CTLr BCMI_QTC_XGXS_WRITE_CL72_TXMISC2_CTLr
#define MODIFY_CL72_TXMISC2_CTLr BCMI_QTC_XGXS_MODIFY_CL72_TXMISC2_CTLr
#define READLN_CL72_TXMISC2_CTLr BCMI_QTC_XGXS_READLN_CL72_TXMISC2_CTLr
#define WRITELN_CL72_TXMISC2_CTLr BCMI_QTC_XGXS_WRITELN_CL72_TXMISC2_CTLr
#define WRITEALL_CL72_TXMISC2_CTLr BCMI_QTC_XGXS_WRITEALL_CL72_TXMISC2_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXMISC2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXDBG3
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd062
 * DEVAD:    1
 * DESC:     CL72 Debug 3 Register
 * SIZE:     32
 * FIELDS:
 *     CL72_BRK_RING_OSC PRBS 11 Ring Oscillator control1: No oscillating - low power mode0: Osciallate - normal mode
 *     CL72_FRAME_LOCK_RDY_FOR_CMD_EN Ready for command based on frame lock detection1: enabled0: disabled
 */
#define BCMI_QTC_XGXS_CL72_TXDBG3r (0x0001d062 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXDBG3r_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXDBG3.
 */
typedef union BCMI_QTC_XGXS_CL72_TXDBG3r_s {
	uint32_t v[1];
	uint32_t cl72_txdbg3[1];
	uint32_t _cl72_txdbg3;
} BCMI_QTC_XGXS_CL72_TXDBG3r_t;

#define BCMI_QTC_XGXS_CL72_TXDBG3r_CLR(r) (r).cl72_txdbg3[0] = 0
#define BCMI_QTC_XGXS_CL72_TXDBG3r_SET(r,d) (r).cl72_txdbg3[0] = d
#define BCMI_QTC_XGXS_CL72_TXDBG3r_GET(r) (r).cl72_txdbg3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_FRAME_LOCK_RDY_FOR_CMD_ENf_GET(r) ((((r).cl72_txdbg3[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_FRAME_LOCK_RDY_FOR_CMD_ENf_SET(r,f) (r).cl72_txdbg3[0]=(((r).cl72_txdbg3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_BRK_RING_OSCf_GET(r) (((r).cl72_txdbg3[0]) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_BRK_RING_OSCf_SET(r,f) (r).cl72_txdbg3[0]=(((r).cl72_txdbg3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL72_TXDBG3.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXDBG3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXDBG3r,(_r._cl72_txdbg3))
#define BCMI_QTC_XGXS_WRITE_CL72_TXDBG3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXDBG3r,(_r._cl72_txdbg3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXDBG3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXDBG3r,(_r._cl72_txdbg3))
#define BCMI_QTC_XGXS_READLN_CL72_TXDBG3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXDBG3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txdbg3))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXDBG3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXDBG3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txdbg3))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXDBG3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXDBG3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txdbg3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXDBG3r BCMI_QTC_XGXS_CL72_TXDBG3r
#define CL72_TXDBG3r_SIZE BCMI_QTC_XGXS_CL72_TXDBG3r_SIZE
typedef BCMI_QTC_XGXS_CL72_TXDBG3r_t CL72_TXDBG3r_t;
#define CL72_TXDBG3r_CLR BCMI_QTC_XGXS_CL72_TXDBG3r_CLR
#define CL72_TXDBG3r_SET BCMI_QTC_XGXS_CL72_TXDBG3r_SET
#define CL72_TXDBG3r_GET BCMI_QTC_XGXS_CL72_TXDBG3r_GET
#define CL72_TXDBG3r_CL72_FRAME_LOCK_RDY_FOR_CMD_ENf_GET BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_FRAME_LOCK_RDY_FOR_CMD_ENf_GET
#define CL72_TXDBG3r_CL72_FRAME_LOCK_RDY_FOR_CMD_ENf_SET BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_FRAME_LOCK_RDY_FOR_CMD_ENf_SET
#define CL72_TXDBG3r_CL72_BRK_RING_OSCf_GET BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_BRK_RING_OSCf_GET
#define CL72_TXDBG3r_CL72_BRK_RING_OSCf_SET BCMI_QTC_XGXS_CL72_TXDBG3r_CL72_BRK_RING_OSCf_SET
#define READ_CL72_TXDBG3r BCMI_QTC_XGXS_READ_CL72_TXDBG3r
#define WRITE_CL72_TXDBG3r BCMI_QTC_XGXS_WRITE_CL72_TXDBG3r
#define MODIFY_CL72_TXDBG3r BCMI_QTC_XGXS_MODIFY_CL72_TXDBG3r
#define READLN_CL72_TXDBG3r BCMI_QTC_XGXS_READLN_CL72_TXDBG3r
#define WRITELN_CL72_TXDBG3r BCMI_QTC_XGXS_WRITELN_CL72_TXDBG3r
#define WRITEALL_CL72_TXDBG3r BCMI_QTC_XGXS_WRITEALL_CL72_TXDBG3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXDBG3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXPCS_INTERFACE_CTL
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd063
 * DEVAD:    1
 * DESC:     CL72 PCS interface control Register
 * SIZE:     32
 * FIELDS:
 *     CL72_DIS_MAX_WAIT_TIMER disable max wait timer1 = max wait timer disabled0 = max wait timer enabled
 */
#define BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr (0x0001d063 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXPCS_INTERFACE_CTL.
 */
typedef union BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_s {
	uint32_t v[1];
	uint32_t cl72_txpcs_interface_ctl[1];
	uint32_t _cl72_txpcs_interface_ctl;
} BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_t;

#define BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_CLR(r) (r).cl72_txpcs_interface_ctl[0] = 0
#define BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_SET(r,d) (r).cl72_txpcs_interface_ctl[0] = d
#define BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_GET(r) (r).cl72_txpcs_interface_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_CL72_DIS_MAX_WAIT_TIMERf_GET(r) (((r).cl72_txpcs_interface_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_CL72_DIS_MAX_WAIT_TIMERf_SET(r,f) (r).cl72_txpcs_interface_ctl[0]=(((r).cl72_txpcs_interface_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL72_TXPCS_INTERFACE_CTL.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXPCS_INTERFACE_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr,(_r._cl72_txpcs_interface_ctl))
#define BCMI_QTC_XGXS_WRITE_CL72_TXPCS_INTERFACE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr,(_r._cl72_txpcs_interface_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXPCS_INTERFACE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr,(_r._cl72_txpcs_interface_ctl))
#define BCMI_QTC_XGXS_READLN_CL72_TXPCS_INTERFACE_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txpcs_interface_ctl))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXPCS_INTERFACE_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txpcs_interface_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXPCS_INTERFACE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txpcs_interface_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXPCS_INTERFACE_CTLr BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr
#define CL72_TXPCS_INTERFACE_CTLr_SIZE BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_t CL72_TXPCS_INTERFACE_CTLr_t;
#define CL72_TXPCS_INTERFACE_CTLr_CLR BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_CLR
#define CL72_TXPCS_INTERFACE_CTLr_SET BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_SET
#define CL72_TXPCS_INTERFACE_CTLr_GET BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_GET
#define CL72_TXPCS_INTERFACE_CTLr_CL72_DIS_MAX_WAIT_TIMERf_GET BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_CL72_DIS_MAX_WAIT_TIMERf_GET
#define CL72_TXPCS_INTERFACE_CTLr_CL72_DIS_MAX_WAIT_TIMERf_SET BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr_CL72_DIS_MAX_WAIT_TIMERf_SET
#define READ_CL72_TXPCS_INTERFACE_CTLr BCMI_QTC_XGXS_READ_CL72_TXPCS_INTERFACE_CTLr
#define WRITE_CL72_TXPCS_INTERFACE_CTLr BCMI_QTC_XGXS_WRITE_CL72_TXPCS_INTERFACE_CTLr
#define MODIFY_CL72_TXPCS_INTERFACE_CTLr BCMI_QTC_XGXS_MODIFY_CL72_TXPCS_INTERFACE_CTLr
#define READLN_CL72_TXPCS_INTERFACE_CTLr BCMI_QTC_XGXS_READLN_CL72_TXPCS_INTERFACE_CTLr
#define WRITELN_CL72_TXPCS_INTERFACE_CTLr BCMI_QTC_XGXS_WRITELN_CL72_TXPCS_INTERFACE_CTLr
#define WRITEALL_CL72_TXPCS_INTERFACE_CTLr BCMI_QTC_XGXS_WRITEALL_CL72_TXPCS_INTERFACE_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXPCS_INTERFACE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXCL72_LD_STS_PAGE
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd064
 * DEVAD:    1
 * DESC:     CL72 local device status Register
 * SIZE:     32
 * FIELDS:
 *     CL72_LD_STATUS_PAGE Local Device status that is sent to the LP
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr (0x0001d064 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXCL72_LD_STS_PAGE.
 */
typedef union BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_s {
	uint32_t v[1];
	uint32_t cl72_txcl72_ld_sts_page[1];
	uint32_t _cl72_txcl72_ld_sts_page;
} BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_t;

#define BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_CLR(r) (r).cl72_txcl72_ld_sts_page[0] = 0
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_SET(r,d) (r).cl72_txcl72_ld_sts_page[0] = d
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_GET(r) (r).cl72_txcl72_ld_sts_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_CL72_LD_STATUS_PAGEf_GET(r) (((r).cl72_txcl72_ld_sts_page[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_CL72_LD_STATUS_PAGEf_SET(r,f) (r).cl72_txcl72_ld_sts_page[0]=(((r).cl72_txcl72_ld_sts_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_TXCL72_LD_STS_PAGE.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXCL72_LD_STS_PAGEr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr,(_r._cl72_txcl72_ld_sts_page))
#define BCMI_QTC_XGXS_WRITE_CL72_TXCL72_LD_STS_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr,(_r._cl72_txcl72_ld_sts_page)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_LD_STS_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr,(_r._cl72_txcl72_ld_sts_page))
#define BCMI_QTC_XGXS_READLN_CL72_TXCL72_LD_STS_PAGEr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_ld_sts_page))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_LD_STS_PAGEr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_ld_sts_page))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_LD_STS_PAGEr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txcl72_ld_sts_page))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXCL72_LD_STS_PAGEr BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr
#define CL72_TXCL72_LD_STS_PAGEr_SIZE BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_t CL72_TXCL72_LD_STS_PAGEr_t;
#define CL72_TXCL72_LD_STS_PAGEr_CLR BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_CLR
#define CL72_TXCL72_LD_STS_PAGEr_SET BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_SET
#define CL72_TXCL72_LD_STS_PAGEr_GET BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_GET
#define CL72_TXCL72_LD_STS_PAGEr_CL72_LD_STATUS_PAGEf_GET BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_CL72_LD_STATUS_PAGEf_GET
#define CL72_TXCL72_LD_STS_PAGEr_CL72_LD_STATUS_PAGEf_SET BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr_CL72_LD_STATUS_PAGEf_SET
#define READ_CL72_TXCL72_LD_STS_PAGEr BCMI_QTC_XGXS_READ_CL72_TXCL72_LD_STS_PAGEr
#define WRITE_CL72_TXCL72_LD_STS_PAGEr BCMI_QTC_XGXS_WRITE_CL72_TXCL72_LD_STS_PAGEr
#define MODIFY_CL72_TXCL72_LD_STS_PAGEr BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_LD_STS_PAGEr
#define READLN_CL72_TXCL72_LD_STS_PAGEr BCMI_QTC_XGXS_READLN_CL72_TXCL72_LD_STS_PAGEr
#define WRITELN_CL72_TXCL72_LD_STS_PAGEr BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_LD_STS_PAGEr
#define WRITEALL_CL72_TXCL72_LD_STS_PAGEr BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_LD_STS_PAGEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXCL72_LD_STS_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXCL72_READY_FOR_CMD
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd065
 * DEVAD:    1
 * DESC:     CL72 Ready for command registers
 * SIZE:     32
 * FIELDS:
 *     CL72_READY_FOR_CMD status indicating link partner is ready for new cl72 command
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr (0x0001d065 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXCL72_READY_FOR_CMD.
 */
typedef union BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_s {
	uint32_t v[1];
	uint32_t cl72_txcl72_ready_for_cmd[1];
	uint32_t _cl72_txcl72_ready_for_cmd;
} BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_t;

#define BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_CLR(r) (r).cl72_txcl72_ready_for_cmd[0] = 0
#define BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_SET(r,d) (r).cl72_txcl72_ready_for_cmd[0] = d
#define BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_GET(r) (r).cl72_txcl72_ready_for_cmd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_GET(r) (((r).cl72_txcl72_ready_for_cmd[0]) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_SET(r,f) (r).cl72_txcl72_ready_for_cmd[0]=(((r).cl72_txcl72_ready_for_cmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CL72_TXCL72_READY_FOR_CMD.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXCL72_READY_FOR_CMDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr,(_r._cl72_txcl72_ready_for_cmd))
#define BCMI_QTC_XGXS_WRITE_CL72_TXCL72_READY_FOR_CMDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr,(_r._cl72_txcl72_ready_for_cmd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_READY_FOR_CMDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr,(_r._cl72_txcl72_ready_for_cmd))
#define BCMI_QTC_XGXS_READLN_CL72_TXCL72_READY_FOR_CMDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_ready_for_cmd))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_READY_FOR_CMDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_ready_for_cmd))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_READY_FOR_CMDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txcl72_ready_for_cmd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXCL72_READY_FOR_CMDr BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr
#define CL72_TXCL72_READY_FOR_CMDr_SIZE BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_t CL72_TXCL72_READY_FOR_CMDr_t;
#define CL72_TXCL72_READY_FOR_CMDr_CLR BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_CLR
#define CL72_TXCL72_READY_FOR_CMDr_SET BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_SET
#define CL72_TXCL72_READY_FOR_CMDr_GET BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_GET
#define CL72_TXCL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_GET BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_GET
#define CL72_TXCL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_SET BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr_CL72_READY_FOR_CMDf_SET
#define READ_CL72_TXCL72_READY_FOR_CMDr BCMI_QTC_XGXS_READ_CL72_TXCL72_READY_FOR_CMDr
#define WRITE_CL72_TXCL72_READY_FOR_CMDr BCMI_QTC_XGXS_WRITE_CL72_TXCL72_READY_FOR_CMDr
#define MODIFY_CL72_TXCL72_READY_FOR_CMDr BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_READY_FOR_CMDr
#define READLN_CL72_TXCL72_READY_FOR_CMDr BCMI_QTC_XGXS_READLN_CL72_TXCL72_READY_FOR_CMDr
#define WRITELN_CL72_TXCL72_READY_FOR_CMDr BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_READY_FOR_CMDr
#define WRITEALL_CL72_TXCL72_READY_FOR_CMDr BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_READY_FOR_CMDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXCL72_READY_FOR_CMDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXKR_DFLT_CTL1
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd066
 * DEVAD:    1
 * DESC:     CL72 KR Default Control 1 Register
 * SIZE:     32
 * FIELDS:
 *     CL72_TX_FIR_TAP_PRE_KR_INIT_VAL 10GBASE-KR pre cursor tap coeeficient initial value.
 *     CL72_TX_FIR_TAP_POST_KR_INIT_VAL 10GBASE-KR post cursor tap coeeficient initial value.
 */
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r (0x0001d066 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXKR_DFLT_CTL1.
 */
typedef union BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_s {
	uint32_t v[1];
	uint32_t cl72_txkr_dflt_ctl1[1];
	uint32_t _cl72_txkr_dflt_ctl1;
} BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_t;

#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CLR(r) (r).cl72_txkr_dflt_ctl1[0] = 0
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_SET(r,d) (r).cl72_txkr_dflt_ctl1[0] = d
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_GET(r) (r).cl72_txkr_dflt_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_POST_KR_INIT_VALf_GET(r) ((((r).cl72_txkr_dflt_ctl1[0]) >> 5) & 0x3f)
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_POST_KR_INIT_VALf_SET(r,f) (r).cl72_txkr_dflt_ctl1[0]=(((r).cl72_txkr_dflt_ctl1[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_PRE_KR_INIT_VALf_GET(r) (((r).cl72_txkr_dflt_ctl1[0]) & 0x1f)
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_PRE_KR_INIT_VALf_SET(r,f) (r).cl72_txkr_dflt_ctl1[0]=(((r).cl72_txkr_dflt_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access CL72_TXKR_DFLT_CTL1.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXKR_DFLT_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r,(_r._cl72_txkr_dflt_ctl1))
#define BCMI_QTC_XGXS_WRITE_CL72_TXKR_DFLT_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r,(_r._cl72_txkr_dflt_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXKR_DFLT_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r,(_r._cl72_txkr_dflt_ctl1))
#define BCMI_QTC_XGXS_READLN_CL72_TXKR_DFLT_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txkr_dflt_ctl1))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXKR_DFLT_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txkr_dflt_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXKR_DFLT_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txkr_dflt_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXKR_DFLT_CTL1r BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r
#define CL72_TXKR_DFLT_CTL1r_SIZE BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_SIZE
typedef BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_t CL72_TXKR_DFLT_CTL1r_t;
#define CL72_TXKR_DFLT_CTL1r_CLR BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CLR
#define CL72_TXKR_DFLT_CTL1r_SET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_SET
#define CL72_TXKR_DFLT_CTL1r_GET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_GET
#define CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_POST_KR_INIT_VALf_GET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_POST_KR_INIT_VALf_GET
#define CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_POST_KR_INIT_VALf_SET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_POST_KR_INIT_VALf_SET
#define CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_PRE_KR_INIT_VALf_GET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_PRE_KR_INIT_VALf_GET
#define CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_PRE_KR_INIT_VALf_SET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r_CL72_TX_FIR_TAP_PRE_KR_INIT_VALf_SET
#define READ_CL72_TXKR_DFLT_CTL1r BCMI_QTC_XGXS_READ_CL72_TXKR_DFLT_CTL1r
#define WRITE_CL72_TXKR_DFLT_CTL1r BCMI_QTC_XGXS_WRITE_CL72_TXKR_DFLT_CTL1r
#define MODIFY_CL72_TXKR_DFLT_CTL1r BCMI_QTC_XGXS_MODIFY_CL72_TXKR_DFLT_CTL1r
#define READLN_CL72_TXKR_DFLT_CTL1r BCMI_QTC_XGXS_READLN_CL72_TXKR_DFLT_CTL1r
#define WRITELN_CL72_TXKR_DFLT_CTL1r BCMI_QTC_XGXS_WRITELN_CL72_TXKR_DFLT_CTL1r
#define WRITEALL_CL72_TXKR_DFLT_CTL1r BCMI_QTC_XGXS_WRITEALL_CL72_TXKR_DFLT_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXKR_DFLT_CTL2
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd067
 * DEVAD:    1
 * DESC:     CL72 KR Default Control 2 Register
 * SIZE:     32
 * FIELDS:
 *     CL72_TX_FIR_TAP_MAIN_KR_INIT_VAL 10GBASE-KR main cursor tap coeeficient initial value.
 */
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r (0x0001d067 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXKR_DFLT_CTL2.
 */
typedef union BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_s {
	uint32_t v[1];
	uint32_t cl72_txkr_dflt_ctl2[1];
	uint32_t _cl72_txkr_dflt_ctl2;
} BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_t;

#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_CLR(r) (r).cl72_txkr_dflt_ctl2[0] = 0
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_SET(r,d) (r).cl72_txkr_dflt_ctl2[0] = d
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_GET(r) (r).cl72_txkr_dflt_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_CL72_TX_FIR_TAP_MAIN_KR_INIT_VALf_GET(r) (((r).cl72_txkr_dflt_ctl2[0]) & 0x7f)
#define BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_CL72_TX_FIR_TAP_MAIN_KR_INIT_VALf_SET(r,f) (r).cl72_txkr_dflt_ctl2[0]=(((r).cl72_txkr_dflt_ctl2[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access CL72_TXKR_DFLT_CTL2.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXKR_DFLT_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r,(_r._cl72_txkr_dflt_ctl2))
#define BCMI_QTC_XGXS_WRITE_CL72_TXKR_DFLT_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r,(_r._cl72_txkr_dflt_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXKR_DFLT_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r,(_r._cl72_txkr_dflt_ctl2))
#define BCMI_QTC_XGXS_READLN_CL72_TXKR_DFLT_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txkr_dflt_ctl2))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXKR_DFLT_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txkr_dflt_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXKR_DFLT_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txkr_dflt_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXKR_DFLT_CTL2r BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r
#define CL72_TXKR_DFLT_CTL2r_SIZE BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_SIZE
typedef BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_t CL72_TXKR_DFLT_CTL2r_t;
#define CL72_TXKR_DFLT_CTL2r_CLR BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_CLR
#define CL72_TXKR_DFLT_CTL2r_SET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_SET
#define CL72_TXKR_DFLT_CTL2r_GET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_GET
#define CL72_TXKR_DFLT_CTL2r_CL72_TX_FIR_TAP_MAIN_KR_INIT_VALf_GET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_CL72_TX_FIR_TAP_MAIN_KR_INIT_VALf_GET
#define CL72_TXKR_DFLT_CTL2r_CL72_TX_FIR_TAP_MAIN_KR_INIT_VALf_SET BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r_CL72_TX_FIR_TAP_MAIN_KR_INIT_VALf_SET
#define READ_CL72_TXKR_DFLT_CTL2r BCMI_QTC_XGXS_READ_CL72_TXKR_DFLT_CTL2r
#define WRITE_CL72_TXKR_DFLT_CTL2r BCMI_QTC_XGXS_WRITE_CL72_TXKR_DFLT_CTL2r
#define MODIFY_CL72_TXKR_DFLT_CTL2r BCMI_QTC_XGXS_MODIFY_CL72_TXKR_DFLT_CTL2r
#define READLN_CL72_TXKR_DFLT_CTL2r BCMI_QTC_XGXS_READLN_CL72_TXKR_DFLT_CTL2r
#define WRITELN_CL72_TXKR_DFLT_CTL2r BCMI_QTC_XGXS_WRITELN_CL72_TXKR_DFLT_CTL2r
#define WRITEALL_CL72_TXKR_DFLT_CTL2r BCMI_QTC_XGXS_WRITEALL_CL72_TXKR_DFLT_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXKR_DFLT_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXMISC_COEFF_CTL
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd068
 * DEVAD:    1
 * DESC:     CL72 Misc Coefficient Control Register
 * SIZE:     32
 * FIELDS:
 *     CL72_INC_DEC_VAL_SEL Controls the Coefficient Update FSM increment/decrement value.2'b00: Increment/decrement by 1;2'b01: Increment/decrement by 2;2'b10: Increment/decrement by 3;2'b11: Increment/decrement by 4;
 *     CL72_TAP_V2_VAL  Cl72 v2 constraint value
 *     CL72_V2_CONSTRAINT_DIS Disable v2 constraint for tap settings
 *     CL72_LD_XMT_STATUS_LOAD Local Device's status page loadUsed with ld_xmt_status_override. When ld_xmt_status_override is 1'b1,then low to High transition ld_xmt_status_load indicates that theLocl devices's software generated status page is ready
 *     CL72_LD_XMT_STATUS_OVERRIDE Local Device's status page override0 - ld status page generated by Local Device coeffcient update logic1 - ld status page generated by software
 *     CL72_DIS_LP_COEFF_UPDATES_TO_LD Disable Link partners coefficient update to Local Device TXFIR1 - disabled0 - enabled
 *     CL72_DOUBLE_CMD_EN Double command enable0 - disabled1 - enabled,  converts the following single command sequence to double command1) post inc   -- step size = 1x2) pre dec    -- step size = 1x3) post inc   -- step size = 1x4) pre dec    -- step size = 1x5) post inc   -- step size = 2x6) pre dec    -- step size = 2x
 */
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr (0x0001d068 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXMISC_COEFF_CTL.
 */
typedef union BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_s {
	uint32_t v[1];
	uint32_t cl72_txmisc_coeff_ctl[1];
	uint32_t _cl72_txmisc_coeff_ctl;
} BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_t;

#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CLR(r) (r).cl72_txmisc_coeff_ctl[0] = 0
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_SET(r,d) (r).cl72_txmisc_coeff_ctl[0] = d
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_GET(r) (r).cl72_txmisc_coeff_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DOUBLE_CMD_ENf_GET(r) ((((r).cl72_txmisc_coeff_ctl[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DOUBLE_CMD_ENf_SET(r,f) (r).cl72_txmisc_coeff_ctl[0]=(((r).cl72_txmisc_coeff_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DIS_LP_COEFF_UPDATES_TO_LDf_GET(r) ((((r).cl72_txmisc_coeff_ctl[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DIS_LP_COEFF_UPDATES_TO_LDf_SET(r,f) (r).cl72_txmisc_coeff_ctl[0]=(((r).cl72_txmisc_coeff_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_OVERRIDEf_GET(r) ((((r).cl72_txmisc_coeff_ctl[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_OVERRIDEf_SET(r,f) (r).cl72_txmisc_coeff_ctl[0]=(((r).cl72_txmisc_coeff_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_LOADf_GET(r) ((((r).cl72_txmisc_coeff_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_LOADf_SET(r,f) (r).cl72_txmisc_coeff_ctl[0]=(((r).cl72_txmisc_coeff_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_V2_CONSTRAINT_DISf_GET(r) ((((r).cl72_txmisc_coeff_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_V2_CONSTRAINT_DISf_SET(r,f) (r).cl72_txmisc_coeff_ctl[0]=(((r).cl72_txmisc_coeff_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_TAP_V2_VALf_GET(r) ((((r).cl72_txmisc_coeff_ctl[0]) >> 2) & 0x3f)
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_TAP_V2_VALf_SET(r,f) (r).cl72_txmisc_coeff_ctl[0]=(((r).cl72_txmisc_coeff_ctl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_INC_DEC_VAL_SELf_GET(r) (((r).cl72_txmisc_coeff_ctl[0]) & 0x3)
#define BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_INC_DEC_VAL_SELf_SET(r,f) (r).cl72_txmisc_coeff_ctl[0]=(((r).cl72_txmisc_coeff_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access CL72_TXMISC_COEFF_CTL.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXMISC_COEFF_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr,(_r._cl72_txmisc_coeff_ctl))
#define BCMI_QTC_XGXS_WRITE_CL72_TXMISC_COEFF_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr,(_r._cl72_txmisc_coeff_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXMISC_COEFF_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr,(_r._cl72_txmisc_coeff_ctl))
#define BCMI_QTC_XGXS_READLN_CL72_TXMISC_COEFF_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txmisc_coeff_ctl))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXMISC_COEFF_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txmisc_coeff_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXMISC_COEFF_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txmisc_coeff_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXMISC_COEFF_CTLr BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr
#define CL72_TXMISC_COEFF_CTLr_SIZE BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_t CL72_TXMISC_COEFF_CTLr_t;
#define CL72_TXMISC_COEFF_CTLr_CLR BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CLR
#define CL72_TXMISC_COEFF_CTLr_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_SET
#define CL72_TXMISC_COEFF_CTLr_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_DOUBLE_CMD_ENf_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DOUBLE_CMD_ENf_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_DOUBLE_CMD_ENf_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DOUBLE_CMD_ENf_SET
#define CL72_TXMISC_COEFF_CTLr_CL72_DIS_LP_COEFF_UPDATES_TO_LDf_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DIS_LP_COEFF_UPDATES_TO_LDf_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_DIS_LP_COEFF_UPDATES_TO_LDf_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_DIS_LP_COEFF_UPDATES_TO_LDf_SET
#define CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_OVERRIDEf_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_OVERRIDEf_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_OVERRIDEf_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_OVERRIDEf_SET
#define CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_LOADf_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_LOADf_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_LOADf_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_LD_XMT_STATUS_LOADf_SET
#define CL72_TXMISC_COEFF_CTLr_CL72_V2_CONSTRAINT_DISf_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_V2_CONSTRAINT_DISf_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_V2_CONSTRAINT_DISf_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_V2_CONSTRAINT_DISf_SET
#define CL72_TXMISC_COEFF_CTLr_CL72_TAP_V2_VALf_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_TAP_V2_VALf_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_TAP_V2_VALf_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_TAP_V2_VALf_SET
#define CL72_TXMISC_COEFF_CTLr_CL72_INC_DEC_VAL_SELf_GET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_INC_DEC_VAL_SELf_GET
#define CL72_TXMISC_COEFF_CTLr_CL72_INC_DEC_VAL_SELf_SET BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr_CL72_INC_DEC_VAL_SELf_SET
#define READ_CL72_TXMISC_COEFF_CTLr BCMI_QTC_XGXS_READ_CL72_TXMISC_COEFF_CTLr
#define WRITE_CL72_TXMISC_COEFF_CTLr BCMI_QTC_XGXS_WRITE_CL72_TXMISC_COEFF_CTLr
#define MODIFY_CL72_TXMISC_COEFF_CTLr BCMI_QTC_XGXS_MODIFY_CL72_TXMISC_COEFF_CTLr
#define READLN_CL72_TXMISC_COEFF_CTLr BCMI_QTC_XGXS_READLN_CL72_TXMISC_COEFF_CTLr
#define WRITELN_CL72_TXMISC_COEFF_CTLr BCMI_QTC_XGXS_WRITELN_CL72_TXMISC_COEFF_CTLr
#define WRITEALL_CL72_TXMISC_COEFF_CTLr BCMI_QTC_XGXS_WRITEALL_CL72_TXMISC_COEFF_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXMISC_COEFF_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXCL72_LD_XMT_STS_PAGE_OVRR
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd069
 * DEVAD:    1
 * DESC:     CL72 Local Device Status Page Override Register
 * SIZE:     32
 * FIELDS:
 *     CL72_OVERRIDE_LD_STATUS_PAGE Local Device's status report override pageUsed with ld_xmt_status_override and ld_xmt_status_load.When ld_xmt_status_override is 1'b1,then low to High transition ld_xmt_status_load indicates that thestatus data in this is register is ready to be transmitted
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr (0x0001d069 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXCL72_LD_XMT_STS_PAGE_OVRR.
 */
typedef union BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_s {
	uint32_t v[1];
	uint32_t cl72_txcl72_ld_xmt_sts_page_ovrr[1];
	uint32_t _cl72_txcl72_ld_xmt_sts_page_ovrr;
} BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_t;

#define BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CLR(r) (r).cl72_txcl72_ld_xmt_sts_page_ovrr[0] = 0
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_SET(r,d) (r).cl72_txcl72_ld_xmt_sts_page_ovrr[0] = d
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_GET(r) (r).cl72_txcl72_ld_xmt_sts_page_ovrr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CL72_OVERRIDE_LD_STATUS_PAGEf_GET(r) (((r).cl72_txcl72_ld_xmt_sts_page_ovrr[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CL72_OVERRIDE_LD_STATUS_PAGEf_SET(r,f) (r).cl72_txcl72_ld_xmt_sts_page_ovrr[0]=(((r).cl72_txcl72_ld_xmt_sts_page_ovrr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_TXCL72_LD_XMT_STS_PAGE_OVRR.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr,(_r._cl72_txcl72_ld_xmt_sts_page_ovrr))
#define BCMI_QTC_XGXS_WRITE_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr,(_r._cl72_txcl72_ld_xmt_sts_page_ovrr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr,(_r._cl72_txcl72_ld_xmt_sts_page_ovrr))
#define BCMI_QTC_XGXS_READLN_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_ld_xmt_sts_page_ovrr))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_ld_xmt_sts_page_ovrr))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txcl72_ld_xmt_sts_page_ovrr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr
#define CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_SIZE BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_t CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_t;
#define CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CLR BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CLR
#define CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_SET BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_SET
#define CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_GET BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_GET
#define CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CL72_OVERRIDE_LD_STATUS_PAGEf_GET BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CL72_OVERRIDE_LD_STATUS_PAGEf_GET
#define CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CL72_OVERRIDE_LD_STATUS_PAGEf_SET BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr_CL72_OVERRIDE_LD_STATUS_PAGEf_SET
#define READ_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr BCMI_QTC_XGXS_READ_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr
#define WRITE_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr BCMI_QTC_XGXS_WRITE_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr
#define MODIFY_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr
#define READLN_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr BCMI_QTC_XGXS_READLN_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr
#define WRITELN_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr
#define WRITEALL_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXCL72_LD_XMT_STS_PAGE_OVRRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXCL72_TX_DBG_STS
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd06a
 * DEVAD:    1
 * DESC:     CL72 debug status register
 * SIZE:     32
 * FIELDS:
 *     CL72_LD_COEFF_CMD_HIST Local Device coefficient update command historyThese bits provide and indications which cammand was previously received andand which command is currently being executedbit10: presetbit9: initializebit8: post_incbit7: post_decbit6: post_holdbit5: main_incbit4: main_decbit3: main_holdbit2: pre_incbit1: pre_decbit0: pre_holdThese bits are cleared upon read for the previously received commands
 *     CL72_FRAME_LOCK_LH frame lock latch upon detectiing high to low transitionclear on read
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr (0x0001d06a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXCL72_TX_DBG_STS.
 */
typedef union BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_s {
	uint32_t v[1];
	uint32_t cl72_txcl72_tx_dbg_sts[1];
	uint32_t _cl72_txcl72_tx_dbg_sts;
} BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_t;

#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CLR(r) (r).cl72_txcl72_tx_dbg_sts[0] = 0
#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_SET(r,d) (r).cl72_txcl72_tx_dbg_sts[0] = d
#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_GET(r) (r).cl72_txcl72_tx_dbg_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_FRAME_LOCK_LHf_GET(r) ((((r).cl72_txcl72_tx_dbg_sts[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_FRAME_LOCK_LHf_SET(r,f) (r).cl72_txcl72_tx_dbg_sts[0]=(((r).cl72_txcl72_tx_dbg_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_LD_COEFF_CMD_HISTf_GET(r) (((r).cl72_txcl72_tx_dbg_sts[0]) & 0x7ff)
#define BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_LD_COEFF_CMD_HISTf_SET(r,f) (r).cl72_txcl72_tx_dbg_sts[0]=(((r).cl72_txcl72_tx_dbg_sts[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (2047 << 16)

/*
 * These macros can be used to access CL72_TXCL72_TX_DBG_STS.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXCL72_TX_DBG_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr,(_r._cl72_txcl72_tx_dbg_sts))
#define BCMI_QTC_XGXS_WRITE_CL72_TXCL72_TX_DBG_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr,(_r._cl72_txcl72_tx_dbg_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_TX_DBG_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr,(_r._cl72_txcl72_tx_dbg_sts))
#define BCMI_QTC_XGXS_READLN_CL72_TXCL72_TX_DBG_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_tx_dbg_sts))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_TX_DBG_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txcl72_tx_dbg_sts))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_TX_DBG_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txcl72_tx_dbg_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXCL72_TX_DBG_STSr BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr
#define CL72_TXCL72_TX_DBG_STSr_SIZE BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_t CL72_TXCL72_TX_DBG_STSr_t;
#define CL72_TXCL72_TX_DBG_STSr_CLR BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CLR
#define CL72_TXCL72_TX_DBG_STSr_SET BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_SET
#define CL72_TXCL72_TX_DBG_STSr_GET BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_GET
#define CL72_TXCL72_TX_DBG_STSr_CL72_FRAME_LOCK_LHf_GET BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_FRAME_LOCK_LHf_GET
#define CL72_TXCL72_TX_DBG_STSr_CL72_FRAME_LOCK_LHf_SET BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_FRAME_LOCK_LHf_SET
#define CL72_TXCL72_TX_DBG_STSr_CL72_LD_COEFF_CMD_HISTf_GET BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_LD_COEFF_CMD_HISTf_GET
#define CL72_TXCL72_TX_DBG_STSr_CL72_LD_COEFF_CMD_HISTf_SET BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr_CL72_LD_COEFF_CMD_HISTf_SET
#define READ_CL72_TXCL72_TX_DBG_STSr BCMI_QTC_XGXS_READ_CL72_TXCL72_TX_DBG_STSr
#define WRITE_CL72_TXCL72_TX_DBG_STSr BCMI_QTC_XGXS_WRITE_CL72_TXCL72_TX_DBG_STSr
#define MODIFY_CL72_TXCL72_TX_DBG_STSr BCMI_QTC_XGXS_MODIFY_CL72_TXCL72_TX_DBG_STSr
#define READLN_CL72_TXCL72_TX_DBG_STSr BCMI_QTC_XGXS_READLN_CL72_TXCL72_TX_DBG_STSr
#define WRITELN_CL72_TXCL72_TX_DBG_STSr BCMI_QTC_XGXS_WRITELN_CL72_TXCL72_TX_DBG_STSr
#define WRITEALL_CL72_TXCL72_TX_DBG_STSr BCMI_QTC_XGXS_WRITEALL_CL72_TXCL72_TX_DBG_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXCL72_TX_DBG_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_CTL0
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd070
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 0
 * SIZE:     32
 * FIELDS:
 *     TX_PI_EN         Transmit Phase Interpolator Enable. If 1'b0 will gate off the TX PI clock and also freeze the PI code.
 *     TX_PI_JITTER_FILTER_EN This enables the IIR filter for the phase_sum_val logic from the CDR ( or external CDR in case of Merlin ) .
 *     TX_PI_EXT_CTRL_EN Enable for the phase error (inc/dec) from the remote loopback ( or HS Phase FIFO in case of Merlin )
 *     TX_PI_FREQ_OVERRIDE_EN Enable for the frequency override mode. It should be 1'b1 for fixed frequency and jitter generation modes.
 *     TX_PI_SJ_GEN_EN  Sinusoidal Jitter (SJ) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_SSC_GEN_EN Spread Spectrum Jitter (SSC) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_JIT_SSC_FREQ_MODE SSJ Mode Select:1'b1 : 10G SSC mode and 1'b0: 6G SSC mode
 *     TX_PI_SECOND_ORDER_LOOP_EN 2nd Order Loop Enable. 1'b1 will enable the 2nd order loop of the IIR filter. 1'b0 will reset the all the flops related to the 2nd order loop.This bit is only valid when tx_pi_loop_timing_en is set to 1'b1.
 *     TX_PI_FIRST_ORDER_BWSEL_INTEG First order bandwidth control.2'd0 -  80 KHz2'd1 - 160 KHz2'd2 - 321 KHz2'd3 - 642 KHz
 *     TX_PI_SECOND_ORDER_BWSEL_INTEG Second order bandwidth control. Valid values are 0, 1, 2 and 3.
 *     TX_PI_EXT_PHASE_BWSEL_INTEG External Phase bandwidth control. Valid values are 0 to 5.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL0r (0x0001d070 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL0.
 */
typedef union BCMI_QTC_XGXS_TX_PI_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl0[1];
	uint32_t _tx_pi_ctl0;
} BCMI_QTC_XGXS_TX_PI_CTL0r_t;

#define BCMI_QTC_XGXS_TX_PI_CTL0r_CLR(r) (r).tx_pi_ctl0[0] = 0
#define BCMI_QTC_XGXS_TX_PI_CTL0r_SET(r,d) (r).tx_pi_ctl0[0] = d
#define BCMI_QTC_XGXS_TX_PI_CTL0r_GET(r) (r).tx_pi_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 12) & 0x7)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET(r) ((((r).tx_pi_ctl0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET(r) (((r).tx_pi_ctl0[0]) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TX_PI_CTL0.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_QTC_XGXS_WRITE_TX_PI_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_QTC_XGXS_READLN_TX_PI_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL0r BCMI_QTC_XGXS_TX_PI_CTL0r
#define TX_PI_CTL0r_SIZE BCMI_QTC_XGXS_TX_PI_CTL0r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_CTL0r_t TX_PI_CTL0r_t;
#define TX_PI_CTL0r_CLR BCMI_QTC_XGXS_TX_PI_CTL0r_CLR
#define TX_PI_CTL0r_SET BCMI_QTC_XGXS_TX_PI_CTL0r_SET
#define TX_PI_CTL0r_GET BCMI_QTC_XGXS_TX_PI_CTL0r_GET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET
#define TX_PI_CTL0r_TX_PI_ENf_GET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET
#define TX_PI_CTL0r_TX_PI_ENf_SET BCMI_QTC_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET
#define READ_TX_PI_CTL0r BCMI_QTC_XGXS_READ_TX_PI_CTL0r
#define WRITE_TX_PI_CTL0r BCMI_QTC_XGXS_WRITE_TX_PI_CTL0r
#define MODIFY_TX_PI_CTL0r BCMI_QTC_XGXS_MODIFY_TX_PI_CTL0r
#define READLN_TX_PI_CTL0r BCMI_QTC_XGXS_READLN_TX_PI_CTL0r
#define WRITELN_TX_PI_CTL0r BCMI_QTC_XGXS_WRITELN_TX_PI_CTL0r
#define WRITEALL_TX_PI_CTL0r BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_CTL1
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd071
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 1
 * SIZE:     32
 * FIELDS:
 *     TX_PI_FREQ_OVERRIDE_VAL Fixed Frequncy Override Value: Valid values are -8192 to +8192. Register tx_pi_freq_override_en should be 1'b1 to enable the Fixed Frequncy Override mode.+8192 (-8192) value in this register will result into 1 TX PI phase inc (dec) every 20T tclk. This results into (1/64 * 1/20)UI phase inc (or dec) per UI = 781.25(-781.25) ppm. So 1 ppm = 10.486 value.If tx_pi_jit_gen_en is set to 1'b1 then this register provides initilization value for Jitter Gen Integ Reg. Valid values in jitter generation mode are -8192 to +8191
 */
#define BCMI_QTC_XGXS_TX_PI_CTL1r (0x0001d071 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL1.
 */
typedef union BCMI_QTC_XGXS_TX_PI_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl1[1];
	uint32_t _tx_pi_ctl1;
} BCMI_QTC_XGXS_TX_PI_CTL1r_t;

#define BCMI_QTC_XGXS_TX_PI_CTL1r_CLR(r) (r).tx_pi_ctl1[0] = 0
#define BCMI_QTC_XGXS_TX_PI_CTL1r_SET(r,d) (r).tx_pi_ctl1[0] = d
#define BCMI_QTC_XGXS_TX_PI_CTL1r_GET(r) (r).tx_pi_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET(r) (((r).tx_pi_ctl1[0]) & 0x7fff)
#define BCMI_QTC_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET(r,f) (r).tx_pi_ctl1[0]=(((r).tx_pi_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (32767 << 16)

/*
 * These macros can be used to access TX_PI_CTL1.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_QTC_XGXS_WRITE_TX_PI_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_QTC_XGXS_READLN_TX_PI_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL1r BCMI_QTC_XGXS_TX_PI_CTL1r
#define TX_PI_CTL1r_SIZE BCMI_QTC_XGXS_TX_PI_CTL1r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_CTL1r_t TX_PI_CTL1r_t;
#define TX_PI_CTL1r_CLR BCMI_QTC_XGXS_TX_PI_CTL1r_CLR
#define TX_PI_CTL1r_SET BCMI_QTC_XGXS_TX_PI_CTL1r_SET
#define TX_PI_CTL1r_GET BCMI_QTC_XGXS_TX_PI_CTL1r_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET BCMI_QTC_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET BCMI_QTC_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET
#define READ_TX_PI_CTL1r BCMI_QTC_XGXS_READ_TX_PI_CTL1r
#define WRITE_TX_PI_CTL1r BCMI_QTC_XGXS_WRITE_TX_PI_CTL1r
#define MODIFY_TX_PI_CTL1r BCMI_QTC_XGXS_MODIFY_TX_PI_CTL1r
#define READLN_TX_PI_CTL1r BCMI_QTC_XGXS_READLN_TX_PI_CTL1r
#define WRITELN_TX_PI_CTL1r BCMI_QTC_XGXS_WRITELN_TX_PI_CTL1r
#define WRITEALL_TX_PI_CTL1r BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_CTL2
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd072
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 2
 * SIZE:     32
 * FIELDS:
 *     TX_PI_JIT_FREQ_IDX Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator parameters.In SJ  mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details.In SSC mode: It provides Nssc.                                               Refer Jitter Generator spec for the table details.
 *     TX_PI_JIT_AMP    Jitter Generator Amplification Factor. Valid values are 0 to 63.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL2r (0x0001d072 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL2.
 */
typedef union BCMI_QTC_XGXS_TX_PI_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl2[1];
	uint32_t _tx_pi_ctl2;
} BCMI_QTC_XGXS_TX_PI_CTL2r_t;

#define BCMI_QTC_XGXS_TX_PI_CTL2r_CLR(r) (r).tx_pi_ctl2[0] = 0
#define BCMI_QTC_XGXS_TX_PI_CTL2r_SET(r,d) (r).tx_pi_ctl2[0] = d
#define BCMI_QTC_XGXS_TX_PI_CTL2r_GET(r) (r).tx_pi_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET(r) ((((r).tx_pi_ctl2[0]) >> 8) & 0x3f)
#define BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET(r) (((r).tx_pi_ctl2[0]) & 0x3f)
#define BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access TX_PI_CTL2.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_QTC_XGXS_WRITE_TX_PI_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_QTC_XGXS_READLN_TX_PI_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL2r BCMI_QTC_XGXS_TX_PI_CTL2r
#define TX_PI_CTL2r_SIZE BCMI_QTC_XGXS_TX_PI_CTL2r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_CTL2r_t TX_PI_CTL2r_t;
#define TX_PI_CTL2r_CLR BCMI_QTC_XGXS_TX_PI_CTL2r_CLR
#define TX_PI_CTL2r_SET BCMI_QTC_XGXS_TX_PI_CTL2r_SET
#define TX_PI_CTL2r_GET BCMI_QTC_XGXS_TX_PI_CTL2r_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_GET BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_SET BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET BCMI_QTC_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET
#define READ_TX_PI_CTL2r BCMI_QTC_XGXS_READ_TX_PI_CTL2r
#define WRITE_TX_PI_CTL2r BCMI_QTC_XGXS_WRITE_TX_PI_CTL2r
#define MODIFY_TX_PI_CTL2r BCMI_QTC_XGXS_MODIFY_TX_PI_CTL2r
#define READLN_TX_PI_CTL2r BCMI_QTC_XGXS_READLN_TX_PI_CTL2r
#define WRITELN_TX_PI_CTL2r BCMI_QTC_XGXS_WRITELN_TX_PI_CTL2r
#define WRITEALL_TX_PI_CTL2r BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_CTL3
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd073
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 3
 * SIZE:     32
 * FIELDS:
 *     TX_PI_PHASE_OVERRIDE Manual Phase Override Mode. When 1'b1 the PI phase can be moved manually using registers. All the filter logic is bypassed during manual mode.
 *     TX_PI_PHASE_STROBE Manual Phase strobe. When set to 1'b1 then it will generate 1 phase step (inc/dec depending on tx_pi_phase_step_dir) or multiple phase steps if tx_pi_phase_step_osr is 1'b1.If tx_pi_phase_override is 1'b0 then manual phase steps will be added with the output of the IIR filter phase steps during the time when there is no phase steps from the IIR filter.Self Clearing Register. Must be polled for 1'b0 before writing it to 1'b1 again for correct Manual Phase Step Shift.
 *     TX_PI_PHASE_STEP_DIR Manual Phase Step direction.1'b0: Increment1'b1: Decrement
 *     TX_PI_PHASE_INVERT 1'b1 : will invert (i.e. swap) the final inc and dec before the PI code shifter logic.
 *     TX_PI_PHASE_STEP_NUM Defines the number of phase steps movement for every manual strobe. Valid values are 1 to 15.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL3r (0x0001d073 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL3.
 */
typedef union BCMI_QTC_XGXS_TX_PI_CTL3r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl3[1];
	uint32_t _tx_pi_ctl3;
} BCMI_QTC_XGXS_TX_PI_CTL3r_t;

#define BCMI_QTC_XGXS_TX_PI_CTL3r_CLR(r) (r).tx_pi_ctl3[0] = 0
#define BCMI_QTC_XGXS_TX_PI_CTL3r_SET(r,d) (r).tx_pi_ctl3[0] = d
#define BCMI_QTC_XGXS_TX_PI_CTL3r_GET(r) (r).tx_pi_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET(r) ((((r).tx_pi_ctl3[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET(r) ((((r).tx_pi_ctl3[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET(r) ((((r).tx_pi_ctl3[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET(r) ((((r).tx_pi_ctl3[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET(r) (((r).tx_pi_ctl3[0]) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TX_PI_CTL3.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_CTL3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3))
#define BCMI_QTC_XGXS_WRITE_TX_PI_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3))
#define BCMI_QTC_XGXS_READLN_TX_PI_CTL3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl3))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_CTL3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl3))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL3r BCMI_QTC_XGXS_TX_PI_CTL3r
#define TX_PI_CTL3r_SIZE BCMI_QTC_XGXS_TX_PI_CTL3r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_CTL3r_t TX_PI_CTL3r_t;
#define TX_PI_CTL3r_CLR BCMI_QTC_XGXS_TX_PI_CTL3r_CLR
#define TX_PI_CTL3r_SET BCMI_QTC_XGXS_TX_PI_CTL3r_SET
#define TX_PI_CTL3r_GET BCMI_QTC_XGXS_TX_PI_CTL3r_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET BCMI_QTC_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET
#define READ_TX_PI_CTL3r BCMI_QTC_XGXS_READ_TX_PI_CTL3r
#define WRITE_TX_PI_CTL3r BCMI_QTC_XGXS_WRITE_TX_PI_CTL3r
#define MODIFY_TX_PI_CTL3r BCMI_QTC_XGXS_MODIFY_TX_PI_CTL3r
#define READLN_TX_PI_CTL3r BCMI_QTC_XGXS_READLN_TX_PI_CTL3r
#define WRITELN_TX_PI_CTL3r BCMI_QTC_XGXS_WRITELN_TX_PI_CTL3r
#define WRITEALL_TX_PI_CTL3r BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_CTL4
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd074
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 4
 * SIZE:     32
 * FIELDS:
 *     TX_PI_FRZ_FRC    IIR filter freeze control by force. 1'b1 will force the freeze value indicated by tx_pi_frz_frc_val otherwise Normal IIR operation.
 *     TX_PI_FRZ_FRC_VAL Force value for the IIR filter freeze. 1'b1 is freeze, 1'b0 is normal IIR operation.
 *     TX_PI_FRZ_MODE   Freeze Mode. 1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm from PLL/VCO clock.
 *     TX_PI_RESET_CODE_DBG Debug register.Resets the TX PI code going to AFE. This is just a debug register and is not recommended to be used during normal operation of TX PI.
 *     TX_PI_RMT_LPBK_BYPASS_FLT 1'b1 will enable filter bypass for inc/dec indication from Remote loopback PD to quicker phase locking time. This mode is recommended for faster simulation time.Note that it is only applicable if tx_pi_ext_ctrl_en is 1'b1.
 *     TX_PI_FRC_PHASE_STEP_MUX_SEL Force tx_phase_step mux select to 1'b1.1'b1 - will force the dsm2_rs_3 to be selected by the tx_phase_step mux.1'b0 - back to back inc and dec from the filter will be cancelled out.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL4r (0x0001d074 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL4.
 */
typedef union BCMI_QTC_XGXS_TX_PI_CTL4r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl4[1];
	uint32_t _tx_pi_ctl4;
} BCMI_QTC_XGXS_TX_PI_CTL4r_t;

#define BCMI_QTC_XGXS_TX_PI_CTL4r_CLR(r) (r).tx_pi_ctl4[0] = 0
#define BCMI_QTC_XGXS_TX_PI_CTL4r_SET(r,d) (r).tx_pi_ctl4[0] = d
#define BCMI_QTC_XGXS_TX_PI_CTL4r_GET(r) (r).tx_pi_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRC_PHASE_STEP_MUX_SELf_GET(r) ((((r).tx_pi_ctl4[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRC_PHASE_STEP_MUX_SELf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_GET(r) ((((r).tx_pi_ctl4[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET(r) ((((r).tx_pi_ctl4[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET(r) ((((r).tx_pi_ctl4[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET(r) ((((r).tx_pi_ctl4[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET(r) (((r).tx_pi_ctl4[0]) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TX_PI_CTL4.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_CTL4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4))
#define BCMI_QTC_XGXS_WRITE_TX_PI_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4))
#define BCMI_QTC_XGXS_READLN_TX_PI_CTL4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl4))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_CTL4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl4))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL4r BCMI_QTC_XGXS_TX_PI_CTL4r
#define TX_PI_CTL4r_SIZE BCMI_QTC_XGXS_TX_PI_CTL4r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_CTL4r_t TX_PI_CTL4r_t;
#define TX_PI_CTL4r_CLR BCMI_QTC_XGXS_TX_PI_CTL4r_CLR
#define TX_PI_CTL4r_SET BCMI_QTC_XGXS_TX_PI_CTL4r_SET
#define TX_PI_CTL4r_GET BCMI_QTC_XGXS_TX_PI_CTL4r_GET
#define TX_PI_CTL4r_TX_PI_FRC_PHASE_STEP_MUX_SELf_GET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRC_PHASE_STEP_MUX_SELf_GET
#define TX_PI_CTL4r_TX_PI_FRC_PHASE_STEP_MUX_SELf_SET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRC_PHASE_STEP_MUX_SELf_SET
#define TX_PI_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_GET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_GET
#define TX_PI_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_SET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_SET
#define TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET
#define TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET BCMI_QTC_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET
#define READ_TX_PI_CTL4r BCMI_QTC_XGXS_READ_TX_PI_CTL4r
#define WRITE_TX_PI_CTL4r BCMI_QTC_XGXS_WRITE_TX_PI_CTL4r
#define MODIFY_TX_PI_CTL4r BCMI_QTC_XGXS_MODIFY_TX_PI_CTL4r
#define READLN_TX_PI_CTL4r BCMI_QTC_XGXS_READLN_TX_PI_CTL4r
#define WRITELN_TX_PI_CTL4r BCMI_QTC_XGXS_WRITELN_TX_PI_CTL4r
#define WRITEALL_TX_PI_CTL4r BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_CTL6
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd076
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 6                    (ONLY Applicable to Eagle)
 * SIZE:     32
 * FIELDS:
 *     TX_PI_LANE_SEL_FRC_VAL 
 *     TX_PI_LANE_SEL_FRC If 1'b1 then phase_sum_val (from the CDR) and inc/dec (from the Remote Loopback PD) will be selected based on the tx_pi_lane_sel_frc_val register field.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL6r (0x0001d076 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL6.
 */
typedef union BCMI_QTC_XGXS_TX_PI_CTL6r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl6[1];
	uint32_t _tx_pi_ctl6;
} BCMI_QTC_XGXS_TX_PI_CTL6r_t;

#define BCMI_QTC_XGXS_TX_PI_CTL6r_CLR(r) (r).tx_pi_ctl6[0] = 0
#define BCMI_QTC_XGXS_TX_PI_CTL6r_SET(r,d) (r).tx_pi_ctl6[0] = d
#define BCMI_QTC_XGXS_TX_PI_CTL6r_GET(r) (r).tx_pi_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRCf_GET(r) ((((r).tx_pi_ctl6[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRCf_SET(r,f) (r).tx_pi_ctl6[0]=(((r).tx_pi_ctl6[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRC_VALf_GET(r) (((r).tx_pi_ctl6[0]) & 0x1f)
#define BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRC_VALf_SET(r,f) (r).tx_pi_ctl6[0]=(((r).tx_pi_ctl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access TX_PI_CTL6.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_CTL6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL6r,(_r._tx_pi_ctl6))
#define BCMI_QTC_XGXS_WRITE_TX_PI_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL6r,(_r._tx_pi_ctl6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL6r,(_r._tx_pi_ctl6))
#define BCMI_QTC_XGXS_READLN_TX_PI_CTL6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl6))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_CTL6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl6))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL6r BCMI_QTC_XGXS_TX_PI_CTL6r
#define TX_PI_CTL6r_SIZE BCMI_QTC_XGXS_TX_PI_CTL6r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_CTL6r_t TX_PI_CTL6r_t;
#define TX_PI_CTL6r_CLR BCMI_QTC_XGXS_TX_PI_CTL6r_CLR
#define TX_PI_CTL6r_SET BCMI_QTC_XGXS_TX_PI_CTL6r_SET
#define TX_PI_CTL6r_GET BCMI_QTC_XGXS_TX_PI_CTL6r_GET
#define TX_PI_CTL6r_TX_PI_LANE_SEL_FRCf_GET BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRCf_GET
#define TX_PI_CTL6r_TX_PI_LANE_SEL_FRCf_SET BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRCf_SET
#define TX_PI_CTL6r_TX_PI_LANE_SEL_FRC_VALf_GET BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRC_VALf_GET
#define TX_PI_CTL6r_TX_PI_LANE_SEL_FRC_VALf_SET BCMI_QTC_XGXS_TX_PI_CTL6r_TX_PI_LANE_SEL_FRC_VALf_SET
#define READ_TX_PI_CTL6r BCMI_QTC_XGXS_READ_TX_PI_CTL6r
#define WRITE_TX_PI_CTL6r BCMI_QTC_XGXS_WRITE_TX_PI_CTL6r
#define MODIFY_TX_PI_CTL6r BCMI_QTC_XGXS_MODIFY_TX_PI_CTL6r
#define READLN_TX_PI_CTL6r BCMI_QTC_XGXS_READLN_TX_PI_CTL6r
#define WRITELN_TX_PI_CTL6r BCMI_QTC_XGXS_WRITELN_TX_PI_CTL6r
#define WRITEALL_TX_PI_CTL6r BCMI_QTC_XGXS_WRITEALL_TX_PI_CTL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_STS0
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd078
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 0
 * SIZE:     32
 * FIELDS:
 *     TX_PI_PHASE_CNTR TX PI Phase Counter. Signed Value.
 */
#define BCMI_QTC_XGXS_TX_PI_STS0r (0x0001d078 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS0.
 */
typedef union BCMI_QTC_XGXS_TX_PI_STS0r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts0[1];
	uint32_t _tx_pi_sts0;
} BCMI_QTC_XGXS_TX_PI_STS0r_t;

#define BCMI_QTC_XGXS_TX_PI_STS0r_CLR(r) (r).tx_pi_sts0[0] = 0
#define BCMI_QTC_XGXS_TX_PI_STS0r_SET(r,d) (r).tx_pi_sts0[0] = d
#define BCMI_QTC_XGXS_TX_PI_STS0r_GET(r) (r).tx_pi_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET(r) (((r).tx_pi_sts0[0]) & 0x7f)
#define BCMI_QTC_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET(r,f) (r).tx_pi_sts0[0]=(((r).tx_pi_sts0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access TX_PI_STS0.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_STS0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0))
#define BCMI_QTC_XGXS_WRITE_TX_PI_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0))
#define BCMI_QTC_XGXS_READLN_TX_PI_STS0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts0))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_STS0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts0))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS0r BCMI_QTC_XGXS_TX_PI_STS0r
#define TX_PI_STS0r_SIZE BCMI_QTC_XGXS_TX_PI_STS0r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_STS0r_t TX_PI_STS0r_t;
#define TX_PI_STS0r_CLR BCMI_QTC_XGXS_TX_PI_STS0r_CLR
#define TX_PI_STS0r_SET BCMI_QTC_XGXS_TX_PI_STS0r_SET
#define TX_PI_STS0r_GET BCMI_QTC_XGXS_TX_PI_STS0r_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET BCMI_QTC_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET BCMI_QTC_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET
#define READ_TX_PI_STS0r BCMI_QTC_XGXS_READ_TX_PI_STS0r
#define WRITE_TX_PI_STS0r BCMI_QTC_XGXS_WRITE_TX_PI_STS0r
#define MODIFY_TX_PI_STS0r BCMI_QTC_XGXS_MODIFY_TX_PI_STS0r
#define READLN_TX_PI_STS0r BCMI_QTC_XGXS_READLN_TX_PI_STS0r
#define WRITELN_TX_PI_STS0r BCMI_QTC_XGXS_WRITELN_TX_PI_STS0r
#define WRITEALL_TX_PI_STS0r BCMI_QTC_XGXS_WRITEALL_TX_PI_STS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_STS1
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd079
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 1
 * SIZE:     32
 * FIELDS:
 *     TX_PI_INTEG1_REG TX PI integ1 register. Signed Value.
 */
#define BCMI_QTC_XGXS_TX_PI_STS1r (0x0001d079 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS1.
 */
typedef union BCMI_QTC_XGXS_TX_PI_STS1r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts1[1];
	uint32_t _tx_pi_sts1;
} BCMI_QTC_XGXS_TX_PI_STS1r_t;

#define BCMI_QTC_XGXS_TX_PI_STS1r_CLR(r) (r).tx_pi_sts1[0] = 0
#define BCMI_QTC_XGXS_TX_PI_STS1r_SET(r,d) (r).tx_pi_sts1[0] = d
#define BCMI_QTC_XGXS_TX_PI_STS1r_GET(r) (r).tx_pi_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET(r) (((r).tx_pi_sts1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET(r,f) (r).tx_pi_sts1[0]=(((r).tx_pi_sts1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access TX_PI_STS1.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_STS1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_QTC_XGXS_WRITE_TX_PI_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_QTC_XGXS_READLN_TX_PI_STS1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_STS1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS1r BCMI_QTC_XGXS_TX_PI_STS1r
#define TX_PI_STS1r_SIZE BCMI_QTC_XGXS_TX_PI_STS1r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_STS1r_t TX_PI_STS1r_t;
#define TX_PI_STS1r_CLR BCMI_QTC_XGXS_TX_PI_STS1r_CLR
#define TX_PI_STS1r_SET BCMI_QTC_XGXS_TX_PI_STS1r_SET
#define TX_PI_STS1r_GET BCMI_QTC_XGXS_TX_PI_STS1r_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_GET BCMI_QTC_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_SET BCMI_QTC_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET
#define READ_TX_PI_STS1r BCMI_QTC_XGXS_READ_TX_PI_STS1r
#define WRITE_TX_PI_STS1r BCMI_QTC_XGXS_WRITE_TX_PI_STS1r
#define MODIFY_TX_PI_STS1r BCMI_QTC_XGXS_MODIFY_TX_PI_STS1r
#define READLN_TX_PI_STS1r BCMI_QTC_XGXS_READLN_TX_PI_STS1r
#define WRITELN_TX_PI_STS1r BCMI_QTC_XGXS_WRITELN_TX_PI_STS1r
#define WRITEALL_TX_PI_STS1r BCMI_QTC_XGXS_WRITEALL_TX_PI_STS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_STS2
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd07a
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 2
 * SIZE:     32
 * FIELDS:
 *     TX_PI_INTEG2_REG TX PI integ2 register. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock.+8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock.
 */
#define BCMI_QTC_XGXS_TX_PI_STS2r (0x0001d07a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS2.
 */
typedef union BCMI_QTC_XGXS_TX_PI_STS2r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts2[1];
	uint32_t _tx_pi_sts2;
} BCMI_QTC_XGXS_TX_PI_STS2r_t;

#define BCMI_QTC_XGXS_TX_PI_STS2r_CLR(r) (r).tx_pi_sts2[0] = 0
#define BCMI_QTC_XGXS_TX_PI_STS2r_SET(r,d) (r).tx_pi_sts2[0] = d
#define BCMI_QTC_XGXS_TX_PI_STS2r_GET(r) (r).tx_pi_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET(r) (((r).tx_pi_sts2[0]) & 0x7fff)
#define BCMI_QTC_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET(r,f) (r).tx_pi_sts2[0]=(((r).tx_pi_sts2[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (32767 << 16)

/*
 * These macros can be used to access TX_PI_STS2.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_STS2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_QTC_XGXS_WRITE_TX_PI_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_QTC_XGXS_READLN_TX_PI_STS2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_STS2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS2r BCMI_QTC_XGXS_TX_PI_STS2r
#define TX_PI_STS2r_SIZE BCMI_QTC_XGXS_TX_PI_STS2r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_STS2r_t TX_PI_STS2r_t;
#define TX_PI_STS2r_CLR BCMI_QTC_XGXS_TX_PI_STS2r_CLR
#define TX_PI_STS2r_SET BCMI_QTC_XGXS_TX_PI_STS2r_SET
#define TX_PI_STS2r_GET BCMI_QTC_XGXS_TX_PI_STS2r_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_GET BCMI_QTC_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_SET BCMI_QTC_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET
#define READ_TX_PI_STS2r BCMI_QTC_XGXS_READ_TX_PI_STS2r
#define WRITE_TX_PI_STS2r BCMI_QTC_XGXS_WRITE_TX_PI_STS2r
#define MODIFY_TX_PI_STS2r BCMI_QTC_XGXS_MODIFY_TX_PI_STS2r
#define READLN_TX_PI_STS2r BCMI_QTC_XGXS_READLN_TX_PI_STS2r
#define WRITELN_TX_PI_STS2r BCMI_QTC_XGXS_WRITELN_TX_PI_STS2r
#define WRITEALL_TX_PI_STS2r BCMI_QTC_XGXS_WRITEALL_TX_PI_STS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TX_PI_STS3
 * BLOCKS:   TX_PI_COM
 * REGADDR:  0xd07b
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 3
 * SIZE:     32
 * FIELDS:
 *     TX_PI_PHASE_ERR  TX PI Phase Error. Signed Value. Valid values are -8 to +8.
 */
#define BCMI_QTC_XGXS_TX_PI_STS3r (0x0001d07b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TX_PI_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS3.
 */
typedef union BCMI_QTC_XGXS_TX_PI_STS3r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts3[1];
	uint32_t _tx_pi_sts3;
} BCMI_QTC_XGXS_TX_PI_STS3r_t;

#define BCMI_QTC_XGXS_TX_PI_STS3r_CLR(r) (r).tx_pi_sts3[0] = 0
#define BCMI_QTC_XGXS_TX_PI_STS3r_SET(r,d) (r).tx_pi_sts3[0] = d
#define BCMI_QTC_XGXS_TX_PI_STS3r_GET(r) (r).tx_pi_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET(r) (((r).tx_pi_sts3[0]) & 0x3f)
#define BCMI_QTC_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET(r,f) (r).tx_pi_sts3[0]=(((r).tx_pi_sts3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access TX_PI_STS3.
 */
#define BCMI_QTC_XGXS_READ_TX_PI_STS3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3))
#define BCMI_QTC_XGXS_WRITE_TX_PI_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TX_PI_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3))
#define BCMI_QTC_XGXS_READLN_TX_PI_STS3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts3))
#define BCMI_QTC_XGXS_WRITELN_TX_PI_STS3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts3))
#define BCMI_QTC_XGXS_WRITEALL_TX_PI_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS3r BCMI_QTC_XGXS_TX_PI_STS3r
#define TX_PI_STS3r_SIZE BCMI_QTC_XGXS_TX_PI_STS3r_SIZE
typedef BCMI_QTC_XGXS_TX_PI_STS3r_t TX_PI_STS3r_t;
#define TX_PI_STS3r_CLR BCMI_QTC_XGXS_TX_PI_STS3r_CLR
#define TX_PI_STS3r_SET BCMI_QTC_XGXS_TX_PI_STS3r_SET
#define TX_PI_STS3r_GET BCMI_QTC_XGXS_TX_PI_STS3r_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_GET BCMI_QTC_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_SET BCMI_QTC_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET
#define READ_TX_PI_STS3r BCMI_QTC_XGXS_READ_TX_PI_STS3r
#define WRITE_TX_PI_STS3r BCMI_QTC_XGXS_WRITE_TX_PI_STS3r
#define MODIFY_TX_PI_STS3r BCMI_QTC_XGXS_MODIFY_TX_PI_STS3r
#define READLN_TX_PI_STS3r BCMI_QTC_XGXS_READLN_TX_PI_STS3r
#define WRITELN_TX_PI_STS3r BCMI_QTC_XGXS_WRITELN_TX_PI_STS3r
#define WRITEALL_TX_PI_STS3r BCMI_QTC_XGXS_WRITEALL_TX_PI_STS3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TX_PI_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_OSR_MODE_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd080
 * DEVAD:    1
 * DESC:     OSR_MODE_CONTROL
 * SIZE:     32
 * FIELDS:
 *     OSR_MODE_FRC_VAL oversample (OS) mode
 *     OSR_MODE_FRC     oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr (0x0001d080 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_OSR_MODE_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_osr_mode_ctl[1];
	uint32_t _ckrst_osr_mode_ctl;
} BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_CLR(r) (r).ckrst_osr_mode_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_SET(r,d) (r).ckrst_osr_mode_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_GET(r) (r).ckrst_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_GET(r) ((((r).ckrst_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_SET(r,f) (r).ckrst_osr_mode_ctl[0]=(((r).ckrst_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET(r) (((r).ckrst_osr_mode_ctl[0]) & 0xf)
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET(r,f) (r).ckrst_osr_mode_ctl[0]=(((r).ckrst_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access CKRST_OSR_MODE_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_OSR_MODE_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr,(_r._ckrst_osr_mode_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_OSR_MODE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr,(_r._ckrst_osr_mode_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_OSR_MODE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr,(_r._ckrst_osr_mode_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_OSR_MODE_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_OSR_MODE_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_OSR_MODE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_osr_mode_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_OSR_MODE_CTLr BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr
#define CKRST_OSR_MODE_CTLr_SIZE BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_t CKRST_OSR_MODE_CTLr_t;
#define CKRST_OSR_MODE_CTLr_CLR BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_CLR
#define CKRST_OSR_MODE_CTLr_SET BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_SET
#define CKRST_OSR_MODE_CTLr_GET BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_GET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_GET BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_GET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_SET BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_SET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET
#define READ_CKRST_OSR_MODE_CTLr BCMI_QTC_XGXS_READ_CKRST_OSR_MODE_CTLr
#define WRITE_CKRST_OSR_MODE_CTLr BCMI_QTC_XGXS_WRITE_CKRST_OSR_MODE_CTLr
#define MODIFY_CKRST_OSR_MODE_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_OSR_MODE_CTLr
#define READLN_CKRST_OSR_MODE_CTLr BCMI_QTC_XGXS_READLN_CKRST_OSR_MODE_CTLr
#define WRITELN_CKRST_OSR_MODE_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_OSR_MODE_CTLr
#define WRITEALL_CKRST_OSR_MODE_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_OSR_MODE_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd081
 * DEVAD:    1
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * SIZE:     32
 * FIELDS:
 *     LN_DP_S_RSTB     Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 *     LN_RX_S_PWRDN    Active High Power Down control for RX Lane.If asserted by writing to 1'b1 will power down the RX Lane.
 *     LN_TX_S_PWRDN    Active High Power Down control for TX Lane.If asserted by writing to 1'b1 will power down the TX Lane.
 *     AFE_SIGDET_PWRDN Power Down for Signal Detect. 1=power down
 */
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d081 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _ckrst_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access CKRST_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_t CKRST_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET
#define READ_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_QTC_XGXS_READ_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_QTC_XGXS_WRITE_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_QTC_XGXS_READLN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_AFE_RST_PWRDWN_CTL_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd082
 * DEVAD:    1
 * DESC:     LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * SIZE:     32
 * FIELDS:
 *     AFE_RX_PWRDN_FRC AFE RX Lane powerdown force.
 *     AFE_RX_PWRDN_FRC_VAL AFE RX Lane powerdown force value.
 *     AFE_RX_RESET_FRC AFE RX Lane reset force.
 *     AFE_RX_RESET_FRC_VAL AFE RX Lane reset force value.
 *     AFE_TX_PWRDN_FRC AFE TX Lane powerdown force.
 *     AFE_TX_PWRDN_FRC_VAL AFE TX Lane powerdown force value.
 *     AFE_TX_RESET_FRC AFE TX Lane reset force.
 *     AFE_TX_RESET_FRC_VAL AFE TX Lane reset force value.
 */
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr (0x0001d082 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_afe_rst_pwrdwn_ctl_ctl[1];
	uint32_t _ckrst_ln_afe_rst_pwrdwn_ctl_ctl;
} BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR(r) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_SET(r,d) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_GET(r) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET(r) (((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._ckrst_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._ckrst_ln_afe_rst_pwrdwn_ctl_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._ckrst_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_afe_rst_pwrdwn_ctl_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_t CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_t;
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET
#define READ_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_QTC_XGXS_READ_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITE_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_QTC_XGXS_WRITE_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr
#define MODIFY_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr
#define READLN_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_QTC_XGXS_READLN_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITELN_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITEALL_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd083
 * DEVAD:    1
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PMD_LN_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 *     PMD_LN_RX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_rx_h_pwrdn input pin.
 *     PMD_LN_TX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_tx_h_pwrdn input pin.
 */
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d083 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _ckrst_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET(r) ((((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET(r) ((((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET(r) ((((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET(r) (((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_t CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET
#define READ_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_QTC_XGXS_READ_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_QTC_XGXS_WRITE_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_QTC_XGXS_READLN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_DBG_RST_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd084
 * DEVAD:    1
 * DESC:     LANE_DEBUG_RESET_CONTROL
 * SIZE:     32
 * FIELDS:
 *     LN_RX_S_RSTB     Active Low Lane Soft Reset for RX datapath and registers. If asserted by writing to 1'b0 will reset the RX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_RX_DP_S_RSTB  Active Low Lane Soft Reset for RX datapath. If asserted by writing to 1'b0 will reset the RX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     SIGDET_DP_RSTB_EN If asserted by writing to 1'b1 then lane datapath reset will also reset the sigdet filetr logic alomg with lane register reset.
 *     LN_TX_S_RSTB     Active Low Lane Soft Reset for TX datapath and registers. If asserted by writing to 1'b0 will reset the TX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_TX_DP_S_RSTB  Active Low Lane Soft Reset for TX datapath. If asserted by writing to 1'b0 will reset the TX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 */
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr (0x0001d084 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_DBG_RST_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_dbg_rst_ctl[1];
	uint32_t _ckrst_ln_dbg_rst_ctl;
} BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_CLR(r) (r).ckrst_ln_dbg_rst_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SET(r,d) (r).ckrst_ln_dbg_rst_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_GET(r) (r).ckrst_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET(r) (((r).ckrst_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_LN_DBG_RST_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_DBG_RST_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr,(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_DBG_RST_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr,(_r._ckrst_ln_dbg_rst_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_DBG_RST_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr,(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_DBG_RST_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_DBG_RST_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_DBG_RST_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_dbg_rst_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_DBG_RST_CTLr BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr
#define CKRST_LN_DBG_RST_CTLr_SIZE BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_t CKRST_LN_DBG_RST_CTLr_t;
#define CKRST_LN_DBG_RST_CTLr_CLR BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_CLR
#define CKRST_LN_DBG_RST_CTLr_SET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SET
#define CKRST_LN_DBG_RST_CTLr_GET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_GET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET
#define CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET
#define CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET
#define READ_CKRST_LN_DBG_RST_CTLr BCMI_QTC_XGXS_READ_CKRST_LN_DBG_RST_CTLr
#define WRITE_CKRST_LN_DBG_RST_CTLr BCMI_QTC_XGXS_WRITE_CKRST_LN_DBG_RST_CTLr
#define MODIFY_CKRST_LN_DBG_RST_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_LN_DBG_RST_CTLr
#define READLN_CKRST_LN_DBG_RST_CTLr BCMI_QTC_XGXS_READLN_CKRST_LN_DBG_RST_CTLr
#define WRITELN_CKRST_LN_DBG_RST_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_LN_DBG_RST_CTLr
#define WRITEALL_CKRST_LN_DBG_RST_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_DBG_RST_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_DBG_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_UC_ACK_LN_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd085
 * DEVAD:    1
 * DESC:     UC_ACK_LANE_CONTROL
 * SIZE:     32
 * FIELDS:
 *     UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr (0x0001d085 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_UC_ACK_LN_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_uc_ack_ln_ctl[1];
	uint32_t _ckrst_uc_ack_ln_ctl;
} BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_CLR(r) (r).ckrst_uc_ack_ln_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_SET(r,d) (r).ckrst_uc_ack_ln_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_GET(r) (r).ckrst_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).ckrst_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).ckrst_uc_ack_ln_ctl[0]=(((r).ckrst_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).ckrst_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).ckrst_uc_ack_ln_ctl[0]=(((r).ckrst_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_UC_ACK_LN_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_UC_ACK_LN_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr,(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_UC_ACK_LN_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr,(_r._ckrst_uc_ack_ln_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_UC_ACK_LN_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr,(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_UC_ACK_LN_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_UC_ACK_LN_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_UC_ACK_LN_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_uc_ack_ln_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_UC_ACK_LN_CTLr BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr
#define CKRST_UC_ACK_LN_CTLr_SIZE BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_t CKRST_UC_ACK_LN_CTLr_t;
#define CKRST_UC_ACK_LN_CTLr_CLR BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_CLR
#define CKRST_UC_ACK_LN_CTLr_SET BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_SET
#define CKRST_UC_ACK_LN_CTLr_GET BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_GET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET
#define READ_CKRST_UC_ACK_LN_CTLr BCMI_QTC_XGXS_READ_CKRST_UC_ACK_LN_CTLr
#define WRITE_CKRST_UC_ACK_LN_CTLr BCMI_QTC_XGXS_WRITE_CKRST_UC_ACK_LN_CTLr
#define MODIFY_CKRST_UC_ACK_LN_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_UC_ACK_LN_CTLr
#define READLN_CKRST_UC_ACK_LN_CTLr BCMI_QTC_XGXS_READLN_CKRST_UC_ACK_LN_CTLr
#define WRITELN_CKRST_UC_ACK_LN_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_UC_ACK_LN_CTLr
#define WRITEALL_CKRST_UC_ACK_LN_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_UC_ACK_LN_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_RST_OCC_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd086
 * DEVAD:    1
 * DESC:     LANE_REG_RESET_OCCURRED_CONTROL
 * SIZE:     32
 * FIELDS:
 *     LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr (0x0001d086 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_RST_OCC_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_rst_occ_ctl[1];
	uint32_t _ckrst_ln_rst_occ_ctl;
} BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_CLR(r) (r).ckrst_ln_rst_occ_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_SET(r,d) (r).ckrst_ln_rst_occ_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_GET(r) (r).ckrst_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET(r) (((r).ckrst_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).ckrst_ln_rst_occ_ctl[0]=(((r).ckrst_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_LN_RST_OCC_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr,(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr,(_r._ckrst_ln_rst_occ_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr,(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_RST_OCC_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_RST_OCC_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_rst_occ_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_RST_OCC_CTLr BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr
#define CKRST_LN_RST_OCC_CTLr_SIZE BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_t CKRST_LN_RST_OCC_CTLr_t;
#define CKRST_LN_RST_OCC_CTLr_CLR BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_CLR
#define CKRST_LN_RST_OCC_CTLr_SET BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_SET
#define CKRST_LN_RST_OCC_CTLr_GET BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_GET
#define CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET
#define CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET
#define READ_CKRST_LN_RST_OCC_CTLr BCMI_QTC_XGXS_READ_CKRST_LN_RST_OCC_CTLr
#define WRITE_CKRST_LN_RST_OCC_CTLr BCMI_QTC_XGXS_WRITE_CKRST_LN_RST_OCC_CTLr
#define MODIFY_CKRST_LN_RST_OCC_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_LN_RST_OCC_CTLr
#define READLN_CKRST_LN_RST_OCC_CTLr BCMI_QTC_XGXS_READLN_CKRST_LN_RST_OCC_CTLr
#define WRITELN_CKRST_LN_RST_OCC_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_LN_RST_OCC_CTLr
#define WRITEALL_CKRST_LN_RST_OCC_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_RST_OCC_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_CLK_N_RST_DBG_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd087
 * DEVAD:    1
 * DESC:     CLOCK_N_RESET_DEBUG_CONTROL
 * SIZE:     32
 * FIELDS:
 *     LN_RX_S_CLKGATE_FRC_ON Active High Lane clock gate control for RX clock gator.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_clkgate_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_SEL Mux control for selection of comclk for RX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_sel is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_FRC_ON Mux control for selection of comclk for RX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the lane clocks. This is a debug bit and should be used only for recovery from a dead AFE lane clock. Use of this bit with an active AFE clock can cause clock glitches.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     PMD_RX_CLK_VLD_FRC pmd_rx_clk_vld core output pin force.
 *     PMD_RX_CLK_VLD_FRC_VAL pmd_rx_clk_vld core output pin force value.
 */
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr (0x0001d087 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_CLK_N_RST_DBG_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_clk_n_rst_dbg_ctl[1];
	uint32_t _ckrst_clk_n_rst_dbg_ctl;
} BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_CLR(r) (r).ckrst_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SET(r,d) (r).ckrst_clk_n_rst_dbg_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_GET(r) (r).ckrst_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET(r) (((r).ckrst_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_CLK_N_RST_DBG_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr,(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr,(_r._ckrst_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr,(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_CLK_N_RST_DBG_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_CLK_N_RST_DBG_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_clk_n_rst_dbg_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_CLK_N_RST_DBG_CTLr BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr
#define CKRST_CLK_N_RST_DBG_CTLr_SIZE BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_t CKRST_CLK_N_RST_DBG_CTLr_t;
#define CKRST_CLK_N_RST_DBG_CTLr_CLR BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_CLR
#define CKRST_CLK_N_RST_DBG_CTLr_SET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SET
#define CKRST_CLK_N_RST_DBG_CTLr_GET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_GET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET
#define READ_CKRST_CLK_N_RST_DBG_CTLr BCMI_QTC_XGXS_READ_CKRST_CLK_N_RST_DBG_CTLr
#define WRITE_CKRST_CLK_N_RST_DBG_CTLr BCMI_QTC_XGXS_WRITE_CKRST_CLK_N_RST_DBG_CTLr
#define MODIFY_CKRST_CLK_N_RST_DBG_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_CLK_N_RST_DBG_CTLr
#define READLN_CKRST_CLK_N_RST_DBG_CTLr BCMI_QTC_XGXS_READLN_CKRST_CLK_N_RST_DBG_CTLr
#define WRITELN_CKRST_CLK_N_RST_DBG_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_CLK_N_RST_DBG_CTLr
#define WRITEALL_CKRST_CLK_N_RST_DBG_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_CLK_N_RST_DBG_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_CLK_N_RST_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_PMD_LN_MODE_STS
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd088
 * DEVAD:    1
 * DESC:     PMD_LANE_MODE_STATUS
 * SIZE:     32
 * FIELDS:
 *     PMD_LANE_MODE    This indicates the status of the core input pin pmd_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr (0x0001d088 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_PMD_LN_MODE_STS.
 */
typedef union BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_pmd_ln_mode_sts[1];
	uint32_t _ckrst_pmd_ln_mode_sts;
} BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_t;

#define BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_CLR(r) (r).ckrst_pmd_ln_mode_sts[0] = 0
#define BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_SET(r,d) (r).ckrst_pmd_ln_mode_sts[0] = d
#define BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_GET(r) (r).ckrst_pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET(r) (((r).ckrst_pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET(r,f) (r).ckrst_pmd_ln_mode_sts[0]=(((r).ckrst_pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CKRST_PMD_LN_MODE_STS.
 */
#define BCMI_QTC_XGXS_READ_CKRST_PMD_LN_MODE_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr,(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_QTC_XGXS_WRITE_CKRST_PMD_LN_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr,(_r._ckrst_pmd_ln_mode_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_PMD_LN_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr,(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_QTC_XGXS_READLN_CKRST_PMD_LN_MODE_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_QTC_XGXS_WRITELN_CKRST_PMD_LN_MODE_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_PMD_LN_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_pmd_ln_mode_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_PMD_LN_MODE_STSr BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr
#define CKRST_PMD_LN_MODE_STSr_SIZE BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_SIZE
typedef BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_t CKRST_PMD_LN_MODE_STSr_t;
#define CKRST_PMD_LN_MODE_STSr_CLR BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_CLR
#define CKRST_PMD_LN_MODE_STSr_SET BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_SET
#define CKRST_PMD_LN_MODE_STSr_GET BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_GET
#define CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET
#define CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET
#define READ_CKRST_PMD_LN_MODE_STSr BCMI_QTC_XGXS_READ_CKRST_PMD_LN_MODE_STSr
#define WRITE_CKRST_PMD_LN_MODE_STSr BCMI_QTC_XGXS_WRITE_CKRST_PMD_LN_MODE_STSr
#define MODIFY_CKRST_PMD_LN_MODE_STSr BCMI_QTC_XGXS_MODIFY_CKRST_PMD_LN_MODE_STSr
#define READLN_CKRST_PMD_LN_MODE_STSr BCMI_QTC_XGXS_READLN_CKRST_PMD_LN_MODE_STSr
#define WRITELN_CKRST_PMD_LN_MODE_STSr BCMI_QTC_XGXS_WRITELN_CKRST_PMD_LN_MODE_STSr
#define WRITEALL_CKRST_PMD_LN_MODE_STSr BCMI_QTC_XGXS_WRITEALL_CKRST_PMD_LN_MODE_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_PMD_LN_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_DP_RST_ST_STS
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd089
 * DEVAD:    1
 * DESC:     LANE_DP_RESET_STATE_STATUS
 * SIZE:     32
 * FIELDS:
 *     LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr (0x0001d089 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_DP_RST_ST_STS.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_dp_rst_st_sts[1];
	uint32_t _ckrst_ln_dp_rst_st_sts;
} BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_t;

#define BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_CLR(r) (r).ckrst_ln_dp_rst_st_sts[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_SET(r,d) (r).ckrst_ln_dp_rst_st_sts[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_GET(r) (r).ckrst_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET(r) (((r).ckrst_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET(r,f) (r).ckrst_ln_dp_rst_st_sts[0]=(((r).ckrst_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (7 << 16)

/*
 * These macros can be used to access CKRST_LN_DP_RST_ST_STS.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr,(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr,(_r._ckrst_ln_dp_rst_st_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr,(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_DP_RST_ST_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_DP_RST_ST_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_dp_rst_st_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_DP_RST_ST_STSr BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr
#define CKRST_LN_DP_RST_ST_STSr_SIZE BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_t CKRST_LN_DP_RST_ST_STSr_t;
#define CKRST_LN_DP_RST_ST_STSr_CLR BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_CLR
#define CKRST_LN_DP_RST_ST_STSr_SET BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_SET
#define CKRST_LN_DP_RST_ST_STSr_GET BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_GET
#define CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET
#define CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET
#define READ_CKRST_LN_DP_RST_ST_STSr BCMI_QTC_XGXS_READ_CKRST_LN_DP_RST_ST_STSr
#define WRITE_CKRST_LN_DP_RST_ST_STSr BCMI_QTC_XGXS_WRITE_CKRST_LN_DP_RST_ST_STSr
#define MODIFY_CKRST_LN_DP_RST_ST_STSr BCMI_QTC_XGXS_MODIFY_CKRST_LN_DP_RST_ST_STSr
#define READLN_CKRST_LN_DP_RST_ST_STSr BCMI_QTC_XGXS_READLN_CKRST_LN_DP_RST_ST_STSr
#define WRITELN_CKRST_LN_DP_RST_ST_STSr BCMI_QTC_XGXS_WRITELN_CKRST_LN_DP_RST_ST_STSr
#define WRITEALL_CKRST_LN_DP_RST_ST_STSr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_DP_RST_ST_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_MCST_MASK_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd08a
 * DEVAD:    1
 * DESC:     LANE_MULTICAST_MASK_CONTROL
 * SIZE:     32
 * FIELDS:
 *     LANE_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr (0x0001d08a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_MCST_MASK_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_mcst_mask_ctl[1];
	uint32_t _ckrst_ln_mcst_mask_ctl;
} BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_CLR(r) (r).ckrst_ln_mcst_mask_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_SET(r,d) (r).ckrst_ln_mcst_mask_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_GET(r) (r).ckrst_ln_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_LANE_MULTICAST_MASK_CONTROLf_GET(r) (((r).ckrst_ln_mcst_mask_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_LANE_MULTICAST_MASK_CONTROLf_SET(r,f) (r).ckrst_ln_mcst_mask_ctl[0]=(((r).ckrst_ln_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_LN_MCST_MASK_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr,(_r._ckrst_ln_mcst_mask_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr,(_r._ckrst_ln_mcst_mask_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr,(_r._ckrst_ln_mcst_mask_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_MCST_MASK_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_mcst_mask_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_MCST_MASK_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_mcst_mask_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_mcst_mask_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_MCST_MASK_CTLr BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr
#define CKRST_LN_MCST_MASK_CTLr_SIZE BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_t CKRST_LN_MCST_MASK_CTLr_t;
#define CKRST_LN_MCST_MASK_CTLr_CLR BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_CLR
#define CKRST_LN_MCST_MASK_CTLr_SET BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_SET
#define CKRST_LN_MCST_MASK_CTLr_GET BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_GET
#define CKRST_LN_MCST_MASK_CTLr_LANE_MULTICAST_MASK_CONTROLf_GET BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_LANE_MULTICAST_MASK_CONTROLf_GET
#define CKRST_LN_MCST_MASK_CTLr_LANE_MULTICAST_MASK_CONTROLf_SET BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr_LANE_MULTICAST_MASK_CONTROLf_SET
#define READ_CKRST_LN_MCST_MASK_CTLr BCMI_QTC_XGXS_READ_CKRST_LN_MCST_MASK_CTLr
#define WRITE_CKRST_LN_MCST_MASK_CTLr BCMI_QTC_XGXS_WRITE_CKRST_LN_MCST_MASK_CTLr
#define MODIFY_CKRST_LN_MCST_MASK_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_LN_MCST_MASK_CTLr
#define READLN_CKRST_LN_MCST_MASK_CTLr BCMI_QTC_XGXS_READLN_CKRST_LN_MCST_MASK_CTLr
#define WRITELN_CKRST_LN_MCST_MASK_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_LN_MCST_MASK_CTLr
#define WRITEALL_CKRST_LN_MCST_MASK_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_MCST_MASK_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_OSR_MODE_STS
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd08b
 * DEVAD:    1
 * DESC:     OSR_MODE_STATUS
 * SIZE:     32
 * FIELDS:
 *     OSR_MODE         OSR Mode status after the mux.
 */
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr (0x0001d08b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_OSR_MODE_STS.
 */
typedef union BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_osr_mode_sts[1];
	uint32_t _ckrst_osr_mode_sts;
} BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_t;

#define BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_CLR(r) (r).ckrst_osr_mode_sts[0] = 0
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_SET(r,d) (r).ckrst_osr_mode_sts[0] = d
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_GET(r) (r).ckrst_osr_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_GET(r) (((r).ckrst_osr_mode_sts[0]) & 0xf)
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_SET(r,f) (r).ckrst_osr_mode_sts[0]=(((r).ckrst_osr_mode_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access CKRST_OSR_MODE_STS.
 */
#define BCMI_QTC_XGXS_READ_CKRST_OSR_MODE_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr,(_r._ckrst_osr_mode_sts))
#define BCMI_QTC_XGXS_WRITE_CKRST_OSR_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr,(_r._ckrst_osr_mode_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_OSR_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr,(_r._ckrst_osr_mode_sts))
#define BCMI_QTC_XGXS_READLN_CKRST_OSR_MODE_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_sts))
#define BCMI_QTC_XGXS_WRITELN_CKRST_OSR_MODE_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_sts))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_OSR_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_osr_mode_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_OSR_MODE_STSr BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr
#define CKRST_OSR_MODE_STSr_SIZE BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_SIZE
typedef BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_t CKRST_OSR_MODE_STSr_t;
#define CKRST_OSR_MODE_STSr_CLR BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_CLR
#define CKRST_OSR_MODE_STSr_SET BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_SET
#define CKRST_OSR_MODE_STSr_GET BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_GET
#define CKRST_OSR_MODE_STSr_OSR_MODEf_GET BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_GET
#define CKRST_OSR_MODE_STSr_OSR_MODEf_SET BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_SET
#define READ_CKRST_OSR_MODE_STSr BCMI_QTC_XGXS_READ_CKRST_OSR_MODE_STSr
#define WRITE_CKRST_OSR_MODE_STSr BCMI_QTC_XGXS_WRITE_CKRST_OSR_MODE_STSr
#define MODIFY_CKRST_OSR_MODE_STSr BCMI_QTC_XGXS_MODIFY_CKRST_OSR_MODE_STSr
#define READLN_CKRST_OSR_MODE_STSr BCMI_QTC_XGXS_READLN_CKRST_OSR_MODE_STSr
#define WRITELN_CKRST_OSR_MODE_STSr BCMI_QTC_XGXS_WRITELN_CKRST_OSR_MODE_STSr
#define WRITEALL_CKRST_OSR_MODE_STSr BCMI_QTC_XGXS_WRITEALL_CKRST_OSR_MODE_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_OSR_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_OSR_MODE_PIN_STS
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd08c
 * DEVAD:    1
 * DESC:     OSR_MODE_PIN_STATUS
 * SIZE:     32
 * FIELDS:
 *     OSR_MODE_PIN     Indicates the status of the pmd_osr_mode input pin. Description of OSR mode decodes are as follows:OSX1       4'd0OSX2       4'd1OSX3       4'd2OSX3P3     4'd3OSX4       4'd4OSX5       4'd5OSX7P5     4'd6OSX8       4'd7OSX8P25    4'd8OSX10      4'd9
 */
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr (0x0001d08c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_OSR_MODE_PIN_STS.
 */
typedef union BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_osr_mode_pin_sts[1];
	uint32_t _ckrst_osr_mode_pin_sts;
} BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_t;

#define BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_CLR(r) (r).ckrst_osr_mode_pin_sts[0] = 0
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_SET(r,d) (r).ckrst_osr_mode_pin_sts[0] = d
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_GET(r) (r).ckrst_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET(r) (((r).ckrst_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET(r,f) (r).ckrst_osr_mode_pin_sts[0]=(((r).ckrst_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access CKRST_OSR_MODE_PIN_STS.
 */
#define BCMI_QTC_XGXS_READ_CKRST_OSR_MODE_PIN_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr,(_r._ckrst_osr_mode_pin_sts))
#define BCMI_QTC_XGXS_WRITE_CKRST_OSR_MODE_PIN_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr,(_r._ckrst_osr_mode_pin_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_OSR_MODE_PIN_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr,(_r._ckrst_osr_mode_pin_sts))
#define BCMI_QTC_XGXS_READLN_CKRST_OSR_MODE_PIN_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_pin_sts))
#define BCMI_QTC_XGXS_WRITELN_CKRST_OSR_MODE_PIN_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_pin_sts))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_OSR_MODE_PIN_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_osr_mode_pin_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_OSR_MODE_PIN_STSr BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr
#define CKRST_OSR_MODE_PIN_STSr_SIZE BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_t CKRST_OSR_MODE_PIN_STSr_t;
#define CKRST_OSR_MODE_PIN_STSr_CLR BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_CLR
#define CKRST_OSR_MODE_PIN_STSr_SET BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_SET
#define CKRST_OSR_MODE_PIN_STSr_GET BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_GET
#define CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET
#define CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET
#define READ_CKRST_OSR_MODE_PIN_STSr BCMI_QTC_XGXS_READ_CKRST_OSR_MODE_PIN_STSr
#define WRITE_CKRST_OSR_MODE_PIN_STSr BCMI_QTC_XGXS_WRITE_CKRST_OSR_MODE_PIN_STSr
#define MODIFY_CKRST_OSR_MODE_PIN_STSr BCMI_QTC_XGXS_MODIFY_CKRST_OSR_MODE_PIN_STSr
#define READLN_CKRST_OSR_MODE_PIN_STSr BCMI_QTC_XGXS_READLN_CKRST_OSR_MODE_PIN_STSr
#define WRITELN_CKRST_OSR_MODE_PIN_STSr BCMI_QTC_XGXS_WRITELN_CKRST_OSR_MODE_PIN_STSr
#define WRITEALL_CKRST_OSR_MODE_PIN_STSr BCMI_QTC_XGXS_WRITEALL_CKRST_OSR_MODE_PIN_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CKRST_LN_S_RSTB_CTL
 * BLOCKS:   CKRST_CTRL
 * REGADDR:  0xd08e
 * DEVAD:    1
 * DESC:     LN_S_RSTB_CONTROL
 * SIZE:     32
 * FIELDS:
 *     LN_S_RSTB        Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 */
#define BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr (0x0001d08e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_S_RSTB_CTL.
 */
typedef union BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_s_rstb_ctl[1];
	uint32_t _ckrst_ln_s_rstb_ctl;
} BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_t;

#define BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_CLR(r) (r).ckrst_ln_s_rstb_ctl[0] = 0
#define BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_SET(r,d) (r).ckrst_ln_s_rstb_ctl[0] = d
#define BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_GET(r) (r).ckrst_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_GET(r) (((r).ckrst_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_SET(r,f) (r).ckrst_ln_s_rstb_ctl[0]=(((r).ckrst_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access CKRST_LN_S_RSTB_CTL.
 */
#define BCMI_QTC_XGXS_READ_CKRST_LN_S_RSTB_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr,(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_QTC_XGXS_WRITE_CKRST_LN_S_RSTB_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr,(_r._ckrst_ln_s_rstb_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CKRST_LN_S_RSTB_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr,(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_QTC_XGXS_READLN_CKRST_LN_S_RSTB_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_QTC_XGXS_WRITELN_CKRST_LN_S_RSTB_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CKRST_LN_S_RSTB_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_s_rstb_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_S_RSTB_CTLr BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr
#define CKRST_LN_S_RSTB_CTLr_SIZE BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_SIZE
typedef BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_t CKRST_LN_S_RSTB_CTLr_t;
#define CKRST_LN_S_RSTB_CTLr_CLR BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_CLR
#define CKRST_LN_S_RSTB_CTLr_SET BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_SET
#define CKRST_LN_S_RSTB_CTLr_GET BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_GET
#define CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_GET BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_GET
#define CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_SET BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_SET
#define READ_CKRST_LN_S_RSTB_CTLr BCMI_QTC_XGXS_READ_CKRST_LN_S_RSTB_CTLr
#define WRITE_CKRST_LN_S_RSTB_CTLr BCMI_QTC_XGXS_WRITE_CKRST_LN_S_RSTB_CTLr
#define MODIFY_CKRST_LN_S_RSTB_CTLr BCMI_QTC_XGXS_MODIFY_CKRST_LN_S_RSTB_CTLr
#define READLN_CKRST_LN_S_RSTB_CTLr BCMI_QTC_XGXS_READLN_CKRST_LN_S_RSTB_CTLr
#define WRITELN_CKRST_LN_S_RSTB_CTLr BCMI_QTC_XGXS_WRITELN_CKRST_LN_S_RSTB_CTLr
#define WRITEALL_CKRST_LN_S_RSTB_CTLr BCMI_QTC_XGXS_WRITEALL_CKRST_LN_S_RSTB_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CKRST_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_RX_CTL0
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd090
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_0
 * SIZE:     32
 * FIELDS:
 *     AMS_RX_SEL_DFECKDELAY see AMS
 *     AMS_RX_PHASE_INT_AMPL_CTRL see AMS
 *     AMS_RX_SIGDET_THRESHOLD NA. Please use afe_sigdet_thresh from sigdet module.
 *     AMS_RX_SIG_PWRDN default=0 for enable signal detector
 *     AMS_RX_VGA_OUTPUT_IDLE see AMS
 *     AMS_RX_TPORT_EN  output rx_wclk20 to PLL test port
 *     AMS_RX_SIGDET_BYPASS force sigdet output = 1
 *     AMS_RX_SIGDET_LOW_POWER use for <= 6G, saves 0.4mA
 *     AMS_RX_VGA_BW_EXTENSION lower gain, see AMS
 *     AMS_RX_DC_COUPLE for QSGMII DC mode
 *     AMS_RX_EN_10GMODE see AMS
 *     AMS_RX_IMIN_COMMONMODE imin (input common mode)
 *     AMS_RX_IMOD_COMMONMODE imode (input common mode)
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL0r (0x0001d090 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_RX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL0.
 */
typedef union BCMI_QTC_XGXS_AMS_RX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl0[1];
	uint32_t _ams_rx_ctl0;
} BCMI_QTC_XGXS_AMS_RX_CTL0r_t;

#define BCMI_QTC_XGXS_AMS_RX_CTL0r_CLR(r) (r).ams_rx_ctl0[0] = 0
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_SET(r,d) (r).ams_rx_ctl0[0] = d
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_GET(r) (r).ams_rx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMOD_COMMONMODEf_GET(r) ((((r).ams_rx_ctl0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMOD_COMMONMODEf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMIN_COMMONMODEf_GET(r) ((((r).ams_rx_ctl0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMIN_COMMONMODEf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_EN_10GMODEf_GET(r) ((((r).ams_rx_ctl0[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_EN_10GMODEf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_GET(r) ((((r).ams_rx_ctl0[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_BW_EXTENSIONf_GET(r) ((((r).ams_rx_ctl0[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_BW_EXTENSIONf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_LOW_POWERf_GET(r) ((((r).ams_rx_ctl0[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_LOW_POWERf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET(r) ((((r).ams_rx_ctl0[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_GET(r) ((((r).ams_rx_ctl0[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_OUTPUT_IDLEf_GET(r) ((((r).ams_rx_ctl0[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_OUTPUT_IDLEf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIG_PWRDNf_GET(r) ((((r).ams_rx_ctl0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIG_PWRDNf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET(r) ((((r).ams_rx_ctl0[0]) >> 3) & 0x7)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_PHASE_INT_AMPL_CTRLf_GET(r) ((((r).ams_rx_ctl0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_PHASE_INT_AMPL_CTRLf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SEL_DFECKDELAYf_GET(r) (((r).ams_rx_ctl0[0]) & 0x3)
#define BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SEL_DFECKDELAYf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AMS_RX_CTL0.
 */
#define BCMI_QTC_XGXS_READ_AMS_RX_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL0r,(_r._ams_rx_ctl0))
#define BCMI_QTC_XGXS_WRITE_AMS_RX_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL0r,(_r._ams_rx_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL0r,(_r._ams_rx_ctl0))
#define BCMI_QTC_XGXS_READLN_AMS_RX_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl0))
#define BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL0r BCMI_QTC_XGXS_AMS_RX_CTL0r
#define AMS_RX_CTL0r_SIZE BCMI_QTC_XGXS_AMS_RX_CTL0r_SIZE
typedef BCMI_QTC_XGXS_AMS_RX_CTL0r_t AMS_RX_CTL0r_t;
#define AMS_RX_CTL0r_CLR BCMI_QTC_XGXS_AMS_RX_CTL0r_CLR
#define AMS_RX_CTL0r_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_SET
#define AMS_RX_CTL0r_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_GET
#define AMS_RX_CTL0r_AMS_RX_IMOD_COMMONMODEf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMOD_COMMONMODEf_GET
#define AMS_RX_CTL0r_AMS_RX_IMOD_COMMONMODEf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMOD_COMMONMODEf_SET
#define AMS_RX_CTL0r_AMS_RX_IMIN_COMMONMODEf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMIN_COMMONMODEf_GET
#define AMS_RX_CTL0r_AMS_RX_IMIN_COMMONMODEf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_IMIN_COMMONMODEf_SET
#define AMS_RX_CTL0r_AMS_RX_EN_10GMODEf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_EN_10GMODEf_GET
#define AMS_RX_CTL0r_AMS_RX_EN_10GMODEf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_EN_10GMODEf_SET
#define AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_GET
#define AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_SET
#define AMS_RX_CTL0r_AMS_RX_VGA_BW_EXTENSIONf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_BW_EXTENSIONf_GET
#define AMS_RX_CTL0r_AMS_RX_VGA_BW_EXTENSIONf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_BW_EXTENSIONf_SET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_LOW_POWERf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_LOW_POWERf_GET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_LOW_POWERf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_LOW_POWERf_SET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET
#define AMS_RX_CTL0r_AMS_RX_TPORT_ENf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_GET
#define AMS_RX_CTL0r_AMS_RX_TPORT_ENf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_SET
#define AMS_RX_CTL0r_AMS_RX_VGA_OUTPUT_IDLEf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_OUTPUT_IDLEf_GET
#define AMS_RX_CTL0r_AMS_RX_VGA_OUTPUT_IDLEf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_OUTPUT_IDLEf_SET
#define AMS_RX_CTL0r_AMS_RX_SIG_PWRDNf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIG_PWRDNf_GET
#define AMS_RX_CTL0r_AMS_RX_SIG_PWRDNf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIG_PWRDNf_SET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET
#define AMS_RX_CTL0r_AMS_RX_PHASE_INT_AMPL_CTRLf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_PHASE_INT_AMPL_CTRLf_GET
#define AMS_RX_CTL0r_AMS_RX_PHASE_INT_AMPL_CTRLf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_PHASE_INT_AMPL_CTRLf_SET
#define AMS_RX_CTL0r_AMS_RX_SEL_DFECKDELAYf_GET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SEL_DFECKDELAYf_GET
#define AMS_RX_CTL0r_AMS_RX_SEL_DFECKDELAYf_SET BCMI_QTC_XGXS_AMS_RX_CTL0r_AMS_RX_SEL_DFECKDELAYf_SET
#define READ_AMS_RX_CTL0r BCMI_QTC_XGXS_READ_AMS_RX_CTL0r
#define WRITE_AMS_RX_CTL0r BCMI_QTC_XGXS_WRITE_AMS_RX_CTL0r
#define MODIFY_AMS_RX_CTL0r BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL0r
#define READLN_AMS_RX_CTL0r BCMI_QTC_XGXS_READLN_AMS_RX_CTL0r
#define WRITELN_AMS_RX_CTL0r BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL0r
#define WRITEALL_AMS_RX_CTL0r BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_RX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_RX_CTL1
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd091
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_1
 * SIZE:     32
 * FIELDS:
 *     AMS_RX_IMAX_COMMONMODE imax (imput common mode)
 *     AMS_RX_IMIN_PHASE_INT imin (Phase interpolator)
 *     AMS_RX_IMODE_PHASE_INT imode (Phase interpolator)
 *     AMS_RX_IMAX_PHASE_INT imax (Phase interpolator)
 *     AMS_RX_IMIN_VGA  imin (VGA)
 *     AMS_RX_IMODE_VGA imode (VGA)
 *     AMS_RX_IMAX_VGA  imax (VGA)
 *     AMS_RX_IMIN_DFE_SUMMER imin(DFE summer/buffer)
 *     AMS_RX_IMODE_DFE_SUMMER imode(DFE summer/buffer)
 *     AMS_RX_IMAX_DFE_SUMMER imax (DFE summer/buffer)
 *     AMS_RX_IMIN_PF   imin(Peaking filter)
 *     AMS_RX_IMODE_PF  imode(Peaking filter)
 *     AMS_RX_IMAX_PF   imax (Peaking filter)
 *     AMS_RX_IMIN_CTAT imin_ctat (CTAT)
 *     AMS_RX_IMODE_CTAT imode_ctat (CTAT)
 *     AMS_RX_IMAX_CTAT imax_ctat (CTAT)
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL1r (0x0001d091 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_RX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL1.
 */
typedef union BCMI_QTC_XGXS_AMS_RX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl1[1];
	uint32_t _ams_rx_ctl1;
} BCMI_QTC_XGXS_AMS_RX_CTL1r_t;

#define BCMI_QTC_XGXS_AMS_RX_CTL1r_CLR(r) (r).ams_rx_ctl1[0] = 0
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_SET(r,d) (r).ams_rx_ctl1[0] = d
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_GET(r) (r).ams_rx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_CTATf_GET(r) ((((r).ams_rx_ctl1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_CTATf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_CTATf_GET(r) ((((r).ams_rx_ctl1[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_CTATf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_CTATf_GET(r) ((((r).ams_rx_ctl1[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_CTATf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PFf_GET(r) ((((r).ams_rx_ctl1[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PFf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PFf_GET(r) ((((r).ams_rx_ctl1[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PFf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PFf_GET(r) ((((r).ams_rx_ctl1[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PFf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_DFE_SUMMERf_GET(r) ((((r).ams_rx_ctl1[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_DFE_SUMMERf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_DFE_SUMMERf_GET(r) ((((r).ams_rx_ctl1[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_DFE_SUMMERf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_DFE_SUMMERf_GET(r) ((((r).ams_rx_ctl1[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_DFE_SUMMERf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_VGAf_GET(r) ((((r).ams_rx_ctl1[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_VGAf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_VGAf_GET(r) ((((r).ams_rx_ctl1[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_VGAf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_VGAf_GET(r) ((((r).ams_rx_ctl1[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_VGAf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PHASE_INTf_GET(r) ((((r).ams_rx_ctl1[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PHASE_INTf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PHASE_INTf_GET(r) ((((r).ams_rx_ctl1[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PHASE_INTf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PHASE_INTf_GET(r) ((((r).ams_rx_ctl1[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PHASE_INTf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_COMMONMODEf_GET(r) (((r).ams_rx_ctl1[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_COMMONMODEf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_RX_CTL1.
 */
#define BCMI_QTC_XGXS_READ_AMS_RX_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL1r,(_r._ams_rx_ctl1))
#define BCMI_QTC_XGXS_WRITE_AMS_RX_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL1r,(_r._ams_rx_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL1r,(_r._ams_rx_ctl1))
#define BCMI_QTC_XGXS_READLN_AMS_RX_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl1))
#define BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL1r BCMI_QTC_XGXS_AMS_RX_CTL1r
#define AMS_RX_CTL1r_SIZE BCMI_QTC_XGXS_AMS_RX_CTL1r_SIZE
typedef BCMI_QTC_XGXS_AMS_RX_CTL1r_t AMS_RX_CTL1r_t;
#define AMS_RX_CTL1r_CLR BCMI_QTC_XGXS_AMS_RX_CTL1r_CLR
#define AMS_RX_CTL1r_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_SET
#define AMS_RX_CTL1r_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_GET
#define AMS_RX_CTL1r_AMS_RX_IMAX_CTATf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_CTATf_GET
#define AMS_RX_CTL1r_AMS_RX_IMAX_CTATf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_CTATf_SET
#define AMS_RX_CTL1r_AMS_RX_IMODE_CTATf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_CTATf_GET
#define AMS_RX_CTL1r_AMS_RX_IMODE_CTATf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_CTATf_SET
#define AMS_RX_CTL1r_AMS_RX_IMIN_CTATf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_CTATf_GET
#define AMS_RX_CTL1r_AMS_RX_IMIN_CTATf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_CTATf_SET
#define AMS_RX_CTL1r_AMS_RX_IMAX_PFf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PFf_GET
#define AMS_RX_CTL1r_AMS_RX_IMAX_PFf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PFf_SET
#define AMS_RX_CTL1r_AMS_RX_IMODE_PFf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PFf_GET
#define AMS_RX_CTL1r_AMS_RX_IMODE_PFf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PFf_SET
#define AMS_RX_CTL1r_AMS_RX_IMIN_PFf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PFf_GET
#define AMS_RX_CTL1r_AMS_RX_IMIN_PFf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PFf_SET
#define AMS_RX_CTL1r_AMS_RX_IMAX_DFE_SUMMERf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_DFE_SUMMERf_GET
#define AMS_RX_CTL1r_AMS_RX_IMAX_DFE_SUMMERf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_DFE_SUMMERf_SET
#define AMS_RX_CTL1r_AMS_RX_IMODE_DFE_SUMMERf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_DFE_SUMMERf_GET
#define AMS_RX_CTL1r_AMS_RX_IMODE_DFE_SUMMERf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_DFE_SUMMERf_SET
#define AMS_RX_CTL1r_AMS_RX_IMIN_DFE_SUMMERf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_DFE_SUMMERf_GET
#define AMS_RX_CTL1r_AMS_RX_IMIN_DFE_SUMMERf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_DFE_SUMMERf_SET
#define AMS_RX_CTL1r_AMS_RX_IMAX_VGAf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_VGAf_GET
#define AMS_RX_CTL1r_AMS_RX_IMAX_VGAf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_VGAf_SET
#define AMS_RX_CTL1r_AMS_RX_IMODE_VGAf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_VGAf_GET
#define AMS_RX_CTL1r_AMS_RX_IMODE_VGAf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_VGAf_SET
#define AMS_RX_CTL1r_AMS_RX_IMIN_VGAf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_VGAf_GET
#define AMS_RX_CTL1r_AMS_RX_IMIN_VGAf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_VGAf_SET
#define AMS_RX_CTL1r_AMS_RX_IMAX_PHASE_INTf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PHASE_INTf_GET
#define AMS_RX_CTL1r_AMS_RX_IMAX_PHASE_INTf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_PHASE_INTf_SET
#define AMS_RX_CTL1r_AMS_RX_IMODE_PHASE_INTf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PHASE_INTf_GET
#define AMS_RX_CTL1r_AMS_RX_IMODE_PHASE_INTf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMODE_PHASE_INTf_SET
#define AMS_RX_CTL1r_AMS_RX_IMIN_PHASE_INTf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PHASE_INTf_GET
#define AMS_RX_CTL1r_AMS_RX_IMIN_PHASE_INTf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMIN_PHASE_INTf_SET
#define AMS_RX_CTL1r_AMS_RX_IMAX_COMMONMODEf_GET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_COMMONMODEf_GET
#define AMS_RX_CTL1r_AMS_RX_IMAX_COMMONMODEf_SET BCMI_QTC_XGXS_AMS_RX_CTL1r_AMS_RX_IMAX_COMMONMODEf_SET
#define READ_AMS_RX_CTL1r BCMI_QTC_XGXS_READ_AMS_RX_CTL1r
#define WRITE_AMS_RX_CTL1r BCMI_QTC_XGXS_WRITE_AMS_RX_CTL1r
#define MODIFY_AMS_RX_CTL1r BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL1r
#define READLN_AMS_RX_CTL1r BCMI_QTC_XGXS_READLN_AMS_RX_CTL1r
#define WRITELN_AMS_RX_CTL1r BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL1r
#define WRITEALL_AMS_RX_CTL1r BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_RX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_RX_CTL2
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd092
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_2
 * SIZE:     32
 * FIELDS:
 *     AMS_RX_SPARE_32  reserved[32]
 *     AMS_RX_SPARE_33  reserved[33]
 *     AMS_RX_SPARE_34  reserved[34]
 *     AMS_RX_IMIN_SLICER imin(Slicers/comparators/latches/D2c)
 *     AMS_RX_IMODE_SLICER imode(Slicers/comparators/latches/D2c)
 *     AMS_RX_IMAX_SLICER imax (Slicers/comparators/latches/D2c)
 *     AMS_RX_IMIN_DFE_TAP_WEIGHT imin(DFE tap weight)
 *     AMS_RX_IMODE_DFE_TAP_WEIGHT imode(DFE tap weight)
 *     AMS_RX_IMAX_DFE_TAP_WEIGHT imax (DFE tap weight)
 *     AMS_RX_SEL_UGBW  unity gain buffer BW
 *     AMS_RX_SEL_TH4DFE DFE tap voltage
 *     AMS_RX_EN_VCCTRL 1 for enable common control for DFE signal path
 *     AMS_RX_SPARE_46  reserve[46]
 *     AMS_RX_SPARE_47  reserve[47]
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL2r (0x0001d092 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_RX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL2.
 */
typedef union BCMI_QTC_XGXS_AMS_RX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl2[1];
	uint32_t _ams_rx_ctl2;
} BCMI_QTC_XGXS_AMS_RX_CTL2r_t;

#define BCMI_QTC_XGXS_AMS_RX_CTL2r_CLR(r) (r).ams_rx_ctl2[0] = 0
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_SET(r,d) (r).ams_rx_ctl2[0] = d
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_GET(r) (r).ams_rx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_47f_GET(r) ((((r).ams_rx_ctl2[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_47f_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_46f_GET(r) ((((r).ams_rx_ctl2[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_46f_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_EN_VCCTRLf_GET(r) ((((r).ams_rx_ctl2[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_EN_VCCTRLf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET(r) ((((r).ams_rx_ctl2[0]) >> 11) & 0x3)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_GET(r) ((((r).ams_rx_ctl2[0]) >> 9) & 0x3)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_DFE_TAP_WEIGHTf_GET(r) ((((r).ams_rx_ctl2[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_DFE_TAP_WEIGHTf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_DFE_TAP_WEIGHTf_GET(r) ((((r).ams_rx_ctl2[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_DFE_TAP_WEIGHTf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_DFE_TAP_WEIGHTf_GET(r) ((((r).ams_rx_ctl2[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_DFE_TAP_WEIGHTf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_SLICERf_GET(r) ((((r).ams_rx_ctl2[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_SLICERf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_SLICERf_GET(r) ((((r).ams_rx_ctl2[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_SLICERf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_SLICERf_GET(r) ((((r).ams_rx_ctl2[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_SLICERf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_34f_GET(r) ((((r).ams_rx_ctl2[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_34f_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_33f_GET(r) ((((r).ams_rx_ctl2[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_33f_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_32f_GET(r) (((r).ams_rx_ctl2[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_32f_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_RX_CTL2.
 */
#define BCMI_QTC_XGXS_READ_AMS_RX_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL2r,(_r._ams_rx_ctl2))
#define BCMI_QTC_XGXS_WRITE_AMS_RX_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL2r,(_r._ams_rx_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL2r,(_r._ams_rx_ctl2))
#define BCMI_QTC_XGXS_READLN_AMS_RX_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl2))
#define BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL2r BCMI_QTC_XGXS_AMS_RX_CTL2r
#define AMS_RX_CTL2r_SIZE BCMI_QTC_XGXS_AMS_RX_CTL2r_SIZE
typedef BCMI_QTC_XGXS_AMS_RX_CTL2r_t AMS_RX_CTL2r_t;
#define AMS_RX_CTL2r_CLR BCMI_QTC_XGXS_AMS_RX_CTL2r_CLR
#define AMS_RX_CTL2r_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_SET
#define AMS_RX_CTL2r_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_GET
#define AMS_RX_CTL2r_AMS_RX_SPARE_47f_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_47f_GET
#define AMS_RX_CTL2r_AMS_RX_SPARE_47f_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_47f_SET
#define AMS_RX_CTL2r_AMS_RX_SPARE_46f_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_46f_GET
#define AMS_RX_CTL2r_AMS_RX_SPARE_46f_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_46f_SET
#define AMS_RX_CTL2r_AMS_RX_EN_VCCTRLf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_EN_VCCTRLf_GET
#define AMS_RX_CTL2r_AMS_RX_EN_VCCTRLf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_EN_VCCTRLf_SET
#define AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET
#define AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET
#define AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_GET
#define AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_SET
#define AMS_RX_CTL2r_AMS_RX_IMAX_DFE_TAP_WEIGHTf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_DFE_TAP_WEIGHTf_GET
#define AMS_RX_CTL2r_AMS_RX_IMAX_DFE_TAP_WEIGHTf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_DFE_TAP_WEIGHTf_SET
#define AMS_RX_CTL2r_AMS_RX_IMODE_DFE_TAP_WEIGHTf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_DFE_TAP_WEIGHTf_GET
#define AMS_RX_CTL2r_AMS_RX_IMODE_DFE_TAP_WEIGHTf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_DFE_TAP_WEIGHTf_SET
#define AMS_RX_CTL2r_AMS_RX_IMIN_DFE_TAP_WEIGHTf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_DFE_TAP_WEIGHTf_GET
#define AMS_RX_CTL2r_AMS_RX_IMIN_DFE_TAP_WEIGHTf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_DFE_TAP_WEIGHTf_SET
#define AMS_RX_CTL2r_AMS_RX_IMAX_SLICERf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_SLICERf_GET
#define AMS_RX_CTL2r_AMS_RX_IMAX_SLICERf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMAX_SLICERf_SET
#define AMS_RX_CTL2r_AMS_RX_IMODE_SLICERf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_SLICERf_GET
#define AMS_RX_CTL2r_AMS_RX_IMODE_SLICERf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMODE_SLICERf_SET
#define AMS_RX_CTL2r_AMS_RX_IMIN_SLICERf_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_SLICERf_GET
#define AMS_RX_CTL2r_AMS_RX_IMIN_SLICERf_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_IMIN_SLICERf_SET
#define AMS_RX_CTL2r_AMS_RX_SPARE_34f_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_34f_GET
#define AMS_RX_CTL2r_AMS_RX_SPARE_34f_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_34f_SET
#define AMS_RX_CTL2r_AMS_RX_SPARE_33f_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_33f_GET
#define AMS_RX_CTL2r_AMS_RX_SPARE_33f_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_33f_SET
#define AMS_RX_CTL2r_AMS_RX_SPARE_32f_GET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_32f_GET
#define AMS_RX_CTL2r_AMS_RX_SPARE_32f_SET BCMI_QTC_XGXS_AMS_RX_CTL2r_AMS_RX_SPARE_32f_SET
#define READ_AMS_RX_CTL2r BCMI_QTC_XGXS_READ_AMS_RX_CTL2r
#define WRITE_AMS_RX_CTL2r BCMI_QTC_XGXS_WRITE_AMS_RX_CTL2r
#define MODIFY_AMS_RX_CTL2r BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL2r
#define READLN_AMS_RX_CTL2r BCMI_QTC_XGXS_READLN_AMS_RX_CTL2r
#define WRITELN_AMS_RX_CTL2r BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL2r
#define WRITEALL_AMS_RX_CTL2r BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_RX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_RX_CTL3
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd093
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_3
 * SIZE:     32
 * FIELDS:
 *     AMS_RX_IMIN_DC_OFFSET_DAC imin(DC offset DAC)
 *     AMS_RX_IMODE_DC_OFFSET_DAC imode (DC offset DAC)
 *     AMS_RX_IMAX_DC_OFFSET_DAC imax (DC offset DAC)
 *     AMS_RX_IMIN_PHASE_INT_P1 imin(phase interpolater_p1)
 *     AMS_RX_IMODE_PHASE_INT_P1 imode(phase interpolater_p1)
 *     AMS_RX_IMAX_PHASE_INT_P1 imax(phase interpolater_p1)
 *     AMS_RX_IMIN_METRES_EYEDIAG imin(metres eyediag)
 *     AMS_RX_IMODE_METRES_EYEDIAG imode (metres eyediag)
 *     AMS_RX_IMAX_METRES_EYEDIAG imax (metres eyediag)
 *     AMS_RX_IMIN_SIGNAL_DETECT imin(Signal Detect)
 *     AMS_RX_IMODE_SIGNAL_DETECT imode (Signal Detect)
 *     AMS_RX_IMAX_SIGNAL_DETECT imax (Signal Detect)
 *     AMS_RX_I4DEADZONE see AMS
 *     AMS_RX_I1P25DFE  increase all DFE tap current 1.25x
 *     AMS_RX_SPARE_62  reserved 62
 *     AMS_RX_SPARE_63  reserved 63
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL3r (0x0001d093 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_RX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL3.
 */
typedef union BCMI_QTC_XGXS_AMS_RX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl3[1];
	uint32_t _ams_rx_ctl3;
} BCMI_QTC_XGXS_AMS_RX_CTL3r_t;

#define BCMI_QTC_XGXS_AMS_RX_CTL3r_CLR(r) (r).ams_rx_ctl3[0] = 0
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_SET(r,d) (r).ams_rx_ctl3[0] = d
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_GET(r) (r).ams_rx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_GET(r) ((((r).ams_rx_ctl3[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_62f_GET(r) ((((r).ams_rx_ctl3[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_62f_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I1P25DFEf_GET(r) ((((r).ams_rx_ctl3[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I1P25DFEf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I4DEADZONEf_GET(r) ((((r).ams_rx_ctl3[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I4DEADZONEf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_SIGNAL_DETECTf_GET(r) ((((r).ams_rx_ctl3[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_SIGNAL_DETECTf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_SIGNAL_DETECTf_GET(r) ((((r).ams_rx_ctl3[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_SIGNAL_DETECTf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_SIGNAL_DETECTf_GET(r) ((((r).ams_rx_ctl3[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_SIGNAL_DETECTf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_METRES_EYEDIAGf_GET(r) ((((r).ams_rx_ctl3[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_METRES_EYEDIAGf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_METRES_EYEDIAGf_GET(r) ((((r).ams_rx_ctl3[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_METRES_EYEDIAGf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_METRES_EYEDIAGf_GET(r) ((((r).ams_rx_ctl3[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_METRES_EYEDIAGf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_PHASE_INT_P1f_GET(r) ((((r).ams_rx_ctl3[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_PHASE_INT_P1f_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_PHASE_INT_P1f_GET(r) ((((r).ams_rx_ctl3[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_PHASE_INT_P1f_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_PHASE_INT_P1f_GET(r) ((((r).ams_rx_ctl3[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_PHASE_INT_P1f_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_DC_OFFSET_DACf_GET(r) ((((r).ams_rx_ctl3[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_DC_OFFSET_DACf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_DC_OFFSET_DACf_GET(r) ((((r).ams_rx_ctl3[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_DC_OFFSET_DACf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_DC_OFFSET_DACf_GET(r) (((r).ams_rx_ctl3[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_DC_OFFSET_DACf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_RX_CTL3.
 */
#define BCMI_QTC_XGXS_READ_AMS_RX_CTL3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL3r,(_r._ams_rx_ctl3))
#define BCMI_QTC_XGXS_WRITE_AMS_RX_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL3r,(_r._ams_rx_ctl3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL3r,(_r._ams_rx_ctl3))
#define BCMI_QTC_XGXS_READLN_AMS_RX_CTL3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl3))
#define BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl3))
#define BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL3r BCMI_QTC_XGXS_AMS_RX_CTL3r
#define AMS_RX_CTL3r_SIZE BCMI_QTC_XGXS_AMS_RX_CTL3r_SIZE
typedef BCMI_QTC_XGXS_AMS_RX_CTL3r_t AMS_RX_CTL3r_t;
#define AMS_RX_CTL3r_CLR BCMI_QTC_XGXS_AMS_RX_CTL3r_CLR
#define AMS_RX_CTL3r_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_SET
#define AMS_RX_CTL3r_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_GET
#define AMS_RX_CTL3r_AMS_RX_SPARE_63f_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_GET
#define AMS_RX_CTL3r_AMS_RX_SPARE_63f_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_SET
#define AMS_RX_CTL3r_AMS_RX_SPARE_62f_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_62f_GET
#define AMS_RX_CTL3r_AMS_RX_SPARE_62f_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_62f_SET
#define AMS_RX_CTL3r_AMS_RX_I1P25DFEf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I1P25DFEf_GET
#define AMS_RX_CTL3r_AMS_RX_I1P25DFEf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I1P25DFEf_SET
#define AMS_RX_CTL3r_AMS_RX_I4DEADZONEf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I4DEADZONEf_GET
#define AMS_RX_CTL3r_AMS_RX_I4DEADZONEf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_I4DEADZONEf_SET
#define AMS_RX_CTL3r_AMS_RX_IMAX_SIGNAL_DETECTf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_SIGNAL_DETECTf_GET
#define AMS_RX_CTL3r_AMS_RX_IMAX_SIGNAL_DETECTf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_SIGNAL_DETECTf_SET
#define AMS_RX_CTL3r_AMS_RX_IMODE_SIGNAL_DETECTf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_SIGNAL_DETECTf_GET
#define AMS_RX_CTL3r_AMS_RX_IMODE_SIGNAL_DETECTf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_SIGNAL_DETECTf_SET
#define AMS_RX_CTL3r_AMS_RX_IMIN_SIGNAL_DETECTf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_SIGNAL_DETECTf_GET
#define AMS_RX_CTL3r_AMS_RX_IMIN_SIGNAL_DETECTf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_SIGNAL_DETECTf_SET
#define AMS_RX_CTL3r_AMS_RX_IMAX_METRES_EYEDIAGf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_METRES_EYEDIAGf_GET
#define AMS_RX_CTL3r_AMS_RX_IMAX_METRES_EYEDIAGf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_METRES_EYEDIAGf_SET
#define AMS_RX_CTL3r_AMS_RX_IMODE_METRES_EYEDIAGf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_METRES_EYEDIAGf_GET
#define AMS_RX_CTL3r_AMS_RX_IMODE_METRES_EYEDIAGf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_METRES_EYEDIAGf_SET
#define AMS_RX_CTL3r_AMS_RX_IMIN_METRES_EYEDIAGf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_METRES_EYEDIAGf_GET
#define AMS_RX_CTL3r_AMS_RX_IMIN_METRES_EYEDIAGf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_METRES_EYEDIAGf_SET
#define AMS_RX_CTL3r_AMS_RX_IMAX_PHASE_INT_P1f_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_PHASE_INT_P1f_GET
#define AMS_RX_CTL3r_AMS_RX_IMAX_PHASE_INT_P1f_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_PHASE_INT_P1f_SET
#define AMS_RX_CTL3r_AMS_RX_IMODE_PHASE_INT_P1f_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_PHASE_INT_P1f_GET
#define AMS_RX_CTL3r_AMS_RX_IMODE_PHASE_INT_P1f_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_PHASE_INT_P1f_SET
#define AMS_RX_CTL3r_AMS_RX_IMIN_PHASE_INT_P1f_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_PHASE_INT_P1f_GET
#define AMS_RX_CTL3r_AMS_RX_IMIN_PHASE_INT_P1f_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_PHASE_INT_P1f_SET
#define AMS_RX_CTL3r_AMS_RX_IMAX_DC_OFFSET_DACf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_DC_OFFSET_DACf_GET
#define AMS_RX_CTL3r_AMS_RX_IMAX_DC_OFFSET_DACf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMAX_DC_OFFSET_DACf_SET
#define AMS_RX_CTL3r_AMS_RX_IMODE_DC_OFFSET_DACf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_DC_OFFSET_DACf_GET
#define AMS_RX_CTL3r_AMS_RX_IMODE_DC_OFFSET_DACf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMODE_DC_OFFSET_DACf_SET
#define AMS_RX_CTL3r_AMS_RX_IMIN_DC_OFFSET_DACf_GET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_DC_OFFSET_DACf_GET
#define AMS_RX_CTL3r_AMS_RX_IMIN_DC_OFFSET_DACf_SET BCMI_QTC_XGXS_AMS_RX_CTL3r_AMS_RX_IMIN_DC_OFFSET_DACf_SET
#define READ_AMS_RX_CTL3r BCMI_QTC_XGXS_READ_AMS_RX_CTL3r
#define WRITE_AMS_RX_CTL3r BCMI_QTC_XGXS_WRITE_AMS_RX_CTL3r
#define MODIFY_AMS_RX_CTL3r BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL3r
#define READLN_AMS_RX_CTL3r BCMI_QTC_XGXS_READLN_AMS_RX_CTL3r
#define WRITELN_AMS_RX_CTL3r BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL3r
#define WRITEALL_AMS_RX_CTL3r BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_RX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_RX_CTL4
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd094
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_4
 * SIZE:     32
 * FIELDS:
 *     AMS_RX_DC_OFFSET see AMS
 *     AMS_RX_FORCE_DC_OFFSET enables override using register bits
 *     AMS_RX_DC_OFFSET_RANGE range 2x
 *     AMS_RX_VGA_RESCAL_MUX VGA rescal mux (force, ctrl[3:2]) - rescal override
 *     AMS_RX_PHS_INTERP_RESCAL_MUX Phase interp rescal mux (force, ctrl[3:1]) - rescal override
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL4r (0x0001d094 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_RX_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL4.
 */
typedef union BCMI_QTC_XGXS_AMS_RX_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl4[1];
	uint32_t _ams_rx_ctl4;
} BCMI_QTC_XGXS_AMS_RX_CTL4r_t;

#define BCMI_QTC_XGXS_AMS_RX_CTL4r_CLR(r) (r).ams_rx_ctl4[0] = 0
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_SET(r,d) (r).ams_rx_ctl4[0] = d
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_GET(r) (r).ams_rx_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_PHS_INTERP_RESCAL_MUXf_GET(r) ((((r).ams_rx_ctl4[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_PHS_INTERP_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_VGA_RESCAL_MUXf_GET(r) ((((r).ams_rx_ctl4[0]) >> 9) & 0x7)
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_VGA_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSET_RANGEf_GET(r) ((((r).ams_rx_ctl4[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSET_RANGEf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_FORCE_DC_OFFSETf_GET(r) ((((r).ams_rx_ctl4[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_FORCE_DC_OFFSETf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSETf_GET(r) (((r).ams_rx_ctl4[0]) & 0x7f)
#define BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSETf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access AMS_RX_CTL4.
 */
#define BCMI_QTC_XGXS_READ_AMS_RX_CTL4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL4r,(_r._ams_rx_ctl4))
#define BCMI_QTC_XGXS_WRITE_AMS_RX_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL4r,(_r._ams_rx_ctl4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL4r,(_r._ams_rx_ctl4))
#define BCMI_QTC_XGXS_READLN_AMS_RX_CTL4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl4))
#define BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl4))
#define BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL4r BCMI_QTC_XGXS_AMS_RX_CTL4r
#define AMS_RX_CTL4r_SIZE BCMI_QTC_XGXS_AMS_RX_CTL4r_SIZE
typedef BCMI_QTC_XGXS_AMS_RX_CTL4r_t AMS_RX_CTL4r_t;
#define AMS_RX_CTL4r_CLR BCMI_QTC_XGXS_AMS_RX_CTL4r_CLR
#define AMS_RX_CTL4r_SET BCMI_QTC_XGXS_AMS_RX_CTL4r_SET
#define AMS_RX_CTL4r_GET BCMI_QTC_XGXS_AMS_RX_CTL4r_GET
#define AMS_RX_CTL4r_AMS_RX_PHS_INTERP_RESCAL_MUXf_GET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_PHS_INTERP_RESCAL_MUXf_GET
#define AMS_RX_CTL4r_AMS_RX_PHS_INTERP_RESCAL_MUXf_SET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_PHS_INTERP_RESCAL_MUXf_SET
#define AMS_RX_CTL4r_AMS_RX_VGA_RESCAL_MUXf_GET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_VGA_RESCAL_MUXf_GET
#define AMS_RX_CTL4r_AMS_RX_VGA_RESCAL_MUXf_SET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_VGA_RESCAL_MUXf_SET
#define AMS_RX_CTL4r_AMS_RX_DC_OFFSET_RANGEf_GET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSET_RANGEf_GET
#define AMS_RX_CTL4r_AMS_RX_DC_OFFSET_RANGEf_SET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSET_RANGEf_SET
#define AMS_RX_CTL4r_AMS_RX_FORCE_DC_OFFSETf_GET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_FORCE_DC_OFFSETf_GET
#define AMS_RX_CTL4r_AMS_RX_FORCE_DC_OFFSETf_SET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_FORCE_DC_OFFSETf_SET
#define AMS_RX_CTL4r_AMS_RX_DC_OFFSETf_GET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSETf_GET
#define AMS_RX_CTL4r_AMS_RX_DC_OFFSETf_SET BCMI_QTC_XGXS_AMS_RX_CTL4r_AMS_RX_DC_OFFSETf_SET
#define READ_AMS_RX_CTL4r BCMI_QTC_XGXS_READ_AMS_RX_CTL4r
#define WRITE_AMS_RX_CTL4r BCMI_QTC_XGXS_WRITE_AMS_RX_CTL4r
#define MODIFY_AMS_RX_CTL4r BCMI_QTC_XGXS_MODIFY_AMS_RX_CTL4r
#define READLN_AMS_RX_CTL4r BCMI_QTC_XGXS_READLN_AMS_RX_CTL4r
#define WRITELN_AMS_RX_CTL4r BCMI_QTC_XGXS_WRITELN_AMS_RX_CTL4r
#define WRITEALL_AMS_RX_CTL4r BCMI_QTC_XGXS_WRITEALL_AMS_RX_CTL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_RX_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_RX_INTCTL
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd098
 * DEVAD:    1
 * DESC:     INTERNAL RX CONTROL
 * SIZE:     32
 * FIELDS:
 *     AMS_RX_DFE_OS2X_MODE dfe_os2x mode to AFE
 */
#define BCMI_QTC_XGXS_AMS_RX_INTCTLr (0x0001d098 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_RX_INTCTLr_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_INTCTL.
 */
typedef union BCMI_QTC_XGXS_AMS_RX_INTCTLr_s {
	uint32_t v[1];
	uint32_t ams_rx_intctl[1];
	uint32_t _ams_rx_intctl;
} BCMI_QTC_XGXS_AMS_RX_INTCTLr_t;

#define BCMI_QTC_XGXS_AMS_RX_INTCTLr_CLR(r) (r).ams_rx_intctl[0] = 0
#define BCMI_QTC_XGXS_AMS_RX_INTCTLr_SET(r,d) (r).ams_rx_intctl[0] = d
#define BCMI_QTC_XGXS_AMS_RX_INTCTLr_GET(r) (r).ams_rx_intctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_RX_INTCTLr_AMS_RX_DFE_OS2X_MODEf_GET(r) (((r).ams_rx_intctl[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_RX_INTCTLr_AMS_RX_DFE_OS2X_MODEf_SET(r,f) (r).ams_rx_intctl[0]=(((r).ams_rx_intctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_RX_INTCTL.
 */
#define BCMI_QTC_XGXS_READ_AMS_RX_INTCTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_INTCTLr,(_r._ams_rx_intctl))
#define BCMI_QTC_XGXS_WRITE_AMS_RX_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_INTCTLr,(_r._ams_rx_intctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_RX_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_INTCTLr,(_r._ams_rx_intctl))
#define BCMI_QTC_XGXS_READLN_AMS_RX_INTCTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_intctl))
#define BCMI_QTC_XGXS_WRITELN_AMS_RX_INTCTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_intctl))
#define BCMI_QTC_XGXS_WRITEALL_AMS_RX_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_intctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_INTCTLr BCMI_QTC_XGXS_AMS_RX_INTCTLr
#define AMS_RX_INTCTLr_SIZE BCMI_QTC_XGXS_AMS_RX_INTCTLr_SIZE
typedef BCMI_QTC_XGXS_AMS_RX_INTCTLr_t AMS_RX_INTCTLr_t;
#define AMS_RX_INTCTLr_CLR BCMI_QTC_XGXS_AMS_RX_INTCTLr_CLR
#define AMS_RX_INTCTLr_SET BCMI_QTC_XGXS_AMS_RX_INTCTLr_SET
#define AMS_RX_INTCTLr_GET BCMI_QTC_XGXS_AMS_RX_INTCTLr_GET
#define AMS_RX_INTCTLr_AMS_RX_DFE_OS2X_MODEf_GET BCMI_QTC_XGXS_AMS_RX_INTCTLr_AMS_RX_DFE_OS2X_MODEf_GET
#define AMS_RX_INTCTLr_AMS_RX_DFE_OS2X_MODEf_SET BCMI_QTC_XGXS_AMS_RX_INTCTLr_AMS_RX_DFE_OS2X_MODEf_SET
#define READ_AMS_RX_INTCTLr BCMI_QTC_XGXS_READ_AMS_RX_INTCTLr
#define WRITE_AMS_RX_INTCTLr BCMI_QTC_XGXS_WRITE_AMS_RX_INTCTLr
#define MODIFY_AMS_RX_INTCTLr BCMI_QTC_XGXS_MODIFY_AMS_RX_INTCTLr
#define READLN_AMS_RX_INTCTLr BCMI_QTC_XGXS_READLN_AMS_RX_INTCTLr
#define WRITELN_AMS_RX_INTCTLr BCMI_QTC_XGXS_WRITELN_AMS_RX_INTCTLr
#define WRITEALL_AMS_RX_INTCTLr BCMI_QTC_XGXS_WRITEALL_AMS_RX_INTCTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_RX_INTCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_RX_STS
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd099
 * DEVAD:    1
 * DESC:     AMS RX STATUS
 * SIZE:     32
 * FIELDS:
 *     AMS_RX_STS       RX status from AFE
 */
#define BCMI_QTC_XGXS_AMS_RX_STSr (0x0001d099 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_RX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_STS.
 */
typedef union BCMI_QTC_XGXS_AMS_RX_STSr_s {
	uint32_t v[1];
	uint32_t ams_rx_sts[1];
	uint32_t _ams_rx_sts;
} BCMI_QTC_XGXS_AMS_RX_STSr_t;

#define BCMI_QTC_XGXS_AMS_RX_STSr_CLR(r) (r).ams_rx_sts[0] = 0
#define BCMI_QTC_XGXS_AMS_RX_STSr_SET(r,d) (r).ams_rx_sts[0] = d
#define BCMI_QTC_XGXS_AMS_RX_STSr_GET(r) (r).ams_rx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_RX_STSr_AMS_RX_STSf_GET(r) (((r).ams_rx_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_AMS_RX_STSr_AMS_RX_STSf_SET(r,f) (r).ams_rx_sts[0]=(((r).ams_rx_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AMS_RX_STS.
 */
#define BCMI_QTC_XGXS_READ_AMS_RX_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_STSr,(_r._ams_rx_sts))
#define BCMI_QTC_XGXS_WRITE_AMS_RX_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_STSr,(_r._ams_rx_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_RX_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_STSr,(_r._ams_rx_sts))
#define BCMI_QTC_XGXS_READLN_AMS_RX_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_sts))
#define BCMI_QTC_XGXS_WRITELN_AMS_RX_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_sts))
#define BCMI_QTC_XGXS_WRITEALL_AMS_RX_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_STSr BCMI_QTC_XGXS_AMS_RX_STSr
#define AMS_RX_STSr_SIZE BCMI_QTC_XGXS_AMS_RX_STSr_SIZE
typedef BCMI_QTC_XGXS_AMS_RX_STSr_t AMS_RX_STSr_t;
#define AMS_RX_STSr_CLR BCMI_QTC_XGXS_AMS_RX_STSr_CLR
#define AMS_RX_STSr_SET BCMI_QTC_XGXS_AMS_RX_STSr_SET
#define AMS_RX_STSr_GET BCMI_QTC_XGXS_AMS_RX_STSr_GET
#define AMS_RX_STSr_AMS_RX_STSf_GET BCMI_QTC_XGXS_AMS_RX_STSr_AMS_RX_STSf_GET
#define AMS_RX_STSr_AMS_RX_STSf_SET BCMI_QTC_XGXS_AMS_RX_STSr_AMS_RX_STSf_SET
#define READ_AMS_RX_STSr BCMI_QTC_XGXS_READ_AMS_RX_STSr
#define WRITE_AMS_RX_STSr BCMI_QTC_XGXS_WRITE_AMS_RX_STSr
#define MODIFY_AMS_RX_STSr BCMI_QTC_XGXS_MODIFY_AMS_RX_STSr
#define READLN_AMS_RX_STSr BCMI_QTC_XGXS_READLN_AMS_RX_STSr
#define WRITELN_AMS_RX_STSr BCMI_QTC_XGXS_WRITELN_AMS_RX_STSr
#define WRITEALL_AMS_RX_STSr BCMI_QTC_XGXS_WRITEALL_AMS_RX_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_RX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_TX_CTL0
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a0
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_0
 * SIZE:     32
 * FIELDS:
 *     AMS_TX_OSR4      OS 4x mode to support lower rates with proper FIR functionality
 *     AMS_TX_SPARE_1   reserved[1]
 *     AMS_TX_SPARE_2   reserved[2]
 *     AMS_TX_SPARE_3   reserved[3]
 *     AMS_TX_TEST_DATA generates output pattern
 *     AMS_TX_TICKSEL   timing control of load signal at ana/dig interface
 *     AMS_TX_KR_TEST_MODE test mode for step size
 *     AMS_TX_DCC_SEL   select feedback signal for DCC
 *     AMS_TX_DCC_DIS   disable Duty Cycle Correction(DCC)
 *     AMS_TX_CAL_OFF   disable RESCAL[3:0], enable cal_aux[3:0]
 *     AMS_TX_CAL_AUX   Rescal manual control when cal_off=1
 */
#define BCMI_QTC_XGXS_AMS_TX_CTL0r (0x0001d0a0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_TX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_CTL0.
 */
typedef union BCMI_QTC_XGXS_AMS_TX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_tx_ctl0[1];
	uint32_t _ams_tx_ctl0;
} BCMI_QTC_XGXS_AMS_TX_CTL0r_t;

#define BCMI_QTC_XGXS_AMS_TX_CTL0r_CLR(r) (r).ams_tx_ctl0[0] = 0
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_SET(r,d) (r).ams_tx_ctl0[0] = d
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_GET(r) (r).ams_tx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_GET(r) ((((r).ams_tx_ctl0[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_GET(r) ((((r).ams_tx_ctl0[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_GET(r) ((((r).ams_tx_ctl0[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_GET(r) ((((r).ams_tx_ctl0[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_KR_TEST_MODEf_GET(r) ((((r).ams_tx_ctl0[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_KR_TEST_MODEf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_GET(r) ((((r).ams_tx_ctl0[0]) >> 6) & 0x3)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_GET(r) ((((r).ams_tx_ctl0[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3f_GET(r) ((((r).ams_tx_ctl0[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3f_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_2f_GET(r) ((((r).ams_tx_ctl0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_2f_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_1f_GET(r) ((((r).ams_tx_ctl0[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_1f_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_OSR4f_GET(r) (((r).ams_tx_ctl0[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_OSR4f_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_TX_CTL0.
 */
#define BCMI_QTC_XGXS_READ_AMS_TX_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_CTL0r,(_r._ams_tx_ctl0))
#define BCMI_QTC_XGXS_WRITE_AMS_TX_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL0r,(_r._ams_tx_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_TX_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL0r,(_r._ams_tx_ctl0))
#define BCMI_QTC_XGXS_READLN_AMS_TX_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl0))
#define BCMI_QTC_XGXS_WRITELN_AMS_TX_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_AMS_TX_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_CTL0r BCMI_QTC_XGXS_AMS_TX_CTL0r
#define AMS_TX_CTL0r_SIZE BCMI_QTC_XGXS_AMS_TX_CTL0r_SIZE
typedef BCMI_QTC_XGXS_AMS_TX_CTL0r_t AMS_TX_CTL0r_t;
#define AMS_TX_CTL0r_CLR BCMI_QTC_XGXS_AMS_TX_CTL0r_CLR
#define AMS_TX_CTL0r_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_SET
#define AMS_TX_CTL0r_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_GET
#define AMS_TX_CTL0r_AMS_TX_CAL_AUXf_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_GET
#define AMS_TX_CTL0r_AMS_TX_CAL_AUXf_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_SET
#define AMS_TX_CTL0r_AMS_TX_CAL_OFFf_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_GET
#define AMS_TX_CTL0r_AMS_TX_CAL_OFFf_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_SET
#define AMS_TX_CTL0r_AMS_TX_DCC_DISf_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_GET
#define AMS_TX_CTL0r_AMS_TX_DCC_DISf_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_SET
#define AMS_TX_CTL0r_AMS_TX_DCC_SELf_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_GET
#define AMS_TX_CTL0r_AMS_TX_DCC_SELf_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_SET
#define AMS_TX_CTL0r_AMS_TX_KR_TEST_MODEf_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_KR_TEST_MODEf_GET
#define AMS_TX_CTL0r_AMS_TX_KR_TEST_MODEf_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_KR_TEST_MODEf_SET
#define AMS_TX_CTL0r_AMS_TX_TICKSELf_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_GET
#define AMS_TX_CTL0r_AMS_TX_TICKSELf_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_SET
#define AMS_TX_CTL0r_AMS_TX_TEST_DATAf_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_GET
#define AMS_TX_CTL0r_AMS_TX_TEST_DATAf_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_SET
#define AMS_TX_CTL0r_AMS_TX_SPARE_3f_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3f_GET
#define AMS_TX_CTL0r_AMS_TX_SPARE_3f_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3f_SET
#define AMS_TX_CTL0r_AMS_TX_SPARE_2f_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_2f_GET
#define AMS_TX_CTL0r_AMS_TX_SPARE_2f_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_2f_SET
#define AMS_TX_CTL0r_AMS_TX_SPARE_1f_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_1f_GET
#define AMS_TX_CTL0r_AMS_TX_SPARE_1f_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_1f_SET
#define AMS_TX_CTL0r_AMS_TX_OSR4f_GET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_OSR4f_GET
#define AMS_TX_CTL0r_AMS_TX_OSR4f_SET BCMI_QTC_XGXS_AMS_TX_CTL0r_AMS_TX_OSR4f_SET
#define READ_AMS_TX_CTL0r BCMI_QTC_XGXS_READ_AMS_TX_CTL0r
#define WRITE_AMS_TX_CTL0r BCMI_QTC_XGXS_WRITE_AMS_TX_CTL0r
#define MODIFY_AMS_TX_CTL0r BCMI_QTC_XGXS_MODIFY_AMS_TX_CTL0r
#define READLN_AMS_TX_CTL0r BCMI_QTC_XGXS_READLN_AMS_TX_CTL0r
#define WRITELN_AMS_TX_CTL0r BCMI_QTC_XGXS_WRITELN_AMS_TX_CTL0r
#define WRITEALL_AMS_TX_CTL0r BCMI_QTC_XGXS_WRITEALL_AMS_TX_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_TX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_TX_CTL1
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a1
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_1
 * SIZE:     32
 * FIELDS:
 *     AMS_TX_IBIAS     master bias diode
 *     AMS_TX_IDCC      DCC opamp current control
 *     AMS_TX_ICML      clock input buffer current control
 *     AMS_TX_SPARE_30_25 ams_reserved [30:25]
 *     AMS_TX_LP_OVRD   override internally generated low power mode
 */
#define BCMI_QTC_XGXS_AMS_TX_CTL1r (0x0001d0a1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_TX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_CTL1.
 */
typedef union BCMI_QTC_XGXS_AMS_TX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_tx_ctl1[1];
	uint32_t _ams_tx_ctl1;
} BCMI_QTC_XGXS_AMS_TX_CTL1r_t;

#define BCMI_QTC_XGXS_AMS_TX_CTL1r_CLR(r) (r).ams_tx_ctl1[0] = 0
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_SET(r,d) (r).ams_tx_ctl1[0] = d
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_GET(r) (r).ams_tx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_LP_OVRDf_GET(r) ((((r).ams_tx_ctl1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_LP_OVRDf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_30_25f_GET(r) ((((r).ams_tx_ctl1[0]) >> 9) & 0x3f)
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_30_25f_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_GET(r) ((((r).ams_tx_ctl1[0]) >> 6) & 0x7)
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IDCCf_GET(r) ((((r).ams_tx_ctl1[0]) >> 3) & 0x7)
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IDCCf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_GET(r) (((r).ams_tx_ctl1[0]) & 0x7)
#define BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (7 << 16)

/*
 * These macros can be used to access AMS_TX_CTL1.
 */
#define BCMI_QTC_XGXS_READ_AMS_TX_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_CTL1r,(_r._ams_tx_ctl1))
#define BCMI_QTC_XGXS_WRITE_AMS_TX_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL1r,(_r._ams_tx_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_TX_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL1r,(_r._ams_tx_ctl1))
#define BCMI_QTC_XGXS_READLN_AMS_TX_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl1))
#define BCMI_QTC_XGXS_WRITELN_AMS_TX_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_AMS_TX_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_CTL1r BCMI_QTC_XGXS_AMS_TX_CTL1r
#define AMS_TX_CTL1r_SIZE BCMI_QTC_XGXS_AMS_TX_CTL1r_SIZE
typedef BCMI_QTC_XGXS_AMS_TX_CTL1r_t AMS_TX_CTL1r_t;
#define AMS_TX_CTL1r_CLR BCMI_QTC_XGXS_AMS_TX_CTL1r_CLR
#define AMS_TX_CTL1r_SET BCMI_QTC_XGXS_AMS_TX_CTL1r_SET
#define AMS_TX_CTL1r_GET BCMI_QTC_XGXS_AMS_TX_CTL1r_GET
#define AMS_TX_CTL1r_AMS_TX_LP_OVRDf_GET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_LP_OVRDf_GET
#define AMS_TX_CTL1r_AMS_TX_LP_OVRDf_SET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_LP_OVRDf_SET
#define AMS_TX_CTL1r_AMS_TX_SPARE_30_25f_GET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_30_25f_GET
#define AMS_TX_CTL1r_AMS_TX_SPARE_30_25f_SET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_30_25f_SET
#define AMS_TX_CTL1r_AMS_TX_ICMLf_GET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_GET
#define AMS_TX_CTL1r_AMS_TX_ICMLf_SET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_SET
#define AMS_TX_CTL1r_AMS_TX_IDCCf_GET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IDCCf_GET
#define AMS_TX_CTL1r_AMS_TX_IDCCf_SET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IDCCf_SET
#define AMS_TX_CTL1r_AMS_TX_IBIASf_GET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_GET
#define AMS_TX_CTL1r_AMS_TX_IBIASf_SET BCMI_QTC_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_SET
#define READ_AMS_TX_CTL1r BCMI_QTC_XGXS_READ_AMS_TX_CTL1r
#define WRITE_AMS_TX_CTL1r BCMI_QTC_XGXS_WRITE_AMS_TX_CTL1r
#define MODIFY_AMS_TX_CTL1r BCMI_QTC_XGXS_MODIFY_AMS_TX_CTL1r
#define READLN_AMS_TX_CTL1r BCMI_QTC_XGXS_READLN_AMS_TX_CTL1r
#define WRITELN_AMS_TX_CTL1r BCMI_QTC_XGXS_WRITELN_AMS_TX_CTL1r
#define WRITEALL_AMS_TX_CTL1r BCMI_QTC_XGXS_WRITEALL_AMS_TX_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_TX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_TX_CTL2
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a2
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_2
 * SIZE:     32
 * FIELDS:
 *     AMS_TX_AMP_CTL   master amplitude control
 *     AMS_TX_POST3_COEF 3rd post cursor de-emphasis tap. NA, drivein by hardware tx_fir
 *     AMS_TX_SIGN_POST3 polarity control for 3rd post cursor tap,assert to cancel ISI
 *     AMS_TX_POST2_COEF 2nd post cursor de-emphasis tap. NA, driven by hardware tx_fir
 *     AMS_TX_SIGN_POST2 polarity control for 2nd post cursor tap
 *     AMS_TX_DRIVERMODE half amplitude / double resolution for main tap
 *     AMS_TX_ELEC_IDLE_AUX force electrical idle mode
 */
#define BCMI_QTC_XGXS_AMS_TX_CTL2r (0x0001d0a2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_TX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_CTL2.
 */
typedef union BCMI_QTC_XGXS_AMS_TX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_tx_ctl2[1];
	uint32_t _ams_tx_ctl2;
} BCMI_QTC_XGXS_AMS_TX_CTL2r_t;

#define BCMI_QTC_XGXS_AMS_TX_CTL2r_CLR(r) (r).ams_tx_ctl2[0] = 0
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_SET(r,d) (r).ams_tx_ctl2[0] = d
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_GET(r) (r).ams_tx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET(r) ((((r).ams_tx_ctl2[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_GET(r) ((((r).ams_tx_ctl2[0]) >> 13) & 0x3)
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_GET(r) ((((r).ams_tx_ctl2[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_GET(r) ((((r).ams_tx_ctl2[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_GET(r) ((((r).ams_tx_ctl2[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_GET(r) ((((r).ams_tx_ctl2[0]) >> 4) & 0x7)
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_GET(r) (((r).ams_tx_ctl2[0]) & 0xf)
#define BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access AMS_TX_CTL2.
 */
#define BCMI_QTC_XGXS_READ_AMS_TX_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_CTL2r,(_r._ams_tx_ctl2))
#define BCMI_QTC_XGXS_WRITE_AMS_TX_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL2r,(_r._ams_tx_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_TX_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL2r,(_r._ams_tx_ctl2))
#define BCMI_QTC_XGXS_READLN_AMS_TX_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl2))
#define BCMI_QTC_XGXS_WRITELN_AMS_TX_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_AMS_TX_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_CTL2r BCMI_QTC_XGXS_AMS_TX_CTL2r
#define AMS_TX_CTL2r_SIZE BCMI_QTC_XGXS_AMS_TX_CTL2r_SIZE
typedef BCMI_QTC_XGXS_AMS_TX_CTL2r_t AMS_TX_CTL2r_t;
#define AMS_TX_CTL2r_CLR BCMI_QTC_XGXS_AMS_TX_CTL2r_CLR
#define AMS_TX_CTL2r_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_SET
#define AMS_TX_CTL2r_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_GET
#define AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET
#define AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET
#define AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_GET
#define AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_SET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_GET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_SET
#define AMS_TX_CTL2r_AMS_TX_POST2_COEFf_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_GET
#define AMS_TX_CTL2r_AMS_TX_POST2_COEFf_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_SET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_GET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_SET
#define AMS_TX_CTL2r_AMS_TX_POST3_COEFf_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_GET
#define AMS_TX_CTL2r_AMS_TX_POST3_COEFf_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_SET
#define AMS_TX_CTL2r_AMS_TX_AMP_CTLf_GET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_GET
#define AMS_TX_CTL2r_AMS_TX_AMP_CTLf_SET BCMI_QTC_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_SET
#define READ_AMS_TX_CTL2r BCMI_QTC_XGXS_READ_AMS_TX_CTL2r
#define WRITE_AMS_TX_CTL2r BCMI_QTC_XGXS_WRITE_AMS_TX_CTL2r
#define MODIFY_AMS_TX_CTL2r BCMI_QTC_XGXS_MODIFY_AMS_TX_CTL2r
#define READLN_AMS_TX_CTL2r BCMI_QTC_XGXS_READLN_AMS_TX_CTL2r
#define WRITELN_AMS_TX_CTL2r BCMI_QTC_XGXS_WRITELN_AMS_TX_CTL2r
#define WRITEALL_AMS_TX_CTL2r BCMI_QTC_XGXS_WRITEALL_AMS_TX_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_TX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_TX_INTCTL
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a8
 * DEVAD:    1
 * DESC:     INTERNAL TX CONTROL
 * SIZE:     32
 * FIELDS:
 *     AMS_TX_SEL_HALFRATE tx_sel_halfrate to AFE
 */
#define BCMI_QTC_XGXS_AMS_TX_INTCTLr (0x0001d0a8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_TX_INTCTLr_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_INTCTL.
 */
typedef union BCMI_QTC_XGXS_AMS_TX_INTCTLr_s {
	uint32_t v[1];
	uint32_t ams_tx_intctl[1];
	uint32_t _ams_tx_intctl;
} BCMI_QTC_XGXS_AMS_TX_INTCTLr_t;

#define BCMI_QTC_XGXS_AMS_TX_INTCTLr_CLR(r) (r).ams_tx_intctl[0] = 0
#define BCMI_QTC_XGXS_AMS_TX_INTCTLr_SET(r,d) (r).ams_tx_intctl[0] = d
#define BCMI_QTC_XGXS_AMS_TX_INTCTLr_GET(r) (r).ams_tx_intctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_TX_INTCTLr_AMS_TX_SEL_HALFRATEf_GET(r) (((r).ams_tx_intctl[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_TX_INTCTLr_AMS_TX_SEL_HALFRATEf_SET(r,f) (r).ams_tx_intctl[0]=(((r).ams_tx_intctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_TX_INTCTL.
 */
#define BCMI_QTC_XGXS_READ_AMS_TX_INTCTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_INTCTLr,(_r._ams_tx_intctl))
#define BCMI_QTC_XGXS_WRITE_AMS_TX_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_INTCTLr,(_r._ams_tx_intctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_TX_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_INTCTLr,(_r._ams_tx_intctl))
#define BCMI_QTC_XGXS_READLN_AMS_TX_INTCTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_intctl))
#define BCMI_QTC_XGXS_WRITELN_AMS_TX_INTCTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_intctl))
#define BCMI_QTC_XGXS_WRITEALL_AMS_TX_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_intctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_INTCTLr BCMI_QTC_XGXS_AMS_TX_INTCTLr
#define AMS_TX_INTCTLr_SIZE BCMI_QTC_XGXS_AMS_TX_INTCTLr_SIZE
typedef BCMI_QTC_XGXS_AMS_TX_INTCTLr_t AMS_TX_INTCTLr_t;
#define AMS_TX_INTCTLr_CLR BCMI_QTC_XGXS_AMS_TX_INTCTLr_CLR
#define AMS_TX_INTCTLr_SET BCMI_QTC_XGXS_AMS_TX_INTCTLr_SET
#define AMS_TX_INTCTLr_GET BCMI_QTC_XGXS_AMS_TX_INTCTLr_GET
#define AMS_TX_INTCTLr_AMS_TX_SEL_HALFRATEf_GET BCMI_QTC_XGXS_AMS_TX_INTCTLr_AMS_TX_SEL_HALFRATEf_GET
#define AMS_TX_INTCTLr_AMS_TX_SEL_HALFRATEf_SET BCMI_QTC_XGXS_AMS_TX_INTCTLr_AMS_TX_SEL_HALFRATEf_SET
#define READ_AMS_TX_INTCTLr BCMI_QTC_XGXS_READ_AMS_TX_INTCTLr
#define WRITE_AMS_TX_INTCTLr BCMI_QTC_XGXS_WRITE_AMS_TX_INTCTLr
#define MODIFY_AMS_TX_INTCTLr BCMI_QTC_XGXS_MODIFY_AMS_TX_INTCTLr
#define READLN_AMS_TX_INTCTLr BCMI_QTC_XGXS_READLN_AMS_TX_INTCTLr
#define WRITELN_AMS_TX_INTCTLr BCMI_QTC_XGXS_WRITELN_AMS_TX_INTCTLr
#define WRITEALL_AMS_TX_INTCTLr BCMI_QTC_XGXS_WRITEALL_AMS_TX_INTCTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_TX_INTCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_TX_STS
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a9
 * DEVAD:    1
 * DESC:     AMS TX STATUS
 * SIZE:     32
 * FIELDS:
 *     AMS_TX_STS       tx status from AFE
 */
#define BCMI_QTC_XGXS_AMS_TX_STSr (0x0001d0a9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_TX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_STS.
 */
typedef union BCMI_QTC_XGXS_AMS_TX_STSr_s {
	uint32_t v[1];
	uint32_t ams_tx_sts[1];
	uint32_t _ams_tx_sts;
} BCMI_QTC_XGXS_AMS_TX_STSr_t;

#define BCMI_QTC_XGXS_AMS_TX_STSr_CLR(r) (r).ams_tx_sts[0] = 0
#define BCMI_QTC_XGXS_AMS_TX_STSr_SET(r,d) (r).ams_tx_sts[0] = d
#define BCMI_QTC_XGXS_AMS_TX_STSr_GET(r) (r).ams_tx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_TX_STSr_AMS_TX_STSf_GET(r) (((r).ams_tx_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_AMS_TX_STSr_AMS_TX_STSf_SET(r,f) (r).ams_tx_sts[0]=(((r).ams_tx_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AMS_TX_STS.
 */
#define BCMI_QTC_XGXS_READ_AMS_TX_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_STSr,(_r._ams_tx_sts))
#define BCMI_QTC_XGXS_WRITE_AMS_TX_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_STSr,(_r._ams_tx_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_TX_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_STSr,(_r._ams_tx_sts))
#define BCMI_QTC_XGXS_READLN_AMS_TX_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_sts))
#define BCMI_QTC_XGXS_WRITELN_AMS_TX_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_sts))
#define BCMI_QTC_XGXS_WRITEALL_AMS_TX_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_STSr BCMI_QTC_XGXS_AMS_TX_STSr
#define AMS_TX_STSr_SIZE BCMI_QTC_XGXS_AMS_TX_STSr_SIZE
typedef BCMI_QTC_XGXS_AMS_TX_STSr_t AMS_TX_STSr_t;
#define AMS_TX_STSr_CLR BCMI_QTC_XGXS_AMS_TX_STSr_CLR
#define AMS_TX_STSr_SET BCMI_QTC_XGXS_AMS_TX_STSr_SET
#define AMS_TX_STSr_GET BCMI_QTC_XGXS_AMS_TX_STSr_GET
#define AMS_TX_STSr_AMS_TX_STSf_GET BCMI_QTC_XGXS_AMS_TX_STSr_AMS_TX_STSf_GET
#define AMS_TX_STSr_AMS_TX_STSf_SET BCMI_QTC_XGXS_AMS_TX_STSr_AMS_TX_STSf_SET
#define READ_AMS_TX_STSr BCMI_QTC_XGXS_READ_AMS_TX_STSr
#define WRITE_AMS_TX_STSr BCMI_QTC_XGXS_WRITE_AMS_TX_STSr
#define MODIFY_AMS_TX_STSr BCMI_QTC_XGXS_MODIFY_AMS_TX_STSr
#define READLN_AMS_TX_STSr BCMI_QTC_XGXS_READLN_AMS_TX_STSr
#define WRITELN_AMS_TX_STSr BCMI_QTC_XGXS_WRITELN_AMS_TX_STSr
#define WRITEALL_AMS_TX_STSr BCMI_QTC_XGXS_WRITEALL_AMS_TX_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_TX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL0
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b0
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_0
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_LOWPWR_6G see AMS
 *     AMS_PLL_TXCG_VDDR_BGB see AMS
 *     AMS_PLL_IMIN_ICLKINT see AMS
 *     AMS_PLL_IMAX_ICLKINT see AMS
 *     AMS_PLL_IMODE_ICLKINT Interpolator bias current control
 *     AMS_PLL_IMIN_ICKGEN see AMS
 *     AMS_PLL_IMAX_ICKGEN see AMS
 *     AMS_PLL_IMODE_ICKGEN Master current mirror control
 *     AMS_PLL_IMIN_ICLKIDRV1 see AMS
 *     AMS_PLL_IMAX_ICLKIDRV1 see AMS
 *     AMS_PLL_IMODE_ICLKIDRV1 Current control for input CML
 *     AMS_PLL_CAL_OFF  Turns off ResCal, turns on cal_aux[3:0]
 *     AMS_PLL_CAL_AUX  see AMS
 */
#define BCMI_QTC_XGXS_AMS_CTL0r (0x0001d0b0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL0.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_ctl0[1];
	uint32_t _ams_ctl0;
} BCMI_QTC_XGXS_AMS_CTL0r_t;

#define BCMI_QTC_XGXS_AMS_CTL0r_CLR(r) (r).ams_ctl0[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL0r_SET(r,d) (r).ams_ctl0[0] = d
#define BCMI_QTC_XGXS_AMS_CTL0r_GET(r) (r).ams_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_AUXf_GET(r) ((((r).ams_ctl0[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_AUXf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_OFFf_GET(r) ((((r).ams_ctl0[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_OFFf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET(r) ((((r).ams_ctl0[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET(r) ((((r).ams_ctl0[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET(r) ((((r).ams_ctl0[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICKGENf_GET(r) ((((r).ams_ctl0[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICKGENf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICKGENf_GET(r) ((((r).ams_ctl0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICKGENf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICKGENf_GET(r) ((((r).ams_ctl0[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICKGENf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKINTf_GET(r) ((((r).ams_ctl0[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKINTf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKINTf_GET(r) ((((r).ams_ctl0[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKINTf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKINTf_GET(r) ((((r).ams_ctl0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKINTf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_TXCG_VDDR_BGBf_GET(r) ((((r).ams_ctl0[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_TXCG_VDDR_BGBf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_LOWPWR_6Gf_GET(r) (((r).ams_ctl0[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_LOWPWR_6Gf_SET(r,f) (r).ams_ctl0[0]=(((r).ams_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_CTL0.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL0r,(_r._ams_ctl0))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL0r,(_r._ams_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL0r,(_r._ams_ctl0))
#define BCMI_QTC_XGXS_READLN_AMS_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl0))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL0r BCMI_QTC_XGXS_AMS_CTL0r
#define AMS_CTL0r_SIZE BCMI_QTC_XGXS_AMS_CTL0r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL0r_t AMS_CTL0r_t;
#define AMS_CTL0r_CLR BCMI_QTC_XGXS_AMS_CTL0r_CLR
#define AMS_CTL0r_SET BCMI_QTC_XGXS_AMS_CTL0r_SET
#define AMS_CTL0r_GET BCMI_QTC_XGXS_AMS_CTL0r_GET
#define AMS_CTL0r_AMS_PLL_CAL_AUXf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_AUXf_GET
#define AMS_CTL0r_AMS_PLL_CAL_AUXf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_AUXf_SET
#define AMS_CTL0r_AMS_PLL_CAL_OFFf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_OFFf_GET
#define AMS_CTL0r_AMS_PLL_CAL_OFFf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_CAL_OFFf_SET
#define AMS_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET
#define AMS_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET
#define AMS_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET
#define AMS_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET
#define AMS_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET
#define AMS_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET
#define AMS_CTL0r_AMS_PLL_IMODE_ICKGENf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICKGENf_GET
#define AMS_CTL0r_AMS_PLL_IMODE_ICKGENf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICKGENf_SET
#define AMS_CTL0r_AMS_PLL_IMAX_ICKGENf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICKGENf_GET
#define AMS_CTL0r_AMS_PLL_IMAX_ICKGENf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICKGENf_SET
#define AMS_CTL0r_AMS_PLL_IMIN_ICKGENf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICKGENf_GET
#define AMS_CTL0r_AMS_PLL_IMIN_ICKGENf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICKGENf_SET
#define AMS_CTL0r_AMS_PLL_IMODE_ICLKINTf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKINTf_GET
#define AMS_CTL0r_AMS_PLL_IMODE_ICLKINTf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMODE_ICLKINTf_SET
#define AMS_CTL0r_AMS_PLL_IMAX_ICLKINTf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKINTf_GET
#define AMS_CTL0r_AMS_PLL_IMAX_ICLKINTf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMAX_ICLKINTf_SET
#define AMS_CTL0r_AMS_PLL_IMIN_ICLKINTf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKINTf_GET
#define AMS_CTL0r_AMS_PLL_IMIN_ICLKINTf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_IMIN_ICLKINTf_SET
#define AMS_CTL0r_AMS_PLL_TXCG_VDDR_BGBf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_TXCG_VDDR_BGBf_GET
#define AMS_CTL0r_AMS_PLL_TXCG_VDDR_BGBf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_TXCG_VDDR_BGBf_SET
#define AMS_CTL0r_AMS_PLL_LOWPWR_6Gf_GET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_LOWPWR_6Gf_GET
#define AMS_CTL0r_AMS_PLL_LOWPWR_6Gf_SET BCMI_QTC_XGXS_AMS_CTL0r_AMS_PLL_LOWPWR_6Gf_SET
#define READ_AMS_CTL0r BCMI_QTC_XGXS_READ_AMS_CTL0r
#define WRITE_AMS_CTL0r BCMI_QTC_XGXS_WRITE_AMS_CTL0r
#define MODIFY_AMS_CTL0r BCMI_QTC_XGXS_MODIFY_AMS_CTL0r
#define READLN_AMS_CTL0r BCMI_QTC_XGXS_READLN_AMS_CTL0r
#define WRITELN_AMS_CTL0r BCMI_QTC_XGXS_WRITELN_AMS_CTL0r
#define WRITEALL_AMS_CTL0r BCMI_QTC_XGXS_WRITEALL_AMS_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL1
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b1
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_1
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_DBLR_CTRL set the delays in refclk doubler.
 *     AMS_PLL_SPARE_18 AMS reserved[18]
 *     AMS_PLL_FP3_RH   increase rfp3 to 800 ohm from 160 ohm.
 *     AMS_PLL_FP3_CTRL 3rd pole for loop filter, adjustable BW
 *     AMS_PLL_VCO_DIV2 divides the VCO output by 2
 *     AMS_PLL_VCO_DIV4 divides the VCO output by 4
 *     AMS_PLL_VCOICTRL adjusts VCO bias current, ~6%
 *     AMS_PLL_VCO_IMAX increase vco current
 *     AMS_PLL_IVCO     see AMS
 *     AMS_PLL_RESET    active high
 *     AMS_PLL_ENABLE_FTUNE see AMS
 */
#define BCMI_QTC_XGXS_AMS_CTL1r (0x0001d0b1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL1.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_ctl1[1];
	uint32_t _ams_ctl1;
} BCMI_QTC_XGXS_AMS_CTL1r_t;

#define BCMI_QTC_XGXS_AMS_CTL1r_CLR(r) (r).ams_ctl1[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL1r_SET(r,d) (r).ams_ctl1[0] = d
#define BCMI_QTC_XGXS_AMS_CTL1r_GET(r) (r).ams_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET(r) ((((r).ams_ctl1[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_RESETf_GET(r) ((((r).ams_ctl1[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_RESETf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_IVCOf_GET(r) ((((r).ams_ctl1[0]) >> 11) & 0x7)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_IVCOf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_IMAXf_GET(r) ((((r).ams_ctl1[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_IMAXf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCOICTRLf_GET(r) ((((r).ams_ctl1[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCOICTRLf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV4f_GET(r) ((((r).ams_ctl1[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV4f_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV2f_GET(r) ((((r).ams_ctl1[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV2f_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_CTRLf_GET(r) ((((r).ams_ctl1[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_CTRLf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_RHf_GET(r) ((((r).ams_ctl1[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_RHf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_SPARE_18f_GET(r) ((((r).ams_ctl1[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_SPARE_18f_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_DBLR_CTRLf_GET(r) (((r).ams_ctl1[0]) & 0x3)
#define BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_DBLR_CTRLf_SET(r,f) (r).ams_ctl1[0]=(((r).ams_ctl1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AMS_CTL1.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL1r,(_r._ams_ctl1))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL1r,(_r._ams_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL1r,(_r._ams_ctl1))
#define BCMI_QTC_XGXS_READLN_AMS_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl1))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL1r BCMI_QTC_XGXS_AMS_CTL1r
#define AMS_CTL1r_SIZE BCMI_QTC_XGXS_AMS_CTL1r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL1r_t AMS_CTL1r_t;
#define AMS_CTL1r_CLR BCMI_QTC_XGXS_AMS_CTL1r_CLR
#define AMS_CTL1r_SET BCMI_QTC_XGXS_AMS_CTL1r_SET
#define AMS_CTL1r_GET BCMI_QTC_XGXS_AMS_CTL1r_GET
#define AMS_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET
#define AMS_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET
#define AMS_CTL1r_AMS_PLL_RESETf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_RESETf_GET
#define AMS_CTL1r_AMS_PLL_RESETf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_RESETf_SET
#define AMS_CTL1r_AMS_PLL_IVCOf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_IVCOf_GET
#define AMS_CTL1r_AMS_PLL_IVCOf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_IVCOf_SET
#define AMS_CTL1r_AMS_PLL_VCO_IMAXf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_IMAXf_GET
#define AMS_CTL1r_AMS_PLL_VCO_IMAXf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_IMAXf_SET
#define AMS_CTL1r_AMS_PLL_VCOICTRLf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCOICTRLf_GET
#define AMS_CTL1r_AMS_PLL_VCOICTRLf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCOICTRLf_SET
#define AMS_CTL1r_AMS_PLL_VCO_DIV4f_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV4f_GET
#define AMS_CTL1r_AMS_PLL_VCO_DIV4f_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV4f_SET
#define AMS_CTL1r_AMS_PLL_VCO_DIV2f_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV2f_GET
#define AMS_CTL1r_AMS_PLL_VCO_DIV2f_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_VCO_DIV2f_SET
#define AMS_CTL1r_AMS_PLL_FP3_CTRLf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_CTRLf_GET
#define AMS_CTL1r_AMS_PLL_FP3_CTRLf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_CTRLf_SET
#define AMS_CTL1r_AMS_PLL_FP3_RHf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_RHf_GET
#define AMS_CTL1r_AMS_PLL_FP3_RHf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_FP3_RHf_SET
#define AMS_CTL1r_AMS_PLL_SPARE_18f_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_SPARE_18f_GET
#define AMS_CTL1r_AMS_PLL_SPARE_18f_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_SPARE_18f_SET
#define AMS_CTL1r_AMS_PLL_DBLR_CTRLf_GET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_DBLR_CTRLf_GET
#define AMS_CTL1r_AMS_PLL_DBLR_CTRLf_SET BCMI_QTC_XGXS_AMS_CTL1r_AMS_PLL_DBLR_CTRLf_SET
#define READ_AMS_CTL1r BCMI_QTC_XGXS_READ_AMS_CTL1r
#define WRITE_AMS_CTL1r BCMI_QTC_XGXS_WRITE_AMS_CTL1r
#define MODIFY_AMS_CTL1r BCMI_QTC_XGXS_MODIFY_AMS_CTL1r
#define READLN_AMS_CTL1r BCMI_QTC_XGXS_READLN_AMS_CTL1r
#define WRITELN_AMS_CTL1r BCMI_QTC_XGXS_WRITELN_AMS_CTL1r
#define WRITEALL_AMS_CTL1r BCMI_QTC_XGXS_WRITEALL_AMS_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL2
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b2
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_2
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_EN_HRZ   increases Rz, 2.4K ==> 4.8K
 *     AMS_PLL_IQP      charge pump current, 50,100,150,..800uA
 *     AMS_PLL_REFL_PLL see AMS
 *     AMS_PLL_REFH_PLL see AMS
 *     AMS_PLL_IMIN_IBIAS see AMS
 *     AMS_PLL_IMODE_IBIAS see AMS
 *     AMS_PLL_IMAX_IBIAS ibias all 6 above
 *     AMS_PLL_IMIN_ICP see AMS
 *     AMS_PLL_IMODE_ICP see AMS
 *     AMS_PLL_IMAX_ICP charge pump
 *     AMS_PLL_IMIN_ICK see AMS
 *     AMS_PLL_IMODE_ICK see AMS
 *     AMS_PLL_IMAX_ICK fref buffer
 */
#define BCMI_QTC_XGXS_AMS_CTL2r (0x0001d0b2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL2.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_ctl2[1];
	uint32_t _ams_ctl2;
} BCMI_QTC_XGXS_AMS_CTL2r_t;

#define BCMI_QTC_XGXS_AMS_CTL2r_CLR(r) (r).ams_ctl2[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL2r_SET(r,d) (r).ams_ctl2[0] = d
#define BCMI_QTC_XGXS_AMS_CTL2r_GET(r) (r).ams_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICKf_GET(r) ((((r).ams_ctl2[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICKf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICKf_GET(r) ((((r).ams_ctl2[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICKf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICKf_GET(r) ((((r).ams_ctl2[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICKf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICPf_GET(r) ((((r).ams_ctl2[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICPf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICPf_GET(r) ((((r).ams_ctl2[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICPf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICPf_GET(r) ((((r).ams_ctl2[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICPf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_IBIASf_GET(r) ((((r).ams_ctl2[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_IBIASf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_IBIASf_GET(r) ((((r).ams_ctl2[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_IBIASf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_IBIASf_GET(r) ((((r).ams_ctl2[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_IBIASf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFH_PLLf_GET(r) ((((r).ams_ctl2[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFH_PLLf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFL_PLLf_GET(r) ((((r).ams_ctl2[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFL_PLLf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IQPf_GET(r) ((((r).ams_ctl2[0]) >> 1) & 0xf)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IQPf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_EN_HRZf_GET(r) (((r).ams_ctl2[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_EN_HRZf_SET(r,f) (r).ams_ctl2[0]=(((r).ams_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_CTL2.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL2r,(_r._ams_ctl2))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL2r,(_r._ams_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL2r,(_r._ams_ctl2))
#define BCMI_QTC_XGXS_READLN_AMS_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl2))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL2r BCMI_QTC_XGXS_AMS_CTL2r
#define AMS_CTL2r_SIZE BCMI_QTC_XGXS_AMS_CTL2r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL2r_t AMS_CTL2r_t;
#define AMS_CTL2r_CLR BCMI_QTC_XGXS_AMS_CTL2r_CLR
#define AMS_CTL2r_SET BCMI_QTC_XGXS_AMS_CTL2r_SET
#define AMS_CTL2r_GET BCMI_QTC_XGXS_AMS_CTL2r_GET
#define AMS_CTL2r_AMS_PLL_IMAX_ICKf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICKf_GET
#define AMS_CTL2r_AMS_PLL_IMAX_ICKf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICKf_SET
#define AMS_CTL2r_AMS_PLL_IMODE_ICKf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICKf_GET
#define AMS_CTL2r_AMS_PLL_IMODE_ICKf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICKf_SET
#define AMS_CTL2r_AMS_PLL_IMIN_ICKf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICKf_GET
#define AMS_CTL2r_AMS_PLL_IMIN_ICKf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICKf_SET
#define AMS_CTL2r_AMS_PLL_IMAX_ICPf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICPf_GET
#define AMS_CTL2r_AMS_PLL_IMAX_ICPf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_ICPf_SET
#define AMS_CTL2r_AMS_PLL_IMODE_ICPf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICPf_GET
#define AMS_CTL2r_AMS_PLL_IMODE_ICPf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_ICPf_SET
#define AMS_CTL2r_AMS_PLL_IMIN_ICPf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICPf_GET
#define AMS_CTL2r_AMS_PLL_IMIN_ICPf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_ICPf_SET
#define AMS_CTL2r_AMS_PLL_IMAX_IBIASf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_IBIASf_GET
#define AMS_CTL2r_AMS_PLL_IMAX_IBIASf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMAX_IBIASf_SET
#define AMS_CTL2r_AMS_PLL_IMODE_IBIASf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_IBIASf_GET
#define AMS_CTL2r_AMS_PLL_IMODE_IBIASf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMODE_IBIASf_SET
#define AMS_CTL2r_AMS_PLL_IMIN_IBIASf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_IBIASf_GET
#define AMS_CTL2r_AMS_PLL_IMIN_IBIASf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IMIN_IBIASf_SET
#define AMS_CTL2r_AMS_PLL_REFH_PLLf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFH_PLLf_GET
#define AMS_CTL2r_AMS_PLL_REFH_PLLf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFH_PLLf_SET
#define AMS_CTL2r_AMS_PLL_REFL_PLLf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFL_PLLf_GET
#define AMS_CTL2r_AMS_PLL_REFL_PLLf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_REFL_PLLf_SET
#define AMS_CTL2r_AMS_PLL_IQPf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IQPf_GET
#define AMS_CTL2r_AMS_PLL_IQPf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_IQPf_SET
#define AMS_CTL2r_AMS_PLL_EN_HRZf_GET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_EN_HRZf_GET
#define AMS_CTL2r_AMS_PLL_EN_HRZf_SET BCMI_QTC_XGXS_AMS_CTL2r_AMS_PLL_EN_HRZf_SET
#define READ_AMS_CTL2r BCMI_QTC_XGXS_READ_AMS_CTL2r
#define WRITE_AMS_CTL2r BCMI_QTC_XGXS_WRITE_AMS_CTL2r
#define MODIFY_AMS_CTL2r BCMI_QTC_XGXS_MODIFY_AMS_CTL2r
#define READLN_AMS_CTL2r BCMI_QTC_XGXS_READLN_AMS_CTL2r
#define WRITELN_AMS_CTL2r BCMI_QTC_XGXS_WRITELN_AMS_CTL2r
#define WRITEALL_AMS_CTL2r BCMI_QTC_XGXS_WRITEALL_AMS_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL3
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b3
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_3
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_IMIN_I10GBUF see AMS
 *     AMS_PLL_IMODE_I10GBUF see AMS
 *     AMS_PLL_IMAX_I10GBUF 10GHz VCO buffer
 *     AMS_PLL_IMIN_ICML see AMS
 *     AMS_PLL_IMODE_ICML see AMS
 *     AMS_PLL_IMAX_ICML VCO divider/buffer
 *     AMS_PLL_IMIN_ICOMP see AMS
 *     AMS_PLL_IMODE_ICOMP see AMS
 *     AMS_PLL_IMAX_ICOMP VCO comparator
 *     AMS_PLL_IMIN_IOP see AMS
 *     AMS_PLL_IMODE_IOP see AMS
 *     AMS_PLL_IMAX_IOP test current
 *     AMS_PLL_TEST_VREF see AMS
 *     AMS_PLL_TEST_VC  test Vcontrol
 *     AMS_PLL_TEST_PLL test LC
 *     AMS_PLL_TEST_RX  send RX word ck to PLL test port
 */
#define BCMI_QTC_XGXS_AMS_CTL3r (0x0001d0b3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL3.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_ctl3[1];
	uint32_t _ams_ctl3;
} BCMI_QTC_XGXS_AMS_CTL3r_t;

#define BCMI_QTC_XGXS_AMS_CTL3r_CLR(r) (r).ams_ctl3[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL3r_SET(r,d) (r).ams_ctl3[0] = d
#define BCMI_QTC_XGXS_AMS_CTL3r_GET(r) (r).ams_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_RXf_GET(r) ((((r).ams_ctl3[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_RXf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_PLLf_GET(r) ((((r).ams_ctl3[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_PLLf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VCf_GET(r) ((((r).ams_ctl3[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VCf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VREFf_GET(r) ((((r).ams_ctl3[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VREFf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_IOPf_GET(r) ((((r).ams_ctl3[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_IOPf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_IOPf_GET(r) ((((r).ams_ctl3[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_IOPf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_IOPf_GET(r) ((((r).ams_ctl3[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_IOPf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICOMPf_GET(r) ((((r).ams_ctl3[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICOMPf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICOMPf_GET(r) ((((r).ams_ctl3[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICOMPf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICOMPf_GET(r) ((((r).ams_ctl3[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICOMPf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICMLf_GET(r) ((((r).ams_ctl3[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICMLf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICMLf_GET(r) ((((r).ams_ctl3[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICMLf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICMLf_GET(r) ((((r).ams_ctl3[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICMLf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_I10GBUFf_GET(r) ((((r).ams_ctl3[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_I10GBUFf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_I10GBUFf_GET(r) ((((r).ams_ctl3[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_I10GBUFf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_I10GBUFf_GET(r) (((r).ams_ctl3[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_I10GBUFf_SET(r,f) (r).ams_ctl3[0]=(((r).ams_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_CTL3.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL3r,(_r._ams_ctl3))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL3r,(_r._ams_ctl3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL3r,(_r._ams_ctl3))
#define BCMI_QTC_XGXS_READLN_AMS_CTL3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl3))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl3))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL3r BCMI_QTC_XGXS_AMS_CTL3r
#define AMS_CTL3r_SIZE BCMI_QTC_XGXS_AMS_CTL3r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL3r_t AMS_CTL3r_t;
#define AMS_CTL3r_CLR BCMI_QTC_XGXS_AMS_CTL3r_CLR
#define AMS_CTL3r_SET BCMI_QTC_XGXS_AMS_CTL3r_SET
#define AMS_CTL3r_GET BCMI_QTC_XGXS_AMS_CTL3r_GET
#define AMS_CTL3r_AMS_PLL_TEST_RXf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_RXf_GET
#define AMS_CTL3r_AMS_PLL_TEST_RXf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_RXf_SET
#define AMS_CTL3r_AMS_PLL_TEST_PLLf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_PLLf_GET
#define AMS_CTL3r_AMS_PLL_TEST_PLLf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_PLLf_SET
#define AMS_CTL3r_AMS_PLL_TEST_VCf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VCf_GET
#define AMS_CTL3r_AMS_PLL_TEST_VCf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VCf_SET
#define AMS_CTL3r_AMS_PLL_TEST_VREFf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VREFf_GET
#define AMS_CTL3r_AMS_PLL_TEST_VREFf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_TEST_VREFf_SET
#define AMS_CTL3r_AMS_PLL_IMAX_IOPf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_IOPf_GET
#define AMS_CTL3r_AMS_PLL_IMAX_IOPf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_IOPf_SET
#define AMS_CTL3r_AMS_PLL_IMODE_IOPf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_IOPf_GET
#define AMS_CTL3r_AMS_PLL_IMODE_IOPf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_IOPf_SET
#define AMS_CTL3r_AMS_PLL_IMIN_IOPf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_IOPf_GET
#define AMS_CTL3r_AMS_PLL_IMIN_IOPf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_IOPf_SET
#define AMS_CTL3r_AMS_PLL_IMAX_ICOMPf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICOMPf_GET
#define AMS_CTL3r_AMS_PLL_IMAX_ICOMPf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICOMPf_SET
#define AMS_CTL3r_AMS_PLL_IMODE_ICOMPf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICOMPf_GET
#define AMS_CTL3r_AMS_PLL_IMODE_ICOMPf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICOMPf_SET
#define AMS_CTL3r_AMS_PLL_IMIN_ICOMPf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICOMPf_GET
#define AMS_CTL3r_AMS_PLL_IMIN_ICOMPf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICOMPf_SET
#define AMS_CTL3r_AMS_PLL_IMAX_ICMLf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICMLf_GET
#define AMS_CTL3r_AMS_PLL_IMAX_ICMLf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_ICMLf_SET
#define AMS_CTL3r_AMS_PLL_IMODE_ICMLf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICMLf_GET
#define AMS_CTL3r_AMS_PLL_IMODE_ICMLf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_ICMLf_SET
#define AMS_CTL3r_AMS_PLL_IMIN_ICMLf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICMLf_GET
#define AMS_CTL3r_AMS_PLL_IMIN_ICMLf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_ICMLf_SET
#define AMS_CTL3r_AMS_PLL_IMAX_I10GBUFf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_I10GBUFf_GET
#define AMS_CTL3r_AMS_PLL_IMAX_I10GBUFf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMAX_I10GBUFf_SET
#define AMS_CTL3r_AMS_PLL_IMODE_I10GBUFf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_I10GBUFf_GET
#define AMS_CTL3r_AMS_PLL_IMODE_I10GBUFf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMODE_I10GBUFf_SET
#define AMS_CTL3r_AMS_PLL_IMIN_I10GBUFf_GET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_I10GBUFf_GET
#define AMS_CTL3r_AMS_PLL_IMIN_I10GBUFf_SET BCMI_QTC_XGXS_AMS_CTL3r_AMS_PLL_IMIN_I10GBUFf_SET
#define READ_AMS_CTL3r BCMI_QTC_XGXS_READ_AMS_CTL3r
#define WRITE_AMS_CTL3r BCMI_QTC_XGXS_WRITE_AMS_CTL3r
#define MODIFY_AMS_CTL3r BCMI_QTC_XGXS_MODIFY_AMS_CTL3r
#define READLN_AMS_CTL3r BCMI_QTC_XGXS_READLN_AMS_CTL3r
#define WRITELN_AMS_CTL3r BCMI_QTC_XGXS_WRITELN_AMS_CTL3r
#define WRITEALL_AMS_CTL3r BCMI_QTC_XGXS_WRITEALL_AMS_CTL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL4
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b4
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_4
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_BGR_PTATADJ BG bias, same decoder as CTAT
 *     AMS_PLL_BGR_CTATADJ BG CTAT bias control
 *     AMS_PLL_2RX_CLKBW controls BW of interpolator input
 *     AMS_PLL_COMP_VTH VCO tuning comparator threshold
 *     AMS_PLL_VDDR_BGB select between PVDD or BG Vbias
 *     AMS_PLL_KVH_FORCE force Kvco, override tuning control
 *     AMS_PLL_FORCE_KVH_BW enable force kvh and bw modes
 *     AMS_PLL_FORCE_RESCAL Exp7 B0 - force_rescal with pll_ctrl<15:12>
 */
#define BCMI_QTC_XGXS_AMS_CTL4r (0x0001d0b4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL4.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_ctl4[1];
	uint32_t _ams_ctl4;
} BCMI_QTC_XGXS_AMS_CTL4r_t;

#define BCMI_QTC_XGXS_AMS_CTL4r_CLR(r) (r).ams_ctl4[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL4r_SET(r,d) (r).ams_ctl4[0] = d
#define BCMI_QTC_XGXS_AMS_CTL4r_GET(r) (r).ams_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_RESCALf_GET(r) ((((r).ams_ctl4[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_RESCALf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET(r) ((((r).ams_ctl4[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_KVH_FORCEf_GET(r) ((((r).ams_ctl4[0]) >> 12) & 0x3)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_KVH_FORCEf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_VDDR_BGBf_GET(r) ((((r).ams_ctl4[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_VDDR_BGBf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_COMP_VTHf_GET(r) ((((r).ams_ctl4[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_COMP_VTHf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_2RX_CLKBWf_GET(r) ((((r).ams_ctl4[0]) >> 8) & 0x3)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_2RX_CLKBWf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_CTATADJf_GET(r) ((((r).ams_ctl4[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_CTATADJf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_PTATADJf_GET(r) (((r).ams_ctl4[0]) & 0xf)
#define BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_PTATADJf_SET(r,f) (r).ams_ctl4[0]=(((r).ams_ctl4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access AMS_CTL4.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL4r,(_r._ams_ctl4))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL4r,(_r._ams_ctl4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL4r,(_r._ams_ctl4))
#define BCMI_QTC_XGXS_READLN_AMS_CTL4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl4))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl4))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL4r BCMI_QTC_XGXS_AMS_CTL4r
#define AMS_CTL4r_SIZE BCMI_QTC_XGXS_AMS_CTL4r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL4r_t AMS_CTL4r_t;
#define AMS_CTL4r_CLR BCMI_QTC_XGXS_AMS_CTL4r_CLR
#define AMS_CTL4r_SET BCMI_QTC_XGXS_AMS_CTL4r_SET
#define AMS_CTL4r_GET BCMI_QTC_XGXS_AMS_CTL4r_GET
#define AMS_CTL4r_AMS_PLL_FORCE_RESCALf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_RESCALf_GET
#define AMS_CTL4r_AMS_PLL_FORCE_RESCALf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_RESCALf_SET
#define AMS_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET
#define AMS_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET
#define AMS_CTL4r_AMS_PLL_KVH_FORCEf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_KVH_FORCEf_GET
#define AMS_CTL4r_AMS_PLL_KVH_FORCEf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_KVH_FORCEf_SET
#define AMS_CTL4r_AMS_PLL_VDDR_BGBf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_VDDR_BGBf_GET
#define AMS_CTL4r_AMS_PLL_VDDR_BGBf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_VDDR_BGBf_SET
#define AMS_CTL4r_AMS_PLL_COMP_VTHf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_COMP_VTHf_GET
#define AMS_CTL4r_AMS_PLL_COMP_VTHf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_COMP_VTHf_SET
#define AMS_CTL4r_AMS_PLL_2RX_CLKBWf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_2RX_CLKBWf_GET
#define AMS_CTL4r_AMS_PLL_2RX_CLKBWf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_2RX_CLKBWf_SET
#define AMS_CTL4r_AMS_PLL_BGR_CTATADJf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_CTATADJf_GET
#define AMS_CTL4r_AMS_PLL_BGR_CTATADJf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_CTATADJf_SET
#define AMS_CTL4r_AMS_PLL_BGR_PTATADJf_GET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_PTATADJf_GET
#define AMS_CTL4r_AMS_PLL_BGR_PTATADJf_SET BCMI_QTC_XGXS_AMS_CTL4r_AMS_PLL_BGR_PTATADJf_SET
#define READ_AMS_CTL4r BCMI_QTC_XGXS_READ_AMS_CTL4r
#define WRITE_AMS_CTL4r BCMI_QTC_XGXS_WRITE_AMS_CTL4r
#define MODIFY_AMS_CTL4r BCMI_QTC_XGXS_MODIFY_AMS_CTL4r
#define READLN_AMS_CTL4r BCMI_QTC_XGXS_READLN_AMS_CTL4r
#define WRITELN_AMS_CTL4r BCMI_QTC_XGXS_WRITELN_AMS_CTL4r
#define WRITEALL_AMS_CTL4r BCMI_QTC_XGXS_WRITEALL_AMS_CTL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL5
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b5
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_5
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_MAX_TEST_PORT_AMPL see AMS
 *     AMS_PLL_BGIP     test, measure Ibg internal PMOS current
 *     AMS_PLL_BGINT    test, measure Vbg internal
 *     AMS_PLL_VBYPASS  test, bypass test port opamp buffer
 *     AMS_PLL_TEST_PNP see AMS
 *     AMS_PLL_BGCALR_CTATADJ bias control for BG/calR
 *     AMS_PLL_BGCALR_PTATADJ bias control for BG/calR
 */
#define BCMI_QTC_XGXS_AMS_CTL5r (0x0001d0b5 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL5.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL5r_s {
	uint32_t v[1];
	uint32_t ams_ctl5[1];
	uint32_t _ams_ctl5;
} BCMI_QTC_XGXS_AMS_CTL5r_t;

#define BCMI_QTC_XGXS_AMS_CTL5r_CLR(r) (r).ams_ctl5[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL5r_SET(r,d) (r).ams_ctl5[0] = d
#define BCMI_QTC_XGXS_AMS_CTL5r_GET(r) (r).ams_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_PTATADJf_GET(r) ((((r).ams_ctl5[0]) >> 11) & 0x1f)
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_PTATADJf_SET(r,f) (r).ams_ctl5[0]=(((r).ams_ctl5[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_CTATADJf_GET(r) ((((r).ams_ctl5[0]) >> 6) & 0x1f)
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_CTATADJf_SET(r,f) (r).ams_ctl5[0]=(((r).ams_ctl5[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_TEST_PNPf_GET(r) ((((r).ams_ctl5[0]) >> 4) & 0x3)
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_TEST_PNPf_SET(r,f) (r).ams_ctl5[0]=(((r).ams_ctl5[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_VBYPASSf_GET(r) ((((r).ams_ctl5[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_VBYPASSf_SET(r,f) (r).ams_ctl5[0]=(((r).ams_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGINTf_GET(r) ((((r).ams_ctl5[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGINTf_SET(r,f) (r).ams_ctl5[0]=(((r).ams_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGIPf_GET(r) ((((r).ams_ctl5[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGIPf_SET(r,f) (r).ams_ctl5[0]=(((r).ams_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLf_GET(r) (((r).ams_ctl5[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLf_SET(r,f) (r).ams_ctl5[0]=(((r).ams_ctl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_CTL5.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL5r,(_r._ams_ctl5))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL5r,(_r._ams_ctl5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL5r,(_r._ams_ctl5))
#define BCMI_QTC_XGXS_READLN_AMS_CTL5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl5))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl5))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL5r BCMI_QTC_XGXS_AMS_CTL5r
#define AMS_CTL5r_SIZE BCMI_QTC_XGXS_AMS_CTL5r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL5r_t AMS_CTL5r_t;
#define AMS_CTL5r_CLR BCMI_QTC_XGXS_AMS_CTL5r_CLR
#define AMS_CTL5r_SET BCMI_QTC_XGXS_AMS_CTL5r_SET
#define AMS_CTL5r_GET BCMI_QTC_XGXS_AMS_CTL5r_GET
#define AMS_CTL5r_AMS_PLL_BGCALR_PTATADJf_GET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_PTATADJf_GET
#define AMS_CTL5r_AMS_PLL_BGCALR_PTATADJf_SET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_PTATADJf_SET
#define AMS_CTL5r_AMS_PLL_BGCALR_CTATADJf_GET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_CTATADJf_GET
#define AMS_CTL5r_AMS_PLL_BGCALR_CTATADJf_SET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGCALR_CTATADJf_SET
#define AMS_CTL5r_AMS_PLL_TEST_PNPf_GET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_TEST_PNPf_GET
#define AMS_CTL5r_AMS_PLL_TEST_PNPf_SET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_TEST_PNPf_SET
#define AMS_CTL5r_AMS_PLL_VBYPASSf_GET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_VBYPASSf_GET
#define AMS_CTL5r_AMS_PLL_VBYPASSf_SET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_VBYPASSf_SET
#define AMS_CTL5r_AMS_PLL_BGINTf_GET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGINTf_GET
#define AMS_CTL5r_AMS_PLL_BGINTf_SET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGINTf_SET
#define AMS_CTL5r_AMS_PLL_BGIPf_GET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGIPf_GET
#define AMS_CTL5r_AMS_PLL_BGIPf_SET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_BGIPf_SET
#define AMS_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLf_GET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLf_GET
#define AMS_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLf_SET BCMI_QTC_XGXS_AMS_CTL5r_AMS_PLL_MAX_TEST_PORT_AMPLf_SET
#define READ_AMS_CTL5r BCMI_QTC_XGXS_READ_AMS_CTL5r
#define WRITE_AMS_CTL5r BCMI_QTC_XGXS_WRITE_AMS_CTL5r
#define MODIFY_AMS_CTL5r BCMI_QTC_XGXS_MODIFY_AMS_CTL5r
#define READLN_AMS_CTL5r BCMI_QTC_XGXS_READLN_AMS_CTL5r
#define WRITELN_AMS_CTL5r BCMI_QTC_XGXS_WRITELN_AMS_CTL5r
#define WRITEALL_AMS_CTL5r BCMI_QTC_XGXS_WRITEALL_AMS_CTL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL6
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b6
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_6
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_TEST_FRACN_EN test mode to power up fracn block
 *     AMS_PLL_PDF_SKEW_ENLARGE see AMS
 *     AMS_PLL_PDF_FD_SKEW see AMS
 *     AMS_PLL_PDF_REF_SKEW see AMS
 *     AMS_PLL_SPARE_100 reserved[100]
 *     AMS_PLL_REFCLK_DOUBLER see AMS
 *     AMS_PLL_MIX2P1CR_CTATADJ CTAT bias control for Mix2P1C/R
 *     AMS_PLL_MIX2P1CR_PTATADJ PTAT bias control for Mix2P1C/R
 */
#define BCMI_QTC_XGXS_AMS_CTL6r (0x0001d0b6 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL6.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_ctl6[1];
	uint32_t _ams_ctl6;
} BCMI_QTC_XGXS_AMS_CTL6r_t;

#define BCMI_QTC_XGXS_AMS_CTL6r_CLR(r) (r).ams_ctl6[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL6r_SET(r,d) (r).ams_ctl6[0] = d
#define BCMI_QTC_XGXS_AMS_CTL6r_GET(r) (r).ams_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_PTATADJf_GET(r) ((((r).ams_ctl6[0]) >> 11) & 0x1f)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_PTATADJf_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_CTATADJf_GET(r) ((((r).ams_ctl6[0]) >> 6) & 0x1f)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_CTATADJf_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET(r) ((((r).ams_ctl6[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_SPARE_100f_GET(r) ((((r).ams_ctl6[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_SPARE_100f_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_REF_SKEWf_GET(r) ((((r).ams_ctl6[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_REF_SKEWf_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_FD_SKEWf_GET(r) ((((r).ams_ctl6[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_FD_SKEWf_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_SKEW_ENLARGEf_GET(r) ((((r).ams_ctl6[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_SKEW_ENLARGEf_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_TEST_FRACN_ENf_GET(r) (((r).ams_ctl6[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_TEST_FRACN_ENf_SET(r,f) (r).ams_ctl6[0]=(((r).ams_ctl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_CTL6.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL6r,(_r._ams_ctl6))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL6r,(_r._ams_ctl6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL6r,(_r._ams_ctl6))
#define BCMI_QTC_XGXS_READLN_AMS_CTL6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl6))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl6))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL6r BCMI_QTC_XGXS_AMS_CTL6r
#define AMS_CTL6r_SIZE BCMI_QTC_XGXS_AMS_CTL6r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL6r_t AMS_CTL6r_t;
#define AMS_CTL6r_CLR BCMI_QTC_XGXS_AMS_CTL6r_CLR
#define AMS_CTL6r_SET BCMI_QTC_XGXS_AMS_CTL6r_SET
#define AMS_CTL6r_GET BCMI_QTC_XGXS_AMS_CTL6r_GET
#define AMS_CTL6r_AMS_PLL_MIX2P1CR_PTATADJf_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_PTATADJf_GET
#define AMS_CTL6r_AMS_PLL_MIX2P1CR_PTATADJf_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_PTATADJf_SET
#define AMS_CTL6r_AMS_PLL_MIX2P1CR_CTATADJf_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_CTATADJf_GET
#define AMS_CTL6r_AMS_PLL_MIX2P1CR_CTATADJf_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_MIX2P1CR_CTATADJf_SET
#define AMS_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET
#define AMS_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET
#define AMS_CTL6r_AMS_PLL_SPARE_100f_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_SPARE_100f_GET
#define AMS_CTL6r_AMS_PLL_SPARE_100f_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_SPARE_100f_SET
#define AMS_CTL6r_AMS_PLL_PDF_REF_SKEWf_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_REF_SKEWf_GET
#define AMS_CTL6r_AMS_PLL_PDF_REF_SKEWf_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_REF_SKEWf_SET
#define AMS_CTL6r_AMS_PLL_PDF_FD_SKEWf_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_FD_SKEWf_GET
#define AMS_CTL6r_AMS_PLL_PDF_FD_SKEWf_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_FD_SKEWf_SET
#define AMS_CTL6r_AMS_PLL_PDF_SKEW_ENLARGEf_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_SKEW_ENLARGEf_GET
#define AMS_CTL6r_AMS_PLL_PDF_SKEW_ENLARGEf_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_PDF_SKEW_ENLARGEf_SET
#define AMS_CTL6r_AMS_PLL_TEST_FRACN_ENf_GET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_TEST_FRACN_ENf_GET
#define AMS_CTL6r_AMS_PLL_TEST_FRACN_ENf_SET BCMI_QTC_XGXS_AMS_CTL6r_AMS_PLL_TEST_FRACN_ENf_SET
#define READ_AMS_CTL6r BCMI_QTC_XGXS_READ_AMS_CTL6r
#define WRITE_AMS_CTL6r BCMI_QTC_XGXS_WRITE_AMS_CTL6r
#define MODIFY_AMS_CTL6r BCMI_QTC_XGXS_MODIFY_AMS_CTL6r
#define READLN_AMS_CTL6r BCMI_QTC_XGXS_READLN_AMS_CTL6r
#define WRITELN_AMS_CTL6r BCMI_QTC_XGXS_WRITELN_AMS_CTL6r
#define WRITEALL_AMS_CTL6r BCMI_QTC_XGXS_WRITEALL_AMS_CTL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL7
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b7
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_7
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_FRACN_DIV_L AMS fracn_div[15:0], lower 16bits of fractional divider[17:0]
 */
#define BCMI_QTC_XGXS_AMS_CTL7r (0x0001d0b7 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL7.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_ctl7[1];
	uint32_t _ams_ctl7;
} BCMI_QTC_XGXS_AMS_CTL7r_t;

#define BCMI_QTC_XGXS_AMS_CTL7r_CLR(r) (r).ams_ctl7[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL7r_SET(r,d) (r).ams_ctl7[0] = d
#define BCMI_QTC_XGXS_AMS_CTL7r_GET(r) (r).ams_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL7r_AMS_PLL_FRACN_DIV_Lf_GET(r) (((r).ams_ctl7[0]) & 0xffff)
#define BCMI_QTC_XGXS_AMS_CTL7r_AMS_PLL_FRACN_DIV_Lf_SET(r,f) (r).ams_ctl7[0]=(((r).ams_ctl7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AMS_CTL7.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL7r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL7r,(_r._ams_ctl7))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL7r,(_r._ams_ctl7)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL7r,(_r._ams_ctl7))
#define BCMI_QTC_XGXS_READLN_AMS_CTL7r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl7))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL7r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl7))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL7r BCMI_QTC_XGXS_AMS_CTL7r
#define AMS_CTL7r_SIZE BCMI_QTC_XGXS_AMS_CTL7r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL7r_t AMS_CTL7r_t;
#define AMS_CTL7r_CLR BCMI_QTC_XGXS_AMS_CTL7r_CLR
#define AMS_CTL7r_SET BCMI_QTC_XGXS_AMS_CTL7r_SET
#define AMS_CTL7r_GET BCMI_QTC_XGXS_AMS_CTL7r_GET
#define AMS_CTL7r_AMS_PLL_FRACN_DIV_Lf_GET BCMI_QTC_XGXS_AMS_CTL7r_AMS_PLL_FRACN_DIV_Lf_GET
#define AMS_CTL7r_AMS_PLL_FRACN_DIV_Lf_SET BCMI_QTC_XGXS_AMS_CTL7r_AMS_PLL_FRACN_DIV_Lf_SET
#define READ_AMS_CTL7r BCMI_QTC_XGXS_READ_AMS_CTL7r
#define WRITE_AMS_CTL7r BCMI_QTC_XGXS_WRITE_AMS_CTL7r
#define MODIFY_AMS_CTL7r BCMI_QTC_XGXS_MODIFY_AMS_CTL7r
#define READLN_AMS_CTL7r BCMI_QTC_XGXS_READLN_AMS_CTL7r
#define WRITELN_AMS_CTL7r BCMI_QTC_XGXS_WRITELN_AMS_CTL7r
#define WRITEALL_AMS_CTL7r BCMI_QTC_XGXS_WRITEALL_AMS_CTL7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_CTL8
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b8
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_8
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_FRACN_DIV_H AMS fracn_div[17:16], upper 2 MSB for fractional diverder[17:0]
 *     AMS_PLL_FRACN_DIVRANGE select MMD range, 0=8/9, 1=4/5
 *     AMS_PLL_FRACN_BYPASS used for integer mode of fracn blk
 *     AMS_PLL_FRACN_NDIV_INT AMS fracn_int[9:0]
 *     AMS_PLL_DITHEREN enables dithering to reduce the refclk spu
 *     AMS_PLL_FRACN_SEL master enable and select for the frac-N mode
 */
#define BCMI_QTC_XGXS_AMS_CTL8r (0x0001d0b8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program AMS_CTL8.
 */
typedef union BCMI_QTC_XGXS_AMS_CTL8r_s {
	uint32_t v[1];
	uint32_t ams_ctl8[1];
	uint32_t _ams_ctl8;
} BCMI_QTC_XGXS_AMS_CTL8r_t;

#define BCMI_QTC_XGXS_AMS_CTL8r_CLR(r) (r).ams_ctl8[0] = 0
#define BCMI_QTC_XGXS_AMS_CTL8r_SET(r,d) (r).ams_ctl8[0] = d
#define BCMI_QTC_XGXS_AMS_CTL8r_GET(r) (r).ams_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_SELf_GET(r) ((((r).ams_ctl8[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_SELf_SET(r,f) (r).ams_ctl8[0]=(((r).ams_ctl8[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_DITHERENf_GET(r) ((((r).ams_ctl8[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_DITHERENf_SET(r,f) (r).ams_ctl8[0]=(((r).ams_ctl8[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_NDIV_INTf_GET(r) ((((r).ams_ctl8[0]) >> 4) & 0x3ff)
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_NDIV_INTf_SET(r,f) (r).ams_ctl8[0]=(((r).ams_ctl8[0] & ~((uint32_t)0x3ff << 4)) | ((((uint32_t)f) & 0x3ff) << 4)) | (1023 << (16 + 4))
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_BYPASSf_GET(r) ((((r).ams_ctl8[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_BYPASSf_SET(r,f) (r).ams_ctl8[0]=(((r).ams_ctl8[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIVRANGEf_GET(r) ((((r).ams_ctl8[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIVRANGEf_SET(r,f) (r).ams_ctl8[0]=(((r).ams_ctl8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIV_Hf_GET(r) (((r).ams_ctl8[0]) & 0x3)
#define BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIV_Hf_SET(r,f) (r).ams_ctl8[0]=(((r).ams_ctl8[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access AMS_CTL8.
 */
#define BCMI_QTC_XGXS_READ_AMS_CTL8r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL8r,(_r._ams_ctl8))
#define BCMI_QTC_XGXS_WRITE_AMS_CTL8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL8r,(_r._ams_ctl8)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_CTL8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL8r,(_r._ams_ctl8))
#define BCMI_QTC_XGXS_READLN_AMS_CTL8r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl8))
#define BCMI_QTC_XGXS_WRITELN_AMS_CTL8r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_ctl8))
#define BCMI_QTC_XGXS_WRITEALL_AMS_CTL8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_ctl8))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_CTL8r BCMI_QTC_XGXS_AMS_CTL8r
#define AMS_CTL8r_SIZE BCMI_QTC_XGXS_AMS_CTL8r_SIZE
typedef BCMI_QTC_XGXS_AMS_CTL8r_t AMS_CTL8r_t;
#define AMS_CTL8r_CLR BCMI_QTC_XGXS_AMS_CTL8r_CLR
#define AMS_CTL8r_SET BCMI_QTC_XGXS_AMS_CTL8r_SET
#define AMS_CTL8r_GET BCMI_QTC_XGXS_AMS_CTL8r_GET
#define AMS_CTL8r_AMS_PLL_FRACN_SELf_GET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_SELf_GET
#define AMS_CTL8r_AMS_PLL_FRACN_SELf_SET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_SELf_SET
#define AMS_CTL8r_AMS_PLL_DITHERENf_GET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_DITHERENf_GET
#define AMS_CTL8r_AMS_PLL_DITHERENf_SET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_DITHERENf_SET
#define AMS_CTL8r_AMS_PLL_FRACN_NDIV_INTf_GET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_NDIV_INTf_GET
#define AMS_CTL8r_AMS_PLL_FRACN_NDIV_INTf_SET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_NDIV_INTf_SET
#define AMS_CTL8r_AMS_PLL_FRACN_BYPASSf_GET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_BYPASSf_GET
#define AMS_CTL8r_AMS_PLL_FRACN_BYPASSf_SET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_BYPASSf_SET
#define AMS_CTL8r_AMS_PLL_FRACN_DIVRANGEf_GET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIVRANGEf_GET
#define AMS_CTL8r_AMS_PLL_FRACN_DIVRANGEf_SET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIVRANGEf_SET
#define AMS_CTL8r_AMS_PLL_FRACN_DIV_Hf_GET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIV_Hf_GET
#define AMS_CTL8r_AMS_PLL_FRACN_DIV_Hf_SET BCMI_QTC_XGXS_AMS_CTL8r_AMS_PLL_FRACN_DIV_Hf_SET
#define READ_AMS_CTL8r BCMI_QTC_XGXS_READ_AMS_CTL8r
#define WRITE_AMS_CTL8r BCMI_QTC_XGXS_WRITE_AMS_CTL8r
#define MODIFY_AMS_CTL8r BCMI_QTC_XGXS_MODIFY_AMS_CTL8r
#define READLN_AMS_CTL8r BCMI_QTC_XGXS_READLN_AMS_CTL8r
#define WRITELN_AMS_CTL8r BCMI_QTC_XGXS_WRITELN_AMS_CTL8r
#define WRITEALL_AMS_CTL8r BCMI_QTC_XGXS_WRITEALL_AMS_CTL8r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_INTCTL
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0b9
 * DEVAD:    1
 * DESC:     INTERNAL PLL CONTROL
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_TX_LOWPWR_6G control bit for AFE input tx_lowpwr_6g
 */
#define BCMI_QTC_XGXS_AMS_INTCTLr (0x0001d0b9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_INTCTLr_SIZE 4

/*
 * This structure should be used to declare and program AMS_INTCTL.
 */
typedef union BCMI_QTC_XGXS_AMS_INTCTLr_s {
	uint32_t v[1];
	uint32_t ams_intctl[1];
	uint32_t _ams_intctl;
} BCMI_QTC_XGXS_AMS_INTCTLr_t;

#define BCMI_QTC_XGXS_AMS_INTCTLr_CLR(r) (r).ams_intctl[0] = 0
#define BCMI_QTC_XGXS_AMS_INTCTLr_SET(r,d) (r).ams_intctl[0] = d
#define BCMI_QTC_XGXS_AMS_INTCTLr_GET(r) (r).ams_intctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_INTCTLr_AMS_PLL_TX_LOWPWR_6Gf_GET(r) (((r).ams_intctl[0]) & 0x1)
#define BCMI_QTC_XGXS_AMS_INTCTLr_AMS_PLL_TX_LOWPWR_6Gf_SET(r,f) (r).ams_intctl[0]=(((r).ams_intctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access AMS_INTCTL.
 */
#define BCMI_QTC_XGXS_READ_AMS_INTCTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_INTCTLr,(_r._ams_intctl))
#define BCMI_QTC_XGXS_WRITE_AMS_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_INTCTLr,(_r._ams_intctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_INTCTLr,(_r._ams_intctl))
#define BCMI_QTC_XGXS_READLN_AMS_INTCTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_intctl))
#define BCMI_QTC_XGXS_WRITELN_AMS_INTCTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_intctl))
#define BCMI_QTC_XGXS_WRITEALL_AMS_INTCTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_intctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_INTCTLr BCMI_QTC_XGXS_AMS_INTCTLr
#define AMS_INTCTLr_SIZE BCMI_QTC_XGXS_AMS_INTCTLr_SIZE
typedef BCMI_QTC_XGXS_AMS_INTCTLr_t AMS_INTCTLr_t;
#define AMS_INTCTLr_CLR BCMI_QTC_XGXS_AMS_INTCTLr_CLR
#define AMS_INTCTLr_SET BCMI_QTC_XGXS_AMS_INTCTLr_SET
#define AMS_INTCTLr_GET BCMI_QTC_XGXS_AMS_INTCTLr_GET
#define AMS_INTCTLr_AMS_PLL_TX_LOWPWR_6Gf_GET BCMI_QTC_XGXS_AMS_INTCTLr_AMS_PLL_TX_LOWPWR_6Gf_GET
#define AMS_INTCTLr_AMS_PLL_TX_LOWPWR_6Gf_SET BCMI_QTC_XGXS_AMS_INTCTLr_AMS_PLL_TX_LOWPWR_6Gf_SET
#define READ_AMS_INTCTLr BCMI_QTC_XGXS_READ_AMS_INTCTLr
#define WRITE_AMS_INTCTLr BCMI_QTC_XGXS_WRITE_AMS_INTCTLr
#define MODIFY_AMS_INTCTLr BCMI_QTC_XGXS_MODIFY_AMS_INTCTLr
#define READLN_AMS_INTCTLr BCMI_QTC_XGXS_READLN_AMS_INTCTLr
#define WRITELN_AMS_INTCTLr BCMI_QTC_XGXS_WRITELN_AMS_INTCTLr
#define WRITEALL_AMS_INTCTLr BCMI_QTC_XGXS_WRITEALL_AMS_INTCTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_INTCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  AMS_STS
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd0ba
 * DEVAD:    1
 * DESC:     AMS PLL STATUS
 * SIZE:     32
 * FIELDS:
 *     AMS_PLL_STS      pll status from AFE
 */
#define BCMI_QTC_XGXS_AMS_STSr (0x0001d0ba | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_AMS_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_STS.
 */
typedef union BCMI_QTC_XGXS_AMS_STSr_s {
	uint32_t v[1];
	uint32_t ams_sts[1];
	uint32_t _ams_sts;
} BCMI_QTC_XGXS_AMS_STSr_t;

#define BCMI_QTC_XGXS_AMS_STSr_CLR(r) (r).ams_sts[0] = 0
#define BCMI_QTC_XGXS_AMS_STSr_SET(r,d) (r).ams_sts[0] = d
#define BCMI_QTC_XGXS_AMS_STSr_GET(r) (r).ams_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_AMS_STSr_AMS_PLL_STSf_GET(r) (((r).ams_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_AMS_STSr_AMS_PLL_STSf_SET(r,f) (r).ams_sts[0]=(((r).ams_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access AMS_STS.
 */
#define BCMI_QTC_XGXS_READ_AMS_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_STSr,(_r._ams_sts))
#define BCMI_QTC_XGXS_WRITE_AMS_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_STSr,(_r._ams_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_AMS_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_STSr,(_r._ams_sts))
#define BCMI_QTC_XGXS_READLN_AMS_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_AMS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_sts))
#define BCMI_QTC_XGXS_WRITELN_AMS_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_sts))
#define BCMI_QTC_XGXS_WRITEALL_AMS_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_AMS_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AMS_STSr BCMI_QTC_XGXS_AMS_STSr
#define AMS_STSr_SIZE BCMI_QTC_XGXS_AMS_STSr_SIZE
typedef BCMI_QTC_XGXS_AMS_STSr_t AMS_STSr_t;
#define AMS_STSr_CLR BCMI_QTC_XGXS_AMS_STSr_CLR
#define AMS_STSr_SET BCMI_QTC_XGXS_AMS_STSr_SET
#define AMS_STSr_GET BCMI_QTC_XGXS_AMS_STSr_GET
#define AMS_STSr_AMS_PLL_STSf_GET BCMI_QTC_XGXS_AMS_STSr_AMS_PLL_STSf_GET
#define AMS_STSr_AMS_PLL_STSf_SET BCMI_QTC_XGXS_AMS_STSr_AMS_PLL_STSf_SET
#define READ_AMS_STSr BCMI_QTC_XGXS_READ_AMS_STSr
#define WRITE_AMS_STSr BCMI_QTC_XGXS_WRITE_AMS_STSr
#define MODIFY_AMS_STSr BCMI_QTC_XGXS_MODIFY_AMS_STSr
#define READLN_AMS_STSr BCMI_QTC_XGXS_READLN_AMS_STSr
#define WRITELN_AMS_STSr BCMI_QTC_XGXS_WRITELN_AMS_STSr
#define WRITEALL_AMS_STSr BCMI_QTC_XGXS_WRITEALL_AMS_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_AMS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SIGDET_CTL0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c0
 * DEVAD:    1
 * DESC:     CTRL_0
 * SIZE:     32
 * FIELDS:
 *     SIGNAL_DETECT_FILTER_COUNT Defines the width of the signal_detect==1'b1 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 *     LOS_FILTER_COUNT Defines the width of the signal_detect==1'b0 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 */
#define BCMI_QTC_XGXS_SIGDET_CTL0r (0x0001d0c0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SIGDET_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL0.
 */
typedef union BCMI_QTC_XGXS_SIGDET_CTL0r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl0[1];
	uint32_t _sigdet_ctl0;
} BCMI_QTC_XGXS_SIGDET_CTL0r_t;

#define BCMI_QTC_XGXS_SIGDET_CTL0r_CLR(r) (r).sigdet_ctl0[0] = 0
#define BCMI_QTC_XGXS_SIGDET_CTL0r_SET(r,d) (r).sigdet_ctl0[0] = d
#define BCMI_QTC_XGXS_SIGDET_CTL0r_GET(r) (r).sigdet_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET(r) ((((r).sigdet_ctl0[0]) >> 8) & 0x1f)
#define BCMI_QTC_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_QTC_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET(r) (((r).sigdet_ctl0[0]) & 0x1f)
#define BCMI_QTC_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access SIGDET_CTL0.
 */
#define BCMI_QTC_XGXS_READ_SIGDET_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_QTC_XGXS_WRITE_SIGDET_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SIGDET_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_QTC_XGXS_READLN_SIGDET_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_QTC_XGXS_WRITELN_SIGDET_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_SIGDET_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL0r BCMI_QTC_XGXS_SIGDET_CTL0r
#define SIGDET_CTL0r_SIZE BCMI_QTC_XGXS_SIGDET_CTL0r_SIZE
typedef BCMI_QTC_XGXS_SIGDET_CTL0r_t SIGDET_CTL0r_t;
#define SIGDET_CTL0r_CLR BCMI_QTC_XGXS_SIGDET_CTL0r_CLR
#define SIGDET_CTL0r_SET BCMI_QTC_XGXS_SIGDET_CTL0r_SET
#define SIGDET_CTL0r_GET BCMI_QTC_XGXS_SIGDET_CTL0r_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_GET BCMI_QTC_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_SET BCMI_QTC_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET BCMI_QTC_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET BCMI_QTC_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET
#define READ_SIGDET_CTL0r BCMI_QTC_XGXS_READ_SIGDET_CTL0r
#define WRITE_SIGDET_CTL0r BCMI_QTC_XGXS_WRITE_SIGDET_CTL0r
#define MODIFY_SIGDET_CTL0r BCMI_QTC_XGXS_MODIFY_SIGDET_CTL0r
#define READLN_SIGDET_CTL0r BCMI_QTC_XGXS_READLN_SIGDET_CTL0r
#define WRITELN_SIGDET_CTL0r BCMI_QTC_XGXS_WRITELN_SIGDET_CTL0r
#define WRITEALL_SIGDET_CTL0r BCMI_QTC_XGXS_WRITEALL_SIGDET_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SIGDET_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SIGDET_CTL1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c1
 * DEVAD:    1
 * DESC:     CTRL_1
 * SIZE:     32
 * FIELDS:
 *     AFE_SIGNAL_DETECT_DIS 1'b1 will disable the signal_detect from AFE.
 *     EXT_LOS_EN       1'b1 will enable the external (optical) LOS path into the sigdet filter.
 *     EXT_LOS_INV      1'b1 will invert the polarity of the pmd_ext_los pin.
 *     IGNORE_LP_MODE   1'b1 will ignore the pmd_rx_mode (low power mode) input pin. Set to 1'b0 if EEE mode is supported by the PCS
 *     SIGNAL_DETECT_FILTER_1US 1'b1 will use 1us heartbeat for los_count, signal_detect_count and mask_count counters instead of comclk.
 *     ENERGY_DETECT_FRC pmd_energy_detect Force.
 *     ENERGY_DETECT_FRC_VAL pmd_energy_detect Force Value.
 *     SIGNAL_DETECT_FRC pmd_signal_detect Force.
 *     SIGNAL_DETECT_FRC_VAL pmd_signal_detect Force Value.
 *     ENERGY_DETECT_MASK_COUNT Defines the mask_count timer for energy_detect. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 */
#define BCMI_QTC_XGXS_SIGDET_CTL1r (0x0001d0c1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SIGDET_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL1.
 */
typedef union BCMI_QTC_XGXS_SIGDET_CTL1r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl1[1];
	uint32_t _sigdet_ctl1;
} BCMI_QTC_XGXS_SIGDET_CTL1r_t;

#define BCMI_QTC_XGXS_SIGDET_CTL1r_CLR(r) (r).sigdet_ctl1[0] = 0
#define BCMI_QTC_XGXS_SIGDET_CTL1r_SET(r,d) (r).sigdet_ctl1[0] = d
#define BCMI_QTC_XGXS_SIGDET_CTL1r_GET(r) (r).sigdet_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET(r) ((((r).sigdet_ctl1[0]) >> 11) & 0x1f)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET(r) ((((r).sigdet_ctl1[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET(r) ((((r).sigdet_ctl1[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET(r) ((((r).sigdet_ctl1[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET(r) ((((r).sigdet_ctl1[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET(r) (((r).sigdet_ctl1[0]) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access SIGDET_CTL1.
 */
#define BCMI_QTC_XGXS_READ_SIGDET_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_QTC_XGXS_WRITE_SIGDET_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SIGDET_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_QTC_XGXS_READLN_SIGDET_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_QTC_XGXS_WRITELN_SIGDET_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_SIGDET_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL1r BCMI_QTC_XGXS_SIGDET_CTL1r
#define SIGDET_CTL1r_SIZE BCMI_QTC_XGXS_SIGDET_CTL1r_SIZE
typedef BCMI_QTC_XGXS_SIGDET_CTL1r_t SIGDET_CTL1r_t;
#define SIGDET_CTL1r_CLR BCMI_QTC_XGXS_SIGDET_CTL1r_CLR
#define SIGDET_CTL1r_SET BCMI_QTC_XGXS_SIGDET_CTL1r_SET
#define SIGDET_CTL1r_GET BCMI_QTC_XGXS_SIGDET_CTL1r_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET
#define SIGDET_CTL1r_EXT_LOS_INVf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET
#define SIGDET_CTL1r_EXT_LOS_INVf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET
#define SIGDET_CTL1r_EXT_LOS_ENf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET
#define SIGDET_CTL1r_EXT_LOS_ENf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET BCMI_QTC_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET BCMI_QTC_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET
#define READ_SIGDET_CTL1r BCMI_QTC_XGXS_READ_SIGDET_CTL1r
#define WRITE_SIGDET_CTL1r BCMI_QTC_XGXS_WRITE_SIGDET_CTL1r
#define MODIFY_SIGDET_CTL1r BCMI_QTC_XGXS_MODIFY_SIGDET_CTL1r
#define READLN_SIGDET_CTL1r BCMI_QTC_XGXS_READLN_SIGDET_CTL1r
#define WRITELN_SIGDET_CTL1r BCMI_QTC_XGXS_WRITELN_SIGDET_CTL1r
#define WRITEALL_SIGDET_CTL1r BCMI_QTC_XGXS_WRITEALL_SIGDET_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SIGDET_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SIGDET_CTL2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c2
 * DEVAD:    1
 * DESC:     CTRL_2
 * SIZE:     32
 * FIELDS:
 *     LOS_THRESH       AFE signal detect threshold to be used when filtered signal_detect == 1.
 *     SIGNAL_DETECT_THRESH AFE signal detect threshold to be used when filtered signal_detect == 0.
 *     HOLD_LOS_COUNT   HOLD_LOS state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 *     HOLD_SD_COUNT    HOLD_SD state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 */
#define BCMI_QTC_XGXS_SIGDET_CTL2r (0x0001d0c2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SIGDET_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL2.
 */
typedef union BCMI_QTC_XGXS_SIGDET_CTL2r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl2[1];
	uint32_t _sigdet_ctl2;
} BCMI_QTC_XGXS_SIGDET_CTL2r_t;

#define BCMI_QTC_XGXS_SIGDET_CTL2r_CLR(r) (r).sigdet_ctl2[0] = 0
#define BCMI_QTC_XGXS_SIGDET_CTL2r_SET(r,d) (r).sigdet_ctl2[0] = d
#define BCMI_QTC_XGXS_SIGDET_CTL2r_GET(r) (r).sigdet_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 11) & 0x7)
#define BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 8) & 0x7)
#define BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_QTC_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET(r) ((((r).sigdet_ctl2[0]) >> 4) & 0x7)
#define BCMI_QTC_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_QTC_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET(r) (((r).sigdet_ctl2[0]) & 0x7)
#define BCMI_QTC_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (7 << 16)

/*
 * These macros can be used to access SIGDET_CTL2.
 */
#define BCMI_QTC_XGXS_READ_SIGDET_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_QTC_XGXS_WRITE_SIGDET_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SIGDET_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_QTC_XGXS_READLN_SIGDET_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_QTC_XGXS_WRITELN_SIGDET_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_SIGDET_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL2r BCMI_QTC_XGXS_SIGDET_CTL2r
#define SIGDET_CTL2r_SIZE BCMI_QTC_XGXS_SIGDET_CTL2r_SIZE
typedef BCMI_QTC_XGXS_SIGDET_CTL2r_t SIGDET_CTL2r_t;
#define SIGDET_CTL2r_CLR BCMI_QTC_XGXS_SIGDET_CTL2r_CLR
#define SIGDET_CTL2r_SET BCMI_QTC_XGXS_SIGDET_CTL2r_SET
#define SIGDET_CTL2r_GET BCMI_QTC_XGXS_SIGDET_CTL2r_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_GET BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_SET BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_GET BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_SET BCMI_QTC_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET BCMI_QTC_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET BCMI_QTC_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET
#define SIGDET_CTL2r_LOS_THRESHf_GET BCMI_QTC_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET
#define SIGDET_CTL2r_LOS_THRESHf_SET BCMI_QTC_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET
#define READ_SIGDET_CTL2r BCMI_QTC_XGXS_READ_SIGDET_CTL2r
#define WRITE_SIGDET_CTL2r BCMI_QTC_XGXS_WRITE_SIGDET_CTL2r
#define MODIFY_SIGDET_CTL2r BCMI_QTC_XGXS_MODIFY_SIGDET_CTL2r
#define READLN_SIGDET_CTL2r BCMI_QTC_XGXS_READLN_SIGDET_CTL2r
#define WRITELN_SIGDET_CTL2r BCMI_QTC_XGXS_WRITELN_SIGDET_CTL2r
#define WRITEALL_SIGDET_CTL2r BCMI_QTC_XGXS_WRITEALL_SIGDET_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SIGDET_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  SIGDET_STS0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c8
 * DEVAD:    1
 * DESC:     STATUS_0
 * SIZE:     32
 * FIELDS:
 *     SIGNAL_DETECT    Filtered version of Signal Detect after frc/frc_val.
 *     SIGNAL_DETECT_CHANGE This latches the transition on signal_detect and cleared on read.
 *     ENERGY_DETECT    Filtered version of Energy Detect after frc/frc_val.
 *     ENERGY_DETECT_CHANGE This latches the transition on energy_detect and cleared on read.
 *     SIGNAL_DETECT_RAW Raw version of Signal Detect going into the filter.
 *     SIGNAL_DETECT_RAW_CHANGE This latches the transition on signal_detect_raw and cleared on read.
 *     AFE_SIGDET_THRESH Live status of sigdet_thresh going to AFE.
 */
#define BCMI_QTC_XGXS_SIGDET_STS0r (0x0001d0c8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_SIGDET_STS0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS0.
 */
typedef union BCMI_QTC_XGXS_SIGDET_STS0r_s {
	uint32_t v[1];
	uint32_t sigdet_sts0[1];
	uint32_t _sigdet_sts0;
} BCMI_QTC_XGXS_SIGDET_STS0r_t;

#define BCMI_QTC_XGXS_SIGDET_STS0r_CLR(r) (r).sigdet_sts0[0] = 0
#define BCMI_QTC_XGXS_SIGDET_STS0r_SET(r,d) (r).sigdet_sts0[0] = d
#define BCMI_QTC_XGXS_SIGDET_STS0r_GET(r) (r).sigdet_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_GET(r) ((((r).sigdet_sts0[0]) >> 8) & 0x7)
#define BCMI_QTC_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET(r) ((((r).sigdet_sts0[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECTf_GET(r) ((((r).sigdet_sts0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts0[0]) & 0x1)
#define BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access SIGDET_STS0.
 */
#define BCMI_QTC_XGXS_READ_SIGDET_STS0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_QTC_XGXS_WRITE_SIGDET_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_STS0r,(_r._sigdet_sts0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_SIGDET_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_QTC_XGXS_READLN_SIGDET_STS0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_QTC_XGXS_WRITELN_SIGDET_STS0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_QTC_XGXS_WRITEALL_SIGDET_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS0r BCMI_QTC_XGXS_SIGDET_STS0r
#define SIGDET_STS0r_SIZE BCMI_QTC_XGXS_SIGDET_STS0r_SIZE
typedef BCMI_QTC_XGXS_SIGDET_STS0r_t SIGDET_STS0r_t;
#define SIGDET_STS0r_CLR BCMI_QTC_XGXS_SIGDET_STS0r_CLR
#define SIGDET_STS0r_SET BCMI_QTC_XGXS_SIGDET_STS0r_SET
#define SIGDET_STS0r_GET BCMI_QTC_XGXS_SIGDET_STS0r_GET
#define SIGDET_STS0r_AFE_SIGDET_THRESHf_GET BCMI_QTC_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_GET
#define SIGDET_STS0r_AFE_SIGDET_THRESHf_SET BCMI_QTC_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET
#define SIGDET_STS0r_ENERGY_DETECT_CHANGEf_GET BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_GET
#define SIGDET_STS0r_ENERGY_DETECT_CHANGEf_SET BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_SET
#define SIGDET_STS0r_ENERGY_DETECTf_GET BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECTf_GET
#define SIGDET_STS0r_ENERGY_DETECTf_SET BCMI_QTC_XGXS_SIGDET_STS0r_ENERGY_DETECTf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECTf_GET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET
#define SIGDET_STS0r_SIGNAL_DETECTf_SET BCMI_QTC_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS0r BCMI_QTC_XGXS_READ_SIGDET_STS0r
#define WRITE_SIGDET_STS0r BCMI_QTC_XGXS_WRITE_SIGDET_STS0r
#define MODIFY_SIGDET_STS0r BCMI_QTC_XGXS_MODIFY_SIGDET_STS0r
#define READLN_SIGDET_STS0r BCMI_QTC_XGXS_READLN_SIGDET_STS0r
#define WRITELN_SIGDET_STS0r BCMI_QTC_XGXS_WRITELN_SIGDET_STS0r
#define WRITEALL_SIGDET_STS0r BCMI_QTC_XGXS_WRITEALL_SIGDET_STS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_SIGDET_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CNT_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d0
 * DEVAD:    1
 * DESC:     PRBS Checker Count Control
 * SIZE:     32
 * FIELDS:
 *     PRBS_CHK_LOCK_CNT specifies the number of consecutive valid clock cycles without any bit errorfor PRBS checker to go into PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will lock as soon as it gets the first clock cycle with no bit error.likewise 31 indicates that PRBS will lock as soon as it gets the 32 consecutive clocks with no error.
 *     PRBS_CHK_OOL_CNT specifies the number of consecutive valid clock cycles with 1 or more bit errorsfor PRBS checker to go out of PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will go out of lock as soon as it gets the first clock cycle with 1 or more bit errors.likewise 31 indicates that PRBS will go out of lock as soon as it gets the 32 consecutive clocks with 1 or more errors.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr (0x0001d0d0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CNT_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cnt_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cnt_cfg;
} BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t;

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cnt_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cnt_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET(r) (r).tlb_rx_prbs_chk_cnt_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 8) & 0x1f)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET(r) (((r).tlb_rx_prbs_chk_cnt_cfg[0]) & 0x1f)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CNT_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cnt_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CNT_CFGr BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr
#define TLB_RX_PRBS_CHK_CNT_CFGr_SIZE BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t TLB_RX_PRBS_CHK_CNT_CFGr_t;
#define TLB_RX_PRBS_CHK_CNT_CFGr_CLR BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR
#define TLB_RX_PRBS_CHK_CNT_CFGr_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr
#define READLN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d1
 * DEVAD:    1
 * DESC:     PRBS Checker Control
 * SIZE:     32
 * FIELDS:
 *     PRBS_CHK_EN      PRBS checker enable.1 => enable  the PRBS checker.0 => disable the PRBS checker.
 *     PRBS_CHK_MODE_SEL PRBS checker mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_CHK_INV     PRBS Invert enable.1 => will invert all the data bits to the PRBS checker.0 => will send normal data to the PRBS checker.
 *     PRBS_CHK_MODE    PRBS LOCK state machine select.2'd0 -> Self-sync mode w/ hysteresis. PRBS seed register is continuously seeded with previous received bits.2'd1 -> Initial seed mode w/ hysteresis. PRBS seed registers is seeded with previous received bits only till PRBS lock isacquired and then they run locally independently from the received data until the checker goes out of PRBS lock.2'd2 -> Initial seed mode w/o hysteresis. Similar to mode 1 above except once locked it stays locked until PRBS is disabled.2'd3 -> reserved for future use.
 *     PRBS_CHK_EN_AUTO_MODE PRBS Checker Enable Mode Control.1 => select (rx_dsc_lock & prbs_chk_en) as PRBS checker enable control.0 => select                prbs_chk_en  as PRBS checker enable control.
 *     PRBS_CHK_ERR_CNT_BURST_MODE PRBS Error Counter Mode.1 => Each busrt of error will be counted as 1 error in the error counter. Each error busrt must be separated by 1 error-free cycle of data which in worst case should be 39 bits.0 => Each bit error will be counted.
 *     TRNSUM_ERROR_COUNT_EN Training sum error counter Mode enable.1 => will make the PRBS error counter used as trnsum_error counter. PRBS checker can not be used during this mode.0 => PRBS checker mode.
 *     PRBS_CHK_CLK_EN_FRC_ON PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr (0x0001d0d1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cfg;
} BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_t;

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_GET(r) (r).tlb_rx_prbs_chk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 5) & 0x3)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 1) & 0x7)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET(r) (((r).tlb_rx_prbs_chk_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CFGr BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr
#define TLB_RX_PRBS_CHK_CFGr_SIZE BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_t TLB_RX_PRBS_CHK_CFGr_t;
#define TLB_RX_PRBS_CHK_CFGr_CLR BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR
#define TLB_RX_PRBS_CHK_CFGr_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_SET
#define TLB_RX_PRBS_CHK_CFGr_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET
#define READ_TLB_RX_PRBS_CHK_CFGr BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CFGr BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CFGr BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr
#define READLN_TLB_RX_PRBS_CHK_CFGr BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CFGr BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d2
 * DEVAD:    1
 * DESC:     Digital Loopback Control
 * SIZE:     32
 * FIELDS:
 *     DIG_LPBK_EN      TX to RX Parallel Loopback (Digital Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     DIG_LPBK_PD_MODE Digital Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     DIG_LPBK_PD_FLT_BYPASS Digital Loopback Phase Detector Filter Bypass. For repeater applications, it should be 1'b1.For other applications filter can be enabled for better jitter tolerance performance for the didgital loopback.
 */
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr (0x0001d0d2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_cfg[1];
	uint32_t _tlb_rx_dig_lpbk_cfg;
} BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_t;

#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR(r) (r).tlb_rx_dig_lpbk_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_SET(r,d) (r).tlb_rx_dig_lpbk_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_GET(r) (r).tlb_rx_dig_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET(r) (((r).tlb_rx_dig_lpbk_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_DIG_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_CFGr BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr
#define TLB_RX_DIG_LPBK_CFGr_SIZE BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_t TLB_RX_DIG_LPBK_CFGr_t;
#define TLB_RX_DIG_LPBK_CFGr_CLR BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR
#define TLB_RX_DIG_LPBK_CFGr_SET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_SET
#define TLB_RX_DIG_LPBK_CFGr_GET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET
#define READ_TLB_RX_DIG_LPBK_CFGr BCMI_QTC_XGXS_READ_TLB_RX_DIG_LPBK_CFGr
#define WRITE_TLB_RX_DIG_LPBK_CFGr BCMI_QTC_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr
#define MODIFY_TLB_RX_DIG_LPBK_CFGr BCMI_QTC_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr
#define READLN_TLB_RX_DIG_LPBK_CFGr BCMI_QTC_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr
#define WRITELN_TLB_RX_DIG_LPBK_CFGr BCMI_QTC_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr
#define WRITEALL_TLB_RX_DIG_LPBK_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_TLB_RX_MISC_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d3
 * DEVAD:    1
 * DESC:     TLB RX Misc. Control
 * SIZE:     32
 * FIELDS:
 *     RX_PMD_DP_INVERT RX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     RX_AGGREGATOR_BYPASS_EN RX Aggregator Bypass EnableWhen Enabled by writing to 1'b1, DSC Data will bypass the RX Data aggregator block and sent directly to PCS along with a sync pulse which will indicate the (clk_cnt ==0).Recommended for use if low latency is desired and where data aggregation will be done in the PCS block based on the sync pulse.
 *     DBG_MASK_DIG_LPBK_EN Mask bit for dig_lpbk_en in the pmd_rx_lock equation. This is a debug register.1 => pmd_rx_lock will be forced to 1'b0 during digital loopback.0 => pmd_rx_lock will be forced to 1'b1 during digital loopback.
 */
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr (0x0001d0d3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_TLB_RX_MISC_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_tlb_rx_misc_cfg[1];
	uint32_t _tlb_rx_tlb_rx_misc_cfg;
} BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t;

#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR(r) (r).tlb_rx_tlb_rx_misc_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET(r,d) (r).tlb_rx_tlb_rx_misc_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET(r) (r).tlb_rx_tlb_rx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET(r) (((r).tlb_rx_tlb_rx_misc_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_RX_TLB_RX_MISC_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_tlb_rx_misc_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_TLB_RX_MISC_CFGr BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr
#define TLB_RX_TLB_RX_MISC_CFGr_SIZE BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t TLB_RX_TLB_RX_MISC_CFGr_t;
#define TLB_RX_TLB_RX_MISC_CFGr_CLR BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR
#define TLB_RX_TLB_RX_MISC_CFGr_SET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET
#define TLB_RX_TLB_RX_MISC_CFGr_GET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_GET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_SET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET
#define READ_TLB_RX_TLB_RX_MISC_CFGr BCMI_QTC_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr
#define WRITE_TLB_RX_TLB_RX_MISC_CFGr BCMI_QTC_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr
#define MODIFY_TLB_RX_TLB_RX_MISC_CFGr BCMI_QTC_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr
#define READLN_TLB_RX_TLB_RX_MISC_CFGr BCMI_QTC_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITELN_TLB_RX_TLB_RX_MISC_CFGr BCMI_QTC_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITEALL_TLB_RX_TLB_RX_MISC_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_TLB_RX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_EN_TMR_CTL
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d4
 * DEVAD:    1
 * DESC:     TLB RX PRBS Checker Enable Timer Control
 * SIZE:     32
 * FIELDS:
 *     PRBS_CHK_EN_TIMER_MODE prbs_chk_en timer mode.2'b0x => prbs_chk_en timer is disabled and PRBS checker mode is enabled as per prbs_chk_en register.2'b10 => use heartbeat_toggle_1us for the timer.2'b11 => use heartbeat_toggle_1ms for the timer.
 *     PRBS_CHK_EN_TIMEOUT PRBS timer timeout value.Valid range 0 to 31 which maps to 0 to 448. Should be programmed before enabling the PRBS checker in timer mode.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr (0x0001d0d4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_en_tmr_ctl[1];
	uint32_t _tlb_rx_prbs_chk_en_tmr_ctl;
} BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET(r,d) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = d
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET(r) ((((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) >> 8) & 0x1f)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET(r) (((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) & 0x3)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (3 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_en_tmr_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET
#define READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_PD_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d8
 * DEVAD:    1
 * DESC:     Digital Loopback Status
 * SIZE:     32
 * FIELDS:
 *     DIG_LPBK_PD_LATE_IND 1 means dp_rclk20 is sampling data late so reduce the delay of the dp_rclk20 clock phase. This will result in RX PI phase step decrement.
 *     DIG_LPBK_PD_EARLY_IND 1 means dp_rclk20 is sampling data earlier so delay the dp_rclk20 clock phase. This will result in RX PI phase step increment.
 */
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr (0x0001d0d8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_PD_STS.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_pd_sts[1];
	uint32_t _tlb_rx_dig_lpbk_pd_sts;
} BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t;

#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR(r) (r).tlb_rx_dig_lpbk_pd_sts[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET(r,d) (r).tlb_rx_dig_lpbk_pd_sts[0] = d
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET(r) (r).tlb_rx_dig_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_rx_dig_lpbk_pd_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_PD_STS.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_QTC_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_pd_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_PD_STSr BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr
#define TLB_RX_DIG_LPBK_PD_STSr_SIZE BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t TLB_RX_DIG_LPBK_PD_STSr_t;
#define TLB_RX_DIG_LPBK_PD_STSr_CLR BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR
#define TLB_RX_DIG_LPBK_PD_STSr_SET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET
#define TLB_RX_DIG_LPBK_PD_STSr_GET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET
#define READ_TLB_RX_DIG_LPBK_PD_STSr BCMI_QTC_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr
#define WRITE_TLB_RX_DIG_LPBK_PD_STSr BCMI_QTC_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr
#define MODIFY_TLB_RX_DIG_LPBK_PD_STSr BCMI_QTC_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr
#define READLN_TLB_RX_DIG_LPBK_PD_STSr BCMI_QTC_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITELN_TLB_RX_DIG_LPBK_PD_STSr BCMI_QTC_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITEALL_TLB_RX_DIG_LPBK_PD_STSr BCMI_QTC_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_DIG_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d9
 * DEVAD:    1
 * DESC:     PRBS Checker LOCK Status
 * SIZE:     32
 * FIELDS:
 *     PRBS_CHK_LOCK    PRBS Checker LOCK Indication. This is a live indication of the status of the PRBS Checker state machine.1 => PRBS Checker is in LOCKED state.0 => PRBS Checker is out of LOCK state and state machine is seraching for a LOCK.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr (0x0001d0d9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_LOCK_STS.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_lock_sts[1];
	uint32_t _tlb_rx_prbs_chk_lock_sts;
} BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t;

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR(r) (r).tlb_rx_prbs_chk_lock_sts[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET(r,d) (r).tlb_rx_prbs_chk_lock_sts[0] = d
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET(r) (r).tlb_rx_prbs_chk_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET(r) (((r).tlb_rx_prbs_chk_lock_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_LOCK_STS.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_lock_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_LOCK_STSr BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr
#define TLB_RX_PRBS_CHK_LOCK_STSr_SIZE BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t TLB_RX_PRBS_CHK_LOCK_STSr_t;
#define TLB_RX_PRBS_CHK_LOCK_STSr_CLR BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR
#define TLB_RX_PRBS_CHK_LOCK_STSr_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET
#define READ_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITE_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr
#define MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr
#define READLN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0da
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter MSB Status
 * SIZE:     32
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_MSB 15 bits MSB portion of PRBS Checker Error Counter Status Register. It is a clear on read register.Once MSB bits [30:16] of the counter are read then LSB bits [15:0] of the error counter is loadedinto a holding register and internal PRBS error counter's all bits are cleared to 0s(or if there are any error in that particular clock cycle then that will be loaded).MSB portion must be read first before reading the LSB portion of the error counter.
 *     PRBS_CHK_LOCK_LOST_LH PRBS Checker LOCK_LOST Latch High Indication. This register captures the 1->0 transition on theprbs_chk_lock live status register and keep it latched until read. This is a clear on read status registers.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr (0x0001d0da | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_msb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_msb_sts;
} BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = d
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET(r) ((((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) & 0x7fff)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (32767 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0db
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter LSB Status
 * SIZE:     32
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_LSB 16 bits LSB portion of PRBS Checker Error Counter Status Register. This register indicatesthe value in the holding register when MSB portion [30:16] of the error counter are read.MSB portion must be read first before reading the LSB portion of the error counter.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr (0x0001d0db | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_lsb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_lsb_sts;
} BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;

#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = d
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_QTC_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_QTC_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_QTC_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_QTC_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_QTC_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_QTC_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_RX_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0dc
 * DEVAD:    1
 * DESC:     PMD RX LOCK Status
 * SIZE:     32
 * FIELDS:
 *     PMD_RX_LOCK      PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read.
 */
#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr (0x0001d0dc | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PMD_RX_LOCK_STS.
 */
typedef union BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_pmd_rx_lock_sts;
} BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t;

#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_pmd_rx_lock_sts[0] = 0
#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_pmd_rx_lock_sts[0] = d
#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_RX_PMD_RX_LOCK_STS.
 */
#define BCMI_QTC_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_QTC_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_QTC_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_QTC_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_QTC_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_pmd_rx_lock_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PMD_RX_LOCK_STSr BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr
#define TLB_RX_PMD_RX_LOCK_STSr_SIZE BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t TLB_RX_PMD_RX_LOCK_STSr_t;
#define TLB_RX_PMD_RX_LOCK_STSr_CLR BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_PMD_RX_LOCK_STSr_SET BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET
#define TLB_RX_PMD_RX_LOCK_STSr_GET BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET
#define READ_TLB_RX_PMD_RX_LOCK_STSr BCMI_QTC_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_PMD_RX_LOCK_STSr BCMI_QTC_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_PMD_RX_LOCK_STSr BCMI_QTC_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_PMD_RX_LOCK_STSr BCMI_QTC_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_PMD_RX_LOCK_STSr BCMI_QTC_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_PMD_RX_LOCK_STSr BCMI_QTC_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_RX_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_TX_PATGEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e0
 * DEVAD:    1
 * DESC:     Pattern Generator Control
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_EN      Fixed pattern generator enable.1 => enable  the fixed pattern generator.0 => disable the fixed pattern generator.
 *     PATT_GEN_STOP_POS Valid values are 11 to 0. Defines the stop  position of the pattern in 20 bit chunks.This register value should be less than or equal to rg_patt_gen_start_pos.11 means stop at bit  220,10 means stop at bit  200, ...,0 means stop at bit    0so stop  bit is (rg_patt_gen_stop_pos*20).
 *     PATT_GEN_START_POS Valid values are 11 to 0. Defines the start position of the pattern in 20 bit chunks.11 means start at bit 239,10 means start at bit 219, ...,0 means start at bit  19so start bit is (rg_patt_gen_start_pos*20 + 19).
 */
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr (0x0001d0e0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PATGEN_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_patgen_cfg[1];
	uint32_t _tlb_tx_patgen_cfg;
} BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_t;

#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_CLR(r) (r).tlb_tx_patgen_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_SET(r,d) (r).tlb_tx_patgen_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_GET(r) (r).tlb_tx_patgen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET(r) (((r).tlb_tx_patgen_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_TX_PATGEN_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_TX_PATGEN_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_TX_PATGEN_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_TX_PATGEN_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_TX_PATGEN_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patgen_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_TX_PATGEN_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patgen_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_TX_PATGEN_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_patgen_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PATGEN_CFGr BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr
#define TLB_TX_PATGEN_CFGr_SIZE BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_t TLB_TX_PATGEN_CFGr_t;
#define TLB_TX_PATGEN_CFGr_CLR BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_CLR
#define TLB_TX_PATGEN_CFGr_SET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_SET
#define TLB_TX_PATGEN_CFGr_GET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET
#define READ_TLB_TX_PATGEN_CFGr BCMI_QTC_XGXS_READ_TLB_TX_PATGEN_CFGr
#define WRITE_TLB_TX_PATGEN_CFGr BCMI_QTC_XGXS_WRITE_TLB_TX_PATGEN_CFGr
#define MODIFY_TLB_TX_PATGEN_CFGr BCMI_QTC_XGXS_MODIFY_TLB_TX_PATGEN_CFGr
#define READLN_TLB_TX_PATGEN_CFGr BCMI_QTC_XGXS_READLN_TLB_TX_PATGEN_CFGr
#define WRITELN_TLB_TX_PATGEN_CFGr BCMI_QTC_XGXS_WRITELN_TLB_TX_PATGEN_CFGr
#define WRITEALL_TLB_TX_PATGEN_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_TX_PATGEN_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_TX_PATGEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_TX_PRBS_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e1
 * DEVAD:    1
 * DESC:     PRBS Generator Control
 * SIZE:     32
 * FIELDS:
 *     PRBS_GEN_EN      PRBS generator enable.1 => enable  the PRBS generator.0 => disable the PRBS generator.
 *     PRBS_GEN_MODE_SEL PRBS generator mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_GEN_INV     PRBS Invert enable.1 => will invert all the data bits from the PRBS generator.0 => will send normal data from the PRBS generator.
 *     PRBS_GEN_ERR_INS PRBS Error Insert.0 to 1 transition on this signal will insert single bit error in the MSB bit of the data bus.
 */
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr (0x0001d0e1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PRBS_GEN_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_prbs_gen_cfg[1];
	uint32_t _tlb_tx_prbs_gen_cfg;
} BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_t;

#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR(r) (r).tlb_tx_prbs_gen_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_SET(r,d) (r).tlb_tx_prbs_gen_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_GET(r) (r).tlb_tx_prbs_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 1) & 0x7)
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET(r) (((r).tlb_tx_prbs_gen_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_TX_PRBS_GEN_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_TX_PRBS_GEN_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_prbs_gen_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PRBS_GEN_CFGr BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr
#define TLB_TX_PRBS_GEN_CFGr_SIZE BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_t TLB_TX_PRBS_GEN_CFGr_t;
#define TLB_TX_PRBS_GEN_CFGr_CLR BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR
#define TLB_TX_PRBS_GEN_CFGr_SET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_SET
#define TLB_TX_PRBS_GEN_CFGr_GET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET
#define READ_TLB_TX_PRBS_GEN_CFGr BCMI_QTC_XGXS_READ_TLB_TX_PRBS_GEN_CFGr
#define WRITE_TLB_TX_PRBS_GEN_CFGr BCMI_QTC_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr
#define MODIFY_TLB_TX_PRBS_GEN_CFGr BCMI_QTC_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr
#define READLN_TLB_TX_PRBS_GEN_CFGr BCMI_QTC_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr
#define WRITELN_TLB_TX_PRBS_GEN_CFGr BCMI_QTC_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr
#define WRITEALL_TLB_TX_PRBS_GEN_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_TX_PRBS_GEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e2
 * DEVAD:    1
 * DESC:     Remote Loopback Control
 * SIZE:     32
 * FIELDS:
 *     RMT_LPBK_EN      RX to TX Parallel Loopback (Remote Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     RMT_LPBK_PD_MODE Remote Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     RMT_LPBK_PD_FRC_ON Remote loopback PD enable by force irrespective of rg_rmt_lpbk_en.1'b1 - enable the phase detector without the remote loopback enable. Can be used to lock RX and TXclock phases when there is a remote loopback outside PMD
 */
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr (0x0001d0e2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_cfg[1];
	uint32_t _tlb_tx_rmt_lpbk_cfg;
} BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_t;

#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR(r) (r).tlb_tx_rmt_lpbk_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_SET(r,d) (r).tlb_tx_rmt_lpbk_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_GET(r) (r).tlb_tx_rmt_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET(r) (((r).tlb_tx_rmt_lpbk_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_TX_RMT_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_CFGr BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr
#define TLB_TX_RMT_LPBK_CFGr_SIZE BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_t TLB_TX_RMT_LPBK_CFGr_t;
#define TLB_TX_RMT_LPBK_CFGr_CLR BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR
#define TLB_TX_RMT_LPBK_CFGr_SET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_SET
#define TLB_TX_RMT_LPBK_CFGr_GET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET
#define READ_TLB_TX_RMT_LPBK_CFGr BCMI_QTC_XGXS_READ_TLB_TX_RMT_LPBK_CFGr
#define WRITE_TLB_TX_RMT_LPBK_CFGr BCMI_QTC_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr
#define MODIFY_TLB_TX_RMT_LPBK_CFGr BCMI_QTC_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr
#define READLN_TLB_TX_RMT_LPBK_CFGr BCMI_QTC_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr
#define WRITELN_TLB_TX_RMT_LPBK_CFGr BCMI_QTC_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr
#define WRITEALL_TLB_TX_RMT_LPBK_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_TX_TLB_TX_MISC_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e3
 * DEVAD:    1
 * DESC:     TLB TX Misc. Control
 * SIZE:     32
 * FIELDS:
 *     TX_PMD_DP_INVERT TX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     TX_PCS_NATIVE_ANA_FRMT_EN TX PCS Interface Native Analog Format Enable.1 => TX PCS Interface is enabled in the Native Analog Format mode. TX PCS sends the over-sampled data in this mode which is sent directly to AFE.0 => Raw Data Mode where for every data request TX PCS will send 20 bits of valid data.
 *     TX_MUX_SEL_ORDER TX Data MUX Select Priority Order. When 1'b1 then priority of Pattern and PRBS generators are swapped w.r.t. CL72.0 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, patt_gen, cl72_tx, prbs_gen, tx_pcs}.1 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, prbs_gen, cl72_tx, patt_gen, tx_pcs}.
 */
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr (0x0001d0e3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_MISC_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_misc_cfg[1];
	uint32_t _tlb_tx_tlb_tx_misc_cfg;
} BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t;

#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR(r) (r).tlb_tx_tlb_tx_misc_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET(r,d) (r).tlb_tx_tlb_tx_misc_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET(r) (r).tlb_tx_tlb_tx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET(r) (((r).tlb_tx_tlb_tx_misc_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_MISC_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_misc_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_MISC_CFGr BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr
#define TLB_TX_TLB_TX_MISC_CFGr_SIZE BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t TLB_TX_TLB_TX_MISC_CFGr_t;
#define TLB_TX_TLB_TX_MISC_CFGr_CLR BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR
#define TLB_TX_TLB_TX_MISC_CFGr_SET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET
#define TLB_TX_TLB_TX_MISC_CFGr_GET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET
#define READ_TLB_TX_TLB_TX_MISC_CFGr BCMI_QTC_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr
#define WRITE_TLB_TX_TLB_TX_MISC_CFGr BCMI_QTC_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr
#define MODIFY_TLB_TX_TLB_TX_MISC_CFGr BCMI_QTC_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr
#define READLN_TLB_TX_TLB_TX_MISC_CFGr BCMI_QTC_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITELN_TLB_TX_TLB_TX_MISC_CFGr BCMI_QTC_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITEALL_TLB_TX_TLB_TX_MISC_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_TX_TLB_TX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_TX_TX_PI_LOOP_TIMING_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e4
 * DEVAD:    1
 * DESC:     TX PI Loop timing select control
 * SIZE:     32
 * FIELDS:
 *     TX_PI_LOOP_TIMING_SRC_SEL If enabled by writing to 1'b1 then rx_phase_sum_val from the corresponding CDRwill be selected as the loop timing source for the TX Phase interpolator filter.This bit is recommended to be set to 1'b1 for only 1 lane. If more than 1 lane is enabled then the smallest enabled lane number CDRwill be selected as the loop timing source. It must be enabled for the lane in remote loopback but can also be enabled just for loop timing.
 */
#define BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr (0x0001d0e4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TX_PI_LOOP_TIMING_CFG.
 */
typedef union BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_tx_pi_loop_timing_cfg[1];
	uint32_t _tlb_tx_tx_pi_loop_timing_cfg;
} BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_t;

#define BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_CLR(r) (r).tlb_tx_tx_pi_loop_timing_cfg[0] = 0
#define BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_SET(r,d) (r).tlb_tx_tx_pi_loop_timing_cfg[0] = d
#define BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_GET(r) (r).tlb_tx_tx_pi_loop_timing_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_TX_PI_LOOP_TIMING_SRC_SELf_GET(r) (((r).tlb_tx_tx_pi_loop_timing_cfg[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_TX_PI_LOOP_TIMING_SRC_SELf_SET(r,f) (r).tlb_tx_tx_pi_loop_timing_cfg[0]=(((r).tlb_tx_tx_pi_loop_timing_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_TX_TX_PI_LOOP_TIMING_CFG.
 */
#define BCMI_QTC_XGXS_READ_TLB_TX_TX_PI_LOOP_TIMING_CFGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr,(_r._tlb_tx_tx_pi_loop_timing_cfg))
#define BCMI_QTC_XGXS_WRITE_TLB_TX_TX_PI_LOOP_TIMING_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr,(_r._tlb_tx_tx_pi_loop_timing_cfg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_TX_TX_PI_LOOP_TIMING_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr,(_r._tlb_tx_tx_pi_loop_timing_cfg))
#define BCMI_QTC_XGXS_READLN_TLB_TX_TX_PI_LOOP_TIMING_CFGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tx_pi_loop_timing_cfg))
#define BCMI_QTC_XGXS_WRITELN_TLB_TX_TX_PI_LOOP_TIMING_CFGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tx_pi_loop_timing_cfg))
#define BCMI_QTC_XGXS_WRITEALL_TLB_TX_TX_PI_LOOP_TIMING_CFGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tx_pi_loop_timing_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TX_PI_LOOP_TIMING_CFGr BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr
#define TLB_TX_TX_PI_LOOP_TIMING_CFGr_SIZE BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_SIZE
typedef BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_t TLB_TX_TX_PI_LOOP_TIMING_CFGr_t;
#define TLB_TX_TX_PI_LOOP_TIMING_CFGr_CLR BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_CLR
#define TLB_TX_TX_PI_LOOP_TIMING_CFGr_SET BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_SET
#define TLB_TX_TX_PI_LOOP_TIMING_CFGr_GET BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_GET
#define TLB_TX_TX_PI_LOOP_TIMING_CFGr_TX_PI_LOOP_TIMING_SRC_SELf_GET BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_TX_PI_LOOP_TIMING_SRC_SELf_GET
#define TLB_TX_TX_PI_LOOP_TIMING_CFGr_TX_PI_LOOP_TIMING_SRC_SELf_SET BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr_TX_PI_LOOP_TIMING_SRC_SELf_SET
#define READ_TLB_TX_TX_PI_LOOP_TIMING_CFGr BCMI_QTC_XGXS_READ_TLB_TX_TX_PI_LOOP_TIMING_CFGr
#define WRITE_TLB_TX_TX_PI_LOOP_TIMING_CFGr BCMI_QTC_XGXS_WRITE_TLB_TX_TX_PI_LOOP_TIMING_CFGr
#define MODIFY_TLB_TX_TX_PI_LOOP_TIMING_CFGr BCMI_QTC_XGXS_MODIFY_TLB_TX_TX_PI_LOOP_TIMING_CFGr
#define READLN_TLB_TX_TX_PI_LOOP_TIMING_CFGr BCMI_QTC_XGXS_READLN_TLB_TX_TX_PI_LOOP_TIMING_CFGr
#define WRITELN_TLB_TX_TX_PI_LOOP_TIMING_CFGr BCMI_QTC_XGXS_WRITELN_TLB_TX_TX_PI_LOOP_TIMING_CFGr
#define WRITEALL_TLB_TX_TX_PI_LOOP_TIMING_CFGr BCMI_QTC_XGXS_WRITEALL_TLB_TX_TX_PI_LOOP_TIMING_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_TX_TX_PI_LOOP_TIMING_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_PD_STS
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e8
 * DEVAD:    1
 * DESC:     Remote Loopback Status
 * SIZE:     32
 * FIELDS:
 *     RMT_LPBK_PD_LATE_IND 1 means dp_tclk20 is sampling data late so reduce the delay of the dp_tclk20 clock phase. This will result in TX PI phase step decrement.
 *     RMT_LPBK_PD_EARLY_IND 1 means dp_tclk20 is sampling data earlier so delay the dp_tclk20 clock phase. This will result in TX PI phase step increment.
 */
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr (0x0001d0e8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_PD_STS.
 */
typedef union BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_pd_sts[1];
	uint32_t _tlb_tx_rmt_lpbk_pd_sts;
} BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t;

#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR(r) (r).tlb_tx_rmt_lpbk_pd_sts[0] = 0
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET(r,d) (r).tlb_tx_rmt_lpbk_pd_sts[0] = d
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET(r) (r).tlb_tx_rmt_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_tx_rmt_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_tx_rmt_lpbk_pd_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_PD_STS.
 */
#define BCMI_QTC_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_QTC_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_QTC_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_QTC_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_QTC_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_pd_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_PD_STSr BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr
#define TLB_TX_RMT_LPBK_PD_STSr_SIZE BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE
typedef BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t TLB_TX_RMT_LPBK_PD_STSr_t;
#define TLB_TX_RMT_LPBK_PD_STSr_CLR BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR
#define TLB_TX_RMT_LPBK_PD_STSr_SET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET
#define TLB_TX_RMT_LPBK_PD_STSr_GET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET
#define READ_TLB_TX_RMT_LPBK_PD_STSr BCMI_QTC_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr
#define WRITE_TLB_TX_RMT_LPBK_PD_STSr BCMI_QTC_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr
#define MODIFY_TLB_TX_RMT_LPBK_PD_STSr BCMI_QTC_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr
#define READLN_TLB_TX_RMT_LPBK_PD_STSr BCMI_QTC_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITELN_TLB_TX_RMT_LPBK_PD_STSr BCMI_QTC_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITEALL_TLB_TX_RMT_LPBK_PD_STSr BCMI_QTC_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TLB_TX_RMT_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_REVID0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f0
 * DEVAD:    1
 * DESC:     REVID0
 * SIZE:     32
 * FIELDS:
 *     REVID_MODEL      model number
 *     REVID_PROCESS    technology process0 = 90nm1 = 65nm2 = 40nm3 = 28nm4 = 20nm5 = 16nm6-7 = reserved
 *     REVID_BONDING    bonding0 = wire bond1 = flip chip2-3 = reserved
 *     REVID_REV_NUMBER Metal mask revision number
 *     REVID_REV_LETTER All layer revision letter0 = revA1 = revB2 = revC3 = revD
 */
#define BCMI_QTC_XGXS_DIG_REVID0r (0x0001d0f0 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_REVID0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID0.
 */
typedef union BCMI_QTC_XGXS_DIG_REVID0r_s {
	uint32_t v[1];
	uint32_t dig_revid0[1];
	uint32_t _dig_revid0;
} BCMI_QTC_XGXS_DIG_REVID0r_t;

#define BCMI_QTC_XGXS_DIG_REVID0r_CLR(r) (r).dig_revid0[0] = 0
#define BCMI_QTC_XGXS_DIG_REVID0r_SET(r,d) (r).dig_revid0[0] = d
#define BCMI_QTC_XGXS_DIG_REVID0r_GET(r) (r).dig_revid0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET(r) ((((r).dig_revid0[0]) >> 14) & 0x3)
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET(r) ((((r).dig_revid0[0]) >> 11) & 0x7)
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_BONDINGf_GET(r) ((((r).dig_revid0[0]) >> 9) & 0x3)
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_BONDINGf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_PROCESSf_GET(r) ((((r).dig_revid0[0]) >> 6) & 0x7)
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_PROCESSf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_MODELf_GET(r) (((r).dig_revid0[0]) & 0x3f)
#define BCMI_QTC_XGXS_DIG_REVID0r_REVID_MODELf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access DIG_REVID0.
 */
#define BCMI_QTC_XGXS_READ_DIG_REVID0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_QTC_XGXS_WRITE_DIG_REVID0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID0r,(_r._dig_revid0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_REVID0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_QTC_XGXS_READLN_DIG_REVID0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_QTC_XGXS_WRITELN_DIG_REVID0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_QTC_XGXS_WRITEALL_DIG_REVID0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID0r BCMI_QTC_XGXS_DIG_REVID0r
#define DIG_REVID0r_SIZE BCMI_QTC_XGXS_DIG_REVID0r_SIZE
typedef BCMI_QTC_XGXS_DIG_REVID0r_t DIG_REVID0r_t;
#define DIG_REVID0r_CLR BCMI_QTC_XGXS_DIG_REVID0r_CLR
#define DIG_REVID0r_SET BCMI_QTC_XGXS_DIG_REVID0r_SET
#define DIG_REVID0r_GET BCMI_QTC_XGXS_DIG_REVID0r_GET
#define DIG_REVID0r_REVID_REV_LETTERf_GET BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET
#define DIG_REVID0r_REVID_REV_LETTERf_SET BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET
#define DIG_REVID0r_REVID_REV_NUMBERf_GET BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET
#define DIG_REVID0r_REVID_REV_NUMBERf_SET BCMI_QTC_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET
#define DIG_REVID0r_REVID_BONDINGf_GET BCMI_QTC_XGXS_DIG_REVID0r_REVID_BONDINGf_GET
#define DIG_REVID0r_REVID_BONDINGf_SET BCMI_QTC_XGXS_DIG_REVID0r_REVID_BONDINGf_SET
#define DIG_REVID0r_REVID_PROCESSf_GET BCMI_QTC_XGXS_DIG_REVID0r_REVID_PROCESSf_GET
#define DIG_REVID0r_REVID_PROCESSf_SET BCMI_QTC_XGXS_DIG_REVID0r_REVID_PROCESSf_SET
#define DIG_REVID0r_REVID_MODELf_GET BCMI_QTC_XGXS_DIG_REVID0r_REVID_MODELf_GET
#define DIG_REVID0r_REVID_MODELf_SET BCMI_QTC_XGXS_DIG_REVID0r_REVID_MODELf_SET
#define READ_DIG_REVID0r BCMI_QTC_XGXS_READ_DIG_REVID0r
#define WRITE_DIG_REVID0r BCMI_QTC_XGXS_WRITE_DIG_REVID0r
#define MODIFY_DIG_REVID0r BCMI_QTC_XGXS_MODIFY_DIG_REVID0r
#define READLN_DIG_REVID0r BCMI_QTC_XGXS_READLN_DIG_REVID0r
#define WRITELN_DIG_REVID0r BCMI_QTC_XGXS_WRITELN_DIG_REVID0r
#define WRITEALL_DIG_REVID0r BCMI_QTC_XGXS_WRITEALL_DIG_REVID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_REVID0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_RST_CTL_PMD
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f1
 * DEVAD:    1
 * DESC:     RESET_CONTROL_PMD
 * SIZE:     32
 * FIELDS:
 *     CORE_S_RSTB      Active Low Core Level Soft Reset. If asserted by writing to 1'b0 will reset the whole core.This soft reset is equivalent to the hard reset input pin pmd_por_h_rstb. This regiter bit can only bereset by assertion of the hard reset input pin pmd_por_h_rstb
 */
#define BCMI_QTC_XGXS_DIG_RST_CTL_PMDr (0x0001d0f1 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_PMD.
 */
typedef union BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_pmd[1];
	uint32_t _dig_rst_ctl_pmd;
} BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_t;

#define BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_CLR(r) (r).dig_rst_ctl_pmd[0] = 0
#define BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_SET(r,d) (r).dig_rst_ctl_pmd[0] = d
#define BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_GET(r) (r).dig_rst_ctl_pmd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET(r) (((r).dig_rst_ctl_pmd[0]) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET(r,f) (r).dig_rst_ctl_pmd[0]=(((r).dig_rst_ctl_pmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DIG_RST_CTL_PMD.
 */
#define BCMI_QTC_XGXS_READ_DIG_RST_CTL_PMDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_QTC_XGXS_WRITE_DIG_RST_CTL_PMDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_RST_CTL_PMDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_QTC_XGXS_READLN_DIG_RST_CTL_PMDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_QTC_XGXS_WRITELN_DIG_RST_CTL_PMDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_QTC_XGXS_WRITEALL_DIG_RST_CTL_PMDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_pmd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_PMDr BCMI_QTC_XGXS_DIG_RST_CTL_PMDr
#define DIG_RST_CTL_PMDr_SIZE BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_SIZE
typedef BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_t DIG_RST_CTL_PMDr_t;
#define DIG_RST_CTL_PMDr_CLR BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_CLR
#define DIG_RST_CTL_PMDr_SET BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_SET
#define DIG_RST_CTL_PMDr_GET BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET BCMI_QTC_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET
#define READ_DIG_RST_CTL_PMDr BCMI_QTC_XGXS_READ_DIG_RST_CTL_PMDr
#define WRITE_DIG_RST_CTL_PMDr BCMI_QTC_XGXS_WRITE_DIG_RST_CTL_PMDr
#define MODIFY_DIG_RST_CTL_PMDr BCMI_QTC_XGXS_MODIFY_DIG_RST_CTL_PMDr
#define READLN_DIG_RST_CTL_PMDr BCMI_QTC_XGXS_READLN_DIG_RST_CTL_PMDr
#define WRITELN_DIG_RST_CTL_PMDr BCMI_QTC_XGXS_WRITELN_DIG_RST_CTL_PMDr
#define WRITEALL_DIG_RST_CTL_PMDr BCMI_QTC_XGXS_WRITEALL_DIG_RST_CTL_PMDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_RST_CTL_PMDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_RST_CTL_CORE_DP
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f2
 * DEVAD:    1
 * DESC:     RESET_CONTROL_CORE_DP
 * SIZE:     32
 * FIELDS:
 *     PMD_CORE_DP_H_RSTB_PKILL 1'b1 will disable the pmd_core_dp_h_rstb pin.
 *     SUP_RST_SEQ_FRC_VAL Suppress reset sequence force value.
 *     SUP_RST_SEQ_FRC  Suppress reset sequence force.
 *     PMD_MDIO_TRANS_PKILL 1'b1 will disable the pmd_mdio_trans pin.
 *     PMD_TX_CLK_VLD_FRC pmd_tx_clk_vld core output pin force.
 *     PMD_TX_CLK_VLD_FRC_VAL pmd_tx_clk_vld core output pin force value.
 *     TX_S_COMCLK_SEL  Mux control for selection of comclk for TX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_sel is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     TX_S_COMCLK_FRC_ON Mux control for selection of comclk for TX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the TX lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     TX_S_CLKGATE_FRC_ON TX Active High Lane clock gator enable. If 1'1b1 then tx lane clock will be gated off. It does not affect the tclk goingto RMIC block so tx lane based registers can still be readable but not writable.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_clkgate_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     AFE_S_PLL_RESET_FRC_VAL Active High PLL Reset force value control.
 *     AFE_S_PLL_RESET_FRC Active High PLL Reset force control.
 *     TX_PI_LOOP_FILTER_STABLE This register bit is ANDed with pmd_tx_clk_vld before frc/frc_val mux. This register will be controlled by the firmware when TX_PI is enabled.When TX_PI is enabled then this register will be written to 1'b0 while TX_PI is acquiring the lock with the source clock and will be written to 1'b1 by firmwareto indicate that clocks are locked. It indicates to chip level via pmd_tx_clk_vld to reset any datapath FIFOs and come out of reset when TX clock is stable.
 */
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr (0x0001d0f2 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_CORE_DP.
 */
typedef union BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_core_dp[1];
	uint32_t _dig_rst_ctl_core_dp;
} BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_t;

#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_CLR(r) (r).dig_rst_ctl_core_dp[0] = 0
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SET(r,d) (r).dig_rst_ctl_core_dp[0] = d
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_GET(r) (r).dig_rst_ctl_core_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access DIG_RST_CTL_CORE_DP.
 */
#define BCMI_QTC_XGXS_READ_DIG_RST_CTL_CORE_DPr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_QTC_XGXS_WRITE_DIG_RST_CTL_CORE_DPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_QTC_XGXS_READLN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_QTC_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_QTC_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_core_dp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_CORE_DPr BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr
#define DIG_RST_CTL_CORE_DPr_SIZE BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SIZE
typedef BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_t DIG_RST_CTL_CORE_DPr_t;
#define DIG_RST_CTL_CORE_DPr_CLR BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_CLR
#define DIG_RST_CTL_CORE_DPr_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SET
#define DIG_RST_CTL_CORE_DPr_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_GET
#define DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_GET
#define DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_SET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_SET
#define DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_GET
#define DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_SET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_GET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_SET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_GET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET
#define READ_DIG_RST_CTL_CORE_DPr BCMI_QTC_XGXS_READ_DIG_RST_CTL_CORE_DPr
#define WRITE_DIG_RST_CTL_CORE_DPr BCMI_QTC_XGXS_WRITE_DIG_RST_CTL_CORE_DPr
#define MODIFY_DIG_RST_CTL_CORE_DPr BCMI_QTC_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr
#define READLN_DIG_RST_CTL_CORE_DPr BCMI_QTC_XGXS_READLN_DIG_RST_CTL_CORE_DPr
#define WRITELN_DIG_RST_CTL_CORE_DPr BCMI_QTC_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr
#define WRITEALL_DIG_RST_CTL_CORE_DPr BCMI_QTC_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_RST_CTL_CORE_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_CORE_MCST_MASK_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f3
 * DEVAD:    1
 * DESC:     CORE_MULTICAST_MASK_CONRTOL
 * SIZE:     32
 * FIELDS:
 *     CORE_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr (0x0001d0f3 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_MCST_MASK_CTL.
 */
typedef union BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t dig_core_mcst_mask_ctl[1];
	uint32_t _dig_core_mcst_mask_ctl;
} BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_t;

#define BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_CLR(r) (r).dig_core_mcst_mask_ctl[0] = 0
#define BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_SET(r,d) (r).dig_core_mcst_mask_ctl[0] = d
#define BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_GET(r) (r).dig_core_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_CORE_MULTICAST_MASK_CONTROLf_GET(r) (((r).dig_core_mcst_mask_ctl[0]) & 0xf)
#define BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_CORE_MULTICAST_MASK_CONTROLf_SET(r,f) (r).dig_core_mcst_mask_ctl[0]=(((r).dig_core_mcst_mask_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access DIG_CORE_MCST_MASK_CTL.
 */
#define BCMI_QTC_XGXS_READ_DIG_CORE_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr,(_r._dig_core_mcst_mask_ctl))
#define BCMI_QTC_XGXS_WRITE_DIG_CORE_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr,(_r._dig_core_mcst_mask_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_CORE_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr,(_r._dig_core_mcst_mask_ctl))
#define BCMI_QTC_XGXS_READLN_DIG_CORE_MCST_MASK_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_mcst_mask_ctl))
#define BCMI_QTC_XGXS_WRITELN_DIG_CORE_MCST_MASK_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_mcst_mask_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DIG_CORE_MCST_MASK_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_mcst_mask_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_MCST_MASK_CTLr BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr
#define DIG_CORE_MCST_MASK_CTLr_SIZE BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_SIZE
typedef BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_t DIG_CORE_MCST_MASK_CTLr_t;
#define DIG_CORE_MCST_MASK_CTLr_CLR BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_CLR
#define DIG_CORE_MCST_MASK_CTLr_SET BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_SET
#define DIG_CORE_MCST_MASK_CTLr_GET BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_GET
#define DIG_CORE_MCST_MASK_CTLr_CORE_MULTICAST_MASK_CONTROLf_GET BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_CORE_MULTICAST_MASK_CONTROLf_GET
#define DIG_CORE_MCST_MASK_CTLr_CORE_MULTICAST_MASK_CONTROLf_SET BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr_CORE_MULTICAST_MASK_CONTROLf_SET
#define READ_DIG_CORE_MCST_MASK_CTLr BCMI_QTC_XGXS_READ_DIG_CORE_MCST_MASK_CTLr
#define WRITE_DIG_CORE_MCST_MASK_CTLr BCMI_QTC_XGXS_WRITE_DIG_CORE_MCST_MASK_CTLr
#define MODIFY_DIG_CORE_MCST_MASK_CTLr BCMI_QTC_XGXS_MODIFY_DIG_CORE_MCST_MASK_CTLr
#define READLN_DIG_CORE_MCST_MASK_CTLr BCMI_QTC_XGXS_READLN_DIG_CORE_MCST_MASK_CTLr
#define WRITELN_DIG_CORE_MCST_MASK_CTLr BCMI_QTC_XGXS_WRITELN_DIG_CORE_MCST_MASK_CTLr
#define WRITEALL_DIG_CORE_MCST_MASK_CTLr BCMI_QTC_XGXS_WRITEALL_DIG_CORE_MCST_MASK_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_CORE_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_TOP_USER_CTL0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f4
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL_0
 * SIZE:     32
 * FIELDS:
 *     HEARTBEAT_COUNT_1US Heartbeat timer count in comclk cycles to create 1us heartbeat_1us period. It should be programmed to the nearest increment of 0.25Mhz value of the comclk frequency in Mhz.For example, for comclk of 125 Mhz, it should be programmed to 10'd500. For 156.25 Mhz comclk, it should be programmed to 10'd625 and similarly for any other comclk frequency.
 *     CORE_DP_S_RSTB   Active Low Core Level Datapath Soft Reset. If asserted by writingto 1'b0 will reset datapath logic of all the lanes. This soft resetis equivalent to the hard reset input pin core_dp_h_rstb. Assertion of this
 *     AFE_S_PLL_PWRDN  Active High PLL Power Down control.
 *     UC_ACTIVE        When set to 1'b1 then Hardware should wait for uC handshakes to wake up from datapath resetWhen set to 1'b0 then Hardware can internally assume that uc_ack_* = 1.
 */
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r (0x0001d0f4 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TOP_USER_CTL0.
 */
typedef union BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_s {
	uint32_t v[1];
	uint32_t dig_top_user_ctl0[1];
	uint32_t _dig_top_user_ctl0;
} BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_t;

#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_CLR(r) (r).dig_top_user_ctl0[0] = 0
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_SET(r,d) (r).dig_top_user_ctl0[0] = d
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_GET(r) (r).dig_top_user_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET(r) (((r).dig_top_user_ctl0[0]) & 0x3ff)
#define BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (1023 << 16)

/*
 * These macros can be used to access DIG_TOP_USER_CTL0.
 */
#define BCMI_QTC_XGXS_READ_DIG_TOP_USER_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_QTC_XGXS_WRITE_DIG_TOP_USER_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_TOP_USER_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_QTC_XGXS_READLN_DIG_TOP_USER_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_QTC_XGXS_WRITELN_DIG_TOP_USER_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_DIG_TOP_USER_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_top_user_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_TOP_USER_CTL0r BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r
#define DIG_TOP_USER_CTL0r_SIZE BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_SIZE
typedef BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_t DIG_TOP_USER_CTL0r_t;
#define DIG_TOP_USER_CTL0r_CLR BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_CLR
#define DIG_TOP_USER_CTL0r_SET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_SET
#define DIG_TOP_USER_CTL0r_GET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_GET
#define DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET
#define DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET
#define DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET
#define DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET
#define DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET
#define DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET
#define READ_DIG_TOP_USER_CTL0r BCMI_QTC_XGXS_READ_DIG_TOP_USER_CTL0r
#define WRITE_DIG_TOP_USER_CTL0r BCMI_QTC_XGXS_WRITE_DIG_TOP_USER_CTL0r
#define MODIFY_DIG_TOP_USER_CTL0r BCMI_QTC_XGXS_MODIFY_DIG_TOP_USER_CTL0r
#define READLN_DIG_TOP_USER_CTL0r BCMI_QTC_XGXS_READLN_DIG_TOP_USER_CTL0r
#define WRITELN_DIG_TOP_USER_CTL0r BCMI_QTC_XGXS_WRITELN_DIG_TOP_USER_CTL0r
#define WRITEALL_DIG_TOP_USER_CTL0r BCMI_QTC_XGXS_WRITEALL_DIG_TOP_USER_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_TOP_USER_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_UC_ACK_CORE_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f5
 * DEVAD:    1
 * DESC:     UC_ACK_CORE_CONTROL
 * SIZE:     32
 * FIELDS:
 *     UC_ACK_CORE_CFG_DONE uC will write this to 1 to indicate it's configuration of the core is complete. Writing to 1'b1 willshould release internal hold on core_dp_reset, only if core_dp_reset_state is 3'b001.
 *     UC_ACK_CORE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "core_dp_reset_coccured".
 */
#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr (0x0001d0f5 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_UC_ACK_CORE_CTL.
 */
typedef union BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_s {
	uint32_t v[1];
	uint32_t dig_uc_ack_core_ctl[1];
	uint32_t _dig_uc_ack_core_ctl;
} BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_t;

#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_CLR(r) (r).dig_uc_ack_core_ctl[0] = 0
#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_SET(r,d) (r).dig_uc_ack_core_ctl[0] = d
#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_GET(r) (r).dig_uc_ack_core_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET(r) ((((r).dig_uc_ack_core_ctl[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET(r,f) (r).dig_uc_ack_core_ctl[0]=(((r).dig_uc_ack_core_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET(r) (((r).dig_uc_ack_core_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET(r,f) (r).dig_uc_ack_core_ctl[0]=(((r).dig_uc_ack_core_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DIG_UC_ACK_CORE_CTL.
 */
#define BCMI_QTC_XGXS_READ_DIG_UC_ACK_CORE_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr,(_r._dig_uc_ack_core_ctl))
#define BCMI_QTC_XGXS_WRITE_DIG_UC_ACK_CORE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr,(_r._dig_uc_ack_core_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_UC_ACK_CORE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr,(_r._dig_uc_ack_core_ctl))
#define BCMI_QTC_XGXS_READLN_DIG_UC_ACK_CORE_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_uc_ack_core_ctl))
#define BCMI_QTC_XGXS_WRITELN_DIG_UC_ACK_CORE_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_uc_ack_core_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DIG_UC_ACK_CORE_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_uc_ack_core_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_UC_ACK_CORE_CTLr BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr
#define DIG_UC_ACK_CORE_CTLr_SIZE BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_SIZE
typedef BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_t DIG_UC_ACK_CORE_CTLr_t;
#define DIG_UC_ACK_CORE_CTLr_CLR BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_CLR
#define DIG_UC_ACK_CORE_CTLr_SET BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_SET
#define DIG_UC_ACK_CORE_CTLr_GET BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_GET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET
#define READ_DIG_UC_ACK_CORE_CTLr BCMI_QTC_XGXS_READ_DIG_UC_ACK_CORE_CTLr
#define WRITE_DIG_UC_ACK_CORE_CTLr BCMI_QTC_XGXS_WRITE_DIG_UC_ACK_CORE_CTLr
#define MODIFY_DIG_UC_ACK_CORE_CTLr BCMI_QTC_XGXS_MODIFY_DIG_UC_ACK_CORE_CTLr
#define READLN_DIG_UC_ACK_CORE_CTLr BCMI_QTC_XGXS_READLN_DIG_UC_ACK_CORE_CTLr
#define WRITELN_DIG_UC_ACK_CORE_CTLr BCMI_QTC_XGXS_WRITELN_DIG_UC_ACK_CORE_CTLr
#define WRITEALL_DIG_UC_ACK_CORE_CTLr BCMI_QTC_XGXS_WRITEALL_DIG_UC_ACK_CORE_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_UC_ACK_CORE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_CORE_RST_OCC_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f6
 * DEVAD:    1
 * DESC:     CORE_REG_RESET_OCCURRED_CONTROL
 * SIZE:     32
 * FIELDS:
 *     CORE_REG_RESET_OCCURRED Set to 1'b1 upon core level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr (0x0001d0f6 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_RST_OCC_CTL.
 */
typedef union BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t dig_core_rst_occ_ctl[1];
	uint32_t _dig_core_rst_occ_ctl;
} BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_t;

#define BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_CLR(r) (r).dig_core_rst_occ_ctl[0] = 0
#define BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_SET(r,d) (r).dig_core_rst_occ_ctl[0] = d
#define BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_GET(r) (r).dig_core_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET(r) (((r).dig_core_rst_occ_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET(r,f) (r).dig_core_rst_occ_ctl[0]=(((r).dig_core_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DIG_CORE_RST_OCC_CTL.
 */
#define BCMI_QTC_XGXS_READ_DIG_CORE_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl))
#define BCMI_QTC_XGXS_WRITE_DIG_CORE_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_CORE_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl))
#define BCMI_QTC_XGXS_READLN_DIG_CORE_RST_OCC_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_rst_occ_ctl))
#define BCMI_QTC_XGXS_WRITELN_DIG_CORE_RST_OCC_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_rst_occ_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DIG_CORE_RST_OCC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_rst_occ_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_RST_OCC_CTLr BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr
#define DIG_CORE_RST_OCC_CTLr_SIZE BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_SIZE
typedef BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_t DIG_CORE_RST_OCC_CTLr_t;
#define DIG_CORE_RST_OCC_CTLr_CLR BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_CLR
#define DIG_CORE_RST_OCC_CTLr_SET BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_SET
#define DIG_CORE_RST_OCC_CTLr_GET BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET
#define READ_DIG_CORE_RST_OCC_CTLr BCMI_QTC_XGXS_READ_DIG_CORE_RST_OCC_CTLr
#define WRITE_DIG_CORE_RST_OCC_CTLr BCMI_QTC_XGXS_WRITE_DIG_CORE_RST_OCC_CTLr
#define MODIFY_DIG_CORE_RST_OCC_CTLr BCMI_QTC_XGXS_MODIFY_DIG_CORE_RST_OCC_CTLr
#define READLN_DIG_CORE_RST_OCC_CTLr BCMI_QTC_XGXS_READLN_DIG_CORE_RST_OCC_CTLr
#define WRITELN_DIG_CORE_RST_OCC_CTLr BCMI_QTC_XGXS_WRITELN_DIG_CORE_RST_OCC_CTLr
#define WRITEALL_DIG_CORE_RST_OCC_CTLr BCMI_QTC_XGXS_WRITEALL_DIG_CORE_RST_OCC_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_CORE_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_RST_SEQ_TMR_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f7
 * DEVAD:    1
 * DESC:     RST_SEQ_TIMER_CONTROL
 * SIZE:     32
 * FIELDS:
 *     RST_SEQ_TIMER    Defines the number of comclk cycles between de-assertion of AFE RX/TX lane reset and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 2 to 16 clock cycles between de-assertion of AFE RX/TX lane resetand clock muxing from comclk to lane clock. Wait_time = 2 * (rst_seq_timer + 1).
 *     PWRDN_SEQ_TIMER  Defines the number of comclk cycles between de-assertion of AFE RX/TX lane pwrdn and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 8 to 64 clock cycles between de-assertion of AFE RX/TX lane pwrdnand clock muxing from comclk to lane clock. Wait_time = 8 * (pwrdn_seq_timer + 1).
 *     RST_SEQ_DIS_FLT_MODE Defines the filter mode for rst_seq_dis/pmd_mdio_trans pin.2'd0 - filter is bypassed where input is passed to output untouched.2'd1 - filter output is 16 comclk cycles if input is > 16 comclk cycles else output is same as input signal.2'd2 - filter output is 20 comclk cycles if input is > 20 comclk cycles else output is same as input signal.2'd3 - filter output is 24 comclk cycles if input is > 24 comclk cycles else output is same as input signal.
 */
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr (0x0001d0f7 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_SEQ_TMR_CTL.
 */
typedef union BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t dig_rst_seq_tmr_ctl[1];
	uint32_t _dig_rst_seq_tmr_ctl;
} BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_t;

#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_CLR(r) (r).dig_rst_seq_tmr_ctl[0] = 0
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_SET(r,d) (r).dig_rst_seq_tmr_ctl[0] = d
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_GET(r) (r).dig_rst_seq_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 14) & 0x3)
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 8) & 0x7)
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET(r) (((r).dig_rst_seq_tmr_ctl[0]) & 0x7)
#define BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (7 << 16)

/*
 * These macros can be used to access DIG_RST_SEQ_TMR_CTL.
 */
#define BCMI_QTC_XGXS_READ_DIG_RST_SEQ_TMR_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl))
#define BCMI_QTC_XGXS_WRITE_DIG_RST_SEQ_TMR_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_RST_SEQ_TMR_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl))
#define BCMI_QTC_XGXS_READLN_DIG_RST_SEQ_TMR_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_seq_tmr_ctl))
#define BCMI_QTC_XGXS_WRITELN_DIG_RST_SEQ_TMR_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_seq_tmr_ctl))
#define BCMI_QTC_XGXS_WRITEALL_DIG_RST_SEQ_TMR_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_seq_tmr_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_SEQ_TMR_CTLr BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr
#define DIG_RST_SEQ_TMR_CTLr_SIZE BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_SIZE
typedef BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_t DIG_RST_SEQ_TMR_CTLr_t;
#define DIG_RST_SEQ_TMR_CTLr_CLR BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_CLR
#define DIG_RST_SEQ_TMR_CTLr_SET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_SET
#define DIG_RST_SEQ_TMR_CTLr_GET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET
#define READ_DIG_RST_SEQ_TMR_CTLr BCMI_QTC_XGXS_READ_DIG_RST_SEQ_TMR_CTLr
#define WRITE_DIG_RST_SEQ_TMR_CTLr BCMI_QTC_XGXS_WRITE_DIG_RST_SEQ_TMR_CTLr
#define MODIFY_DIG_RST_SEQ_TMR_CTLr BCMI_QTC_XGXS_MODIFY_DIG_RST_SEQ_TMR_CTLr
#define READLN_DIG_RST_SEQ_TMR_CTLr BCMI_QTC_XGXS_READLN_DIG_RST_SEQ_TMR_CTLr
#define WRITELN_DIG_RST_SEQ_TMR_CTLr BCMI_QTC_XGXS_WRITELN_DIG_RST_SEQ_TMR_CTLr
#define WRITEALL_DIG_RST_SEQ_TMR_CTLr BCMI_QTC_XGXS_WRITEALL_DIG_RST_SEQ_TMR_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_RST_SEQ_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_CORE_DP_RST_ST_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f8
 * DEVAD:    1
 * DESC:     CORE_DP_RESET_STATE_STATUS
 * SIZE:     32
 * FIELDS:
 *     CORE_DP_RESET_STATE Bit 2: core_dp_reset_active   : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls.Bit 1: core_dp_reset_occurred : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: core_dp_reset_held     : Set to 1'b1 whenenver core_dp_reset is internally held. Cleared to 1'b0, only if core_dp_reset_state==001 and uc_ack_core_cfg_done == 1.
 *     LANE_RESET_RELEASED_INDEX Index of the lane number of the first lane in lane_reset_released state.
 *     LANE_RESET_RELEASED indicates if a lane is currently at {lane_dp_reset_active, lane_dp_reset_occurred} = 01.
 */
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr (0x0001d0f8 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_DP_RST_ST_STS.
 */
typedef union BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t dig_core_dp_rst_st_sts[1];
	uint32_t _dig_core_dp_rst_st_sts;
} BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_t;

#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR(r) (r).dig_core_dp_rst_st_sts[0] = 0
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_SET(r,d) (r).dig_core_dp_rst_st_sts[0] = d
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_GET(r) (r).dig_core_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 8) & 0x1f)
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET(r) (((r).dig_core_dp_rst_st_sts[0]) & 0x7)
#define BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (7 << 16)

/*
 * These macros can be used to access DIG_CORE_DP_RST_ST_STS.
 */
#define BCMI_QTC_XGXS_READ_DIG_CORE_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_QTC_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_QTC_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_QTC_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_QTC_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_dp_rst_st_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_DP_RST_ST_STSr BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr
#define DIG_CORE_DP_RST_ST_STSr_SIZE BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE
typedef BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_t DIG_CORE_DP_RST_ST_STSr_t;
#define DIG_CORE_DP_RST_ST_STSr_CLR BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR
#define DIG_CORE_DP_RST_ST_STSr_SET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_SET
#define DIG_CORE_DP_RST_ST_STSr_GET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET
#define DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET
#define DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET
#define READ_DIG_CORE_DP_RST_ST_STSr BCMI_QTC_XGXS_READ_DIG_CORE_DP_RST_ST_STSr
#define WRITE_DIG_CORE_DP_RST_ST_STSr BCMI_QTC_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr
#define MODIFY_DIG_CORE_DP_RST_ST_STSr BCMI_QTC_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr
#define READLN_DIG_CORE_DP_RST_ST_STSr BCMI_QTC_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr
#define WRITELN_DIG_CORE_DP_RST_ST_STSr BCMI_QTC_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr
#define WRITEALL_DIG_CORE_DP_RST_ST_STSr BCMI_QTC_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_CORE_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_PMD_CORE_MODE_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0f9
 * DEVAD:    1
 * DESC:     PMD_CORE_MODE_STATUS
 * SIZE:     32
 * FIELDS:
 *     PMD_CORE_MODE    This indicates the status of the core input pin pmd_core_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr (0x0001d0f9 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_PMD_CORE_MODE_STS.
 */
typedef union BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_s {
	uint32_t v[1];
	uint32_t dig_pmd_core_mode_sts[1];
	uint32_t _dig_pmd_core_mode_sts;
} BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_t;

#define BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_CLR(r) (r).dig_pmd_core_mode_sts[0] = 0
#define BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_SET(r,d) (r).dig_pmd_core_mode_sts[0] = d
#define BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_GET(r) (r).dig_pmd_core_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET(r) (((r).dig_pmd_core_mode_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET(r,f) (r).dig_pmd_core_mode_sts[0]=(((r).dig_pmd_core_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access DIG_PMD_CORE_MODE_STS.
 */
#define BCMI_QTC_XGXS_READ_DIG_PMD_CORE_MODE_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr,(_r._dig_pmd_core_mode_sts))
#define BCMI_QTC_XGXS_WRITE_DIG_PMD_CORE_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr,(_r._dig_pmd_core_mode_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_PMD_CORE_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr,(_r._dig_pmd_core_mode_sts))
#define BCMI_QTC_XGXS_READLN_DIG_PMD_CORE_MODE_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_pmd_core_mode_sts))
#define BCMI_QTC_XGXS_WRITELN_DIG_PMD_CORE_MODE_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_pmd_core_mode_sts))
#define BCMI_QTC_XGXS_WRITEALL_DIG_PMD_CORE_MODE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_pmd_core_mode_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_PMD_CORE_MODE_STSr BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr
#define DIG_PMD_CORE_MODE_STSr_SIZE BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_SIZE
typedef BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_t DIG_PMD_CORE_MODE_STSr_t;
#define DIG_PMD_CORE_MODE_STSr_CLR BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_CLR
#define DIG_PMD_CORE_MODE_STSr_SET BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_SET
#define DIG_PMD_CORE_MODE_STSr_GET BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_GET
#define DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET
#define DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET
#define READ_DIG_PMD_CORE_MODE_STSr BCMI_QTC_XGXS_READ_DIG_PMD_CORE_MODE_STSr
#define WRITE_DIG_PMD_CORE_MODE_STSr BCMI_QTC_XGXS_WRITE_DIG_PMD_CORE_MODE_STSr
#define MODIFY_DIG_PMD_CORE_MODE_STSr BCMI_QTC_XGXS_MODIFY_DIG_PMD_CORE_MODE_STSr
#define READLN_DIG_PMD_CORE_MODE_STSr BCMI_QTC_XGXS_READLN_DIG_PMD_CORE_MODE_STSr
#define WRITELN_DIG_PMD_CORE_MODE_STSr BCMI_QTC_XGXS_WRITELN_DIG_PMD_CORE_MODE_STSr
#define WRITEALL_DIG_PMD_CORE_MODE_STSr BCMI_QTC_XGXS_WRITEALL_DIG_PMD_CORE_MODE_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_PMD_CORE_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_REVID1
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0fa
 * DEVAD:    1
 * DESC:     REVID1
 * SIZE:     32
 * FIELDS:
 *     REVID_EEE        EEE support present in core
 *     REVID_LLP        Ultra low latency path present in core
 *     REVID_PIR        PCS interface retiming flops present in core
 *     REVID_CL72       Clause 72 present in core
 *     REVID_MICRO      Microcontroller present in core
 *     REVID_MDIO       MDIO interface present in core
 *     REVID_MULTIPLICITY Number of lanes
 */
#define BCMI_QTC_XGXS_DIG_REVID1r (0x0001d0fa | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_REVID1r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID1.
 */
typedef union BCMI_QTC_XGXS_DIG_REVID1r_s {
	uint32_t v[1];
	uint32_t dig_revid1[1];
	uint32_t _dig_revid1;
} BCMI_QTC_XGXS_DIG_REVID1r_t;

#define BCMI_QTC_XGXS_DIG_REVID1r_CLR(r) (r).dig_revid1[0] = 0
#define BCMI_QTC_XGXS_DIG_REVID1r_SET(r,d) (r).dig_revid1[0] = d
#define BCMI_QTC_XGXS_DIG_REVID1r_GET(r) (r).dig_revid1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET(r) ((((r).dig_revid1[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_MDIOf_GET(r) ((((r).dig_revid1[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_MDIOf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_MICROf_GET(r) ((((r).dig_revid1[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_MICROf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_CL72f_GET(r) ((((r).dig_revid1[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_CL72f_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_PIRf_GET(r) ((((r).dig_revid1[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_PIRf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_LLPf_GET(r) ((((r).dig_revid1[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_LLPf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_EEEf_GET(r) (((r).dig_revid1[0]) & 0x1)
#define BCMI_QTC_XGXS_DIG_REVID1r_REVID_EEEf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access DIG_REVID1.
 */
#define BCMI_QTC_XGXS_READ_DIG_REVID1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_QTC_XGXS_WRITE_DIG_REVID1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID1r,(_r._dig_revid1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_REVID1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_QTC_XGXS_READLN_DIG_REVID1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_QTC_XGXS_WRITELN_DIG_REVID1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_QTC_XGXS_WRITEALL_DIG_REVID1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID1r BCMI_QTC_XGXS_DIG_REVID1r
#define DIG_REVID1r_SIZE BCMI_QTC_XGXS_DIG_REVID1r_SIZE
typedef BCMI_QTC_XGXS_DIG_REVID1r_t DIG_REVID1r_t;
#define DIG_REVID1r_CLR BCMI_QTC_XGXS_DIG_REVID1r_CLR
#define DIG_REVID1r_SET BCMI_QTC_XGXS_DIG_REVID1r_SET
#define DIG_REVID1r_GET BCMI_QTC_XGXS_DIG_REVID1r_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_GET BCMI_QTC_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_SET BCMI_QTC_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET
#define DIG_REVID1r_REVID_MDIOf_GET BCMI_QTC_XGXS_DIG_REVID1r_REVID_MDIOf_GET
#define DIG_REVID1r_REVID_MDIOf_SET BCMI_QTC_XGXS_DIG_REVID1r_REVID_MDIOf_SET
#define DIG_REVID1r_REVID_MICROf_GET BCMI_QTC_XGXS_DIG_REVID1r_REVID_MICROf_GET
#define DIG_REVID1r_REVID_MICROf_SET BCMI_QTC_XGXS_DIG_REVID1r_REVID_MICROf_SET
#define DIG_REVID1r_REVID_CL72f_GET BCMI_QTC_XGXS_DIG_REVID1r_REVID_CL72f_GET
#define DIG_REVID1r_REVID_CL72f_SET BCMI_QTC_XGXS_DIG_REVID1r_REVID_CL72f_SET
#define DIG_REVID1r_REVID_PIRf_GET BCMI_QTC_XGXS_DIG_REVID1r_REVID_PIRf_GET
#define DIG_REVID1r_REVID_PIRf_SET BCMI_QTC_XGXS_DIG_REVID1r_REVID_PIRf_SET
#define DIG_REVID1r_REVID_LLPf_GET BCMI_QTC_XGXS_DIG_REVID1r_REVID_LLPf_GET
#define DIG_REVID1r_REVID_LLPf_SET BCMI_QTC_XGXS_DIG_REVID1r_REVID_LLPf_SET
#define DIG_REVID1r_REVID_EEEf_GET BCMI_QTC_XGXS_DIG_REVID1r_REVID_EEEf_GET
#define DIG_REVID1r_REVID_EEEf_SET BCMI_QTC_XGXS_DIG_REVID1r_REVID_EEEf_SET
#define READ_DIG_REVID1r BCMI_QTC_XGXS_READ_DIG_REVID1r
#define WRITE_DIG_REVID1r BCMI_QTC_XGXS_WRITE_DIG_REVID1r
#define MODIFY_DIG_REVID1r BCMI_QTC_XGXS_MODIFY_DIG_REVID1r
#define READLN_DIG_REVID1r BCMI_QTC_XGXS_READLN_DIG_REVID1r
#define WRITELN_DIG_REVID1r BCMI_QTC_XGXS_WRITELN_DIG_REVID1r
#define WRITEALL_DIG_REVID1r BCMI_QTC_XGXS_WRITEALL_DIG_REVID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_REVID1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_TX_LN_MAP_0_1_2
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0fb
 * DEVAD:    1
 * DESC:     TX_LANE_MAP_0_1_2
 * SIZE:     32
 * FIELDS:
 *     TX_LANE_MAP_0    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 0
 *     TX_LANE_MAP_1    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 1
 *     TX_LANE_MAP_2    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 2
 */
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r (0x0001d0fb | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TX_LN_MAP_0_1_2.
 */
typedef union BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_s {
	uint32_t v[1];
	uint32_t dig_tx_ln_map_0_1_2[1];
	uint32_t _dig_tx_ln_map_0_1_2;
} BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_t;

#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_CLR(r) (r).dig_tx_ln_map_0_1_2[0] = 0
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_SET(r,d) (r).dig_tx_ln_map_0_1_2[0] = d
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_GET(r) (r).dig_tx_ln_map_0_1_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_GET(r) ((((r).dig_tx_ln_map_0_1_2[0]) >> 10) & 0x1f)
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_SET(r,f) (r).dig_tx_ln_map_0_1_2[0]=(((r).dig_tx_ln_map_0_1_2[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_GET(r) ((((r).dig_tx_ln_map_0_1_2[0]) >> 5) & 0x1f)
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_SET(r,f) (r).dig_tx_ln_map_0_1_2[0]=(((r).dig_tx_ln_map_0_1_2[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_GET(r) (((r).dig_tx_ln_map_0_1_2[0]) & 0x1f)
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_SET(r,f) (r).dig_tx_ln_map_0_1_2[0]=(((r).dig_tx_ln_map_0_1_2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DIG_TX_LN_MAP_0_1_2.
 */
#define BCMI_QTC_XGXS_READ_DIG_TX_LN_MAP_0_1_2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r,(_r._dig_tx_ln_map_0_1_2))
#define BCMI_QTC_XGXS_WRITE_DIG_TX_LN_MAP_0_1_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r,(_r._dig_tx_ln_map_0_1_2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_TX_LN_MAP_0_1_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r,(_r._dig_tx_ln_map_0_1_2))
#define BCMI_QTC_XGXS_READLN_DIG_TX_LN_MAP_0_1_2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_0_1_2))
#define BCMI_QTC_XGXS_WRITELN_DIG_TX_LN_MAP_0_1_2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_0_1_2))
#define BCMI_QTC_XGXS_WRITEALL_DIG_TX_LN_MAP_0_1_2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_tx_ln_map_0_1_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_TX_LN_MAP_0_1_2r BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r
#define DIG_TX_LN_MAP_0_1_2r_SIZE BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_SIZE
typedef BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_t DIG_TX_LN_MAP_0_1_2r_t;
#define DIG_TX_LN_MAP_0_1_2r_CLR BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_CLR
#define DIG_TX_LN_MAP_0_1_2r_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_SET
#define DIG_TX_LN_MAP_0_1_2r_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_SET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_SET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_SET
#define READ_DIG_TX_LN_MAP_0_1_2r BCMI_QTC_XGXS_READ_DIG_TX_LN_MAP_0_1_2r
#define WRITE_DIG_TX_LN_MAP_0_1_2r BCMI_QTC_XGXS_WRITE_DIG_TX_LN_MAP_0_1_2r
#define MODIFY_DIG_TX_LN_MAP_0_1_2r BCMI_QTC_XGXS_MODIFY_DIG_TX_LN_MAP_0_1_2r
#define READLN_DIG_TX_LN_MAP_0_1_2r BCMI_QTC_XGXS_READLN_DIG_TX_LN_MAP_0_1_2r
#define WRITELN_DIG_TX_LN_MAP_0_1_2r BCMI_QTC_XGXS_WRITELN_DIG_TX_LN_MAP_0_1_2r
#define WRITEALL_DIG_TX_LN_MAP_0_1_2r BCMI_QTC_XGXS_WRITEALL_DIG_TX_LN_MAP_0_1_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_TX_LN_MAP_0_1_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_TX_LN_MAP_3_N_LN_ADDR_0_1
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0fc
 * DEVAD:    1
 * DESC:     TX_LANE_MAP_3_N_LANE_ADDR_0_1
 * SIZE:     32
 * FIELDS:
 *     TX_LANE_MAP_3    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 3
 *     LANE_ADDR_0      Determines the logical address associated with the PMD lane with physical index  "_0" at the PCS interface.lane_addr_0 is the logical address of the lane with pins at the PCS interface labeled "_0".
 *     LANE_ADDR_1      Determines the logical address associated with the PMD lane with physical index  "_1" at the PCS interface.lane_addr_1 is the logical address of the lane with pins at the PCS interface labeled "_1".
 */
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r (0x0001d0fc | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TX_LN_MAP_3_N_LN_ADDR_0_1.
 */
typedef union BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_s {
	uint32_t v[1];
	uint32_t dig_tx_ln_map_3_n_ln_addr_0_1[1];
	uint32_t _dig_tx_ln_map_3_n_ln_addr_0_1;
} BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_t;

#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_CLR(r) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0] = 0
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SET(r,d) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0] = d
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_GET(r) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_GET(r) ((((r).dig_tx_ln_map_3_n_ln_addr_0_1[0]) >> 10) & 0x1f)
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_SET(r,f) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]=(((r).dig_tx_ln_map_3_n_ln_addr_0_1[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_GET(r) ((((r).dig_tx_ln_map_3_n_ln_addr_0_1[0]) >> 5) & 0x1f)
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_SET(r,f) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]=(((r).dig_tx_ln_map_3_n_ln_addr_0_1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_GET(r) (((r).dig_tx_ln_map_3_n_ln_addr_0_1[0]) & 0x1f)
#define BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_SET(r,f) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]=(((r).dig_tx_ln_map_3_n_ln_addr_0_1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DIG_TX_LN_MAP_3_N_LN_ADDR_0_1.
 */
#define BCMI_QTC_XGXS_READ_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r,(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_QTC_XGXS_WRITE_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r,(_r._dig_tx_ln_map_3_n_ln_addr_0_1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r,(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_QTC_XGXS_READLN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_QTC_XGXS_WRITELN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_QTC_XGXS_WRITEALL_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_tx_ln_map_3_n_ln_addr_0_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SIZE BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SIZE
typedef BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_t DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_t;
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_CLR BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_CLR
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_SET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_SET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_GET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_SET BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_SET
#define READ_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_QTC_XGXS_READ_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define WRITE_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_QTC_XGXS_WRITE_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define MODIFY_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_QTC_XGXS_MODIFY_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define READLN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_QTC_XGXS_READLN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define WRITELN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_QTC_XGXS_WRITELN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define WRITEALL_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_QTC_XGXS_WRITEALL_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_LN_ADDR_2_3
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0fd
 * DEVAD:    1
 * DESC:     LANE_ADDR_2_3
 * SIZE:     32
 * FIELDS:
 *     LANE_ADDR_2      Determines the logical address associated with the PMD lane with physical index  "_2" at the PCS interface.lane_addr_2 is the logical address of the lane with pins at the PCS interface labeled "_2".
 *     LANE_ADDR_3      Determines the logical address associated with the PMD lane with physical index  "_3" at the PCS interface.lane_addr_3 is the logical address of the lane with pins at the PCS interface labeled "_3".
 */
#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r (0x0001d0fd | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_SIZE 4

/*
 * This structure should be used to declare and program DIG_LN_ADDR_2_3.
 */
typedef union BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_s {
	uint32_t v[1];
	uint32_t dig_ln_addr_2_3[1];
	uint32_t _dig_ln_addr_2_3;
} BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_t;

#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_CLR(r) (r).dig_ln_addr_2_3[0] = 0
#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_SET(r,d) (r).dig_ln_addr_2_3[0] = d
#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_GET(r) (r).dig_ln_addr_2_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_GET(r) ((((r).dig_ln_addr_2_3[0]) >> 8) & 0x1f)
#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_SET(r,f) (r).dig_ln_addr_2_3[0]=(((r).dig_ln_addr_2_3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_GET(r) (((r).dig_ln_addr_2_3[0]) & 0x1f)
#define BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_SET(r,f) (r).dig_ln_addr_2_3[0]=(((r).dig_ln_addr_2_3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access DIG_LN_ADDR_2_3.
 */
#define BCMI_QTC_XGXS_READ_DIG_LN_ADDR_2_3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r,(_r._dig_ln_addr_2_3))
#define BCMI_QTC_XGXS_WRITE_DIG_LN_ADDR_2_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r,(_r._dig_ln_addr_2_3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_LN_ADDR_2_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r,(_r._dig_ln_addr_2_3))
#define BCMI_QTC_XGXS_READLN_DIG_LN_ADDR_2_3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_ln_addr_2_3))
#define BCMI_QTC_XGXS_WRITELN_DIG_LN_ADDR_2_3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_ln_addr_2_3))
#define BCMI_QTC_XGXS_WRITEALL_DIG_LN_ADDR_2_3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_ln_addr_2_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_LN_ADDR_2_3r BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r
#define DIG_LN_ADDR_2_3r_SIZE BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_SIZE
typedef BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_t DIG_LN_ADDR_2_3r_t;
#define DIG_LN_ADDR_2_3r_CLR BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_CLR
#define DIG_LN_ADDR_2_3r_SET BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_SET
#define DIG_LN_ADDR_2_3r_GET BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_GET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_3f_GET BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_GET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_3f_SET BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_SET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_2f_GET BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_GET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_2f_SET BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_SET
#define READ_DIG_LN_ADDR_2_3r BCMI_QTC_XGXS_READ_DIG_LN_ADDR_2_3r
#define WRITE_DIG_LN_ADDR_2_3r BCMI_QTC_XGXS_WRITE_DIG_LN_ADDR_2_3r
#define MODIFY_DIG_LN_ADDR_2_3r BCMI_QTC_XGXS_MODIFY_DIG_LN_ADDR_2_3r
#define READLN_DIG_LN_ADDR_2_3r BCMI_QTC_XGXS_READLN_DIG_LN_ADDR_2_3r
#define WRITELN_DIG_LN_ADDR_2_3r BCMI_QTC_XGXS_WRITELN_DIG_LN_ADDR_2_3r
#define WRITEALL_DIG_LN_ADDR_2_3r BCMI_QTC_XGXS_WRITEALL_DIG_LN_ADDR_2_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_LN_ADDR_2_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  DIG_REVID2
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd0fe
 * DEVAD:    1
 * DESC:     REVID2
 * SIZE:     32
 * FIELDS:
 *     REVID2           Revision ID2 code
 */
#define BCMI_QTC_XGXS_DIG_REVID2r (0x0001d0fe | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_DIG_REVID2r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID2.
 */
typedef union BCMI_QTC_XGXS_DIG_REVID2r_s {
	uint32_t v[1];
	uint32_t dig_revid2[1];
	uint32_t _dig_revid2;
} BCMI_QTC_XGXS_DIG_REVID2r_t;

#define BCMI_QTC_XGXS_DIG_REVID2r_CLR(r) (r).dig_revid2[0] = 0
#define BCMI_QTC_XGXS_DIG_REVID2r_SET(r,d) (r).dig_revid2[0] = d
#define BCMI_QTC_XGXS_DIG_REVID2r_GET(r) (r).dig_revid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_DIG_REVID2r_REVID2f_GET(r) (((r).dig_revid2[0]) & 0xf)
#define BCMI_QTC_XGXS_DIG_REVID2r_REVID2f_SET(r,f) (r).dig_revid2[0]=(((r).dig_revid2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access DIG_REVID2.
 */
#define BCMI_QTC_XGXS_READ_DIG_REVID2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_QTC_XGXS_WRITE_DIG_REVID2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID2r,(_r._dig_revid2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_DIG_REVID2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_QTC_XGXS_READLN_DIG_REVID2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_QTC_XGXS_WRITELN_DIG_REVID2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_QTC_XGXS_WRITEALL_DIG_REVID2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID2r BCMI_QTC_XGXS_DIG_REVID2r
#define DIG_REVID2r_SIZE BCMI_QTC_XGXS_DIG_REVID2r_SIZE
typedef BCMI_QTC_XGXS_DIG_REVID2r_t DIG_REVID2r_t;
#define DIG_REVID2r_CLR BCMI_QTC_XGXS_DIG_REVID2r_CLR
#define DIG_REVID2r_SET BCMI_QTC_XGXS_DIG_REVID2r_SET
#define DIG_REVID2r_GET BCMI_QTC_XGXS_DIG_REVID2r_GET
#define DIG_REVID2r_REVID2f_GET BCMI_QTC_XGXS_DIG_REVID2r_REVID2f_GET
#define DIG_REVID2r_REVID2f_SET BCMI_QTC_XGXS_DIG_REVID2r_REVID2f_SET
#define READ_DIG_REVID2r BCMI_QTC_XGXS_READ_DIG_REVID2r
#define WRITE_DIG_REVID2r BCMI_QTC_XGXS_WRITE_DIG_REVID2r
#define MODIFY_DIG_REVID2r BCMI_QTC_XGXS_MODIFY_DIG_REVID2r
#define READLN_DIG_REVID2r BCMI_QTC_XGXS_READLN_DIG_REVID2r
#define WRITELN_DIG_REVID2r BCMI_QTC_XGXS_WRITELN_DIG_REVID2r
#define WRITEALL_DIG_REVID2r BCMI_QTC_XGXS_WRITEALL_DIG_REVID2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_DIG_REVID2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ0
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd100
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 0
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_0   Fixed Pattern Generator Sequence Word 0. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted last.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ0r (0x0001d100 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ0r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ0.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ0r_s {
	uint32_t v[1];
	uint32_t patgen_seq0[1];
	uint32_t _patgen_seq0;
} BCMI_QTC_XGXS_PATGEN_SEQ0r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ0r_CLR(r) (r).patgen_seq0[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ0r_SET(r,d) (r).patgen_seq0[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ0r_GET(r) (r).patgen_seq0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET(r) (((r).patgen_seq0[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET(r,f) (r).patgen_seq0[0]=(((r).patgen_seq0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ0.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ0r,(_r._patgen_seq0))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ0r,(_r._patgen_seq0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ0r,(_r._patgen_seq0))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq0))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq0))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ0r BCMI_QTC_XGXS_PATGEN_SEQ0r
#define PATGEN_SEQ0r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ0r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ0r_t PATGEN_SEQ0r_t;
#define PATGEN_SEQ0r_CLR BCMI_QTC_XGXS_PATGEN_SEQ0r_CLR
#define PATGEN_SEQ0r_SET BCMI_QTC_XGXS_PATGEN_SEQ0r_SET
#define PATGEN_SEQ0r_GET BCMI_QTC_XGXS_PATGEN_SEQ0r_GET
#define PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET BCMI_QTC_XGXS_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET
#define PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET BCMI_QTC_XGXS_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET
#define READ_PATGEN_SEQ0r BCMI_QTC_XGXS_READ_PATGEN_SEQ0r
#define WRITE_PATGEN_SEQ0r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ0r
#define MODIFY_PATGEN_SEQ0r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ0r
#define READLN_PATGEN_SEQ0r BCMI_QTC_XGXS_READLN_PATGEN_SEQ0r
#define WRITELN_PATGEN_SEQ0r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ0r
#define WRITEALL_PATGEN_SEQ0r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ1
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd101
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 1
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_1   Fixed Pattern Generator Sequence Word 1. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ1r (0x0001d101 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ1r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ1.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ1r_s {
	uint32_t v[1];
	uint32_t patgen_seq1[1];
	uint32_t _patgen_seq1;
} BCMI_QTC_XGXS_PATGEN_SEQ1r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ1r_CLR(r) (r).patgen_seq1[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ1r_SET(r,d) (r).patgen_seq1[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ1r_GET(r) (r).patgen_seq1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET(r) (((r).patgen_seq1[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET(r,f) (r).patgen_seq1[0]=(((r).patgen_seq1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ1.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ1r,(_r._patgen_seq1))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ1r,(_r._patgen_seq1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ1r,(_r._patgen_seq1))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq1))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq1))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ1r BCMI_QTC_XGXS_PATGEN_SEQ1r
#define PATGEN_SEQ1r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ1r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ1r_t PATGEN_SEQ1r_t;
#define PATGEN_SEQ1r_CLR BCMI_QTC_XGXS_PATGEN_SEQ1r_CLR
#define PATGEN_SEQ1r_SET BCMI_QTC_XGXS_PATGEN_SEQ1r_SET
#define PATGEN_SEQ1r_GET BCMI_QTC_XGXS_PATGEN_SEQ1r_GET
#define PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET BCMI_QTC_XGXS_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET
#define PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET BCMI_QTC_XGXS_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET
#define READ_PATGEN_SEQ1r BCMI_QTC_XGXS_READ_PATGEN_SEQ1r
#define WRITE_PATGEN_SEQ1r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ1r
#define MODIFY_PATGEN_SEQ1r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ1r
#define READLN_PATGEN_SEQ1r BCMI_QTC_XGXS_READLN_PATGEN_SEQ1r
#define WRITELN_PATGEN_SEQ1r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ1r
#define WRITEALL_PATGEN_SEQ1r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ2
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd102
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 2
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_2   Fixed Pattern Generator Sequence Word 2. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ2r (0x0001d102 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ2r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ2.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ2r_s {
	uint32_t v[1];
	uint32_t patgen_seq2[1];
	uint32_t _patgen_seq2;
} BCMI_QTC_XGXS_PATGEN_SEQ2r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ2r_CLR(r) (r).patgen_seq2[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ2r_SET(r,d) (r).patgen_seq2[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ2r_GET(r) (r).patgen_seq2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET(r) (((r).patgen_seq2[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET(r,f) (r).patgen_seq2[0]=(((r).patgen_seq2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ2.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ2r,(_r._patgen_seq2))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ2r,(_r._patgen_seq2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ2r,(_r._patgen_seq2))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq2))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq2))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ2r BCMI_QTC_XGXS_PATGEN_SEQ2r
#define PATGEN_SEQ2r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ2r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ2r_t PATGEN_SEQ2r_t;
#define PATGEN_SEQ2r_CLR BCMI_QTC_XGXS_PATGEN_SEQ2r_CLR
#define PATGEN_SEQ2r_SET BCMI_QTC_XGXS_PATGEN_SEQ2r_SET
#define PATGEN_SEQ2r_GET BCMI_QTC_XGXS_PATGEN_SEQ2r_GET
#define PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET BCMI_QTC_XGXS_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET
#define PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET BCMI_QTC_XGXS_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET
#define READ_PATGEN_SEQ2r BCMI_QTC_XGXS_READ_PATGEN_SEQ2r
#define WRITE_PATGEN_SEQ2r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ2r
#define MODIFY_PATGEN_SEQ2r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ2r
#define READLN_PATGEN_SEQ2r BCMI_QTC_XGXS_READLN_PATGEN_SEQ2r
#define WRITELN_PATGEN_SEQ2r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ2r
#define WRITEALL_PATGEN_SEQ2r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ3
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd103
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 3
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_3   Fixed Pattern Generator Sequence Word 3. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ3r (0x0001d103 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ3r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ3.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ3r_s {
	uint32_t v[1];
	uint32_t patgen_seq3[1];
	uint32_t _patgen_seq3;
} BCMI_QTC_XGXS_PATGEN_SEQ3r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ3r_CLR(r) (r).patgen_seq3[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ3r_SET(r,d) (r).patgen_seq3[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ3r_GET(r) (r).patgen_seq3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET(r) (((r).patgen_seq3[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET(r,f) (r).patgen_seq3[0]=(((r).patgen_seq3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ3.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ3r,(_r._patgen_seq3))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ3r,(_r._patgen_seq3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ3r,(_r._patgen_seq3))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq3))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq3))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ3r BCMI_QTC_XGXS_PATGEN_SEQ3r
#define PATGEN_SEQ3r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ3r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ3r_t PATGEN_SEQ3r_t;
#define PATGEN_SEQ3r_CLR BCMI_QTC_XGXS_PATGEN_SEQ3r_CLR
#define PATGEN_SEQ3r_SET BCMI_QTC_XGXS_PATGEN_SEQ3r_SET
#define PATGEN_SEQ3r_GET BCMI_QTC_XGXS_PATGEN_SEQ3r_GET
#define PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET BCMI_QTC_XGXS_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET
#define PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET BCMI_QTC_XGXS_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET
#define READ_PATGEN_SEQ3r BCMI_QTC_XGXS_READ_PATGEN_SEQ3r
#define WRITE_PATGEN_SEQ3r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ3r
#define MODIFY_PATGEN_SEQ3r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ3r
#define READLN_PATGEN_SEQ3r BCMI_QTC_XGXS_READLN_PATGEN_SEQ3r
#define WRITELN_PATGEN_SEQ3r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ3r
#define WRITEALL_PATGEN_SEQ3r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ4
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd104
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 4
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_4   Fixed Pattern Generator Sequence Word 4. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ4r (0x0001d104 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ4r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ4.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ4r_s {
	uint32_t v[1];
	uint32_t patgen_seq4[1];
	uint32_t _patgen_seq4;
} BCMI_QTC_XGXS_PATGEN_SEQ4r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ4r_CLR(r) (r).patgen_seq4[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ4r_SET(r,d) (r).patgen_seq4[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ4r_GET(r) (r).patgen_seq4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET(r) (((r).patgen_seq4[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET(r,f) (r).patgen_seq4[0]=(((r).patgen_seq4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ4.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ4r,(_r._patgen_seq4))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ4r,(_r._patgen_seq4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ4r,(_r._patgen_seq4))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq4))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq4))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ4r BCMI_QTC_XGXS_PATGEN_SEQ4r
#define PATGEN_SEQ4r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ4r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ4r_t PATGEN_SEQ4r_t;
#define PATGEN_SEQ4r_CLR BCMI_QTC_XGXS_PATGEN_SEQ4r_CLR
#define PATGEN_SEQ4r_SET BCMI_QTC_XGXS_PATGEN_SEQ4r_SET
#define PATGEN_SEQ4r_GET BCMI_QTC_XGXS_PATGEN_SEQ4r_GET
#define PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET BCMI_QTC_XGXS_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET
#define PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET BCMI_QTC_XGXS_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET
#define READ_PATGEN_SEQ4r BCMI_QTC_XGXS_READ_PATGEN_SEQ4r
#define WRITE_PATGEN_SEQ4r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ4r
#define MODIFY_PATGEN_SEQ4r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ4r
#define READLN_PATGEN_SEQ4r BCMI_QTC_XGXS_READLN_PATGEN_SEQ4r
#define WRITELN_PATGEN_SEQ4r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ4r
#define WRITEALL_PATGEN_SEQ4r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ5
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd105
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 5
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_5   Fixed Pattern Generator Sequence Word 5. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ5r (0x0001d105 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ5r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ5.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ5r_s {
	uint32_t v[1];
	uint32_t patgen_seq5[1];
	uint32_t _patgen_seq5;
} BCMI_QTC_XGXS_PATGEN_SEQ5r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ5r_CLR(r) (r).patgen_seq5[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ5r_SET(r,d) (r).patgen_seq5[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ5r_GET(r) (r).patgen_seq5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET(r) (((r).patgen_seq5[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET(r,f) (r).patgen_seq5[0]=(((r).patgen_seq5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ5.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ5r,(_r._patgen_seq5))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ5r,(_r._patgen_seq5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ5r,(_r._patgen_seq5))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq5))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq5))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ5r BCMI_QTC_XGXS_PATGEN_SEQ5r
#define PATGEN_SEQ5r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ5r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ5r_t PATGEN_SEQ5r_t;
#define PATGEN_SEQ5r_CLR BCMI_QTC_XGXS_PATGEN_SEQ5r_CLR
#define PATGEN_SEQ5r_SET BCMI_QTC_XGXS_PATGEN_SEQ5r_SET
#define PATGEN_SEQ5r_GET BCMI_QTC_XGXS_PATGEN_SEQ5r_GET
#define PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET BCMI_QTC_XGXS_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET
#define PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET BCMI_QTC_XGXS_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET
#define READ_PATGEN_SEQ5r BCMI_QTC_XGXS_READ_PATGEN_SEQ5r
#define WRITE_PATGEN_SEQ5r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ5r
#define MODIFY_PATGEN_SEQ5r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ5r
#define READLN_PATGEN_SEQ5r BCMI_QTC_XGXS_READLN_PATGEN_SEQ5r
#define WRITELN_PATGEN_SEQ5r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ5r
#define WRITEALL_PATGEN_SEQ5r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ6
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd106
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 6
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_6   Fixed Pattern Generator Sequence Word 6. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ6r (0x0001d106 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ6r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ6.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ6r_s {
	uint32_t v[1];
	uint32_t patgen_seq6[1];
	uint32_t _patgen_seq6;
} BCMI_QTC_XGXS_PATGEN_SEQ6r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ6r_CLR(r) (r).patgen_seq6[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ6r_SET(r,d) (r).patgen_seq6[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ6r_GET(r) (r).patgen_seq6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET(r) (((r).patgen_seq6[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET(r,f) (r).patgen_seq6[0]=(((r).patgen_seq6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ6.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ6r,(_r._patgen_seq6))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ6r,(_r._patgen_seq6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ6r,(_r._patgen_seq6))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq6))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq6))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ6r BCMI_QTC_XGXS_PATGEN_SEQ6r
#define PATGEN_SEQ6r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ6r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ6r_t PATGEN_SEQ6r_t;
#define PATGEN_SEQ6r_CLR BCMI_QTC_XGXS_PATGEN_SEQ6r_CLR
#define PATGEN_SEQ6r_SET BCMI_QTC_XGXS_PATGEN_SEQ6r_SET
#define PATGEN_SEQ6r_GET BCMI_QTC_XGXS_PATGEN_SEQ6r_GET
#define PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET BCMI_QTC_XGXS_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET
#define PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET BCMI_QTC_XGXS_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET
#define READ_PATGEN_SEQ6r BCMI_QTC_XGXS_READ_PATGEN_SEQ6r
#define WRITE_PATGEN_SEQ6r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ6r
#define MODIFY_PATGEN_SEQ6r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ6r
#define READLN_PATGEN_SEQ6r BCMI_QTC_XGXS_READLN_PATGEN_SEQ6r
#define WRITELN_PATGEN_SEQ6r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ6r
#define WRITEALL_PATGEN_SEQ6r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ7
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd107
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 7
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_7   Fixed Pattern Generator Sequence Word 7. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ7r (0x0001d107 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ7r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ7.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ7r_s {
	uint32_t v[1];
	uint32_t patgen_seq7[1];
	uint32_t _patgen_seq7;
} BCMI_QTC_XGXS_PATGEN_SEQ7r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ7r_CLR(r) (r).patgen_seq7[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ7r_SET(r,d) (r).patgen_seq7[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ7r_GET(r) (r).patgen_seq7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET(r) (((r).patgen_seq7[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET(r,f) (r).patgen_seq7[0]=(((r).patgen_seq7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ7.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ7r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ7r,(_r._patgen_seq7))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ7r,(_r._patgen_seq7)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ7r,(_r._patgen_seq7))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ7r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq7))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ7r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq7))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ7r BCMI_QTC_XGXS_PATGEN_SEQ7r
#define PATGEN_SEQ7r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ7r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ7r_t PATGEN_SEQ7r_t;
#define PATGEN_SEQ7r_CLR BCMI_QTC_XGXS_PATGEN_SEQ7r_CLR
#define PATGEN_SEQ7r_SET BCMI_QTC_XGXS_PATGEN_SEQ7r_SET
#define PATGEN_SEQ7r_GET BCMI_QTC_XGXS_PATGEN_SEQ7r_GET
#define PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET BCMI_QTC_XGXS_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET
#define PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET BCMI_QTC_XGXS_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET
#define READ_PATGEN_SEQ7r BCMI_QTC_XGXS_READ_PATGEN_SEQ7r
#define WRITE_PATGEN_SEQ7r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ7r
#define MODIFY_PATGEN_SEQ7r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ7r
#define READLN_PATGEN_SEQ7r BCMI_QTC_XGXS_READLN_PATGEN_SEQ7r
#define WRITELN_PATGEN_SEQ7r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ7r
#define WRITEALL_PATGEN_SEQ7r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ8
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd108
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 8
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_8   Fixed Pattern Generator Sequence Word 8. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ8r (0x0001d108 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ8r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ8.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ8r_s {
	uint32_t v[1];
	uint32_t patgen_seq8[1];
	uint32_t _patgen_seq8;
} BCMI_QTC_XGXS_PATGEN_SEQ8r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ8r_CLR(r) (r).patgen_seq8[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ8r_SET(r,d) (r).patgen_seq8[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ8r_GET(r) (r).patgen_seq8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET(r) (((r).patgen_seq8[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET(r,f) (r).patgen_seq8[0]=(((r).patgen_seq8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ8.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ8r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ8r,(_r._patgen_seq8))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ8r,(_r._patgen_seq8)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ8r,(_r._patgen_seq8))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ8r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq8))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ8r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq8))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ8r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq8))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ8r BCMI_QTC_XGXS_PATGEN_SEQ8r
#define PATGEN_SEQ8r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ8r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ8r_t PATGEN_SEQ8r_t;
#define PATGEN_SEQ8r_CLR BCMI_QTC_XGXS_PATGEN_SEQ8r_CLR
#define PATGEN_SEQ8r_SET BCMI_QTC_XGXS_PATGEN_SEQ8r_SET
#define PATGEN_SEQ8r_GET BCMI_QTC_XGXS_PATGEN_SEQ8r_GET
#define PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET BCMI_QTC_XGXS_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET
#define PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET BCMI_QTC_XGXS_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET
#define READ_PATGEN_SEQ8r BCMI_QTC_XGXS_READ_PATGEN_SEQ8r
#define WRITE_PATGEN_SEQ8r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ8r
#define MODIFY_PATGEN_SEQ8r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ8r
#define READLN_PATGEN_SEQ8r BCMI_QTC_XGXS_READLN_PATGEN_SEQ8r
#define WRITELN_PATGEN_SEQ8r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ8r
#define WRITEALL_PATGEN_SEQ8r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ8r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ9
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd109
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 9
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_9   Fixed Pattern Generator Sequence Word 9. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ9r (0x0001d109 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ9r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ9.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ9r_s {
	uint32_t v[1];
	uint32_t patgen_seq9[1];
	uint32_t _patgen_seq9;
} BCMI_QTC_XGXS_PATGEN_SEQ9r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ9r_CLR(r) (r).patgen_seq9[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ9r_SET(r,d) (r).patgen_seq9[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ9r_GET(r) (r).patgen_seq9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET(r) (((r).patgen_seq9[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET(r,f) (r).patgen_seq9[0]=(((r).patgen_seq9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ9.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ9r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ9r,(_r._patgen_seq9))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ9r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ9r,(_r._patgen_seq9)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ9r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ9r,(_r._patgen_seq9))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ9r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq9))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ9r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq9))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ9r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq9))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ9r BCMI_QTC_XGXS_PATGEN_SEQ9r
#define PATGEN_SEQ9r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ9r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ9r_t PATGEN_SEQ9r_t;
#define PATGEN_SEQ9r_CLR BCMI_QTC_XGXS_PATGEN_SEQ9r_CLR
#define PATGEN_SEQ9r_SET BCMI_QTC_XGXS_PATGEN_SEQ9r_SET
#define PATGEN_SEQ9r_GET BCMI_QTC_XGXS_PATGEN_SEQ9r_GET
#define PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET BCMI_QTC_XGXS_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET
#define PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET BCMI_QTC_XGXS_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET
#define READ_PATGEN_SEQ9r BCMI_QTC_XGXS_READ_PATGEN_SEQ9r
#define WRITE_PATGEN_SEQ9r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ9r
#define MODIFY_PATGEN_SEQ9r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ9r
#define READLN_PATGEN_SEQ9r BCMI_QTC_XGXS_READLN_PATGEN_SEQ9r
#define WRITELN_PATGEN_SEQ9r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ9r
#define WRITEALL_PATGEN_SEQ9r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ9r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ_10
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd10a
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 10
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_10  Fixed Pattern Generator Sequence Word 10. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_10r (0x0001d10a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ_10r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ_10.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ_10r_s {
	uint32_t v[1];
	uint32_t patgen_seq_10[1];
	uint32_t _patgen_seq_10;
} BCMI_QTC_XGXS_PATGEN_SEQ_10r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ_10r_CLR(r) (r).patgen_seq_10[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ_10r_SET(r,d) (r).patgen_seq_10[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ_10r_GET(r) (r).patgen_seq_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET(r) (((r).patgen_seq_10[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET(r,f) (r).patgen_seq_10[0]=(((r).patgen_seq_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ_10.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ_10r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_10r,(_r._patgen_seq_10))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_10r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_10r,(_r._patgen_seq_10)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_10r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_10r,(_r._patgen_seq_10))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ_10r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_10))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_10r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_10))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_10r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq_10))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ_10r BCMI_QTC_XGXS_PATGEN_SEQ_10r
#define PATGEN_SEQ_10r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ_10r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ_10r_t PATGEN_SEQ_10r_t;
#define PATGEN_SEQ_10r_CLR BCMI_QTC_XGXS_PATGEN_SEQ_10r_CLR
#define PATGEN_SEQ_10r_SET BCMI_QTC_XGXS_PATGEN_SEQ_10r_SET
#define PATGEN_SEQ_10r_GET BCMI_QTC_XGXS_PATGEN_SEQ_10r_GET
#define PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET BCMI_QTC_XGXS_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET
#define PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET BCMI_QTC_XGXS_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET
#define READ_PATGEN_SEQ_10r BCMI_QTC_XGXS_READ_PATGEN_SEQ_10r
#define WRITE_PATGEN_SEQ_10r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_10r
#define MODIFY_PATGEN_SEQ_10r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_10r
#define READLN_PATGEN_SEQ_10r BCMI_QTC_XGXS_READLN_PATGEN_SEQ_10r
#define WRITELN_PATGEN_SEQ_10r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_10r
#define WRITEALL_PATGEN_SEQ_10r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_10r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ_11
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd10b
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 11
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_11  Fixed Pattern Generator Sequence Word 11. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_11r (0x0001d10b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ_11r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ_11.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ_11r_s {
	uint32_t v[1];
	uint32_t patgen_seq_11[1];
	uint32_t _patgen_seq_11;
} BCMI_QTC_XGXS_PATGEN_SEQ_11r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ_11r_CLR(r) (r).patgen_seq_11[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ_11r_SET(r,d) (r).patgen_seq_11[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ_11r_GET(r) (r).patgen_seq_11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET(r) (((r).patgen_seq_11[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET(r,f) (r).patgen_seq_11[0]=(((r).patgen_seq_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ_11.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ_11r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_11r,(_r._patgen_seq_11))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_11r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_11r,(_r._patgen_seq_11)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_11r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_11r,(_r._patgen_seq_11))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ_11r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_11))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_11r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_11))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_11r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq_11))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ_11r BCMI_QTC_XGXS_PATGEN_SEQ_11r
#define PATGEN_SEQ_11r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ_11r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ_11r_t PATGEN_SEQ_11r_t;
#define PATGEN_SEQ_11r_CLR BCMI_QTC_XGXS_PATGEN_SEQ_11r_CLR
#define PATGEN_SEQ_11r_SET BCMI_QTC_XGXS_PATGEN_SEQ_11r_SET
#define PATGEN_SEQ_11r_GET BCMI_QTC_XGXS_PATGEN_SEQ_11r_GET
#define PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET BCMI_QTC_XGXS_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET
#define PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET BCMI_QTC_XGXS_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET
#define READ_PATGEN_SEQ_11r BCMI_QTC_XGXS_READ_PATGEN_SEQ_11r
#define WRITE_PATGEN_SEQ_11r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_11r
#define MODIFY_PATGEN_SEQ_11r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_11r
#define READLN_PATGEN_SEQ_11r BCMI_QTC_XGXS_READLN_PATGEN_SEQ_11r
#define WRITELN_PATGEN_SEQ_11r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_11r
#define WRITEALL_PATGEN_SEQ_11r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_11r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ_11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ_12
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd10c
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 12
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_12  Fixed Pattern Generator Sequence Word 12. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_12r (0x0001d10c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ_12r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ_12.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ_12r_s {
	uint32_t v[1];
	uint32_t patgen_seq_12[1];
	uint32_t _patgen_seq_12;
} BCMI_QTC_XGXS_PATGEN_SEQ_12r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ_12r_CLR(r) (r).patgen_seq_12[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ_12r_SET(r,d) (r).patgen_seq_12[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ_12r_GET(r) (r).patgen_seq_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET(r) (((r).patgen_seq_12[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET(r,f) (r).patgen_seq_12[0]=(((r).patgen_seq_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ_12.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ_12r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_12r,(_r._patgen_seq_12))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_12r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_12r,(_r._patgen_seq_12)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_12r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_12r,(_r._patgen_seq_12))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ_12r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_12))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_12r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_12))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_12r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq_12))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ_12r BCMI_QTC_XGXS_PATGEN_SEQ_12r
#define PATGEN_SEQ_12r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ_12r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ_12r_t PATGEN_SEQ_12r_t;
#define PATGEN_SEQ_12r_CLR BCMI_QTC_XGXS_PATGEN_SEQ_12r_CLR
#define PATGEN_SEQ_12r_SET BCMI_QTC_XGXS_PATGEN_SEQ_12r_SET
#define PATGEN_SEQ_12r_GET BCMI_QTC_XGXS_PATGEN_SEQ_12r_GET
#define PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET BCMI_QTC_XGXS_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET
#define PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET BCMI_QTC_XGXS_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET
#define READ_PATGEN_SEQ_12r BCMI_QTC_XGXS_READ_PATGEN_SEQ_12r
#define WRITE_PATGEN_SEQ_12r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_12r
#define MODIFY_PATGEN_SEQ_12r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_12r
#define READLN_PATGEN_SEQ_12r BCMI_QTC_XGXS_READLN_PATGEN_SEQ_12r
#define WRITELN_PATGEN_SEQ_12r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_12r
#define WRITEALL_PATGEN_SEQ_12r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_12r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ_12r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ_13
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd10d
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 13
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_13  Fixed Pattern Generator Sequence Word 13. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_13r (0x0001d10d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ_13r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ_13.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ_13r_s {
	uint32_t v[1];
	uint32_t patgen_seq_13[1];
	uint32_t _patgen_seq_13;
} BCMI_QTC_XGXS_PATGEN_SEQ_13r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ_13r_CLR(r) (r).patgen_seq_13[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ_13r_SET(r,d) (r).patgen_seq_13[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ_13r_GET(r) (r).patgen_seq_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET(r) (((r).patgen_seq_13[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET(r,f) (r).patgen_seq_13[0]=(((r).patgen_seq_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ_13.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ_13r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_13r,(_r._patgen_seq_13))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_13r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_13r,(_r._patgen_seq_13)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_13r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_13r,(_r._patgen_seq_13))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ_13r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_13))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_13r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_13))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_13r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq_13))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ_13r BCMI_QTC_XGXS_PATGEN_SEQ_13r
#define PATGEN_SEQ_13r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ_13r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ_13r_t PATGEN_SEQ_13r_t;
#define PATGEN_SEQ_13r_CLR BCMI_QTC_XGXS_PATGEN_SEQ_13r_CLR
#define PATGEN_SEQ_13r_SET BCMI_QTC_XGXS_PATGEN_SEQ_13r_SET
#define PATGEN_SEQ_13r_GET BCMI_QTC_XGXS_PATGEN_SEQ_13r_GET
#define PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET BCMI_QTC_XGXS_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET
#define PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET BCMI_QTC_XGXS_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET
#define READ_PATGEN_SEQ_13r BCMI_QTC_XGXS_READ_PATGEN_SEQ_13r
#define WRITE_PATGEN_SEQ_13r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_13r
#define MODIFY_PATGEN_SEQ_13r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_13r
#define READLN_PATGEN_SEQ_13r BCMI_QTC_XGXS_READLN_PATGEN_SEQ_13r
#define WRITELN_PATGEN_SEQ_13r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_13r
#define WRITEALL_PATGEN_SEQ_13r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_13r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ_13r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PATGEN_SEQ_14
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd10e
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 14
 * SIZE:     32
 * FIELDS:
 *     PATT_GEN_SEQ_14  Fixed Pattern Generator Sequence Word 14. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted first.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_14r (0x0001d10e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PATGEN_SEQ_14r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_SEQ_14.
 */
typedef union BCMI_QTC_XGXS_PATGEN_SEQ_14r_s {
	uint32_t v[1];
	uint32_t patgen_seq_14[1];
	uint32_t _patgen_seq_14;
} BCMI_QTC_XGXS_PATGEN_SEQ_14r_t;

#define BCMI_QTC_XGXS_PATGEN_SEQ_14r_CLR(r) (r).patgen_seq_14[0] = 0
#define BCMI_QTC_XGXS_PATGEN_SEQ_14r_SET(r,d) (r).patgen_seq_14[0] = d
#define BCMI_QTC_XGXS_PATGEN_SEQ_14r_GET(r) (r).patgen_seq_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET(r) (((r).patgen_seq_14[0]) & 0xffff)
#define BCMI_QTC_XGXS_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET(r,f) (r).patgen_seq_14[0]=(((r).patgen_seq_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access PATGEN_SEQ_14.
 */
#define BCMI_QTC_XGXS_READ_PATGEN_SEQ_14r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_14r,(_r._patgen_seq_14))
#define BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_14r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_14r,(_r._patgen_seq_14)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_14r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_14r,(_r._patgen_seq_14))
#define BCMI_QTC_XGXS_READLN_PATGEN_SEQ_14r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_14))
#define BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_14r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_seq_14))
#define BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_14r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_seq_14))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_SEQ_14r BCMI_QTC_XGXS_PATGEN_SEQ_14r
#define PATGEN_SEQ_14r_SIZE BCMI_QTC_XGXS_PATGEN_SEQ_14r_SIZE
typedef BCMI_QTC_XGXS_PATGEN_SEQ_14r_t PATGEN_SEQ_14r_t;
#define PATGEN_SEQ_14r_CLR BCMI_QTC_XGXS_PATGEN_SEQ_14r_CLR
#define PATGEN_SEQ_14r_SET BCMI_QTC_XGXS_PATGEN_SEQ_14r_SET
#define PATGEN_SEQ_14r_GET BCMI_QTC_XGXS_PATGEN_SEQ_14r_GET
#define PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET BCMI_QTC_XGXS_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET
#define PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET BCMI_QTC_XGXS_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET
#define READ_PATGEN_SEQ_14r BCMI_QTC_XGXS_READ_PATGEN_SEQ_14r
#define WRITE_PATGEN_SEQ_14r BCMI_QTC_XGXS_WRITE_PATGEN_SEQ_14r
#define MODIFY_PATGEN_SEQ_14r BCMI_QTC_XGXS_MODIFY_PATGEN_SEQ_14r
#define READLN_PATGEN_SEQ_14r BCMI_QTC_XGXS_READLN_PATGEN_SEQ_14r
#define WRITELN_PATGEN_SEQ_14r BCMI_QTC_XGXS_WRITELN_PATGEN_SEQ_14r
#define WRITEALL_PATGEN_SEQ_14r BCMI_QTC_XGXS_WRITEALL_PATGEN_SEQ_14r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PATGEN_SEQ_14r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_CTL1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd110
 * DEVAD:    1
 * DESC:     TX FIR Control1 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_PRE_OVERRIDE tx fir pre tap override value.when txfir_override_en field of the txfir_control2_registeris set 1'b1, then the txfir_pre_override field is used tooverride the cl72 pre tap value
 *     TXFIR_POST_OVERRIDE tx fir post tap override value.when txfir_override_en field of the txfir_control2_registeris set 1'b1, then the txfir_post_override field is used tooverride the cl72 post tap value
 */
#define BCMI_QTC_XGXS_TXFIR_CTL1r (0x0001d110 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL1.
 */
typedef union BCMI_QTC_XGXS_TXFIR_CTL1r_s {
	uint32_t v[1];
	uint32_t txfir_ctl1[1];
	uint32_t _txfir_ctl1;
} BCMI_QTC_XGXS_TXFIR_CTL1r_t;

#define BCMI_QTC_XGXS_TXFIR_CTL1r_CLR(r) (r).txfir_ctl1[0] = 0
#define BCMI_QTC_XGXS_TXFIR_CTL1r_SET(r,d) (r).txfir_ctl1[0] = d
#define BCMI_QTC_XGXS_TXFIR_CTL1r_GET(r) (r).txfir_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_POST_OVERRIDEf_GET(r) ((((r).txfir_ctl1[0]) >> 5) & 0x3f)
#define BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_POST_OVERRIDEf_SET(r,f) (r).txfir_ctl1[0]=(((r).txfir_ctl1[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_PRE_OVERRIDEf_GET(r) (((r).txfir_ctl1[0]) & 0x1f)
#define BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_PRE_OVERRIDEf_SET(r,f) (r).txfir_ctl1[0]=(((r).txfir_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access TXFIR_CTL1.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL1r,(_r._txfir_ctl1))
#define BCMI_QTC_XGXS_WRITE_TXFIR_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL1r,(_r._txfir_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL1r,(_r._txfir_ctl1))
#define BCMI_QTC_XGXS_READLN_TXFIR_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl1))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL1r BCMI_QTC_XGXS_TXFIR_CTL1r
#define TXFIR_CTL1r_SIZE BCMI_QTC_XGXS_TXFIR_CTL1r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_CTL1r_t TXFIR_CTL1r_t;
#define TXFIR_CTL1r_CLR BCMI_QTC_XGXS_TXFIR_CTL1r_CLR
#define TXFIR_CTL1r_SET BCMI_QTC_XGXS_TXFIR_CTL1r_SET
#define TXFIR_CTL1r_GET BCMI_QTC_XGXS_TXFIR_CTL1r_GET
#define TXFIR_CTL1r_TXFIR_POST_OVERRIDEf_GET BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_POST_OVERRIDEf_GET
#define TXFIR_CTL1r_TXFIR_POST_OVERRIDEf_SET BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_POST_OVERRIDEf_SET
#define TXFIR_CTL1r_TXFIR_PRE_OVERRIDEf_GET BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_PRE_OVERRIDEf_GET
#define TXFIR_CTL1r_TXFIR_PRE_OVERRIDEf_SET BCMI_QTC_XGXS_TXFIR_CTL1r_TXFIR_PRE_OVERRIDEf_SET
#define READ_TXFIR_CTL1r BCMI_QTC_XGXS_READ_TXFIR_CTL1r
#define WRITE_TXFIR_CTL1r BCMI_QTC_XGXS_WRITE_TXFIR_CTL1r
#define MODIFY_TXFIR_CTL1r BCMI_QTC_XGXS_MODIFY_TXFIR_CTL1r
#define READLN_TXFIR_CTL1r BCMI_QTC_XGXS_READLN_TXFIR_CTL1r
#define WRITELN_TXFIR_CTL1r BCMI_QTC_XGXS_WRITELN_TXFIR_CTL1r
#define WRITEALL_TXFIR_CTL1r BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_CTL2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd111
 * DEVAD:    1
 * DESC:     TX FIR Control2 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_MAIN_OVERRIDE tx fir main tap override value.when txfir_override_en field of the txfir_control2_registeris set 1'b1, then the txfir_main_override field is used tooverride the cl72 main tap value
 *     TXFIR_POST2      tx fir post2 tap value.Post2 tap value only driven from a registerThe value range is -16 ..+15 and it is in 2's complement format
 *     TXFIR_OVERRIDE_EN txfir override enablewhen txfir_override_en field to 1'b1, then txfir_main_override,txfir_post_override and  txfir_pre_override filed are used tooverride the cl72 main/post/pre tap value
 */
#define BCMI_QTC_XGXS_TXFIR_CTL2r (0x0001d111 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL2.
 */
typedef union BCMI_QTC_XGXS_TXFIR_CTL2r_s {
	uint32_t v[1];
	uint32_t txfir_ctl2[1];
	uint32_t _txfir_ctl2;
} BCMI_QTC_XGXS_TXFIR_CTL2r_t;

#define BCMI_QTC_XGXS_TXFIR_CTL2r_CLR(r) (r).txfir_ctl2[0] = 0
#define BCMI_QTC_XGXS_TXFIR_CTL2r_SET(r,d) (r).txfir_ctl2[0] = d
#define BCMI_QTC_XGXS_TXFIR_CTL2r_GET(r) (r).txfir_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_OVERRIDE_ENf_GET(r) ((((r).txfir_ctl2[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_OVERRIDE_ENf_SET(r,f) (r).txfir_ctl2[0]=(((r).txfir_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_POST2f_GET(r) ((((r).txfir_ctl2[0]) >> 7) & 0x1f)
#define BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_POST2f_SET(r,f) (r).txfir_ctl2[0]=(((r).txfir_ctl2[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_MAIN_OVERRIDEf_GET(r) (((r).txfir_ctl2[0]) & 0x7f)
#define BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_MAIN_OVERRIDEf_SET(r,f) (r).txfir_ctl2[0]=(((r).txfir_ctl2[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access TXFIR_CTL2.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL2r,(_r._txfir_ctl2))
#define BCMI_QTC_XGXS_WRITE_TXFIR_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL2r,(_r._txfir_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL2r,(_r._txfir_ctl2))
#define BCMI_QTC_XGXS_READLN_TXFIR_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl2))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL2r BCMI_QTC_XGXS_TXFIR_CTL2r
#define TXFIR_CTL2r_SIZE BCMI_QTC_XGXS_TXFIR_CTL2r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_CTL2r_t TXFIR_CTL2r_t;
#define TXFIR_CTL2r_CLR BCMI_QTC_XGXS_TXFIR_CTL2r_CLR
#define TXFIR_CTL2r_SET BCMI_QTC_XGXS_TXFIR_CTL2r_SET
#define TXFIR_CTL2r_GET BCMI_QTC_XGXS_TXFIR_CTL2r_GET
#define TXFIR_CTL2r_TXFIR_OVERRIDE_ENf_GET BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_OVERRIDE_ENf_GET
#define TXFIR_CTL2r_TXFIR_OVERRIDE_ENf_SET BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_OVERRIDE_ENf_SET
#define TXFIR_CTL2r_TXFIR_POST2f_GET BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_POST2f_GET
#define TXFIR_CTL2r_TXFIR_POST2f_SET BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_POST2f_SET
#define TXFIR_CTL2r_TXFIR_MAIN_OVERRIDEf_GET BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_MAIN_OVERRIDEf_GET
#define TXFIR_CTL2r_TXFIR_MAIN_OVERRIDEf_SET BCMI_QTC_XGXS_TXFIR_CTL2r_TXFIR_MAIN_OVERRIDEf_SET
#define READ_TXFIR_CTL2r BCMI_QTC_XGXS_READ_TXFIR_CTL2r
#define WRITE_TXFIR_CTL2r BCMI_QTC_XGXS_WRITE_TXFIR_CTL2r
#define MODIFY_TXFIR_CTL2r BCMI_QTC_XGXS_MODIFY_TXFIR_CTL2r
#define READLN_TXFIR_CTL2r BCMI_QTC_XGXS_READLN_TXFIR_CTL2r
#define WRITELN_TXFIR_CTL2r BCMI_QTC_XGXS_WRITELN_TXFIR_CTL2r
#define WRITEALL_TXFIR_CTL2r BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_CTL3
 * BLOCKS:   TX_FED
 * REGADDR:  0xd112
 * DEVAD:    1
 * DESC:     TX FIR Control3 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_PRE_OFFSET tx fir pre tap offset value -8 to +7This field is used to adjust the Pre tap valuesThe mapping is not 2's complement, it isregister value  = tap adjusted by0  = -81  = -72  = -63  = -54  = -45  = -36  = -27  = -18  =  09  = +110 = +211 = +312 = +413 = +514 = +615 = +7
 *     TXFIR_MAIN_OFFSET tx fir main tap offset value -8 to +7This field is used to adjust the Main tap valuesThe mapping is not 2's complement, please txfir_pre_offset field description
 *     TXFIR_POST_OFFSET tx fir post tap offset value -8 to +7This field is used to adjust the Post tap valuesThe mapping is not 2's complement, please txfir_pre_offset field description
 *     TXFIR_POST2_OFFSET tx fir post2 tap offset value -8 to +7This field is used to adjust the Post2 tap valuesThe mapping is not 2's complement, please txfir_pre_offset field description
 */
#define BCMI_QTC_XGXS_TXFIR_CTL3r (0x0001d112 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL3.
 */
typedef union BCMI_QTC_XGXS_TXFIR_CTL3r_s {
	uint32_t v[1];
	uint32_t txfir_ctl3[1];
	uint32_t _txfir_ctl3;
} BCMI_QTC_XGXS_TXFIR_CTL3r_t;

#define BCMI_QTC_XGXS_TXFIR_CTL3r_CLR(r) (r).txfir_ctl3[0] = 0
#define BCMI_QTC_XGXS_TXFIR_CTL3r_SET(r,d) (r).txfir_ctl3[0] = d
#define BCMI_QTC_XGXS_TXFIR_CTL3r_GET(r) (r).txfir_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST2_OFFSETf_GET(r) ((((r).txfir_ctl3[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST2_OFFSETf_SET(r,f) (r).txfir_ctl3[0]=(((r).txfir_ctl3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST_OFFSETf_GET(r) ((((r).txfir_ctl3[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST_OFFSETf_SET(r,f) (r).txfir_ctl3[0]=(((r).txfir_ctl3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_MAIN_OFFSETf_GET(r) ((((r).txfir_ctl3[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_MAIN_OFFSETf_SET(r,f) (r).txfir_ctl3[0]=(((r).txfir_ctl3[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_PRE_OFFSETf_GET(r) (((r).txfir_ctl3[0]) & 0xf)
#define BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_PRE_OFFSETf_SET(r,f) (r).txfir_ctl3[0]=(((r).txfir_ctl3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access TXFIR_CTL3.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_CTL3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL3r,(_r._txfir_ctl3))
#define BCMI_QTC_XGXS_WRITE_TXFIR_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL3r,(_r._txfir_ctl3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL3r,(_r._txfir_ctl3))
#define BCMI_QTC_XGXS_READLN_TXFIR_CTL3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl3))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_CTL3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl3))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_ctl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL3r BCMI_QTC_XGXS_TXFIR_CTL3r
#define TXFIR_CTL3r_SIZE BCMI_QTC_XGXS_TXFIR_CTL3r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_CTL3r_t TXFIR_CTL3r_t;
#define TXFIR_CTL3r_CLR BCMI_QTC_XGXS_TXFIR_CTL3r_CLR
#define TXFIR_CTL3r_SET BCMI_QTC_XGXS_TXFIR_CTL3r_SET
#define TXFIR_CTL3r_GET BCMI_QTC_XGXS_TXFIR_CTL3r_GET
#define TXFIR_CTL3r_TXFIR_POST2_OFFSETf_GET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST2_OFFSETf_GET
#define TXFIR_CTL3r_TXFIR_POST2_OFFSETf_SET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST2_OFFSETf_SET
#define TXFIR_CTL3r_TXFIR_POST_OFFSETf_GET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST_OFFSETf_GET
#define TXFIR_CTL3r_TXFIR_POST_OFFSETf_SET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_POST_OFFSETf_SET
#define TXFIR_CTL3r_TXFIR_MAIN_OFFSETf_GET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_MAIN_OFFSETf_GET
#define TXFIR_CTL3r_TXFIR_MAIN_OFFSETf_SET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_MAIN_OFFSETf_SET
#define TXFIR_CTL3r_TXFIR_PRE_OFFSETf_GET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_PRE_OFFSETf_GET
#define TXFIR_CTL3r_TXFIR_PRE_OFFSETf_SET BCMI_QTC_XGXS_TXFIR_CTL3r_TXFIR_PRE_OFFSETf_SET
#define READ_TXFIR_CTL3r BCMI_QTC_XGXS_READ_TXFIR_CTL3r
#define WRITE_TXFIR_CTL3r BCMI_QTC_XGXS_WRITE_TXFIR_CTL3r
#define MODIFY_TXFIR_CTL3r BCMI_QTC_XGXS_MODIFY_TXFIR_CTL3r
#define READLN_TXFIR_CTL3r BCMI_QTC_XGXS_READLN_TXFIR_CTL3r
#define WRITELN_TXFIR_CTL3r BCMI_QTC_XGXS_WRITELN_TXFIR_CTL3r
#define WRITEALL_TXFIR_CTL3r BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_STS1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd113
 * DEVAD:    1
 * DESC:     TX FIR Status1 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_PRE_AFTER_OVR tx fir pre tap value after override mux. status
 *     TXFIR_POST_AFTER_OVR tx fir post tap value after override mux. status
 */
#define BCMI_QTC_XGXS_TXFIR_STS1r (0x0001d113 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS1.
 */
typedef union BCMI_QTC_XGXS_TXFIR_STS1r_s {
	uint32_t v[1];
	uint32_t txfir_sts1[1];
	uint32_t _txfir_sts1;
} BCMI_QTC_XGXS_TXFIR_STS1r_t;

#define BCMI_QTC_XGXS_TXFIR_STS1r_CLR(r) (r).txfir_sts1[0] = 0
#define BCMI_QTC_XGXS_TXFIR_STS1r_SET(r,d) (r).txfir_sts1[0] = d
#define BCMI_QTC_XGXS_TXFIR_STS1r_GET(r) (r).txfir_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_POST_AFTER_OVRf_GET(r) ((((r).txfir_sts1[0]) >> 5) & 0x3f)
#define BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_POST_AFTER_OVRf_SET(r,f) (r).txfir_sts1[0]=(((r).txfir_sts1[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_PRE_AFTER_OVRf_GET(r) (((r).txfir_sts1[0]) & 0x1f)
#define BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_PRE_AFTER_OVRf_SET(r,f) (r).txfir_sts1[0]=(((r).txfir_sts1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access TXFIR_STS1.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_STS1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS1r,(_r._txfir_sts1))
#define BCMI_QTC_XGXS_WRITE_TXFIR_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS1r,(_r._txfir_sts1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS1r,(_r._txfir_sts1))
#define BCMI_QTC_XGXS_READLN_TXFIR_STS1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts1))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_STS1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts1))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS1r BCMI_QTC_XGXS_TXFIR_STS1r
#define TXFIR_STS1r_SIZE BCMI_QTC_XGXS_TXFIR_STS1r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_STS1r_t TXFIR_STS1r_t;
#define TXFIR_STS1r_CLR BCMI_QTC_XGXS_TXFIR_STS1r_CLR
#define TXFIR_STS1r_SET BCMI_QTC_XGXS_TXFIR_STS1r_SET
#define TXFIR_STS1r_GET BCMI_QTC_XGXS_TXFIR_STS1r_GET
#define TXFIR_STS1r_TXFIR_POST_AFTER_OVRf_GET BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_POST_AFTER_OVRf_GET
#define TXFIR_STS1r_TXFIR_POST_AFTER_OVRf_SET BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_POST_AFTER_OVRf_SET
#define TXFIR_STS1r_TXFIR_PRE_AFTER_OVRf_GET BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_PRE_AFTER_OVRf_GET
#define TXFIR_STS1r_TXFIR_PRE_AFTER_OVRf_SET BCMI_QTC_XGXS_TXFIR_STS1r_TXFIR_PRE_AFTER_OVRf_SET
#define READ_TXFIR_STS1r BCMI_QTC_XGXS_READ_TXFIR_STS1r
#define WRITE_TXFIR_STS1r BCMI_QTC_XGXS_WRITE_TXFIR_STS1r
#define MODIFY_TXFIR_STS1r BCMI_QTC_XGXS_MODIFY_TXFIR_STS1r
#define READLN_TXFIR_STS1r BCMI_QTC_XGXS_READLN_TXFIR_STS1r
#define WRITELN_TXFIR_STS1r BCMI_QTC_XGXS_WRITELN_TXFIR_STS1r
#define WRITEALL_TXFIR_STS1r BCMI_QTC_XGXS_WRITEALL_TXFIR_STS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_STS2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd114
 * DEVAD:    1
 * DESC:     TX FIR Status2 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_MAIN_AFTER_OVR tx fir main tap value after override mux. status
 */
#define BCMI_QTC_XGXS_TXFIR_STS2r (0x0001d114 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS2.
 */
typedef union BCMI_QTC_XGXS_TXFIR_STS2r_s {
	uint32_t v[1];
	uint32_t txfir_sts2[1];
	uint32_t _txfir_sts2;
} BCMI_QTC_XGXS_TXFIR_STS2r_t;

#define BCMI_QTC_XGXS_TXFIR_STS2r_CLR(r) (r).txfir_sts2[0] = 0
#define BCMI_QTC_XGXS_TXFIR_STS2r_SET(r,d) (r).txfir_sts2[0] = d
#define BCMI_QTC_XGXS_TXFIR_STS2r_GET(r) (r).txfir_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_STS2r_TXFIR_MAIN_AFTER_OVRf_GET(r) (((r).txfir_sts2[0]) & 0x7f)
#define BCMI_QTC_XGXS_TXFIR_STS2r_TXFIR_MAIN_AFTER_OVRf_SET(r,f) (r).txfir_sts2[0]=(((r).txfir_sts2[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access TXFIR_STS2.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_STS2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS2r,(_r._txfir_sts2))
#define BCMI_QTC_XGXS_WRITE_TXFIR_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS2r,(_r._txfir_sts2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS2r,(_r._txfir_sts2))
#define BCMI_QTC_XGXS_READLN_TXFIR_STS2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts2))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_STS2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts2))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_STS2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS2r BCMI_QTC_XGXS_TXFIR_STS2r
#define TXFIR_STS2r_SIZE BCMI_QTC_XGXS_TXFIR_STS2r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_STS2r_t TXFIR_STS2r_t;
#define TXFIR_STS2r_CLR BCMI_QTC_XGXS_TXFIR_STS2r_CLR
#define TXFIR_STS2r_SET BCMI_QTC_XGXS_TXFIR_STS2r_SET
#define TXFIR_STS2r_GET BCMI_QTC_XGXS_TXFIR_STS2r_GET
#define TXFIR_STS2r_TXFIR_MAIN_AFTER_OVRf_GET BCMI_QTC_XGXS_TXFIR_STS2r_TXFIR_MAIN_AFTER_OVRf_GET
#define TXFIR_STS2r_TXFIR_MAIN_AFTER_OVRf_SET BCMI_QTC_XGXS_TXFIR_STS2r_TXFIR_MAIN_AFTER_OVRf_SET
#define READ_TXFIR_STS2r BCMI_QTC_XGXS_READ_TXFIR_STS2r
#define WRITE_TXFIR_STS2r BCMI_QTC_XGXS_WRITE_TXFIR_STS2r
#define MODIFY_TXFIR_STS2r BCMI_QTC_XGXS_MODIFY_TXFIR_STS2r
#define READLN_TXFIR_STS2r BCMI_QTC_XGXS_READLN_TXFIR_STS2r
#define WRITELN_TXFIR_STS2r BCMI_QTC_XGXS_WRITELN_TXFIR_STS2r
#define WRITEALL_TXFIR_STS2r BCMI_QTC_XGXS_WRITEALL_TXFIR_STS2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_STS3
 * BLOCKS:   TX_FED
 * REGADDR:  0xd115
 * DEVAD:    1
 * DESC:     TX FIR Status3 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_PRE_ADJUSTED tx fir pre tap value after offset adjustment. status
 *     TXFIR_POST_ADJUSTED tx fir post tap value after offset adjustment. status
 */
#define BCMI_QTC_XGXS_TXFIR_STS3r (0x0001d115 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS3.
 */
typedef union BCMI_QTC_XGXS_TXFIR_STS3r_s {
	uint32_t v[1];
	uint32_t txfir_sts3[1];
	uint32_t _txfir_sts3;
} BCMI_QTC_XGXS_TXFIR_STS3r_t;

#define BCMI_QTC_XGXS_TXFIR_STS3r_CLR(r) (r).txfir_sts3[0] = 0
#define BCMI_QTC_XGXS_TXFIR_STS3r_SET(r,d) (r).txfir_sts3[0] = d
#define BCMI_QTC_XGXS_TXFIR_STS3r_GET(r) (r).txfir_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_POST_ADJUSTEDf_GET(r) ((((r).txfir_sts3[0]) >> 5) & 0x3f)
#define BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_POST_ADJUSTEDf_SET(r,f) (r).txfir_sts3[0]=(((r).txfir_sts3[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_PRE_ADJUSTEDf_GET(r) (((r).txfir_sts3[0]) & 0x1f)
#define BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_PRE_ADJUSTEDf_SET(r,f) (r).txfir_sts3[0]=(((r).txfir_sts3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access TXFIR_STS3.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_STS3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS3r,(_r._txfir_sts3))
#define BCMI_QTC_XGXS_WRITE_TXFIR_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS3r,(_r._txfir_sts3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS3r,(_r._txfir_sts3))
#define BCMI_QTC_XGXS_READLN_TXFIR_STS3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts3))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_STS3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts3))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_STS3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS3r BCMI_QTC_XGXS_TXFIR_STS3r
#define TXFIR_STS3r_SIZE BCMI_QTC_XGXS_TXFIR_STS3r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_STS3r_t TXFIR_STS3r_t;
#define TXFIR_STS3r_CLR BCMI_QTC_XGXS_TXFIR_STS3r_CLR
#define TXFIR_STS3r_SET BCMI_QTC_XGXS_TXFIR_STS3r_SET
#define TXFIR_STS3r_GET BCMI_QTC_XGXS_TXFIR_STS3r_GET
#define TXFIR_STS3r_TXFIR_POST_ADJUSTEDf_GET BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_POST_ADJUSTEDf_GET
#define TXFIR_STS3r_TXFIR_POST_ADJUSTEDf_SET BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_POST_ADJUSTEDf_SET
#define TXFIR_STS3r_TXFIR_PRE_ADJUSTEDf_GET BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_PRE_ADJUSTEDf_GET
#define TXFIR_STS3r_TXFIR_PRE_ADJUSTEDf_SET BCMI_QTC_XGXS_TXFIR_STS3r_TXFIR_PRE_ADJUSTEDf_SET
#define READ_TXFIR_STS3r BCMI_QTC_XGXS_READ_TXFIR_STS3r
#define WRITE_TXFIR_STS3r BCMI_QTC_XGXS_WRITE_TXFIR_STS3r
#define MODIFY_TXFIR_STS3r BCMI_QTC_XGXS_MODIFY_TXFIR_STS3r
#define READLN_TXFIR_STS3r BCMI_QTC_XGXS_READLN_TXFIR_STS3r
#define WRITELN_TXFIR_STS3r BCMI_QTC_XGXS_WRITELN_TXFIR_STS3r
#define WRITEALL_TXFIR_STS3r BCMI_QTC_XGXS_WRITEALL_TXFIR_STS3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_STS4
 * BLOCKS:   TX_FED
 * REGADDR:  0xd116
 * DEVAD:    1
 * DESC:     TX FIR Status4 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_MAIN_ADJUSTED tx fir main tap value after offset adjustment. status
 *     TXFIR_POST2_ADJUSTED tx fir post2 tap value after offset adjustment. statusThe value range is -16 ..+15 and it is in 2's complement format
 *     TXFIR_POST3_ADJUSTED tx fir post3 tap value after offset adjustment. statusThe value range is -8 ..+7 and it is in 2's complement format
 */
#define BCMI_QTC_XGXS_TXFIR_STS4r (0x0001d116 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS4.
 */
typedef union BCMI_QTC_XGXS_TXFIR_STS4r_s {
	uint32_t v[1];
	uint32_t txfir_sts4[1];
	uint32_t _txfir_sts4;
} BCMI_QTC_XGXS_TXFIR_STS4r_t;

#define BCMI_QTC_XGXS_TXFIR_STS4r_CLR(r) (r).txfir_sts4[0] = 0
#define BCMI_QTC_XGXS_TXFIR_STS4r_SET(r,d) (r).txfir_sts4[0] = d
#define BCMI_QTC_XGXS_TXFIR_STS4r_GET(r) (r).txfir_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET(r) ((((r).txfir_sts4[0]) >> 12) & 0xf)
#define BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET(r,f) (r).txfir_sts4[0]=(((r).txfir_sts4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST2_ADJUSTEDf_GET(r) ((((r).txfir_sts4[0]) >> 7) & 0x1f)
#define BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST2_ADJUSTEDf_SET(r,f) (r).txfir_sts4[0]=(((r).txfir_sts4[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_MAIN_ADJUSTEDf_GET(r) (((r).txfir_sts4[0]) & 0x7f)
#define BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_MAIN_ADJUSTEDf_SET(r,f) (r).txfir_sts4[0]=(((r).txfir_sts4[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access TXFIR_STS4.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_STS4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS4r,(_r._txfir_sts4))
#define BCMI_QTC_XGXS_WRITE_TXFIR_STS4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS4r,(_r._txfir_sts4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_STS4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS4r,(_r._txfir_sts4))
#define BCMI_QTC_XGXS_READLN_TXFIR_STS4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts4))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_STS4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts4))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_STS4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS4r BCMI_QTC_XGXS_TXFIR_STS4r
#define TXFIR_STS4r_SIZE BCMI_QTC_XGXS_TXFIR_STS4r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_STS4r_t TXFIR_STS4r_t;
#define TXFIR_STS4r_CLR BCMI_QTC_XGXS_TXFIR_STS4r_CLR
#define TXFIR_STS4r_SET BCMI_QTC_XGXS_TXFIR_STS4r_SET
#define TXFIR_STS4r_GET BCMI_QTC_XGXS_TXFIR_STS4r_GET
#define TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET
#define TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET
#define TXFIR_STS4r_TXFIR_POST2_ADJUSTEDf_GET BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST2_ADJUSTEDf_GET
#define TXFIR_STS4r_TXFIR_POST2_ADJUSTEDf_SET BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_POST2_ADJUSTEDf_SET
#define TXFIR_STS4r_TXFIR_MAIN_ADJUSTEDf_GET BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_MAIN_ADJUSTEDf_GET
#define TXFIR_STS4r_TXFIR_MAIN_ADJUSTEDf_SET BCMI_QTC_XGXS_TXFIR_STS4r_TXFIR_MAIN_ADJUSTEDf_SET
#define READ_TXFIR_STS4r BCMI_QTC_XGXS_READ_TXFIR_STS4r
#define WRITE_TXFIR_STS4r BCMI_QTC_XGXS_WRITE_TXFIR_STS4r
#define MODIFY_TXFIR_STS4r BCMI_QTC_XGXS_MODIFY_TXFIR_STS4r
#define READLN_TXFIR_STS4r BCMI_QTC_XGXS_READLN_TXFIR_STS4r
#define WRITELN_TXFIR_STS4r BCMI_QTC_XGXS_WRITELN_TXFIR_STS4r
#define WRITEALL_TXFIR_STS4r BCMI_QTC_XGXS_WRITEALL_TXFIR_STS4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_UC_CTL
 * BLOCKS:   TX_FED
 * REGADDR:  0xd117
 * DEVAD:    1
 * DESC:     Micro Control Register
 * SIZE:     32
 * FIELDS:
 *     MICRO_TX_DISABLE micro tx disableThis field is used by the Microcontroller for tx disable control during CL72 forced modePlease see Eagle & Merlin PMD Internal Functional Specification for details
 */
#define BCMI_QTC_XGXS_TXFIR_UC_CTLr (0x0001d117 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_UC_CTL.
 */
typedef union BCMI_QTC_XGXS_TXFIR_UC_CTLr_s {
	uint32_t v[1];
	uint32_t txfir_uc_ctl[1];
	uint32_t _txfir_uc_ctl;
} BCMI_QTC_XGXS_TXFIR_UC_CTLr_t;

#define BCMI_QTC_XGXS_TXFIR_UC_CTLr_CLR(r) (r).txfir_uc_ctl[0] = 0
#define BCMI_QTC_XGXS_TXFIR_UC_CTLr_SET(r,d) (r).txfir_uc_ctl[0] = d
#define BCMI_QTC_XGXS_TXFIR_UC_CTLr_GET(r) (r).txfir_uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_UC_CTLr_MICRO_TX_DISABLEf_GET(r) (((r).txfir_uc_ctl[0]) & 0x1)
#define BCMI_QTC_XGXS_TXFIR_UC_CTLr_MICRO_TX_DISABLEf_SET(r,f) (r).txfir_uc_ctl[0]=(((r).txfir_uc_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TXFIR_UC_CTL.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_UC_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_UC_CTLr,(_r._txfir_uc_ctl))
#define BCMI_QTC_XGXS_WRITE_TXFIR_UC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_UC_CTLr,(_r._txfir_uc_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_UC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_UC_CTLr,(_r._txfir_uc_ctl))
#define BCMI_QTC_XGXS_READLN_TXFIR_UC_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_UC_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_UC_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_uc_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_UC_CTLr BCMI_QTC_XGXS_TXFIR_UC_CTLr
#define TXFIR_UC_CTLr_SIZE BCMI_QTC_XGXS_TXFIR_UC_CTLr_SIZE
typedef BCMI_QTC_XGXS_TXFIR_UC_CTLr_t TXFIR_UC_CTLr_t;
#define TXFIR_UC_CTLr_CLR BCMI_QTC_XGXS_TXFIR_UC_CTLr_CLR
#define TXFIR_UC_CTLr_SET BCMI_QTC_XGXS_TXFIR_UC_CTLr_SET
#define TXFIR_UC_CTLr_GET BCMI_QTC_XGXS_TXFIR_UC_CTLr_GET
#define TXFIR_UC_CTLr_MICRO_TX_DISABLEf_GET BCMI_QTC_XGXS_TXFIR_UC_CTLr_MICRO_TX_DISABLEf_GET
#define TXFIR_UC_CTLr_MICRO_TX_DISABLEf_SET BCMI_QTC_XGXS_TXFIR_UC_CTLr_MICRO_TX_DISABLEf_SET
#define READ_TXFIR_UC_CTLr BCMI_QTC_XGXS_READ_TXFIR_UC_CTLr
#define WRITE_TXFIR_UC_CTLr BCMI_QTC_XGXS_WRITE_TXFIR_UC_CTLr
#define MODIFY_TXFIR_UC_CTLr BCMI_QTC_XGXS_MODIFY_TXFIR_UC_CTLr
#define READLN_TXFIR_UC_CTLr BCMI_QTC_XGXS_READLN_TXFIR_UC_CTLr
#define WRITELN_TXFIR_UC_CTLr BCMI_QTC_XGXS_WRITELN_TXFIR_UC_CTLr
#define WRITEALL_TXFIR_UC_CTLr BCMI_QTC_XGXS_WRITEALL_TXFIR_UC_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_UC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_MISC_CTL1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd118
 * DEVAD:    1
 * DESC:     Misc Control 1 Register
 * SIZE:     32
 * FIELDS:
 *     SDK_TX_DISABLE   sdk tx disableThis tx disable control field is for SDK use during TX programmingPlease see Eagle & Merlin PMD Internal Functional Specification for details
 *     PMD_TX_DISABLE_PIN_DIS Tx disable using the pmd_tx_disable pin disable control0 - enable tx disable from pmd_tx_disable pin1 - disable tx disable from pmd_tx_disable pin
 *     TX_DISABLE_TIMER_CTRL tx_disable timer value controlstx_disable_timer_ctrl[5] (MSB) selects the timer units0 - 2us units1 - 1ms unitstx_disable_timer_ctrl[4:0] (LSB[4:0]) = controls the number of units perthe list below0                 0 units1                 1 units2                 2 units3                 3 units4                 4 units5                 5 units6                 6 units7                 7 units8                 8 units9                10 units10               12 units11               14 units12               16 units13               20 units14               24 units15               28 units16               32 units17               40 units18               48 units19               56 units20               64 units21               80 units22               96 units23              112 units24              128 units25              160 units26              192 units27              224 units28              256 units29              320 units30              384 units31              448 units
 *     TX_EEE_QUIET_EN  Tx eee quiet mode control1 - Enable eee quiet mode when pmd_tx_mode (input pins) == 2'b010 - Disable eee quiet mode
 *     TX_EEE_ALERT_EN  Tx eee alert mode control1 - Enable eee alert mode when pmd_tx_mode (input pins) == 2'b100 - Disable eee alert mode
 *     TX_DISABLE_OUTPUT_SEL These bits select tx disable output function2'b00 - send electrical idles2'b01 - send power down2'b10 - send ones2'b11 - send zeroes
 *     DP_RESET_TX_DISABLE_DIS Tx disable based on data path reset0 - Enable tx disable based on data path reset1 - Disable tx disable based on data path reset
 */
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r (0x0001d118 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_CTL1.
 */
typedef union BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_s {
	uint32_t v[1];
	uint32_t txfir_misc_ctl1[1];
	uint32_t _txfir_misc_ctl1;
} BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_t;

#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_CLR(r) (r).txfir_misc_ctl1[0] = 0
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SET(r,d) (r).txfir_misc_ctl1[0] = d
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_GET(r) (r).txfir_misc_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 10) & 0x3)
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 2) & 0x3f)
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_GET(r) (((r).txfir_misc_ctl1[0]) & 0x1)
#define BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_CTL1.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_MISC_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_MISC_CTL1r,(_r._txfir_misc_ctl1))
#define BCMI_QTC_XGXS_WRITE_TXFIR_MISC_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_MISC_CTL1r,(_r._txfir_misc_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_MISC_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_MISC_CTL1r,(_r._txfir_misc_ctl1))
#define BCMI_QTC_XGXS_READLN_TXFIR_MISC_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_MISC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl1))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_MISC_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_MISC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_MISC_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_MISC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_misc_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_CTL1r BCMI_QTC_XGXS_TXFIR_MISC_CTL1r
#define TXFIR_MISC_CTL1r_SIZE BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_t TXFIR_MISC_CTL1r_t;
#define TXFIR_MISC_CTL1r_CLR BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_CLR
#define TXFIR_MISC_CTL1r_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SET
#define TXFIR_MISC_CTL1r_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_GET
#define TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_GET
#define TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_SET
#define TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_GET
#define TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_SET
#define TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_GET
#define TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_SET
#define TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_GET
#define TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_SET
#define TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_GET
#define TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_SET
#define TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_GET
#define TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_SET
#define TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_GET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_GET
#define TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_SET BCMI_QTC_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_SET
#define READ_TXFIR_MISC_CTL1r BCMI_QTC_XGXS_READ_TXFIR_MISC_CTL1r
#define WRITE_TXFIR_MISC_CTL1r BCMI_QTC_XGXS_WRITE_TXFIR_MISC_CTL1r
#define MODIFY_TXFIR_MISC_CTL1r BCMI_QTC_XGXS_MODIFY_TXFIR_MISC_CTL1r
#define READLN_TXFIR_MISC_CTL1r BCMI_QTC_XGXS_READLN_TXFIR_MISC_CTL1r
#define WRITELN_TXFIR_MISC_CTL1r BCMI_QTC_XGXS_WRITELN_TXFIR_MISC_CTL1r
#define WRITEALL_TXFIR_MISC_CTL1r BCMI_QTC_XGXS_WRITEALL_TXFIR_MISC_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_MISC_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  TXFIR_CTL4
 * BLOCKS:   TX_FED
 * REGADDR:  0xd119
 * DEVAD:    1
 * DESC:     TX FIR Control4 Register
 * SIZE:     32
 * FIELDS:
 *     TXFIR_POST3      tx fir post3 tap value.Post3 tap value only driven from a registerThe value range is -8 ..+7 and it is in 2's complement format
 *     TXFIR_POST3_OFFSET tx fir post3 tap offset value -8 to +7This field is used to adjust the Post3 tap valuesThe mapping is not 2's complement, please txfir_pre_offset field description
 */
#define BCMI_QTC_XGXS_TXFIR_CTL4r (0x0001d119 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_TXFIR_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL4.
 */
typedef union BCMI_QTC_XGXS_TXFIR_CTL4r_s {
	uint32_t v[1];
	uint32_t txfir_ctl4[1];
	uint32_t _txfir_ctl4;
} BCMI_QTC_XGXS_TXFIR_CTL4r_t;

#define BCMI_QTC_XGXS_TXFIR_CTL4r_CLR(r) (r).txfir_ctl4[0] = 0
#define BCMI_QTC_XGXS_TXFIR_CTL4r_SET(r,d) (r).txfir_ctl4[0] = d
#define BCMI_QTC_XGXS_TXFIR_CTL4r_GET(r) (r).txfir_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3_OFFSETf_GET(r) ((((r).txfir_ctl4[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3_OFFSETf_SET(r,f) (r).txfir_ctl4[0]=(((r).txfir_ctl4[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3f_GET(r) (((r).txfir_ctl4[0]) & 0xf)
#define BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3f_SET(r,f) (r).txfir_ctl4[0]=(((r).txfir_ctl4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access TXFIR_CTL4.
 */
#define BCMI_QTC_XGXS_READ_TXFIR_CTL4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL4r,(_r._txfir_ctl4))
#define BCMI_QTC_XGXS_WRITE_TXFIR_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL4r,(_r._txfir_ctl4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_TXFIR_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL4r,(_r._txfir_ctl4))
#define BCMI_QTC_XGXS_READLN_TXFIR_CTL4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_TXFIR_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl4))
#define BCMI_QTC_XGXS_WRITELN_TXFIR_CTL4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl4))
#define BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_TXFIR_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_ctl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL4r BCMI_QTC_XGXS_TXFIR_CTL4r
#define TXFIR_CTL4r_SIZE BCMI_QTC_XGXS_TXFIR_CTL4r_SIZE
typedef BCMI_QTC_XGXS_TXFIR_CTL4r_t TXFIR_CTL4r_t;
#define TXFIR_CTL4r_CLR BCMI_QTC_XGXS_TXFIR_CTL4r_CLR
#define TXFIR_CTL4r_SET BCMI_QTC_XGXS_TXFIR_CTL4r_SET
#define TXFIR_CTL4r_GET BCMI_QTC_XGXS_TXFIR_CTL4r_GET
#define TXFIR_CTL4r_TXFIR_POST3_OFFSETf_GET BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3_OFFSETf_GET
#define TXFIR_CTL4r_TXFIR_POST3_OFFSETf_SET BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3_OFFSETf_SET
#define TXFIR_CTL4r_TXFIR_POST3f_GET BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3f_GET
#define TXFIR_CTL4r_TXFIR_POST3f_SET BCMI_QTC_XGXS_TXFIR_CTL4r_TXFIR_POST3f_SET
#define READ_TXFIR_CTL4r BCMI_QTC_XGXS_READ_TXFIR_CTL4r
#define WRITE_TXFIR_CTL4r BCMI_QTC_XGXS_WRITE_TXFIR_CTL4r
#define MODIFY_TXFIR_CTL4r BCMI_QTC_XGXS_MODIFY_TXFIR_CTL4r
#define READLN_TXFIR_CTL4r BCMI_QTC_XGXS_READLN_TXFIR_CTL4r
#define WRITELN_TXFIR_CTL4r BCMI_QTC_XGXS_WRITELN_TXFIR_CTL4r
#define WRITEALL_TXFIR_CTL4r BCMI_QTC_XGXS_WRITEALL_TXFIR_CTL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_TXFIR_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd120
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 0.
 * SIZE:     32
 * FIELDS:
 *     VCO_STEP_TIME    VCO time between iterations
 *     VCO_START_TIME   VCO powerup wait time
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL0r (0x0001d120 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL0.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl0[1];
	uint32_t _pll_cal_ctl0;
} BCMI_QTC_XGXS_PLL_CAL_CTL0r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_CLR(r) (r).pll_cal_ctl0[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_SET(r,d) (r).pll_cal_ctl0[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_GET(r) (r).pll_cal_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_GET(r) ((((r).pll_cal_ctl0[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET(r) (((r).pll_cal_ctl0[0]) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL0.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl0))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl0))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL0r BCMI_QTC_XGXS_PLL_CAL_CTL0r
#define PLL_CAL_CTL0r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL0r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL0r_t PLL_CAL_CTL0r_t;
#define PLL_CAL_CTL0r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL0r_CLR
#define PLL_CAL_CTL0r_SET BCMI_QTC_XGXS_PLL_CAL_CTL0r_SET
#define PLL_CAL_CTL0r_GET BCMI_QTC_XGXS_PLL_CAL_CTL0r_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_SET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET
#define READ_PLL_CAL_CTL0r BCMI_QTC_XGXS_READ_PLL_CAL_CTL0r
#define WRITE_PLL_CAL_CTL0r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL0r
#define MODIFY_PLL_CAL_CTL0r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL0r
#define READLN_PLL_CAL_CTL0r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL0r
#define WRITELN_PLL_CAL_CTL0r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL0r
#define WRITEALL_PLL_CAL_CTL0r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd121
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 1.
 * SIZE:     32
 * FIELDS:
 *     RETRY_TIME       retry wait time
 *     PRE_FREQ_DET_TIME wait time prior to freq det
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL1r (0x0001d121 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL1.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl1[1];
	uint32_t _pll_cal_ctl1;
} BCMI_QTC_XGXS_PLL_CAL_CTL1r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_CLR(r) (r).pll_cal_ctl1[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_SET(r,d) (r).pll_cal_ctl1[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_GET(r) (r).pll_cal_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET(r) ((((r).pll_cal_ctl1[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_GET(r) (((r).pll_cal_ctl1[0]) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL1.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl1))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL1r BCMI_QTC_XGXS_PLL_CAL_CTL1r
#define PLL_CAL_CTL1r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL1r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL1r_t PLL_CAL_CTL1r_t;
#define PLL_CAL_CTL1r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL1r_CLR
#define PLL_CAL_CTL1r_SET BCMI_QTC_XGXS_PLL_CAL_CTL1r_SET
#define PLL_CAL_CTL1r_GET BCMI_QTC_XGXS_PLL_CAL_CTL1r_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET
#define PLL_CAL_CTL1r_RETRY_TIMEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_GET
#define PLL_CAL_CTL1r_RETRY_TIMEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_SET
#define READ_PLL_CAL_CTL1r BCMI_QTC_XGXS_READ_PLL_CAL_CTL1r
#define WRITE_PLL_CAL_CTL1r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL1r
#define MODIFY_PLL_CAL_CTL1r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL1r
#define READLN_PLL_CAL_CTL1r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL1r
#define WRITELN_PLL_CAL_CTL1r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL1r
#define WRITEALL_PLL_CAL_CTL1r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL2
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd122
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 2.
 * SIZE:     32
 * FIELDS:
 *     WIN_CAL_CNTR     freq. counter's 8-lsbits stoping value
 *     RES_CAL_CNTR     freq. counter's 8-msbits starting value
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL2r (0x0001d122 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL2.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL2r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl2[1];
	uint32_t _pll_cal_ctl2;
} BCMI_QTC_XGXS_PLL_CAL_CTL2r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_CLR(r) (r).pll_cal_ctl2[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_SET(r,d) (r).pll_cal_ctl2[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_GET(r) (r).pll_cal_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET(r) ((((r).pll_cal_ctl2[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET(r) (((r).pll_cal_ctl2[0]) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL2.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl2))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL2r BCMI_QTC_XGXS_PLL_CAL_CTL2r
#define PLL_CAL_CTL2r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL2r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL2r_t PLL_CAL_CTL2r_t;
#define PLL_CAL_CTL2r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL2r_CLR
#define PLL_CAL_CTL2r_SET BCMI_QTC_XGXS_PLL_CAL_CTL2r_SET
#define PLL_CAL_CTL2r_GET BCMI_QTC_XGXS_PLL_CAL_CTL2r_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_GET BCMI_QTC_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_SET BCMI_QTC_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET BCMI_QTC_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET BCMI_QTC_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET
#define READ_PLL_CAL_CTL2r BCMI_QTC_XGXS_READ_PLL_CAL_CTL2r
#define WRITE_PLL_CAL_CTL2r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL2r
#define MODIFY_PLL_CAL_CTL2r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL2r
#define READLN_PLL_CAL_CTL2r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL2r
#define WRITELN_PLL_CAL_CTL2r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL2r
#define WRITEALL_PLL_CAL_CTL2r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL3
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd123
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 3.
 * SIZE:     32
 * FIELDS:
 *     FAST_SEARCH_MODE force cap sequencer using select_m value for fast searching
 *     CAP_CNT_MASK_EN  masks cap count to allow control of max value
 *     CAP_SEQ_CYA      cya bit to revert cap sequencer back to original hyper/xaui sequence
 *     CAP_RESTART      force cap sequencer to restart, set to high then low
 *     CAP_RETRY_EN     enable retry on cap search failure
 *     CAP_FORCE_SLOWDOWN slowdown force value
 *     CAP_FORCE_SLOWDOWN_EN slowdown force enable
 *     CAP_SELECT_M_EN  Manual vco cap value mode, force using pll_range force value
 *     CAP_SELECT_M     Manual vco cap value (i.e pll_range[7:0])
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r (0x0001d123 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL3.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL3r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl3[1];
	uint32_t _pll_cal_ctl3;
} BCMI_QTC_XGXS_PLL_CAL_CTL3r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CLR(r) (r).pll_cal_ctl3[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_SET(r,d) (r).pll_cal_ctl3[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_GET(r) (r).pll_cal_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET(r) ((((r).pll_cal_ctl3[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET(r) ((((r).pll_cal_ctl3[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_GET(r) ((((r).pll_cal_ctl3[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET(r) ((((r).pll_cal_ctl3[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET(r) (((r).pll_cal_ctl3[0]) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL3.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl3))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl3))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL3r BCMI_QTC_XGXS_PLL_CAL_CTL3r
#define PLL_CAL_CTL3r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL3r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL3r_t PLL_CAL_CTL3r_t;
#define PLL_CAL_CTL3r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL3r_CLR
#define PLL_CAL_CTL3r_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_SET
#define PLL_CAL_CTL3r_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET
#define PLL_CAL_CTL3r_CAP_RESTARTf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_GET
#define PLL_CAL_CTL3r_CAP_RESTARTf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_SET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET
#define READ_PLL_CAL_CTL3r BCMI_QTC_XGXS_READ_PLL_CAL_CTL3r
#define WRITE_PLL_CAL_CTL3r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL3r
#define MODIFY_PLL_CAL_CTL3r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL3r
#define READLN_PLL_CAL_CTL3r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL3r
#define WRITELN_PLL_CAL_CTL3r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL3r
#define WRITEALL_PLL_CAL_CTL3r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL4
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd124
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 4.
 * SIZE:     32
 * FIELDS:
 *     PLL_LOCK_FRC_VAL force pll lock value
 *     PLL_LOCK_FRC     force pll lock
 *     PLL_FORCE_CAP_PASS force cappass
 *     PLL_FORCE_CAP_PASS_EN enable pllforcecappass
 *     PLL_FORCE_CAP_DONE force capdone
 *     PLL_FORCE_CAP_DONE_EN enable pllforcecapdone
 *     PLL_FORCE_FPASS  force freqpass
 *     PLL_FORCE_FDONE  force freqdone
 *     PLL_FORCE_FDONE_EN enable pllforcefdone & pllforcefpass into pllseq
 *     VCO_RST_EN       enable pll reset when state machine is in start state. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 *     SLOWDN_XOR       invert sense of the slowdn/pll_low input from AFE
 *     FREQ_MONITOR_EN  continuously monitor vco freq
 *     FREQ_DET_RESTART_EN enable restart when not freq locked
 *     FREQ_DET_RETRY_EN enable retry on freq det failure
 *     VCO_DONE_EN      enable vco_done status bit
 *     PLL_SEQ_START    start pll sequencer by writing to 1'b0 followed by writing to 1'b1. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r (0x0001d124 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL4.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL4r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl4[1];
	uint32_t _pll_cal_ctl4;
} BCMI_QTC_XGXS_PLL_CAL_CTL4r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_CLR(r) (r).pll_cal_ctl4[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_SET(r,d) (r).pll_cal_ctl4[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_GET(r) (r).pll_cal_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET(r) ((((r).pll_cal_ctl4[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_GET(r) ((((r).pll_cal_ctl4[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 7) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET(r) ((((r).pll_cal_ctl4[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET(r) (((r).pll_cal_ctl4[0]) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL4.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl4))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl4))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL4r BCMI_QTC_XGXS_PLL_CAL_CTL4r
#define PLL_CAL_CTL4r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL4r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL4r_t PLL_CAL_CTL4r_t;
#define PLL_CAL_CTL4r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL4r_CLR
#define PLL_CAL_CTL4r_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_SET
#define PLL_CAL_CTL4r_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_GET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET
#define PLL_CAL_CTL4r_SLOWDN_XORf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_GET
#define PLL_CAL_CTL4r_SLOWDN_XORf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_SET
#define PLL_CAL_CTL4r_VCO_RST_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_GET
#define PLL_CAL_CTL4r_VCO_RST_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET BCMI_QTC_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET
#define READ_PLL_CAL_CTL4r BCMI_QTC_XGXS_READ_PLL_CAL_CTL4r
#define WRITE_PLL_CAL_CTL4r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL4r
#define MODIFY_PLL_CAL_CTL4r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL4r
#define READLN_PLL_CAL_CTL4r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL4r
#define WRITELN_PLL_CAL_CTL4r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL4r
#define WRITEALL_PLL_CAL_CTL4r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL5
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd125
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 5.
 * SIZE:     32
 * FIELDS:
 *     REFCLK_DIVCNT    Refclk Divider Count to generate 25 Khz clock enable (40 us period apart) for PLL control logic.   change dfs from 0x186A to 0x27 (decimal 39) for faster pll lock time
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL5r (0x0001d125 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL5.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL5r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl5[1];
	uint32_t _pll_cal_ctl5;
} BCMI_QTC_XGXS_PLL_CAL_CTL5r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL5r_CLR(r) (r).pll_cal_ctl5[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL5r_SET(r,d) (r).pll_cal_ctl5[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL5r_GET(r) (r).pll_cal_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET(r) (((r).pll_cal_ctl5[0]) & 0x3fff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET(r,f) (r).pll_cal_ctl5[0]=(((r).pll_cal_ctl5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL5.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL5r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL5r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl5))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL5r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl5))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL5r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL5r BCMI_QTC_XGXS_PLL_CAL_CTL5r
#define PLL_CAL_CTL5r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL5r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL5r_t PLL_CAL_CTL5r_t;
#define PLL_CAL_CTL5r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL5r_CLR
#define PLL_CAL_CTL5r_SET BCMI_QTC_XGXS_PLL_CAL_CTL5r_SET
#define PLL_CAL_CTL5r_GET BCMI_QTC_XGXS_PLL_CAL_CTL5r_GET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET BCMI_QTC_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET BCMI_QTC_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET
#define READ_PLL_CAL_CTL5r BCMI_QTC_XGXS_READ_PLL_CAL_CTL5r
#define WRITE_PLL_CAL_CTL5r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL5r
#define MODIFY_PLL_CAL_CTL5r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL5r
#define READLN_PLL_CAL_CTL5r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL5r
#define WRITELN_PLL_CAL_CTL5r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL5r
#define WRITEALL_PLL_CAL_CTL5r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL6
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd126
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 6.
 * SIZE:     32
 * FIELDS:
 *     REFCLK_DIVCNT_SEL Refclk Divider Mode Select.refclk      refclk_divcnt value to generate 25 Khz signal   refclk_divcnt_sel[2:0]----------------------------------------------------------------------------------390.625 Mhz               15625                             3'd0161.1328185 Mhz           6445.31274 = ~6445                3'd1156.25 Mhz                6250                              3'd2   (default)125.00 Mhz                5000                              3'd3106.25 Mhz                4250                              3'd478.125 Mhz                3125                              3'd5-                         -                                 3'd6   (rsvd for future use)-                         refclk_divcnt[13:0]               3'd7   (programmable with max value of 16383)defaulted to 0x7 for faster pll lock time (0x2 before)
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL6r (0x0001d126 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL6.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL6r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl6[1];
	uint32_t _pll_cal_ctl6;
} BCMI_QTC_XGXS_PLL_CAL_CTL6r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL6r_CLR(r) (r).pll_cal_ctl6[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL6r_SET(r,d) (r).pll_cal_ctl6[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL6r_GET(r) (r).pll_cal_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET(r) (((r).pll_cal_ctl6[0]) & 0x7)
#define BCMI_QTC_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET(r,f) (r).pll_cal_ctl6[0]=(((r).pll_cal_ctl6[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (7 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL6.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL6r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL6r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl6))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL6r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl6))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL6r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl6))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL6r BCMI_QTC_XGXS_PLL_CAL_CTL6r
#define PLL_CAL_CTL6r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL6r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL6r_t PLL_CAL_CTL6r_t;
#define PLL_CAL_CTL6r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL6r_CLR
#define PLL_CAL_CTL6r_SET BCMI_QTC_XGXS_PLL_CAL_CTL6r_SET
#define PLL_CAL_CTL6r_GET BCMI_QTC_XGXS_PLL_CAL_CTL6r_GET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET BCMI_QTC_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET BCMI_QTC_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET
#define READ_PLL_CAL_CTL6r BCMI_QTC_XGXS_READ_PLL_CAL_CTL6r
#define WRITE_PLL_CAL_CTL6r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL6r
#define MODIFY_PLL_CAL_CTL6r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL6r
#define READLN_PLL_CAL_CTL6r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL6r
#define WRITELN_PLL_CAL_CTL6r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL6r
#define WRITEALL_PLL_CAL_CTL6r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL6r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL7
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd127
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 7.
 * SIZE:     32
 * FIELDS:
 *     PLL_MODE         PLL Multiplier.0000  = 46;0001  = 72;0010  = 40;0011  = 42;0100  = 48;0101  = 50;0110  = 52;0111  = 54;1000  = 60;1001  = 64;1010  = 66;1011  = 68;1100  = 70;1101  = 80;1110  = 92;1111  = 100;
 *     RESCAL_FRC_VAL   rescal force value.
 *     RESCAL_FRC       rescal force to use rescal force value.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r (0x0001d127 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL7.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL7r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl7[1];
	uint32_t _pll_cal_ctl7;
} BCMI_QTC_XGXS_PLL_CAL_CTL7r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_CLR(r) (r).pll_cal_ctl7[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_SET(r,d) (r).pll_cal_ctl7[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_GET(r) (r).pll_cal_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET(r) ((((r).pll_cal_ctl7[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET(r) ((((r).pll_cal_ctl7[0]) >> 4) & 0xf)
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET(r) (((r).pll_cal_ctl7[0]) & 0xf)
#define BCMI_QTC_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL7.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL7r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL7r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL7r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL7r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl7))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL7r BCMI_QTC_XGXS_PLL_CAL_CTL7r
#define PLL_CAL_CTL7r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL7r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL7r_t PLL_CAL_CTL7r_t;
#define PLL_CAL_CTL7r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL7r_CLR
#define PLL_CAL_CTL7r_SET BCMI_QTC_XGXS_PLL_CAL_CTL7r_SET
#define PLL_CAL_CTL7r_GET BCMI_QTC_XGXS_PLL_CAL_CTL7r_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_GET BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_SET BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET BCMI_QTC_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET
#define PLL_CAL_CTL7r_PLL_MODEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET
#define PLL_CAL_CTL7r_PLL_MODEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET
#define READ_PLL_CAL_CTL7r BCMI_QTC_XGXS_READ_PLL_CAL_CTL7r
#define WRITE_PLL_CAL_CTL7r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL7r
#define MODIFY_PLL_CAL_CTL7r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL7r
#define READLN_PLL_CAL_CTL7r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL7r
#define WRITELN_PLL_CAL_CTL7r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL7r
#define WRITEALL_PLL_CAL_CTL7r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL7r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL_STS0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd128
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * SIZE:     32
 * FIELDS:
 *     PLL_LOCK_LH_LL   indicates change on pll_lock status bit. It is clear on read status register
 *     PLL_SEQ_PASS_LH_LL indicates change on pll_seq_pass status bit. It is clear on read status register
 *     PLL_SEQ_DONE_LH_LL indicates change on pll_seq_done status bit. It is clear on read status register
 *     FREQ_PASS_SM_LH_LL indicates change on freq_pass_sm status bit. It is clear on read status register
 *     FREQ_DONE_SM_LH_LL indicates change on freq_done_sm status bit. It is clear on read status register
 *     CAP_PASS_LH_LL   indicates change on cap_pass status bit. It is clear on read status register
 *     CAP_DONE_LH_LL   indicates change on cap_done status bit. It is clear on read status register
 *     PLL_LOCK         status bit indicating PLL is locked
 *     PLL_SEQ_PASS     status bit indicating pll sequencer finised successfully
 *     PLL_SEQ_DONE     status bit indicating pll sequencer is done
 *     FREQ_PASS_SM     status bit indicating frequency lock
 *     FREQ_DONE_SM     status bit indicating freq det is done
 *     CAP_PASS         status indicating cap value was found
 *     CAP_DONE         status indicating cap sequencer is done
 *     LOST_PLL_LOCK_SM status bit indicating pll_lock was lost, clear on read
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r (0x0001d128 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS0.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts0[1];
	uint32_t _pll_cal_ctl_sts0;
} BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CLR(r) (r).pll_cal_ctl_sts0[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_SET(r,d) (r).pll_cal_ctl_sts0[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_GET(r) (r).pll_cal_ctl_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 8) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET(r) (((r).pll_cal_ctl_sts0[0]) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS0.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL_STS0r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL_STS0r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL_STS0r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL_STS0r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS0r BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r
#define PLL_CAL_CTL_STS0r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_t PLL_CAL_CTL_STS0r_t;
#define PLL_CAL_CTL_STS0r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CLR
#define PLL_CAL_CTL_STS0r_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_SET
#define PLL_CAL_CTL_STS0r_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET
#define READ_PLL_CAL_CTL_STS0r BCMI_QTC_XGXS_READ_PLL_CAL_CTL_STS0r
#define WRITE_PLL_CAL_CTL_STS0r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL_STS0r
#define MODIFY_PLL_CAL_CTL_STS0r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL_STS0r
#define READLN_PLL_CAL_CTL_STS0r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL_STS0r
#define WRITELN_PLL_CAL_CTL_STS0r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL_STS0r
#define WRITEALL_PLL_CAL_CTL_STS0r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL_STS0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL_STS1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd129
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * SIZE:     32
 * FIELDS:
 *     CAP_SELECT       status bit indicating the selected cap value (i.e. pll_range[7:0])
 *     RESCAL_IN        rescal input value
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r (0x0001d129 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS1.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts1[1];
	uint32_t _pll_cal_ctl_sts1;
} BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_CLR(r) (r).pll_cal_ctl_sts1[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_SET(r,d) (r).pll_cal_ctl_sts1[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_GET(r) (r).pll_cal_ctl_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_GET(r) ((((r).pll_cal_ctl_sts1[0]) >> 8) & 0xf)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET(r) (((r).pll_cal_ctl_sts1[0]) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (255 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS1.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL_STS1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL_STS1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts1))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL_STS1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts1))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL_STS1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS1r BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r
#define PLL_CAL_CTL_STS1r_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_t PLL_CAL_CTL_STS1r_t;
#define PLL_CAL_CTL_STS1r_CLR BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_CLR
#define PLL_CAL_CTL_STS1r_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_SET
#define PLL_CAL_CTL_STS1r_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_SET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET
#define READ_PLL_CAL_CTL_STS1r BCMI_QTC_XGXS_READ_PLL_CAL_CTL_STS1r
#define WRITE_PLL_CAL_CTL_STS1r BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL_STS1r
#define MODIFY_PLL_CAL_CTL_STS1r BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL_STS1r
#define READLN_PLL_CAL_CTL_STS1r BCMI_QTC_XGXS_READLN_PLL_CAL_CTL_STS1r
#define WRITELN_PLL_CAL_CTL_STS1r BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL_STS1r
#define WRITEALL_PLL_CAL_CTL_STS1r BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL_STS1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  PLL_CAL_CTL_STS_DBG
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd12a
 * DEVAD:    1
 * DESC:     PLL CAL debug status registers register.
 * SIZE:     32
 * FIELDS:
 *     DBG_SLOWDN       Indicates AFE pll_low/slowdn output signal status.
 *     DBG_SLOWDN_CHANGE Indicates change on AFE pll_low/slowdn output signal. It is clear on read status register
 *     DBG_FDBCK        Indicates change on AFE fdbck output signal. clear on read status register.Will be used to see if fdbck clock from AFE is toggling and alive
 *     DBG_CAP_STATE_ONE_HOT Indicates one hot encoded Cap Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State    dbg_cap_state_one_hot[x] where x is :==================================================Start          0WaitAmpL       1WaitSpeedL     2IncCapL        3Finish         4
 *     DBG_PLL_STATE_ONE_HOT Indicates one hot encoded PLL Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State   dbg_pll_state_one_hot[x] where x is :==============================================Start          0WaitVco        1VcoAdjust      2WaitFreq       3FreqDet        4Fail           5FreqMon        6Finish         7
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr (0x0001d12a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS_DBG.
 */
typedef union BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts_dbg[1];
	uint32_t _pll_cal_ctl_sts_dbg;
} BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_t;

#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_CLR(r) (r).pll_cal_ctl_sts_dbg[0] = 0
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_SET(r,d) (r).pll_cal_ctl_sts_dbg[0] = d
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_GET(r) (r).pll_cal_ctl_sts_dbg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 8) & 0xff)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 3) & 0x1f)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET(r) (((r).pll_cal_ctl_sts_dbg[0]) & 0x1)
#define BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS_DBG.
 */
#define BCMI_QTC_XGXS_READ_PLL_CAL_CTL_STS_DBGr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg))
#define BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL_STS_DBGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL_STS_DBGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg))
#define BCMI_QTC_XGXS_READLN_PLL_CAL_CTL_STS_DBGr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts_dbg))
#define BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL_STS_DBGr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts_dbg))
#define BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL_STS_DBGr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts_dbg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS_DBGr BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr
#define PLL_CAL_CTL_STS_DBGr_SIZE BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_SIZE
typedef BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_t PLL_CAL_CTL_STS_DBGr_t;
#define PLL_CAL_CTL_STS_DBGr_CLR BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_CLR
#define PLL_CAL_CTL_STS_DBGr_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_SET
#define PLL_CAL_CTL_STS_DBGr_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET
#define READ_PLL_CAL_CTL_STS_DBGr BCMI_QTC_XGXS_READ_PLL_CAL_CTL_STS_DBGr
#define WRITE_PLL_CAL_CTL_STS_DBGr BCMI_QTC_XGXS_WRITE_PLL_CAL_CTL_STS_DBGr
#define MODIFY_PLL_CAL_CTL_STS_DBGr BCMI_QTC_XGXS_MODIFY_PLL_CAL_CTL_STS_DBGr
#define READLN_PLL_CAL_CTL_STS_DBGr BCMI_QTC_XGXS_READLN_PLL_CAL_CTL_STS_DBGr
#define WRITELN_PLL_CAL_CTL_STS_DBGr BCMI_QTC_XGXS_WRITELN_PLL_CAL_CTL_STS_DBGr
#define WRITEALL_PLL_CAL_CTL_STS_DBGr BCMI_QTC_XGXS_WRITEALL_PLL_CAL_CTL_STS_DBGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_PLL_CAL_CTL_STS_DBGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXC_TAP_LIMIT_CTL1
 * BLOCKS:   TX_COM
 * REGADDR:  0xd130
 * DEVAD:    1
 * DESC:     CL72 Tap Limit Control 1 Register
 * SIZE:     32
 * FIELDS:
 *     PRE_TAP_LIMIT    'd0 <= pre_tap <= cl72_pre_tap_limit
 *     POST_TAP_LIMIT   'd0 <= post_tap <= cl72_post_tap_limit
 */
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r (0x0001d130 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXC_TAP_LIMIT_CTL1.
 */
typedef union BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_s {
	uint32_t v[1];
	uint32_t cl72_txc_tap_limit_ctl1[1];
	uint32_t _cl72_txc_tap_limit_ctl1;
} BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_t;

#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_CLR(r) (r).cl72_txc_tap_limit_ctl1[0] = 0
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_SET(r,d) (r).cl72_txc_tap_limit_ctl1[0] = d
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_GET(r) (r).cl72_txc_tap_limit_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_POST_TAP_LIMITf_GET(r) ((((r).cl72_txc_tap_limit_ctl1[0]) >> 5) & 0x3f)
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_POST_TAP_LIMITf_SET(r,f) (r).cl72_txc_tap_limit_ctl1[0]=(((r).cl72_txc_tap_limit_ctl1[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_PRE_TAP_LIMITf_GET(r) (((r).cl72_txc_tap_limit_ctl1[0]) & 0x1f)
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_PRE_TAP_LIMITf_SET(r,f) (r).cl72_txc_tap_limit_ctl1[0]=(((r).cl72_txc_tap_limit_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access CL72_TXC_TAP_LIMIT_CTL1.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXC_TAP_LIMIT_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r,(_r._cl72_txc_tap_limit_ctl1))
#define BCMI_QTC_XGXS_WRITE_CL72_TXC_TAP_LIMIT_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r,(_r._cl72_txc_tap_limit_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXC_TAP_LIMIT_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r,(_r._cl72_txc_tap_limit_ctl1))
#define BCMI_QTC_XGXS_READLN_CL72_TXC_TAP_LIMIT_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_tap_limit_ctl1))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXC_TAP_LIMIT_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_tap_limit_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXC_TAP_LIMIT_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txc_tap_limit_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXC_TAP_LIMIT_CTL1r BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r
#define CL72_TXC_TAP_LIMIT_CTL1r_SIZE BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_SIZE
typedef BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_t CL72_TXC_TAP_LIMIT_CTL1r_t;
#define CL72_TXC_TAP_LIMIT_CTL1r_CLR BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_CLR
#define CL72_TXC_TAP_LIMIT_CTL1r_SET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_SET
#define CL72_TXC_TAP_LIMIT_CTL1r_GET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_GET
#define CL72_TXC_TAP_LIMIT_CTL1r_POST_TAP_LIMITf_GET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_POST_TAP_LIMITf_GET
#define CL72_TXC_TAP_LIMIT_CTL1r_POST_TAP_LIMITf_SET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_POST_TAP_LIMITf_SET
#define CL72_TXC_TAP_LIMIT_CTL1r_PRE_TAP_LIMITf_GET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_PRE_TAP_LIMITf_GET
#define CL72_TXC_TAP_LIMIT_CTL1r_PRE_TAP_LIMITf_SET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r_PRE_TAP_LIMITf_SET
#define READ_CL72_TXC_TAP_LIMIT_CTL1r BCMI_QTC_XGXS_READ_CL72_TXC_TAP_LIMIT_CTL1r
#define WRITE_CL72_TXC_TAP_LIMIT_CTL1r BCMI_QTC_XGXS_WRITE_CL72_TXC_TAP_LIMIT_CTL1r
#define MODIFY_CL72_TXC_TAP_LIMIT_CTL1r BCMI_QTC_XGXS_MODIFY_CL72_TXC_TAP_LIMIT_CTL1r
#define READLN_CL72_TXC_TAP_LIMIT_CTL1r BCMI_QTC_XGXS_READLN_CL72_TXC_TAP_LIMIT_CTL1r
#define WRITELN_CL72_TXC_TAP_LIMIT_CTL1r BCMI_QTC_XGXS_WRITELN_CL72_TXC_TAP_LIMIT_CTL1r
#define WRITEALL_CL72_TXC_TAP_LIMIT_CTL1r BCMI_QTC_XGXS_WRITEALL_CL72_TXC_TAP_LIMIT_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXC_TAP_LIMIT_CTL2
 * BLOCKS:   TX_COM
 * REGADDR:  0xd131
 * DEVAD:    1
 * DESC:     CL72 Tap Limit Control 2 Register
 * SIZE:     32
 * FIELDS:
 *     MAIN_TAP_LIMIT   min_limit <= main_tap <= cl72_main_tap_limitNOTE: main_tap + v2_limit >= post_tap + pre_tap
 */
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r (0x0001d131 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXC_TAP_LIMIT_CTL2.
 */
typedef union BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_s {
	uint32_t v[1];
	uint32_t cl72_txc_tap_limit_ctl2[1];
	uint32_t _cl72_txc_tap_limit_ctl2;
} BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_t;

#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_CLR(r) (r).cl72_txc_tap_limit_ctl2[0] = 0
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_SET(r,d) (r).cl72_txc_tap_limit_ctl2[0] = d
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_GET(r) (r).cl72_txc_tap_limit_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_MAIN_TAP_LIMITf_GET(r) (((r).cl72_txc_tap_limit_ctl2[0]) & 0x7f)
#define BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_MAIN_TAP_LIMITf_SET(r,f) (r).cl72_txc_tap_limit_ctl2[0]=(((r).cl72_txc_tap_limit_ctl2[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access CL72_TXC_TAP_LIMIT_CTL2.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXC_TAP_LIMIT_CTL2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r,(_r._cl72_txc_tap_limit_ctl2))
#define BCMI_QTC_XGXS_WRITE_CL72_TXC_TAP_LIMIT_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r,(_r._cl72_txc_tap_limit_ctl2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXC_TAP_LIMIT_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r,(_r._cl72_txc_tap_limit_ctl2))
#define BCMI_QTC_XGXS_READLN_CL72_TXC_TAP_LIMIT_CTL2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_tap_limit_ctl2))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXC_TAP_LIMIT_CTL2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_tap_limit_ctl2))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXC_TAP_LIMIT_CTL2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txc_tap_limit_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXC_TAP_LIMIT_CTL2r BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r
#define CL72_TXC_TAP_LIMIT_CTL2r_SIZE BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_SIZE
typedef BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_t CL72_TXC_TAP_LIMIT_CTL2r_t;
#define CL72_TXC_TAP_LIMIT_CTL2r_CLR BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_CLR
#define CL72_TXC_TAP_LIMIT_CTL2r_SET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_SET
#define CL72_TXC_TAP_LIMIT_CTL2r_GET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_GET
#define CL72_TXC_TAP_LIMIT_CTL2r_MAIN_TAP_LIMITf_GET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_MAIN_TAP_LIMITf_GET
#define CL72_TXC_TAP_LIMIT_CTL2r_MAIN_TAP_LIMITf_SET BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r_MAIN_TAP_LIMITf_SET
#define READ_CL72_TXC_TAP_LIMIT_CTL2r BCMI_QTC_XGXS_READ_CL72_TXC_TAP_LIMIT_CTL2r
#define WRITE_CL72_TXC_TAP_LIMIT_CTL2r BCMI_QTC_XGXS_WRITE_CL72_TXC_TAP_LIMIT_CTL2r
#define MODIFY_CL72_TXC_TAP_LIMIT_CTL2r BCMI_QTC_XGXS_MODIFY_CL72_TXC_TAP_LIMIT_CTL2r
#define READLN_CL72_TXC_TAP_LIMIT_CTL2r BCMI_QTC_XGXS_READLN_CL72_TXC_TAP_LIMIT_CTL2r
#define WRITELN_CL72_TXC_TAP_LIMIT_CTL2r BCMI_QTC_XGXS_WRITELN_CL72_TXC_TAP_LIMIT_CTL2r
#define WRITEALL_CL72_TXC_TAP_LIMIT_CTL2r BCMI_QTC_XGXS_WRITEALL_CL72_TXC_TAP_LIMIT_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXC_TAP_LIMIT_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXC_TAP_PRESET_CTL
 * BLOCKS:   TX_COM
 * REGADDR:  0xd132
 * DEVAD:    1
 * DESC:     CL72 Tap Present Control Register
 * SIZE:     32
 * FIELDS:
 *     POST_TAP_PRESET_VAL Cl72 post tap init value when preset command is recieved.
 *     PRE_TAP_PRESET_VAL Cl72 pre tap init value when preset command is recieved.
 */
#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr (0x0001d132 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXC_TAP_PRESET_CTL.
 */
typedef union BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_s {
	uint32_t v[1];
	uint32_t cl72_txc_tap_preset_ctl[1];
	uint32_t _cl72_txc_tap_preset_ctl;
} BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_t;

#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_CLR(r) (r).cl72_txc_tap_preset_ctl[0] = 0
#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_SET(r,d) (r).cl72_txc_tap_preset_ctl[0] = d
#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_GET(r) (r).cl72_txc_tap_preset_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_PRE_TAP_PRESET_VALf_GET(r) ((((r).cl72_txc_tap_preset_ctl[0]) >> 6) & 0x1f)
#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_PRE_TAP_PRESET_VALf_SET(r,f) (r).cl72_txc_tap_preset_ctl[0]=(((r).cl72_txc_tap_preset_ctl[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_POST_TAP_PRESET_VALf_GET(r) (((r).cl72_txc_tap_preset_ctl[0]) & 0x3f)
#define BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_POST_TAP_PRESET_VALf_SET(r,f) (r).cl72_txc_tap_preset_ctl[0]=(((r).cl72_txc_tap_preset_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (63 << 16)

/*
 * These macros can be used to access CL72_TXC_TAP_PRESET_CTL.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXC_TAP_PRESET_CTLr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr,(_r._cl72_txc_tap_preset_ctl))
#define BCMI_QTC_XGXS_WRITE_CL72_TXC_TAP_PRESET_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr,(_r._cl72_txc_tap_preset_ctl)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXC_TAP_PRESET_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr,(_r._cl72_txc_tap_preset_ctl))
#define BCMI_QTC_XGXS_READLN_CL72_TXC_TAP_PRESET_CTLr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_tap_preset_ctl))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXC_TAP_PRESET_CTLr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_tap_preset_ctl))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXC_TAP_PRESET_CTLr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txc_tap_preset_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXC_TAP_PRESET_CTLr BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr
#define CL72_TXC_TAP_PRESET_CTLr_SIZE BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_t CL72_TXC_TAP_PRESET_CTLr_t;
#define CL72_TXC_TAP_PRESET_CTLr_CLR BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_CLR
#define CL72_TXC_TAP_PRESET_CTLr_SET BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_SET
#define CL72_TXC_TAP_PRESET_CTLr_GET BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_GET
#define CL72_TXC_TAP_PRESET_CTLr_PRE_TAP_PRESET_VALf_GET BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_PRE_TAP_PRESET_VALf_GET
#define CL72_TXC_TAP_PRESET_CTLr_PRE_TAP_PRESET_VALf_SET BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_PRE_TAP_PRESET_VALf_SET
#define CL72_TXC_TAP_PRESET_CTLr_POST_TAP_PRESET_VALf_GET BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_POST_TAP_PRESET_VALf_GET
#define CL72_TXC_TAP_PRESET_CTLr_POST_TAP_PRESET_VALf_SET BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr_POST_TAP_PRESET_VALf_SET
#define READ_CL72_TXC_TAP_PRESET_CTLr BCMI_QTC_XGXS_READ_CL72_TXC_TAP_PRESET_CTLr
#define WRITE_CL72_TXC_TAP_PRESET_CTLr BCMI_QTC_XGXS_WRITE_CL72_TXC_TAP_PRESET_CTLr
#define MODIFY_CL72_TXC_TAP_PRESET_CTLr BCMI_QTC_XGXS_MODIFY_CL72_TXC_TAP_PRESET_CTLr
#define READLN_CL72_TXC_TAP_PRESET_CTLr BCMI_QTC_XGXS_READLN_CL72_TXC_TAP_PRESET_CTLr
#define WRITELN_CL72_TXC_TAP_PRESET_CTLr BCMI_QTC_XGXS_WRITELN_CL72_TXC_TAP_PRESET_CTLr
#define WRITEALL_CL72_TXC_TAP_PRESET_CTLr BCMI_QTC_XGXS_WRITEALL_CL72_TXC_TAP_PRESET_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXC_TAP_PRESET_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXC_DBG1
 * BLOCKS:   TX_COM
 * REGADDR:  0xd133
 * DEVAD:    1
 * DESC:     CL72 Debug 1 Register
 * SIZE:     32
 * FIELDS:
 *     MAIN_TAP_MIN_VAL Cl72 tap min value.
 *     TAP_SUM_MAX_VAL  Cl72 tap max value. (NOTE: sum_of_all_taps should not exceed tap_max_val.)
 */
#define BCMI_QTC_XGXS_CL72_TXC_DBG1r (0x0001d133 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXC_DBG1.
 */
typedef union BCMI_QTC_XGXS_CL72_TXC_DBG1r_s {
	uint32_t v[1];
	uint32_t cl72_txc_dbg1[1];
	uint32_t _cl72_txc_dbg1;
} BCMI_QTC_XGXS_CL72_TXC_DBG1r_t;

#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_CLR(r) (r).cl72_txc_dbg1[0] = 0
#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_SET(r,d) (r).cl72_txc_dbg1[0] = d
#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_GET(r) (r).cl72_txc_dbg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_TAP_SUM_MAX_VALf_GET(r) ((((r).cl72_txc_dbg1[0]) >> 7) & 0xff)
#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_TAP_SUM_MAX_VALf_SET(r,f) (r).cl72_txc_dbg1[0]=(((r).cl72_txc_dbg1[0] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7)) | (255 << (16 + 7))
#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_MAIN_TAP_MIN_VALf_GET(r) (((r).cl72_txc_dbg1[0]) & 0x7f)
#define BCMI_QTC_XGXS_CL72_TXC_DBG1r_MAIN_TAP_MIN_VALf_SET(r,f) (r).cl72_txc_dbg1[0]=(((r).cl72_txc_dbg1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (127 << 16)

/*
 * These macros can be used to access CL72_TXC_DBG1.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXC_DBG1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_DBG1r,(_r._cl72_txc_dbg1))
#define BCMI_QTC_XGXS_WRITE_CL72_TXC_DBG1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_DBG1r,(_r._cl72_txc_dbg1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXC_DBG1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_DBG1r,(_r._cl72_txc_dbg1))
#define BCMI_QTC_XGXS_READLN_CL72_TXC_DBG1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_dbg1))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXC_DBG1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_dbg1))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXC_DBG1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txc_dbg1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXC_DBG1r BCMI_QTC_XGXS_CL72_TXC_DBG1r
#define CL72_TXC_DBG1r_SIZE BCMI_QTC_XGXS_CL72_TXC_DBG1r_SIZE
typedef BCMI_QTC_XGXS_CL72_TXC_DBG1r_t CL72_TXC_DBG1r_t;
#define CL72_TXC_DBG1r_CLR BCMI_QTC_XGXS_CL72_TXC_DBG1r_CLR
#define CL72_TXC_DBG1r_SET BCMI_QTC_XGXS_CL72_TXC_DBG1r_SET
#define CL72_TXC_DBG1r_GET BCMI_QTC_XGXS_CL72_TXC_DBG1r_GET
#define CL72_TXC_DBG1r_TAP_SUM_MAX_VALf_GET BCMI_QTC_XGXS_CL72_TXC_DBG1r_TAP_SUM_MAX_VALf_GET
#define CL72_TXC_DBG1r_TAP_SUM_MAX_VALf_SET BCMI_QTC_XGXS_CL72_TXC_DBG1r_TAP_SUM_MAX_VALf_SET
#define CL72_TXC_DBG1r_MAIN_TAP_MIN_VALf_GET BCMI_QTC_XGXS_CL72_TXC_DBG1r_MAIN_TAP_MIN_VALf_GET
#define CL72_TXC_DBG1r_MAIN_TAP_MIN_VALf_SET BCMI_QTC_XGXS_CL72_TXC_DBG1r_MAIN_TAP_MIN_VALf_SET
#define READ_CL72_TXC_DBG1r BCMI_QTC_XGXS_READ_CL72_TXC_DBG1r
#define WRITE_CL72_TXC_DBG1r BCMI_QTC_XGXS_WRITE_CL72_TXC_DBG1r
#define MODIFY_CL72_TXC_DBG1r BCMI_QTC_XGXS_MODIFY_CL72_TXC_DBG1r
#define READLN_CL72_TXC_DBG1r BCMI_QTC_XGXS_READLN_CL72_TXC_DBG1r
#define WRITELN_CL72_TXC_DBG1r BCMI_QTC_XGXS_WRITELN_CL72_TXC_DBG1r
#define WRITEALL_CL72_TXC_DBG1r BCMI_QTC_XGXS_WRITEALL_CL72_TXC_DBG1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXC_DBG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXC_MAX_WAIT_TMR
 * BLOCKS:   TX_COM
 * REGADDR:  0xd134
 * DEVAD:    1
 * DESC:     CL72 Max Wait Timer Register
 * SIZE:     32
 * FIELDS:
 *     MAX_WAIT_TIMER_PERIOD Maximum Training Time in msPeriod/range is 500 ms
 */
#define BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr (0x0001d134 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXC_MAX_WAIT_TMR.
 */
typedef union BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_s {
	uint32_t v[1];
	uint32_t cl72_txc_max_wait_tmr[1];
	uint32_t _cl72_txc_max_wait_tmr;
} BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_t;

#define BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_CLR(r) (r).cl72_txc_max_wait_tmr[0] = 0
#define BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_SET(r,d) (r).cl72_txc_max_wait_tmr[0] = d
#define BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_GET(r) (r).cl72_txc_max_wait_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_MAX_WAIT_TIMER_PERIODf_GET(r) (((r).cl72_txc_max_wait_tmr[0]) & 0xffff)
#define BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_MAX_WAIT_TIMER_PERIODf_SET(r,f) (r).cl72_txc_max_wait_tmr[0]=(((r).cl72_txc_max_wait_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access CL72_TXC_MAX_WAIT_TMR.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXC_MAX_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr,(_r._cl72_txc_max_wait_tmr))
#define BCMI_QTC_XGXS_WRITE_CL72_TXC_MAX_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr,(_r._cl72_txc_max_wait_tmr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXC_MAX_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr,(_r._cl72_txc_max_wait_tmr))
#define BCMI_QTC_XGXS_READLN_CL72_TXC_MAX_WAIT_TMRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_max_wait_tmr))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXC_MAX_WAIT_TMRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_max_wait_tmr))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXC_MAX_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txc_max_wait_tmr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXC_MAX_WAIT_TMRr BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr
#define CL72_TXC_MAX_WAIT_TMRr_SIZE BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_t CL72_TXC_MAX_WAIT_TMRr_t;
#define CL72_TXC_MAX_WAIT_TMRr_CLR BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_CLR
#define CL72_TXC_MAX_WAIT_TMRr_SET BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_SET
#define CL72_TXC_MAX_WAIT_TMRr_GET BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_GET
#define CL72_TXC_MAX_WAIT_TMRr_MAX_WAIT_TIMER_PERIODf_GET BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_MAX_WAIT_TIMER_PERIODf_GET
#define CL72_TXC_MAX_WAIT_TMRr_MAX_WAIT_TIMER_PERIODf_SET BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr_MAX_WAIT_TIMER_PERIODf_SET
#define READ_CL72_TXC_MAX_WAIT_TMRr BCMI_QTC_XGXS_READ_CL72_TXC_MAX_WAIT_TMRr
#define WRITE_CL72_TXC_MAX_WAIT_TMRr BCMI_QTC_XGXS_WRITE_CL72_TXC_MAX_WAIT_TMRr
#define MODIFY_CL72_TXC_MAX_WAIT_TMRr BCMI_QTC_XGXS_MODIFY_CL72_TXC_MAX_WAIT_TMRr
#define READLN_CL72_TXC_MAX_WAIT_TMRr BCMI_QTC_XGXS_READLN_CL72_TXC_MAX_WAIT_TMRr
#define WRITELN_CL72_TXC_MAX_WAIT_TMRr BCMI_QTC_XGXS_WRITELN_CL72_TXC_MAX_WAIT_TMRr
#define WRITEALL_CL72_TXC_MAX_WAIT_TMRr BCMI_QTC_XGXS_WRITEALL_CL72_TXC_MAX_WAIT_TMRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXC_MAX_WAIT_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  CL72_TXC_WAIT_TMR
 * BLOCKS:   TX_COM
 * REGADDR:  0xd135
 * DEVAD:    1
 * DESC:     CL72 Wait Timer Register
 * SIZE:     32
 * FIELDS:
 *     WAIT_CNTR_LIMIT  Period/range is 100-300 framesPeriod to keep transiming frames after the local device has completed trainingThe units are training pages.
 */
#define BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr (0x0001d135 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_SIZE 4

/*
 * This structure should be used to declare and program CL72_TXC_WAIT_TMR.
 */
typedef union BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_s {
	uint32_t v[1];
	uint32_t cl72_txc_wait_tmr[1];
	uint32_t _cl72_txc_wait_tmr;
} BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_t;

#define BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_CLR(r) (r).cl72_txc_wait_tmr[0] = 0
#define BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_SET(r,d) (r).cl72_txc_wait_tmr[0] = d
#define BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_GET(r) (r).cl72_txc_wait_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_WAIT_CNTR_LIMITf_GET(r) (((r).cl72_txc_wait_tmr[0]) & 0x1ff)
#define BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_WAIT_CNTR_LIMITf_SET(r,f) (r).cl72_txc_wait_tmr[0]=(((r).cl72_txc_wait_tmr[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (511 << 16)

/*
 * These macros can be used to access CL72_TXC_WAIT_TMR.
 */
#define BCMI_QTC_XGXS_READ_CL72_TXC_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr,(_r._cl72_txc_wait_tmr))
#define BCMI_QTC_XGXS_WRITE_CL72_TXC_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr,(_r._cl72_txc_wait_tmr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_CL72_TXC_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr,(_r._cl72_txc_wait_tmr))
#define BCMI_QTC_XGXS_READLN_CL72_TXC_WAIT_TMRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_wait_tmr))
#define BCMI_QTC_XGXS_WRITELN_CL72_TXC_WAIT_TMRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72_txc_wait_tmr))
#define BCMI_QTC_XGXS_WRITEALL_CL72_TXC_WAIT_TMRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72_txc_wait_tmr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define CL72_TXC_WAIT_TMRr BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr
#define CL72_TXC_WAIT_TMRr_SIZE BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_SIZE
typedef BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_t CL72_TXC_WAIT_TMRr_t;
#define CL72_TXC_WAIT_TMRr_CLR BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_CLR
#define CL72_TXC_WAIT_TMRr_SET BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_SET
#define CL72_TXC_WAIT_TMRr_GET BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_GET
#define CL72_TXC_WAIT_TMRr_WAIT_CNTR_LIMITf_GET BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_WAIT_CNTR_LIMITf_GET
#define CL72_TXC_WAIT_TMRr_WAIT_CNTR_LIMITf_SET BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr_WAIT_CNTR_LIMITf_SET
#define READ_CL72_TXC_WAIT_TMRr BCMI_QTC_XGXS_READ_CL72_TXC_WAIT_TMRr
#define WRITE_CL72_TXC_WAIT_TMRr BCMI_QTC_XGXS_WRITE_CL72_TXC_WAIT_TMRr
#define MODIFY_CL72_TXC_WAIT_TMRr BCMI_QTC_XGXS_MODIFY_CL72_TXC_WAIT_TMRr
#define READLN_CL72_TXC_WAIT_TMRr BCMI_QTC_XGXS_READLN_CL72_TXC_WAIT_TMRr
#define WRITELN_CL72_TXC_WAIT_TMRr BCMI_QTC_XGXS_WRITELN_CL72_TXC_WAIT_TMRr
#define WRITEALL_CL72_TXC_WAIT_TMRr BCMI_QTC_XGXS_WRITEALL_CL72_TXC_WAIT_TMRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_CL72_TXC_WAIT_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_RAMWORD
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd200
 * DEVAD:    1
 * DESC:     ramWord Register
 * SIZE:     32
 * FIELDS:
 *     MICRO_RAM_COUNT  number of bytes to be written in the program RAM during microocode load through the MDIO/register interface
 */
#define BCMI_QTC_XGXS_UC_RAMWORDr (0x0001d200 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_RAMWORDr_SIZE 4

/*
 * This structure should be used to declare and program UC_RAMWORD.
 */
typedef union BCMI_QTC_XGXS_UC_RAMWORDr_s {
	uint32_t v[1];
	uint32_t uc_ramword[1];
	uint32_t _uc_ramword;
} BCMI_QTC_XGXS_UC_RAMWORDr_t;

#define BCMI_QTC_XGXS_UC_RAMWORDr_CLR(r) (r).uc_ramword[0] = 0
#define BCMI_QTC_XGXS_UC_RAMWORDr_SET(r,d) (r).uc_ramword[0] = d
#define BCMI_QTC_XGXS_UC_RAMWORDr_GET(r) (r).uc_ramword[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_RAMWORDr_MICRO_RAM_COUNTf_GET(r) (((r).uc_ramword[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_RAMWORDr_MICRO_RAM_COUNTf_SET(r,f) (r).uc_ramword[0]=(((r).uc_ramword[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_RAMWORD.
 */
#define BCMI_QTC_XGXS_READ_UC_RAMWORDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_RAMWORDr,(_r._uc_ramword))
#define BCMI_QTC_XGXS_WRITE_UC_RAMWORDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAMWORDr,(_r._uc_ramword)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_RAMWORDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAMWORDr,(_r._uc_ramword))
#define BCMI_QTC_XGXS_READLN_UC_RAMWORDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_RAMWORDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ramword))
#define BCMI_QTC_XGXS_WRITELN_UC_RAMWORDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAMWORDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ramword))
#define BCMI_QTC_XGXS_WRITEALL_UC_RAMWORDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAMWORDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ramword))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_RAMWORDr BCMI_QTC_XGXS_UC_RAMWORDr
#define UC_RAMWORDr_SIZE BCMI_QTC_XGXS_UC_RAMWORDr_SIZE
typedef BCMI_QTC_XGXS_UC_RAMWORDr_t UC_RAMWORDr_t;
#define UC_RAMWORDr_CLR BCMI_QTC_XGXS_UC_RAMWORDr_CLR
#define UC_RAMWORDr_SET BCMI_QTC_XGXS_UC_RAMWORDr_SET
#define UC_RAMWORDr_GET BCMI_QTC_XGXS_UC_RAMWORDr_GET
#define UC_RAMWORDr_MICRO_RAM_COUNTf_GET BCMI_QTC_XGXS_UC_RAMWORDr_MICRO_RAM_COUNTf_GET
#define UC_RAMWORDr_MICRO_RAM_COUNTf_SET BCMI_QTC_XGXS_UC_RAMWORDr_MICRO_RAM_COUNTf_SET
#define READ_UC_RAMWORDr BCMI_QTC_XGXS_READ_UC_RAMWORDr
#define WRITE_UC_RAMWORDr BCMI_QTC_XGXS_WRITE_UC_RAMWORDr
#define MODIFY_UC_RAMWORDr BCMI_QTC_XGXS_MODIFY_UC_RAMWORDr
#define READLN_UC_RAMWORDr BCMI_QTC_XGXS_READLN_UC_RAMWORDr
#define WRITELN_UC_RAMWORDr BCMI_QTC_XGXS_WRITELN_UC_RAMWORDr
#define WRITEALL_UC_RAMWORDr BCMI_QTC_XGXS_WRITEALL_UC_RAMWORDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_RAMWORDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_ADDR
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd201
 * DEVAD:    1
 * DESC:     Adress Register
 * SIZE:     32
 * FIELDS:
 *     MICRO_RAM_ADDRESS RAM program/data RAM addressThese bits specify1) Start address of the Program RAM when microcode is loaded through the MDIO/register interface2) Program RAM address when the program RAM is accessed through the MDIO/register interface3) Data RAM address when the data RAM is accessed through the MDIO/register interface
 */
#define BCMI_QTC_XGXS_UC_ADDRr (0x0001d201 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program UC_ADDR.
 */
typedef union BCMI_QTC_XGXS_UC_ADDRr_s {
	uint32_t v[1];
	uint32_t uc_addr[1];
	uint32_t _uc_addr;
} BCMI_QTC_XGXS_UC_ADDRr_t;

#define BCMI_QTC_XGXS_UC_ADDRr_CLR(r) (r).uc_addr[0] = 0
#define BCMI_QTC_XGXS_UC_ADDRr_SET(r,d) (r).uc_addr[0] = d
#define BCMI_QTC_XGXS_UC_ADDRr_GET(r) (r).uc_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_ADDRr_MICRO_RAM_ADDRESSf_GET(r) (((r).uc_addr[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_ADDRr_MICRO_RAM_ADDRESSf_SET(r,f) (r).uc_addr[0]=(((r).uc_addr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_ADDR.
 */
#define BCMI_QTC_XGXS_READ_UC_ADDRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_ADDRr,(_r._uc_addr))
#define BCMI_QTC_XGXS_WRITE_UC_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_ADDRr,(_r._uc_addr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_ADDRr,(_r._uc_addr))
#define BCMI_QTC_XGXS_READLN_UC_ADDRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_addr))
#define BCMI_QTC_XGXS_WRITELN_UC_ADDRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_addr))
#define BCMI_QTC_XGXS_WRITEALL_UC_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_addr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_ADDRr BCMI_QTC_XGXS_UC_ADDRr
#define UC_ADDRr_SIZE BCMI_QTC_XGXS_UC_ADDRr_SIZE
typedef BCMI_QTC_XGXS_UC_ADDRr_t UC_ADDRr_t;
#define UC_ADDRr_CLR BCMI_QTC_XGXS_UC_ADDRr_CLR
#define UC_ADDRr_SET BCMI_QTC_XGXS_UC_ADDRr_SET
#define UC_ADDRr_GET BCMI_QTC_XGXS_UC_ADDRr_GET
#define UC_ADDRr_MICRO_RAM_ADDRESSf_GET BCMI_QTC_XGXS_UC_ADDRr_MICRO_RAM_ADDRESSf_GET
#define UC_ADDRr_MICRO_RAM_ADDRESSf_SET BCMI_QTC_XGXS_UC_ADDRr_MICRO_RAM_ADDRESSf_SET
#define READ_UC_ADDRr BCMI_QTC_XGXS_READ_UC_ADDRr
#define WRITE_UC_ADDRr BCMI_QTC_XGXS_WRITE_UC_ADDRr
#define MODIFY_UC_ADDRr BCMI_QTC_XGXS_MODIFY_UC_ADDRr
#define READLN_UC_ADDRr BCMI_QTC_XGXS_READLN_UC_ADDRr
#define WRITELN_UC_ADDRr BCMI_QTC_XGXS_WRITELN_UC_ADDRr
#define WRITEALL_UC_ADDRr BCMI_QTC_XGXS_WRITEALL_UC_ADDRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_COMMAND
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd202
 * DEVAD:    1
 * DESC:     Command Register
 * SIZE:     32
 * FIELDS:
 *     MICRO_RUN        start read/write to program RAM
 *     MICRO_STOP       stop read/write to program RAM
 *     MICRO_READ       Read program RAM to readback the microcode
 *     MICRO_WRITE      Write program RAM to load the microcode
 *     MICRO_MDIO_DW8051_RESET_N mdio DW8051 reset0 - asserted1 - de-asserted
 *     MICRO_MDIO_RAM_READ_AUTOINC_EN Auto-increment RAM address after read to the ram_rddata registers and read the next RAM location1 - Enabled0 - Disabled
 *     MICRO_MDIO_RAM_ACCESS_MODE ram access through the mdio (register interface) mode2'b00 - Program RAM load while DW8051 in reset2'b01 - Program RAM access while dw8051 could be running2'b10 - Data memory access while dw8051 could be running
 *     MICRO_BYTE_MODE  Program/Data RAM access through ram_wrdata and ram_rddata registers width1 - 8 bits (byte)0 - 16 bits (word)
 *     MICRO_MDIO_AUTOWAKEUP uc will automatically out of reset after the download is complete
 *     MICRO_MDIO_PROG_RAM_CS_FRC Force chip select to program RAM during mdio program write.0 = chip select to program RAM from mdio_to_program.1 = chip select to program RAM  is from mdio_prog_ram_cs_frc_val
 *     MICRO_MDIO_PROG_RAM_CS_FRC_VAL Force chip select to program RAM value.See mdio_prog_ram_cs_frc description.
 *     MICRO_PMI_HP_ACK_FRC Force pmi_hp_ack.0 = pmi_hp_ack to the DW8051_to_pmi fsm is from pmi_hp_ack pins.1 = pmi_hp_ack to the DW8051_to_pmi fsm is pmi_hp_ack_frc_val.
 *     MICRO_PMI_HP_ACK_FRC_VAL Force pmi_hp_ack value. See pmi_hp_ack_frc description.
 *     MICRO_INIT_CMD   Initialize program RAM commandThe program RAM can initialized (i.e. write zeroes all loactions) by setting this bitThis operation is normally required before the microcode is loaded to calculate the checksum
 */
#define BCMI_QTC_XGXS_UC_COMMANDr (0x0001d202 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_COMMANDr_SIZE 4

/*
 * This structure should be used to declare and program UC_COMMAND.
 */
typedef union BCMI_QTC_XGXS_UC_COMMANDr_s {
	uint32_t v[1];
	uint32_t uc_command[1];
	uint32_t _uc_command;
} BCMI_QTC_XGXS_UC_COMMANDr_t;

#define BCMI_QTC_XGXS_UC_COMMANDr_CLR(r) (r).uc_command[0] = 0
#define BCMI_QTC_XGXS_UC_COMMANDr_SET(r,d) (r).uc_command[0] = d
#define BCMI_QTC_XGXS_UC_COMMANDr_GET(r) (r).uc_command[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_INIT_CMDf_GET(r) ((((r).uc_command[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_INIT_CMDf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRC_VALf_GET(r) ((((r).uc_command[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRC_VALf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRCf_GET(r) ((((r).uc_command[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRCf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRC_VALf_GET(r) ((((r).uc_command[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRC_VALf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRCf_GET(r) ((((r).uc_command[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRCf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_AUTOWAKEUPf_GET(r) ((((r).uc_command[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_AUTOWAKEUPf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_BYTE_MODEf_GET(r) ((((r).uc_command[0]) >> 9) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_BYTE_MODEf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_ACCESS_MODEf_GET(r) ((((r).uc_command[0]) >> 7) & 0x3)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_ACCESS_MODEf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_READ_AUTOINC_ENf_GET(r) ((((r).uc_command[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_READ_AUTOINC_ENf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_DW8051_RESET_Nf_GET(r) ((((r).uc_command[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_DW8051_RESET_Nf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_WRITEf_GET(r) ((((r).uc_command[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_WRITEf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_READf_GET(r) ((((r).uc_command[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_READf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_STOPf_GET(r) ((((r).uc_command[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_STOPf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_RUNf_GET(r) (((r).uc_command[0]) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMANDr_MICRO_RUNf_SET(r,f) (r).uc_command[0]=(((r).uc_command[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access UC_COMMAND.
 */
#define BCMI_QTC_XGXS_READ_UC_COMMANDr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMANDr,(_r._uc_command))
#define BCMI_QTC_XGXS_WRITE_UC_COMMANDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMANDr,(_r._uc_command)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_COMMANDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMANDr,(_r._uc_command))
#define BCMI_QTC_XGXS_READLN_UC_COMMANDr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMANDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command))
#define BCMI_QTC_XGXS_WRITELN_UC_COMMANDr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMANDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command))
#define BCMI_QTC_XGXS_WRITEALL_UC_COMMANDr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMANDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_command))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_COMMANDr BCMI_QTC_XGXS_UC_COMMANDr
#define UC_COMMANDr_SIZE BCMI_QTC_XGXS_UC_COMMANDr_SIZE
typedef BCMI_QTC_XGXS_UC_COMMANDr_t UC_COMMANDr_t;
#define UC_COMMANDr_CLR BCMI_QTC_XGXS_UC_COMMANDr_CLR
#define UC_COMMANDr_SET BCMI_QTC_XGXS_UC_COMMANDr_SET
#define UC_COMMANDr_GET BCMI_QTC_XGXS_UC_COMMANDr_GET
#define UC_COMMANDr_MICRO_INIT_CMDf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_INIT_CMDf_GET
#define UC_COMMANDr_MICRO_INIT_CMDf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_INIT_CMDf_SET
#define UC_COMMANDr_MICRO_PMI_HP_ACK_FRC_VALf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRC_VALf_GET
#define UC_COMMANDr_MICRO_PMI_HP_ACK_FRC_VALf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRC_VALf_SET
#define UC_COMMANDr_MICRO_PMI_HP_ACK_FRCf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRCf_GET
#define UC_COMMANDr_MICRO_PMI_HP_ACK_FRCf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_PMI_HP_ACK_FRCf_SET
#define UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRC_VALf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRC_VALf_GET
#define UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRC_VALf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRC_VALf_SET
#define UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRCf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRCf_GET
#define UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRCf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_PROG_RAM_CS_FRCf_SET
#define UC_COMMANDr_MICRO_MDIO_AUTOWAKEUPf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_AUTOWAKEUPf_GET
#define UC_COMMANDr_MICRO_MDIO_AUTOWAKEUPf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_AUTOWAKEUPf_SET
#define UC_COMMANDr_MICRO_BYTE_MODEf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_BYTE_MODEf_GET
#define UC_COMMANDr_MICRO_BYTE_MODEf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_BYTE_MODEf_SET
#define UC_COMMANDr_MICRO_MDIO_RAM_ACCESS_MODEf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_ACCESS_MODEf_GET
#define UC_COMMANDr_MICRO_MDIO_RAM_ACCESS_MODEf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_ACCESS_MODEf_SET
#define UC_COMMANDr_MICRO_MDIO_RAM_READ_AUTOINC_ENf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_READ_AUTOINC_ENf_GET
#define UC_COMMANDr_MICRO_MDIO_RAM_READ_AUTOINC_ENf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_RAM_READ_AUTOINC_ENf_SET
#define UC_COMMANDr_MICRO_MDIO_DW8051_RESET_Nf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_DW8051_RESET_Nf_GET
#define UC_COMMANDr_MICRO_MDIO_DW8051_RESET_Nf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_MDIO_DW8051_RESET_Nf_SET
#define UC_COMMANDr_MICRO_WRITEf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_WRITEf_GET
#define UC_COMMANDr_MICRO_WRITEf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_WRITEf_SET
#define UC_COMMANDr_MICRO_READf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_READf_GET
#define UC_COMMANDr_MICRO_READf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_READf_SET
#define UC_COMMANDr_MICRO_STOPf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_STOPf_GET
#define UC_COMMANDr_MICRO_STOPf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_STOPf_SET
#define UC_COMMANDr_MICRO_RUNf_GET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_RUNf_GET
#define UC_COMMANDr_MICRO_RUNf_SET BCMI_QTC_XGXS_UC_COMMANDr_MICRO_RUNf_SET
#define READ_UC_COMMANDr BCMI_QTC_XGXS_READ_UC_COMMANDr
#define WRITE_UC_COMMANDr BCMI_QTC_XGXS_WRITE_UC_COMMANDr
#define MODIFY_UC_COMMANDr BCMI_QTC_XGXS_MODIFY_UC_COMMANDr
#define READLN_UC_COMMANDr BCMI_QTC_XGXS_READLN_UC_COMMANDr
#define WRITELN_UC_COMMANDr BCMI_QTC_XGXS_WRITELN_UC_COMMANDr
#define WRITEALL_UC_COMMANDr BCMI_QTC_XGXS_WRITEALL_UC_COMMANDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_COMMANDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_RAM_WRDATA
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd203
 * DEVAD:    1
 * DESC:     Write Data Register
 * SIZE:     32
 * FIELDS:
 *     MICRO_RAM_WRDATA Program/Data RAM write data
 */
#define BCMI_QTC_XGXS_UC_RAM_WRDATAr (0x0001d203 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_RAM_WRDATAr_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_WRDATA.
 */
typedef union BCMI_QTC_XGXS_UC_RAM_WRDATAr_s {
	uint32_t v[1];
	uint32_t uc_ram_wrdata[1];
	uint32_t _uc_ram_wrdata;
} BCMI_QTC_XGXS_UC_RAM_WRDATAr_t;

#define BCMI_QTC_XGXS_UC_RAM_WRDATAr_CLR(r) (r).uc_ram_wrdata[0] = 0
#define BCMI_QTC_XGXS_UC_RAM_WRDATAr_SET(r,d) (r).uc_ram_wrdata[0] = d
#define BCMI_QTC_XGXS_UC_RAM_WRDATAr_GET(r) (r).uc_ram_wrdata[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_RAM_WRDATAr_MICRO_RAM_WRDATAf_GET(r) (((r).uc_ram_wrdata[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_RAM_WRDATAr_MICRO_RAM_WRDATAf_SET(r,f) (r).uc_ram_wrdata[0]=(((r).uc_ram_wrdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_RAM_WRDATA.
 */
#define BCMI_QTC_XGXS_READ_UC_RAM_WRDATAr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_RAM_WRDATAr,(_r._uc_ram_wrdata))
#define BCMI_QTC_XGXS_WRITE_UC_RAM_WRDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_WRDATAr,(_r._uc_ram_wrdata)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_RAM_WRDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_WRDATAr,(_r._uc_ram_wrdata))
#define BCMI_QTC_XGXS_READLN_UC_RAM_WRDATAr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_RAM_WRDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_wrdata))
#define BCMI_QTC_XGXS_WRITELN_UC_RAM_WRDATAr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_WRDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_wrdata))
#define BCMI_QTC_XGXS_WRITEALL_UC_RAM_WRDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_WRDATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_wrdata))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_WRDATAr BCMI_QTC_XGXS_UC_RAM_WRDATAr
#define UC_RAM_WRDATAr_SIZE BCMI_QTC_XGXS_UC_RAM_WRDATAr_SIZE
typedef BCMI_QTC_XGXS_UC_RAM_WRDATAr_t UC_RAM_WRDATAr_t;
#define UC_RAM_WRDATAr_CLR BCMI_QTC_XGXS_UC_RAM_WRDATAr_CLR
#define UC_RAM_WRDATAr_SET BCMI_QTC_XGXS_UC_RAM_WRDATAr_SET
#define UC_RAM_WRDATAr_GET BCMI_QTC_XGXS_UC_RAM_WRDATAr_GET
#define UC_RAM_WRDATAr_MICRO_RAM_WRDATAf_GET BCMI_QTC_XGXS_UC_RAM_WRDATAr_MICRO_RAM_WRDATAf_GET
#define UC_RAM_WRDATAr_MICRO_RAM_WRDATAf_SET BCMI_QTC_XGXS_UC_RAM_WRDATAr_MICRO_RAM_WRDATAf_SET
#define READ_UC_RAM_WRDATAr BCMI_QTC_XGXS_READ_UC_RAM_WRDATAr
#define WRITE_UC_RAM_WRDATAr BCMI_QTC_XGXS_WRITE_UC_RAM_WRDATAr
#define MODIFY_UC_RAM_WRDATAr BCMI_QTC_XGXS_MODIFY_UC_RAM_WRDATAr
#define READLN_UC_RAM_WRDATAr BCMI_QTC_XGXS_READLN_UC_RAM_WRDATAr
#define WRITELN_UC_RAM_WRDATAr BCMI_QTC_XGXS_WRITELN_UC_RAM_WRDATAr
#define WRITEALL_UC_RAM_WRDATAr BCMI_QTC_XGXS_WRITEALL_UC_RAM_WRDATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_RAM_WRDATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_RAM_RDDATA
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd204
 * DEVAD:    1
 * DESC:     Read Data Register
 * SIZE:     32
 * FIELDS:
 *     MICRO_RAM_RDDATA Program/Data RAM read data
 */
#define BCMI_QTC_XGXS_UC_RAM_RDDATAr (0x0001d204 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_RAM_RDDATAr_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_RDDATA.
 */
typedef union BCMI_QTC_XGXS_UC_RAM_RDDATAr_s {
	uint32_t v[1];
	uint32_t uc_ram_rddata[1];
	uint32_t _uc_ram_rddata;
} BCMI_QTC_XGXS_UC_RAM_RDDATAr_t;

#define BCMI_QTC_XGXS_UC_RAM_RDDATAr_CLR(r) (r).uc_ram_rddata[0] = 0
#define BCMI_QTC_XGXS_UC_RAM_RDDATAr_SET(r,d) (r).uc_ram_rddata[0] = d
#define BCMI_QTC_XGXS_UC_RAM_RDDATAr_GET(r) (r).uc_ram_rddata[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_RAM_RDDATAr_MICRO_RAM_RDDATAf_GET(r) (((r).uc_ram_rddata[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_RAM_RDDATAr_MICRO_RAM_RDDATAf_SET(r,f) (r).uc_ram_rddata[0]=(((r).uc_ram_rddata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_RAM_RDDATA.
 */
#define BCMI_QTC_XGXS_READ_UC_RAM_RDDATAr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_RAM_RDDATAr,(_r._uc_ram_rddata))
#define BCMI_QTC_XGXS_WRITE_UC_RAM_RDDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_RDDATAr,(_r._uc_ram_rddata)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_RAM_RDDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_RDDATAr,(_r._uc_ram_rddata))
#define BCMI_QTC_XGXS_READLN_UC_RAM_RDDATAr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_RAM_RDDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_rddata))
#define BCMI_QTC_XGXS_WRITELN_UC_RAM_RDDATAr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_RDDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_rddata))
#define BCMI_QTC_XGXS_WRITEALL_UC_RAM_RDDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_RAM_RDDATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_rddata))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_RDDATAr BCMI_QTC_XGXS_UC_RAM_RDDATAr
#define UC_RAM_RDDATAr_SIZE BCMI_QTC_XGXS_UC_RAM_RDDATAr_SIZE
typedef BCMI_QTC_XGXS_UC_RAM_RDDATAr_t UC_RAM_RDDATAr_t;
#define UC_RAM_RDDATAr_CLR BCMI_QTC_XGXS_UC_RAM_RDDATAr_CLR
#define UC_RAM_RDDATAr_SET BCMI_QTC_XGXS_UC_RAM_RDDATAr_SET
#define UC_RAM_RDDATAr_GET BCMI_QTC_XGXS_UC_RAM_RDDATAr_GET
#define UC_RAM_RDDATAr_MICRO_RAM_RDDATAf_GET BCMI_QTC_XGXS_UC_RAM_RDDATAr_MICRO_RAM_RDDATAf_GET
#define UC_RAM_RDDATAr_MICRO_RAM_RDDATAf_SET BCMI_QTC_XGXS_UC_RAM_RDDATAr_MICRO_RAM_RDDATAf_SET
#define READ_UC_RAM_RDDATAr BCMI_QTC_XGXS_READ_UC_RAM_RDDATAr
#define WRITE_UC_RAM_RDDATAr BCMI_QTC_XGXS_WRITE_UC_RAM_RDDATAr
#define MODIFY_UC_RAM_RDDATAr BCMI_QTC_XGXS_MODIFY_UC_RAM_RDDATAr
#define READLN_UC_RAM_RDDATAr BCMI_QTC_XGXS_READLN_UC_RAM_RDDATAr
#define WRITELN_UC_RAM_RDDATAr BCMI_QTC_XGXS_WRITELN_UC_RAM_RDDATAr
#define WRITEALL_UC_RAM_RDDATAr BCMI_QTC_XGXS_WRITEALL_UC_RAM_RDDATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_RAM_RDDATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_DWNLOAD_STS
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd205
 * DEVAD:    1
 * DESC:     MDIO to 8051 FSM Status Register
 * SIZE:     32
 * FIELDS:
 *     MICRO_ERR0       set when user change the start_address during burst rd/wr
 *     MICRO_ERR1       set when user stop during burst rd/wr
 *     MICRO_FSM        FSM value
 *     MICRO_INIT_DONE  Program RAM initialization done
 */
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr (0x0001d205 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_SIZE 4

/*
 * This structure should be used to declare and program UC_DWNLOAD_STS.
 */
typedef union BCMI_QTC_XGXS_UC_DWNLOAD_STSr_s {
	uint32_t v[1];
	uint32_t uc_dwnload_sts[1];
	uint32_t _uc_dwnload_sts;
} BCMI_QTC_XGXS_UC_DWNLOAD_STSr_t;

#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_CLR(r) (r).uc_dwnload_sts[0] = 0
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_SET(r,d) (r).uc_dwnload_sts[0] = d
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_GET(r) (r).uc_dwnload_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_INIT_DONEf_GET(r) ((((r).uc_dwnload_sts[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_INIT_DONEf_SET(r,f) (r).uc_dwnload_sts[0]=(((r).uc_dwnload_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_FSMf_GET(r) ((((r).uc_dwnload_sts[0]) >> 2) & 0xf)
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_FSMf_SET(r,f) (r).uc_dwnload_sts[0]=(((r).uc_dwnload_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR1f_GET(r) ((((r).uc_dwnload_sts[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR1f_SET(r,f) (r).uc_dwnload_sts[0]=(((r).uc_dwnload_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR0f_GET(r) (((r).uc_dwnload_sts[0]) & 0x1)
#define BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR0f_SET(r,f) (r).uc_dwnload_sts[0]=(((r).uc_dwnload_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access UC_DWNLOAD_STS.
 */
#define BCMI_QTC_XGXS_READ_UC_DWNLOAD_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_DWNLOAD_STSr,(_r._uc_dwnload_sts))
#define BCMI_QTC_XGXS_WRITE_UC_DWNLOAD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DWNLOAD_STSr,(_r._uc_dwnload_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_DWNLOAD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DWNLOAD_STSr,(_r._uc_dwnload_sts))
#define BCMI_QTC_XGXS_READLN_UC_DWNLOAD_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_DWNLOAD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_dwnload_sts))
#define BCMI_QTC_XGXS_WRITELN_UC_DWNLOAD_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DWNLOAD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_dwnload_sts))
#define BCMI_QTC_XGXS_WRITEALL_UC_DWNLOAD_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DWNLOAD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_dwnload_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_DWNLOAD_STSr BCMI_QTC_XGXS_UC_DWNLOAD_STSr
#define UC_DWNLOAD_STSr_SIZE BCMI_QTC_XGXS_UC_DWNLOAD_STSr_SIZE
typedef BCMI_QTC_XGXS_UC_DWNLOAD_STSr_t UC_DWNLOAD_STSr_t;
#define UC_DWNLOAD_STSr_CLR BCMI_QTC_XGXS_UC_DWNLOAD_STSr_CLR
#define UC_DWNLOAD_STSr_SET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_SET
#define UC_DWNLOAD_STSr_GET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_GET
#define UC_DWNLOAD_STSr_MICRO_INIT_DONEf_GET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_INIT_DONEf_GET
#define UC_DWNLOAD_STSr_MICRO_INIT_DONEf_SET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_INIT_DONEf_SET
#define UC_DWNLOAD_STSr_MICRO_FSMf_GET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_FSMf_GET
#define UC_DWNLOAD_STSr_MICRO_FSMf_SET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_FSMf_SET
#define UC_DWNLOAD_STSr_MICRO_ERR1f_GET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR1f_GET
#define UC_DWNLOAD_STSr_MICRO_ERR1f_SET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR1f_SET
#define UC_DWNLOAD_STSr_MICRO_ERR0f_GET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR0f_GET
#define UC_DWNLOAD_STSr_MICRO_ERR0f_SET BCMI_QTC_XGXS_UC_DWNLOAD_STSr_MICRO_ERR0f_SET
#define READ_UC_DWNLOAD_STSr BCMI_QTC_XGXS_READ_UC_DWNLOAD_STSr
#define WRITE_UC_DWNLOAD_STSr BCMI_QTC_XGXS_WRITE_UC_DWNLOAD_STSr
#define MODIFY_UC_DWNLOAD_STSr BCMI_QTC_XGXS_MODIFY_UC_DWNLOAD_STSr
#define READLN_UC_DWNLOAD_STSr BCMI_QTC_XGXS_READLN_UC_DWNLOAD_STSr
#define WRITELN_UC_DWNLOAD_STSr BCMI_QTC_XGXS_WRITELN_UC_DWNLOAD_STSr
#define WRITEALL_UC_DWNLOAD_STSr BCMI_QTC_XGXS_WRITEALL_UC_DWNLOAD_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_DWNLOAD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_SFR_STS
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd206
 * DEVAD:    1
 * DESC:     Status Register 1
 * SIZE:     32
 * FIELDS:
 *     MICRO_STATUS_MUXED when command3.gen_status_sel == 0error correction counter value{uncorrectable_error_counter, correctable_error_counter}cleared upon readwhen command3.gen_status_sel == 1mdio program load fsm status{curst[3:0], 1'b0, his_state[10:0]}his_state detects state transitioncleared upon readwhen command3.gen_status_sel == 2mdio program ram access fsm status{state[3:0], 3'd0,his_state[8:0]}his_state detects state transitioncleared upon readwhen command3.gen_status_sel == 3mdio dataram ram access fsm status{state[3:0], 3'd0, his_state[8:0]}his_state detects state transitioncleared upon readwhen command3.gen_status_sel == 4dw8051_to_pmi fsm status{pmi_state[2:0], 7'd0,  pmi_ack_timeout_status, his_state[4:0]}his_state detects state transitioncleared upon read
 */
#define BCMI_QTC_XGXS_UC_SFR_STSr (0x0001d206 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_SFR_STSr_SIZE 4

/*
 * This structure should be used to declare and program UC_SFR_STS.
 */
typedef union BCMI_QTC_XGXS_UC_SFR_STSr_s {
	uint32_t v[1];
	uint32_t uc_sfr_sts[1];
	uint32_t _uc_sfr_sts;
} BCMI_QTC_XGXS_UC_SFR_STSr_t;

#define BCMI_QTC_XGXS_UC_SFR_STSr_CLR(r) (r).uc_sfr_sts[0] = 0
#define BCMI_QTC_XGXS_UC_SFR_STSr_SET(r,d) (r).uc_sfr_sts[0] = d
#define BCMI_QTC_XGXS_UC_SFR_STSr_GET(r) (r).uc_sfr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_SFR_STSr_MICRO_STATUS_MUXEDf_GET(r) (((r).uc_sfr_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_SFR_STSr_MICRO_STATUS_MUXEDf_SET(r,f) (r).uc_sfr_sts[0]=(((r).uc_sfr_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_SFR_STS.
 */
#define BCMI_QTC_XGXS_READ_UC_SFR_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_SFR_STSr,(_r._uc_sfr_sts))
#define BCMI_QTC_XGXS_WRITE_UC_SFR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_SFR_STSr,(_r._uc_sfr_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_SFR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_SFR_STSr,(_r._uc_sfr_sts))
#define BCMI_QTC_XGXS_READLN_UC_SFR_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_SFR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_sfr_sts))
#define BCMI_QTC_XGXS_WRITELN_UC_SFR_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_SFR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_sfr_sts))
#define BCMI_QTC_XGXS_WRITEALL_UC_SFR_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_SFR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_sfr_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_SFR_STSr BCMI_QTC_XGXS_UC_SFR_STSr
#define UC_SFR_STSr_SIZE BCMI_QTC_XGXS_UC_SFR_STSr_SIZE
typedef BCMI_QTC_XGXS_UC_SFR_STSr_t UC_SFR_STSr_t;
#define UC_SFR_STSr_CLR BCMI_QTC_XGXS_UC_SFR_STSr_CLR
#define UC_SFR_STSr_SET BCMI_QTC_XGXS_UC_SFR_STSr_SET
#define UC_SFR_STSr_GET BCMI_QTC_XGXS_UC_SFR_STSr_GET
#define UC_SFR_STSr_MICRO_STATUS_MUXEDf_GET BCMI_QTC_XGXS_UC_SFR_STSr_MICRO_STATUS_MUXEDf_GET
#define UC_SFR_STSr_MICRO_STATUS_MUXEDf_SET BCMI_QTC_XGXS_UC_SFR_STSr_MICRO_STATUS_MUXEDf_SET
#define READ_UC_SFR_STSr BCMI_QTC_XGXS_READ_UC_SFR_STSr
#define WRITE_UC_SFR_STSr BCMI_QTC_XGXS_WRITE_UC_SFR_STSr
#define MODIFY_UC_SFR_STSr BCMI_QTC_XGXS_MODIFY_UC_SFR_STSr
#define READLN_UC_SFR_STSr BCMI_QTC_XGXS_READLN_UC_SFR_STSr
#define WRITELN_UC_SFR_STSr BCMI_QTC_XGXS_WRITELN_UC_SFR_STSr
#define WRITEALL_UC_SFR_STSr BCMI_QTC_XGXS_WRITEALL_UC_SFR_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_SFR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_MDIO_UC_MAILBOX_MSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd207
 * DEVAD:    1
 * DESC:     External station to uc mailbox MSW
 * SIZE:     32
 * FIELDS:
 *     MICRO_MDIO_UC_MAILBOX_MSW mdio to micro mailbox register MS word
 */
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr (0x0001d207 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_MDIO_UC_MAILBOX_MSW.
 */
typedef union BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_s {
	uint32_t v[1];
	uint32_t uc_mdio_uc_mailbox_msw[1];
	uint32_t _uc_mdio_uc_mailbox_msw;
} BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_t;

#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_CLR(r) (r).uc_mdio_uc_mailbox_msw[0] = 0
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_SET(r,d) (r).uc_mdio_uc_mailbox_msw[0] = d
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_GET(r) (r).uc_mdio_uc_mailbox_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_MICRO_MDIO_UC_MAILBOX_MSWf_GET(r) (((r).uc_mdio_uc_mailbox_msw[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_MICRO_MDIO_UC_MAILBOX_MSWf_SET(r,f) (r).uc_mdio_uc_mailbox_msw[0]=(((r).uc_mdio_uc_mailbox_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_MDIO_UC_MAILBOX_MSW.
 */
#define BCMI_QTC_XGXS_READ_UC_MDIO_UC_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr,(_r._uc_mdio_uc_mailbox_msw))
#define BCMI_QTC_XGXS_WRITE_UC_MDIO_UC_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr,(_r._uc_mdio_uc_mailbox_msw)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_MDIO_UC_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr,(_r._uc_mdio_uc_mailbox_msw))
#define BCMI_QTC_XGXS_READLN_UC_MDIO_UC_MAILBOX_MSWr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_mdio_uc_mailbox_msw))
#define BCMI_QTC_XGXS_WRITELN_UC_MDIO_UC_MAILBOX_MSWr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_mdio_uc_mailbox_msw))
#define BCMI_QTC_XGXS_WRITEALL_UC_MDIO_UC_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_mdio_uc_mailbox_msw))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_MDIO_UC_MAILBOX_MSWr BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr
#define UC_MDIO_UC_MAILBOX_MSWr_SIZE BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_SIZE
typedef BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_t UC_MDIO_UC_MAILBOX_MSWr_t;
#define UC_MDIO_UC_MAILBOX_MSWr_CLR BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_CLR
#define UC_MDIO_UC_MAILBOX_MSWr_SET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_SET
#define UC_MDIO_UC_MAILBOX_MSWr_GET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_GET
#define UC_MDIO_UC_MAILBOX_MSWr_MICRO_MDIO_UC_MAILBOX_MSWf_GET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_MICRO_MDIO_UC_MAILBOX_MSWf_GET
#define UC_MDIO_UC_MAILBOX_MSWr_MICRO_MDIO_UC_MAILBOX_MSWf_SET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr_MICRO_MDIO_UC_MAILBOX_MSWf_SET
#define READ_UC_MDIO_UC_MAILBOX_MSWr BCMI_QTC_XGXS_READ_UC_MDIO_UC_MAILBOX_MSWr
#define WRITE_UC_MDIO_UC_MAILBOX_MSWr BCMI_QTC_XGXS_WRITE_UC_MDIO_UC_MAILBOX_MSWr
#define MODIFY_UC_MDIO_UC_MAILBOX_MSWr BCMI_QTC_XGXS_MODIFY_UC_MDIO_UC_MAILBOX_MSWr
#define READLN_UC_MDIO_UC_MAILBOX_MSWr BCMI_QTC_XGXS_READLN_UC_MDIO_UC_MAILBOX_MSWr
#define WRITELN_UC_MDIO_UC_MAILBOX_MSWr BCMI_QTC_XGXS_WRITELN_UC_MDIO_UC_MAILBOX_MSWr
#define WRITEALL_UC_MDIO_UC_MAILBOX_MSWr BCMI_QTC_XGXS_WRITEALL_UC_MDIO_UC_MAILBOX_MSWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_MDIO_UC_MAILBOX_LSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd208
 * DEVAD:    1
 * DESC:     External station to uc mailbox LSW
 * SIZE:     32
 * FIELDS:
 *     MICRO_MDIO_UC_MAILBOX_LSW mdio to micro mailbox register LS word
 */
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr (0x0001d208 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_MDIO_UC_MAILBOX_LSW.
 */
typedef union BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_s {
	uint32_t v[1];
	uint32_t uc_mdio_uc_mailbox_lsw[1];
	uint32_t _uc_mdio_uc_mailbox_lsw;
} BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_t;

#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_CLR(r) (r).uc_mdio_uc_mailbox_lsw[0] = 0
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_SET(r,d) (r).uc_mdio_uc_mailbox_lsw[0] = d
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_GET(r) (r).uc_mdio_uc_mailbox_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_MICRO_MDIO_UC_MAILBOX_LSWf_GET(r) (((r).uc_mdio_uc_mailbox_lsw[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_MICRO_MDIO_UC_MAILBOX_LSWf_SET(r,f) (r).uc_mdio_uc_mailbox_lsw[0]=(((r).uc_mdio_uc_mailbox_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_MDIO_UC_MAILBOX_LSW.
 */
#define BCMI_QTC_XGXS_READ_UC_MDIO_UC_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr,(_r._uc_mdio_uc_mailbox_lsw))
#define BCMI_QTC_XGXS_WRITE_UC_MDIO_UC_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr,(_r._uc_mdio_uc_mailbox_lsw)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_MDIO_UC_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr,(_r._uc_mdio_uc_mailbox_lsw))
#define BCMI_QTC_XGXS_READLN_UC_MDIO_UC_MAILBOX_LSWr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_mdio_uc_mailbox_lsw))
#define BCMI_QTC_XGXS_WRITELN_UC_MDIO_UC_MAILBOX_LSWr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_mdio_uc_mailbox_lsw))
#define BCMI_QTC_XGXS_WRITEALL_UC_MDIO_UC_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_mdio_uc_mailbox_lsw))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_MDIO_UC_MAILBOX_LSWr BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr
#define UC_MDIO_UC_MAILBOX_LSWr_SIZE BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_SIZE
typedef BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_t UC_MDIO_UC_MAILBOX_LSWr_t;
#define UC_MDIO_UC_MAILBOX_LSWr_CLR BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_CLR
#define UC_MDIO_UC_MAILBOX_LSWr_SET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_SET
#define UC_MDIO_UC_MAILBOX_LSWr_GET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_GET
#define UC_MDIO_UC_MAILBOX_LSWr_MICRO_MDIO_UC_MAILBOX_LSWf_GET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_MICRO_MDIO_UC_MAILBOX_LSWf_GET
#define UC_MDIO_UC_MAILBOX_LSWr_MICRO_MDIO_UC_MAILBOX_LSWf_SET BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr_MICRO_MDIO_UC_MAILBOX_LSWf_SET
#define READ_UC_MDIO_UC_MAILBOX_LSWr BCMI_QTC_XGXS_READ_UC_MDIO_UC_MAILBOX_LSWr
#define WRITE_UC_MDIO_UC_MAILBOX_LSWr BCMI_QTC_XGXS_WRITE_UC_MDIO_UC_MAILBOX_LSWr
#define MODIFY_UC_MDIO_UC_MAILBOX_LSWr BCMI_QTC_XGXS_MODIFY_UC_MDIO_UC_MAILBOX_LSWr
#define READLN_UC_MDIO_UC_MAILBOX_LSWr BCMI_QTC_XGXS_READLN_UC_MDIO_UC_MAILBOX_LSWr
#define WRITELN_UC_MDIO_UC_MAILBOX_LSWr BCMI_QTC_XGXS_WRITELN_UC_MDIO_UC_MAILBOX_LSWr
#define WRITEALL_UC_MDIO_UC_MAILBOX_LSWr BCMI_QTC_XGXS_WRITEALL_UC_MDIO_UC_MAILBOX_LSWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_MDIO_UC_MAILBOX_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_UC_MDIO_MAILBOX_LSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd209
 * DEVAD:    1
 * DESC:     uc to external station mailbox LSW
 * SIZE:     32
 * FIELDS:
 *     MICRO_UC_MDIO_MAILBOX_LSW micro to mdio mailbox register LS word
 */
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr (0x0001d209 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_MDIO_MAILBOX_LSW.
 */
typedef union BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_s {
	uint32_t v[1];
	uint32_t uc_uc_mdio_mailbox_lsw[1];
	uint32_t _uc_uc_mdio_mailbox_lsw;
} BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_t;

#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_CLR(r) (r).uc_uc_mdio_mailbox_lsw[0] = 0
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_SET(r,d) (r).uc_uc_mdio_mailbox_lsw[0] = d
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_GET(r) (r).uc_uc_mdio_mailbox_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_MICRO_UC_MDIO_MAILBOX_LSWf_GET(r) (((r).uc_uc_mdio_mailbox_lsw[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_MICRO_UC_MDIO_MAILBOX_LSWf_SET(r,f) (r).uc_uc_mdio_mailbox_lsw[0]=(((r).uc_uc_mdio_mailbox_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_UC_MDIO_MAILBOX_LSW.
 */
#define BCMI_QTC_XGXS_READ_UC_UC_MDIO_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr,(_r._uc_uc_mdio_mailbox_lsw))
#define BCMI_QTC_XGXS_WRITE_UC_UC_MDIO_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr,(_r._uc_uc_mdio_mailbox_lsw)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_UC_MDIO_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr,(_r._uc_uc_mdio_mailbox_lsw))
#define BCMI_QTC_XGXS_READLN_UC_UC_MDIO_MAILBOX_LSWr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_mdio_mailbox_lsw))
#define BCMI_QTC_XGXS_WRITELN_UC_UC_MDIO_MAILBOX_LSWr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_mdio_mailbox_lsw))
#define BCMI_QTC_XGXS_WRITEALL_UC_UC_MDIO_MAILBOX_LSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_mdio_mailbox_lsw))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_MDIO_MAILBOX_LSWr BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr
#define UC_UC_MDIO_MAILBOX_LSWr_SIZE BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_SIZE
typedef BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_t UC_UC_MDIO_MAILBOX_LSWr_t;
#define UC_UC_MDIO_MAILBOX_LSWr_CLR BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_CLR
#define UC_UC_MDIO_MAILBOX_LSWr_SET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_SET
#define UC_UC_MDIO_MAILBOX_LSWr_GET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_GET
#define UC_UC_MDIO_MAILBOX_LSWr_MICRO_UC_MDIO_MAILBOX_LSWf_GET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_MICRO_UC_MDIO_MAILBOX_LSWf_GET
#define UC_UC_MDIO_MAILBOX_LSWr_MICRO_UC_MDIO_MAILBOX_LSWf_SET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr_MICRO_UC_MDIO_MAILBOX_LSWf_SET
#define READ_UC_UC_MDIO_MAILBOX_LSWr BCMI_QTC_XGXS_READ_UC_UC_MDIO_MAILBOX_LSWr
#define WRITE_UC_UC_MDIO_MAILBOX_LSWr BCMI_QTC_XGXS_WRITE_UC_UC_MDIO_MAILBOX_LSWr
#define MODIFY_UC_UC_MDIO_MAILBOX_LSWr BCMI_QTC_XGXS_MODIFY_UC_UC_MDIO_MAILBOX_LSWr
#define READLN_UC_UC_MDIO_MAILBOX_LSWr BCMI_QTC_XGXS_READLN_UC_UC_MDIO_MAILBOX_LSWr
#define WRITELN_UC_UC_MDIO_MAILBOX_LSWr BCMI_QTC_XGXS_WRITELN_UC_UC_MDIO_MAILBOX_LSWr
#define WRITEALL_UC_UC_MDIO_MAILBOX_LSWr BCMI_QTC_XGXS_WRITEALL_UC_UC_MDIO_MAILBOX_LSWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_COMMAND2
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20a
 * DEVAD:    1
 * DESC:     Command Register 2
 * SIZE:     32
 * FIELDS:
 *     MICRO_PMI_ACK_TIMEOUT_VAL pmi ack timeout valueThese bits specify number of micro clocks the dw8051 wait for an ack from RMICIf the micro does not receive an ACK within the number of clock specified,  then itset the pmi_ack_timeout_status bit in the status register
 *     MICRO_SRST_MDIO_DATARAM_ACCESS Software reset for the mdio_dataram_access block0 - de-asserted1 - asserted
 *     MICRO_RAM_CLK_INVERT invert clock to the RAM's
 *     MICRO_ZERO_ROM_DATAOUT zero out program memory output
 *     MICRO_SRST_MDIO_LOAD_PROGRAM_RAM Software reset for mdio_load_program_ram block0 - de-asserted1 - asserted
 *     MICRO_SRST_MDIO_PROGRAM_ACCESS Software reset for the mdio_program_access block0 - de-asserted1 - asserted
 *     MICRO_SRST_DW8051_TO_PMI Software reset for the dw8051_to_pmi block0 - de-asserted1 - asserted
 */
#define BCMI_QTC_XGXS_UC_COMMAND2r (0x0001d20a | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_COMMAND2r_SIZE 4

/*
 * This structure should be used to declare and program UC_COMMAND2.
 */
typedef union BCMI_QTC_XGXS_UC_COMMAND2r_s {
	uint32_t v[1];
	uint32_t uc_command2[1];
	uint32_t _uc_command2;
} BCMI_QTC_XGXS_UC_COMMAND2r_t;

#define BCMI_QTC_XGXS_UC_COMMAND2r_CLR(r) (r).uc_command2[0] = 0
#define BCMI_QTC_XGXS_UC_COMMAND2r_SET(r,d) (r).uc_command2[0] = d
#define BCMI_QTC_XGXS_UC_COMMAND2r_GET(r) (r).uc_command2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_DW8051_TO_PMIf_GET(r) ((((r).uc_command2[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_DW8051_TO_PMIf_SET(r,f) (r).uc_command2[0]=(((r).uc_command2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_PROGRAM_ACCESSf_GET(r) ((((r).uc_command2[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_PROGRAM_ACCESSf_SET(r,f) (r).uc_command2[0]=(((r).uc_command2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_LOAD_PROGRAM_RAMf_GET(r) ((((r).uc_command2[0]) >> 13) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_LOAD_PROGRAM_RAMf_SET(r,f) (r).uc_command2[0]=(((r).uc_command2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_ZERO_ROM_DATAOUTf_GET(r) ((((r).uc_command2[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_ZERO_ROM_DATAOUTf_SET(r,f) (r).uc_command2[0]=(((r).uc_command2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_RAM_CLK_INVERTf_GET(r) ((((r).uc_command2[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_RAM_CLK_INVERTf_SET(r,f) (r).uc_command2[0]=(((r).uc_command2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_DATARAM_ACCESSf_GET(r) ((((r).uc_command2[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_DATARAM_ACCESSf_SET(r,f) (r).uc_command2[0]=(((r).uc_command2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_PMI_ACK_TIMEOUT_VALf_GET(r) (((r).uc_command2[0]) & 0xf)
#define BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_PMI_ACK_TIMEOUT_VALf_SET(r,f) (r).uc_command2[0]=(((r).uc_command2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (15 << 16)

/*
 * These macros can be used to access UC_COMMAND2.
 */
#define BCMI_QTC_XGXS_READ_UC_COMMAND2r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMAND2r,(_r._uc_command2))
#define BCMI_QTC_XGXS_WRITE_UC_COMMAND2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND2r,(_r._uc_command2)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_COMMAND2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND2r,(_r._uc_command2))
#define BCMI_QTC_XGXS_READLN_UC_COMMAND2r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMAND2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command2))
#define BCMI_QTC_XGXS_WRITELN_UC_COMMAND2r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command2))
#define BCMI_QTC_XGXS_WRITEALL_UC_COMMAND2r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_command2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_COMMAND2r BCMI_QTC_XGXS_UC_COMMAND2r
#define UC_COMMAND2r_SIZE BCMI_QTC_XGXS_UC_COMMAND2r_SIZE
typedef BCMI_QTC_XGXS_UC_COMMAND2r_t UC_COMMAND2r_t;
#define UC_COMMAND2r_CLR BCMI_QTC_XGXS_UC_COMMAND2r_CLR
#define UC_COMMAND2r_SET BCMI_QTC_XGXS_UC_COMMAND2r_SET
#define UC_COMMAND2r_GET BCMI_QTC_XGXS_UC_COMMAND2r_GET
#define UC_COMMAND2r_MICRO_SRST_DW8051_TO_PMIf_GET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_DW8051_TO_PMIf_GET
#define UC_COMMAND2r_MICRO_SRST_DW8051_TO_PMIf_SET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_DW8051_TO_PMIf_SET
#define UC_COMMAND2r_MICRO_SRST_MDIO_PROGRAM_ACCESSf_GET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_PROGRAM_ACCESSf_GET
#define UC_COMMAND2r_MICRO_SRST_MDIO_PROGRAM_ACCESSf_SET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_PROGRAM_ACCESSf_SET
#define UC_COMMAND2r_MICRO_SRST_MDIO_LOAD_PROGRAM_RAMf_GET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_LOAD_PROGRAM_RAMf_GET
#define UC_COMMAND2r_MICRO_SRST_MDIO_LOAD_PROGRAM_RAMf_SET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_LOAD_PROGRAM_RAMf_SET
#define UC_COMMAND2r_MICRO_ZERO_ROM_DATAOUTf_GET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_ZERO_ROM_DATAOUTf_GET
#define UC_COMMAND2r_MICRO_ZERO_ROM_DATAOUTf_SET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_ZERO_ROM_DATAOUTf_SET
#define UC_COMMAND2r_MICRO_RAM_CLK_INVERTf_GET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_RAM_CLK_INVERTf_GET
#define UC_COMMAND2r_MICRO_RAM_CLK_INVERTf_SET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_RAM_CLK_INVERTf_SET
#define UC_COMMAND2r_MICRO_SRST_MDIO_DATARAM_ACCESSf_GET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_DATARAM_ACCESSf_GET
#define UC_COMMAND2r_MICRO_SRST_MDIO_DATARAM_ACCESSf_SET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_SRST_MDIO_DATARAM_ACCESSf_SET
#define UC_COMMAND2r_MICRO_PMI_ACK_TIMEOUT_VALf_GET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_PMI_ACK_TIMEOUT_VALf_GET
#define UC_COMMAND2r_MICRO_PMI_ACK_TIMEOUT_VALf_SET BCMI_QTC_XGXS_UC_COMMAND2r_MICRO_PMI_ACK_TIMEOUT_VALf_SET
#define READ_UC_COMMAND2r BCMI_QTC_XGXS_READ_UC_COMMAND2r
#define WRITE_UC_COMMAND2r BCMI_QTC_XGXS_WRITE_UC_COMMAND2r
#define MODIFY_UC_COMMAND2r BCMI_QTC_XGXS_MODIFY_UC_COMMAND2r
#define READLN_UC_COMMAND2r BCMI_QTC_XGXS_READLN_UC_COMMAND2r
#define WRITELN_UC_COMMAND2r BCMI_QTC_XGXS_WRITELN_UC_COMMAND2r
#define WRITEALL_UC_COMMAND2r BCMI_QTC_XGXS_WRITEALL_UC_COMMAND2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_COMMAND2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_UC_MDIO_MAILBOX_MSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20b
 * DEVAD:    1
 * DESC:     uc to external station mailbox MSW
 * SIZE:     32
 * FIELDS:
 *     MICRO_UC_MDIO_MAILBOX_MSW micro to mdio mailbox register MS word
 */
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr (0x0001d20b | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_MDIO_MAILBOX_MSW.
 */
typedef union BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_s {
	uint32_t v[1];
	uint32_t uc_uc_mdio_mailbox_msw[1];
	uint32_t _uc_uc_mdio_mailbox_msw;
} BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_t;

#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_CLR(r) (r).uc_uc_mdio_mailbox_msw[0] = 0
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_SET(r,d) (r).uc_uc_mdio_mailbox_msw[0] = d
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_GET(r) (r).uc_uc_mdio_mailbox_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_MICRO_UC_MDIO_MAILBOX_MSWf_GET(r) (((r).uc_uc_mdio_mailbox_msw[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_MICRO_UC_MDIO_MAILBOX_MSWf_SET(r,f) (r).uc_uc_mdio_mailbox_msw[0]=(((r).uc_uc_mdio_mailbox_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_UC_MDIO_MAILBOX_MSW.
 */
#define BCMI_QTC_XGXS_READ_UC_UC_MDIO_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr,(_r._uc_uc_mdio_mailbox_msw))
#define BCMI_QTC_XGXS_WRITE_UC_UC_MDIO_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr,(_r._uc_uc_mdio_mailbox_msw)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_UC_MDIO_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr,(_r._uc_uc_mdio_mailbox_msw))
#define BCMI_QTC_XGXS_READLN_UC_UC_MDIO_MAILBOX_MSWr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_mdio_mailbox_msw))
#define BCMI_QTC_XGXS_WRITELN_UC_UC_MDIO_MAILBOX_MSWr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_mdio_mailbox_msw))
#define BCMI_QTC_XGXS_WRITEALL_UC_UC_MDIO_MAILBOX_MSWr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_mdio_mailbox_msw))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_MDIO_MAILBOX_MSWr BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr
#define UC_UC_MDIO_MAILBOX_MSWr_SIZE BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_SIZE
typedef BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_t UC_UC_MDIO_MAILBOX_MSWr_t;
#define UC_UC_MDIO_MAILBOX_MSWr_CLR BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_CLR
#define UC_UC_MDIO_MAILBOX_MSWr_SET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_SET
#define UC_UC_MDIO_MAILBOX_MSWr_GET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_GET
#define UC_UC_MDIO_MAILBOX_MSWr_MICRO_UC_MDIO_MAILBOX_MSWf_GET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_MICRO_UC_MDIO_MAILBOX_MSWf_GET
#define UC_UC_MDIO_MAILBOX_MSWr_MICRO_UC_MDIO_MAILBOX_MSWf_SET BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr_MICRO_UC_MDIO_MAILBOX_MSWf_SET
#define READ_UC_UC_MDIO_MAILBOX_MSWr BCMI_QTC_XGXS_READ_UC_UC_MDIO_MAILBOX_MSWr
#define WRITE_UC_UC_MDIO_MAILBOX_MSWr BCMI_QTC_XGXS_WRITE_UC_UC_MDIO_MAILBOX_MSWr
#define MODIFY_UC_UC_MDIO_MAILBOX_MSWr BCMI_QTC_XGXS_MODIFY_UC_UC_MDIO_MAILBOX_MSWr
#define READLN_UC_UC_MDIO_MAILBOX_MSWr BCMI_QTC_XGXS_READLN_UC_UC_MDIO_MAILBOX_MSWr
#define WRITELN_UC_UC_MDIO_MAILBOX_MSWr BCMI_QTC_XGXS_WRITELN_UC_UC_MDIO_MAILBOX_MSWr
#define WRITEALL_UC_UC_MDIO_MAILBOX_MSWr BCMI_QTC_XGXS_WRITEALL_UC_UC_MDIO_MAILBOX_MSWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_UC_MDIO_MAILBOX_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_COMMAND3
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20c
 * DEVAD:    1
 * DESC:     Command Register 3
 * SIZE:     32
 * FIELDS:
 *     MICRO_PRAM_IF_EN Enable parallel interface to load program RAM
 *     MICRO_PRAM_IF_FLOP_BYPASS Bypass the flops used to capature data from the pram_* interface
 *     MICRO_PRAM_IF_RSTB Parallel Interface from Program RAM load0 - asserted1 - de-asserted
 *     MICRO_INRUSH_CURRENT_FRC SRAM (program ram) in rush current input(s) force
 *     MICRO_INRUSH_CURRENT_FRC_VAL SRAM (program ram) in rush current input(s) force value
 *     MICRO_DISABLE_ECC disable program RAM ECC
 *     MICRO_GEN_STATUS_SEL 
 */
#define BCMI_QTC_XGXS_UC_COMMAND3r (0x0001d20c | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_COMMAND3r_SIZE 4

/*
 * This structure should be used to declare and program UC_COMMAND3.
 */
typedef union BCMI_QTC_XGXS_UC_COMMAND3r_s {
	uint32_t v[1];
	uint32_t uc_command3[1];
	uint32_t _uc_command3;
} BCMI_QTC_XGXS_UC_COMMAND3r_t;

#define BCMI_QTC_XGXS_UC_COMMAND3r_CLR(r) (r).uc_command3[0] = 0
#define BCMI_QTC_XGXS_UC_COMMAND3r_SET(r,d) (r).uc_command3[0] = d
#define BCMI_QTC_XGXS_UC_COMMAND3r_GET(r) (r).uc_command3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_GEN_STATUS_SELf_GET(r) ((((r).uc_command3[0]) >> 13) & 0x7)
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_GEN_STATUS_SELf_SET(r,f) (r).uc_command3[0]=(((r).uc_command3[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_DISABLE_ECCf_GET(r) ((((r).uc_command3[0]) >> 12) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_DISABLE_ECCf_SET(r,f) (r).uc_command3[0]=(((r).uc_command3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRC_VALf_GET(r) ((((r).uc_command3[0]) >> 11) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRC_VALf_SET(r,f) (r).uc_command3[0]=(((r).uc_command3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRCf_GET(r) ((((r).uc_command3[0]) >> 10) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRCf_SET(r,f) (r).uc_command3[0]=(((r).uc_command3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_RSTBf_GET(r) ((((r).uc_command3[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_RSTBf_SET(r,f) (r).uc_command3[0]=(((r).uc_command3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_FLOP_BYPASSf_GET(r) ((((r).uc_command3[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_FLOP_BYPASSf_SET(r,f) (r).uc_command3[0]=(((r).uc_command3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_ENf_GET(r) (((r).uc_command3[0]) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_ENf_SET(r,f) (r).uc_command3[0]=(((r).uc_command3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access UC_COMMAND3.
 */
#define BCMI_QTC_XGXS_READ_UC_COMMAND3r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMAND3r,(_r._uc_command3))
#define BCMI_QTC_XGXS_WRITE_UC_COMMAND3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND3r,(_r._uc_command3)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_COMMAND3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND3r,(_r._uc_command3))
#define BCMI_QTC_XGXS_READLN_UC_COMMAND3r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMAND3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command3))
#define BCMI_QTC_XGXS_WRITELN_UC_COMMAND3r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command3))
#define BCMI_QTC_XGXS_WRITEALL_UC_COMMAND3r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_command3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_COMMAND3r BCMI_QTC_XGXS_UC_COMMAND3r
#define UC_COMMAND3r_SIZE BCMI_QTC_XGXS_UC_COMMAND3r_SIZE
typedef BCMI_QTC_XGXS_UC_COMMAND3r_t UC_COMMAND3r_t;
#define UC_COMMAND3r_CLR BCMI_QTC_XGXS_UC_COMMAND3r_CLR
#define UC_COMMAND3r_SET BCMI_QTC_XGXS_UC_COMMAND3r_SET
#define UC_COMMAND3r_GET BCMI_QTC_XGXS_UC_COMMAND3r_GET
#define UC_COMMAND3r_MICRO_GEN_STATUS_SELf_GET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_GEN_STATUS_SELf_GET
#define UC_COMMAND3r_MICRO_GEN_STATUS_SELf_SET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_GEN_STATUS_SELf_SET
#define UC_COMMAND3r_MICRO_DISABLE_ECCf_GET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_DISABLE_ECCf_GET
#define UC_COMMAND3r_MICRO_DISABLE_ECCf_SET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_DISABLE_ECCf_SET
#define UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRC_VALf_GET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRC_VALf_GET
#define UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRC_VALf_SET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRC_VALf_SET
#define UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRCf_GET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRCf_GET
#define UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRCf_SET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_INRUSH_CURRENT_FRCf_SET
#define UC_COMMAND3r_MICRO_PRAM_IF_RSTBf_GET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_RSTBf_GET
#define UC_COMMAND3r_MICRO_PRAM_IF_RSTBf_SET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_RSTBf_SET
#define UC_COMMAND3r_MICRO_PRAM_IF_FLOP_BYPASSf_GET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_FLOP_BYPASSf_GET
#define UC_COMMAND3r_MICRO_PRAM_IF_FLOP_BYPASSf_SET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_FLOP_BYPASSf_SET
#define UC_COMMAND3r_MICRO_PRAM_IF_ENf_GET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_ENf_GET
#define UC_COMMAND3r_MICRO_PRAM_IF_ENf_SET BCMI_QTC_XGXS_UC_COMMAND3r_MICRO_PRAM_IF_ENf_SET
#define READ_UC_COMMAND3r BCMI_QTC_XGXS_READ_UC_COMMAND3r
#define WRITE_UC_COMMAND3r BCMI_QTC_XGXS_WRITE_UC_COMMAND3r
#define MODIFY_UC_COMMAND3r BCMI_QTC_XGXS_MODIFY_UC_COMMAND3r
#define READLN_UC_COMMAND3r BCMI_QTC_XGXS_READLN_UC_COMMAND3r
#define WRITELN_UC_COMMAND3r BCMI_QTC_XGXS_WRITELN_UC_COMMAND3r
#define WRITEALL_UC_COMMAND3r BCMI_QTC_XGXS_WRITEALL_UC_COMMAND3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_COMMAND3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_COMMAND4
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20d
 * DEVAD:    1
 * DESC:     Command Register 4
 * SIZE:     32
 * FIELDS:
 *     MICRO_SYSTEM_CLK_EN micro system clock enable1'b0 - disabled1'b1 - enabled
 *     MICRO_SYSTEM_RESET_N micro system reset1'b0 - asserted1'b1 - de-asserted
 */
#define BCMI_QTC_XGXS_UC_COMMAND4r (0x0001d20d | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_COMMAND4r_SIZE 4

/*
 * This structure should be used to declare and program UC_COMMAND4.
 */
typedef union BCMI_QTC_XGXS_UC_COMMAND4r_s {
	uint32_t v[1];
	uint32_t uc_command4[1];
	uint32_t _uc_command4;
} BCMI_QTC_XGXS_UC_COMMAND4r_t;

#define BCMI_QTC_XGXS_UC_COMMAND4r_CLR(r) (r).uc_command4[0] = 0
#define BCMI_QTC_XGXS_UC_COMMAND4r_SET(r,d) (r).uc_command4[0] = d
#define BCMI_QTC_XGXS_UC_COMMAND4r_GET(r) (r).uc_command4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_RESET_Nf_GET(r) ((((r).uc_command4[0]) >> 1) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_RESET_Nf_SET(r,f) (r).uc_command4[0]=(((r).uc_command4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_CLK_ENf_GET(r) (((r).uc_command4[0]) & 0x1)
#define BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_CLK_ENf_SET(r,f) (r).uc_command4[0]=(((r).uc_command4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access UC_COMMAND4.
 */
#define BCMI_QTC_XGXS_READ_UC_COMMAND4r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMAND4r,(_r._uc_command4))
#define BCMI_QTC_XGXS_WRITE_UC_COMMAND4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND4r,(_r._uc_command4)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_COMMAND4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND4r,(_r._uc_command4))
#define BCMI_QTC_XGXS_READLN_UC_COMMAND4r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_COMMAND4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command4))
#define BCMI_QTC_XGXS_WRITELN_UC_COMMAND4r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_command4))
#define BCMI_QTC_XGXS_WRITEALL_UC_COMMAND4r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_COMMAND4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_command4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_COMMAND4r BCMI_QTC_XGXS_UC_COMMAND4r
#define UC_COMMAND4r_SIZE BCMI_QTC_XGXS_UC_COMMAND4r_SIZE
typedef BCMI_QTC_XGXS_UC_COMMAND4r_t UC_COMMAND4r_t;
#define UC_COMMAND4r_CLR BCMI_QTC_XGXS_UC_COMMAND4r_CLR
#define UC_COMMAND4r_SET BCMI_QTC_XGXS_UC_COMMAND4r_SET
#define UC_COMMAND4r_GET BCMI_QTC_XGXS_UC_COMMAND4r_GET
#define UC_COMMAND4r_MICRO_SYSTEM_RESET_Nf_GET BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_RESET_Nf_GET
#define UC_COMMAND4r_MICRO_SYSTEM_RESET_Nf_SET BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_RESET_Nf_SET
#define UC_COMMAND4r_MICRO_SYSTEM_CLK_ENf_GET BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_CLK_ENf_GET
#define UC_COMMAND4r_MICRO_SYSTEM_CLK_ENf_SET BCMI_QTC_XGXS_UC_COMMAND4r_MICRO_SYSTEM_CLK_ENf_SET
#define READ_UC_COMMAND4r BCMI_QTC_XGXS_READ_UC_COMMAND4r
#define WRITE_UC_COMMAND4r BCMI_QTC_XGXS_WRITE_UC_COMMAND4r
#define MODIFY_UC_COMMAND4r BCMI_QTC_XGXS_MODIFY_UC_COMMAND4r
#define READLN_UC_COMMAND4r BCMI_QTC_XGXS_READLN_UC_COMMAND4r
#define WRITELN_UC_COMMAND4r BCMI_QTC_XGXS_WRITELN_UC_COMMAND4r
#define WRITEALL_UC_COMMAND4r BCMI_QTC_XGXS_WRITEALL_UC_COMMAND4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_COMMAND4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_TEMPERATURE_STS
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20e
 * DEVAD:    1
 * DESC:     temperature status register
 * SIZE:     32
 * FIELDS:
 *     MICRO_TEMPATURE_DATA temperature data{6'd0,tempearture_data[9:0]}reads the current value of the temperature data capatured
 */
#define BCMI_QTC_XGXS_UC_TEMPERATURE_STSr (0x0001d20e | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_SIZE 4

/*
 * This structure should be used to declare and program UC_TEMPERATURE_STS.
 */
typedef union BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_s {
	uint32_t v[1];
	uint32_t uc_temperature_sts[1];
	uint32_t _uc_temperature_sts;
} BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_t;

#define BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_CLR(r) (r).uc_temperature_sts[0] = 0
#define BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_SET(r,d) (r).uc_temperature_sts[0] = d
#define BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_GET(r) (r).uc_temperature_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_MICRO_TEMPATURE_DATAf_GET(r) (((r).uc_temperature_sts[0]) & 0xffff)
#define BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_MICRO_TEMPATURE_DATAf_SET(r,f) (r).uc_temperature_sts[0]=(((r).uc_temperature_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access UC_TEMPERATURE_STS.
 */
#define BCMI_QTC_XGXS_READ_UC_TEMPERATURE_STSr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_TEMPERATURE_STSr,(_r._uc_temperature_sts))
#define BCMI_QTC_XGXS_WRITE_UC_TEMPERATURE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_TEMPERATURE_STSr,(_r._uc_temperature_sts)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_TEMPERATURE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_TEMPERATURE_STSr,(_r._uc_temperature_sts))
#define BCMI_QTC_XGXS_READLN_UC_TEMPERATURE_STSr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_TEMPERATURE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_temperature_sts))
#define BCMI_QTC_XGXS_WRITELN_UC_TEMPERATURE_STSr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_TEMPERATURE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_temperature_sts))
#define BCMI_QTC_XGXS_WRITEALL_UC_TEMPERATURE_STSr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_TEMPERATURE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_temperature_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_TEMPERATURE_STSr BCMI_QTC_XGXS_UC_TEMPERATURE_STSr
#define UC_TEMPERATURE_STSr_SIZE BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_SIZE
typedef BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_t UC_TEMPERATURE_STSr_t;
#define UC_TEMPERATURE_STSr_CLR BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_CLR
#define UC_TEMPERATURE_STSr_SET BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_SET
#define UC_TEMPERATURE_STSr_GET BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_GET
#define UC_TEMPERATURE_STSr_MICRO_TEMPATURE_DATAf_GET BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_MICRO_TEMPATURE_DATAf_GET
#define UC_TEMPERATURE_STSr_MICRO_TEMPATURE_DATAf_SET BCMI_QTC_XGXS_UC_TEMPERATURE_STSr_MICRO_TEMPATURE_DATAf_SET
#define READ_UC_TEMPERATURE_STSr BCMI_QTC_XGXS_READ_UC_TEMPERATURE_STSr
#define WRITE_UC_TEMPERATURE_STSr BCMI_QTC_XGXS_WRITE_UC_TEMPERATURE_STSr
#define MODIFY_UC_TEMPERATURE_STSr BCMI_QTC_XGXS_MODIFY_UC_TEMPERATURE_STSr
#define READLN_UC_TEMPERATURE_STSr BCMI_QTC_XGXS_READLN_UC_TEMPERATURE_STSr
#define WRITELN_UC_TEMPERATURE_STSr BCMI_QTC_XGXS_WRITELN_UC_TEMPERATURE_STSr
#define WRITEALL_UC_TEMPERATURE_STSr BCMI_QTC_XGXS_WRITEALL_UC_TEMPERATURE_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_TEMPERATURE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_PROGRAM_RAM_CTL1
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd210
 * DEVAD:    1
 * DESC:     program ram control 1
 * SIZE:     32
 * FIELDS:
 *     MICRO_PROGRAM_RAM_TM Test Mode.These pins are used to put the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<13:0>=14'b0. It ishighly recommended that the user has control over all thetm<13:0> inputs. All tm<13:0> inputs are asynchronous. Seethe Test Modes section of the on line M28SP WebSpecification for further details.
 */
#define BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r (0x0001d210 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_PROGRAM_RAM_CTL1.
 */
typedef union BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_program_ram_ctl1[1];
	uint32_t _uc_program_ram_ctl1;
} BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_t;

#define BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_CLR(r) (r).uc_program_ram_ctl1[0] = 0
#define BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_SET(r,d) (r).uc_program_ram_ctl1[0] = d
#define BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_GET(r) (r).uc_program_ram_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_MICRO_PROGRAM_RAM_TMf_GET(r) (((r).uc_program_ram_ctl1[0]) & 0x3fff)
#define BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_MICRO_PROGRAM_RAM_TMf_SET(r,f) (r).uc_program_ram_ctl1[0]=(((r).uc_program_ram_ctl1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (16383 << 16)

/*
 * These macros can be used to access UC_PROGRAM_RAM_CTL1.
 */
#define BCMI_QTC_XGXS_READ_UC_PROGRAM_RAM_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r,(_r._uc_program_ram_ctl1))
#define BCMI_QTC_XGXS_WRITE_UC_PROGRAM_RAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r,(_r._uc_program_ram_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_PROGRAM_RAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r,(_r._uc_program_ram_ctl1))
#define BCMI_QTC_XGXS_READLN_UC_PROGRAM_RAM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_program_ram_ctl1))
#define BCMI_QTC_XGXS_WRITELN_UC_PROGRAM_RAM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_program_ram_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_UC_PROGRAM_RAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_program_ram_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_PROGRAM_RAM_CTL1r BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r
#define UC_PROGRAM_RAM_CTL1r_SIZE BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_SIZE
typedef BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_t UC_PROGRAM_RAM_CTL1r_t;
#define UC_PROGRAM_RAM_CTL1r_CLR BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_CLR
#define UC_PROGRAM_RAM_CTL1r_SET BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_SET
#define UC_PROGRAM_RAM_CTL1r_GET BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_GET
#define UC_PROGRAM_RAM_CTL1r_MICRO_PROGRAM_RAM_TMf_GET BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_MICRO_PROGRAM_RAM_TMf_GET
#define UC_PROGRAM_RAM_CTL1r_MICRO_PROGRAM_RAM_TMf_SET BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r_MICRO_PROGRAM_RAM_TMf_SET
#define READ_UC_PROGRAM_RAM_CTL1r BCMI_QTC_XGXS_READ_UC_PROGRAM_RAM_CTL1r
#define WRITE_UC_PROGRAM_RAM_CTL1r BCMI_QTC_XGXS_WRITE_UC_PROGRAM_RAM_CTL1r
#define MODIFY_UC_PROGRAM_RAM_CTL1r BCMI_QTC_XGXS_MODIFY_UC_PROGRAM_RAM_CTL1r
#define READLN_UC_PROGRAM_RAM_CTL1r BCMI_QTC_XGXS_READLN_UC_PROGRAM_RAM_CTL1r
#define WRITELN_UC_PROGRAM_RAM_CTL1r BCMI_QTC_XGXS_WRITELN_UC_PROGRAM_RAM_CTL1r
#define WRITEALL_UC_PROGRAM_RAM_CTL1r BCMI_QTC_XGXS_WRITEALL_UC_PROGRAM_RAM_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_PROGRAM_RAM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_DATARAM_CTL1
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd214
 * DEVAD:    1
 * DESC:     data ram control 1
 * SIZE:     32
 * FIELDS:
 *     MICRO_DATARAM_TM Test Mode.These pins are used to put the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<9:0>=10'b0. It ishighly recommended that the user has control over all thetm<9:0> inputs. All tm<9:0> inputs are asynchronous. Seethe Test Modes section of the on line M28RF WebSpecification for further details.
 */
#define BCMI_QTC_XGXS_UC_DATARAM_CTL1r (0x0001d214 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_DATARAM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_DATARAM_CTL1.
 */
typedef union BCMI_QTC_XGXS_UC_DATARAM_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_dataram_ctl1[1];
	uint32_t _uc_dataram_ctl1;
} BCMI_QTC_XGXS_UC_DATARAM_CTL1r_t;

#define BCMI_QTC_XGXS_UC_DATARAM_CTL1r_CLR(r) (r).uc_dataram_ctl1[0] = 0
#define BCMI_QTC_XGXS_UC_DATARAM_CTL1r_SET(r,d) (r).uc_dataram_ctl1[0] = d
#define BCMI_QTC_XGXS_UC_DATARAM_CTL1r_GET(r) (r).uc_dataram_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_DATARAM_CTL1r_MICRO_DATARAM_TMf_GET(r) (((r).uc_dataram_ctl1[0]) & 0x3ff)
#define BCMI_QTC_XGXS_UC_DATARAM_CTL1r_MICRO_DATARAM_TMf_SET(r,f) (r).uc_dataram_ctl1[0]=(((r).uc_dataram_ctl1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (1023 << 16)

/*
 * These macros can be used to access UC_DATARAM_CTL1.
 */
#define BCMI_QTC_XGXS_READ_UC_DATARAM_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_DATARAM_CTL1r,(_r._uc_dataram_ctl1))
#define BCMI_QTC_XGXS_WRITE_UC_DATARAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DATARAM_CTL1r,(_r._uc_dataram_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_DATARAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DATARAM_CTL1r,(_r._uc_dataram_ctl1))
#define BCMI_QTC_XGXS_READLN_UC_DATARAM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_DATARAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_dataram_ctl1))
#define BCMI_QTC_XGXS_WRITELN_UC_DATARAM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DATARAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_dataram_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_UC_DATARAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_DATARAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_dataram_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_DATARAM_CTL1r BCMI_QTC_XGXS_UC_DATARAM_CTL1r
#define UC_DATARAM_CTL1r_SIZE BCMI_QTC_XGXS_UC_DATARAM_CTL1r_SIZE
typedef BCMI_QTC_XGXS_UC_DATARAM_CTL1r_t UC_DATARAM_CTL1r_t;
#define UC_DATARAM_CTL1r_CLR BCMI_QTC_XGXS_UC_DATARAM_CTL1r_CLR
#define UC_DATARAM_CTL1r_SET BCMI_QTC_XGXS_UC_DATARAM_CTL1r_SET
#define UC_DATARAM_CTL1r_GET BCMI_QTC_XGXS_UC_DATARAM_CTL1r_GET
#define UC_DATARAM_CTL1r_MICRO_DATARAM_TMf_GET BCMI_QTC_XGXS_UC_DATARAM_CTL1r_MICRO_DATARAM_TMf_GET
#define UC_DATARAM_CTL1r_MICRO_DATARAM_TMf_SET BCMI_QTC_XGXS_UC_DATARAM_CTL1r_MICRO_DATARAM_TMf_SET
#define READ_UC_DATARAM_CTL1r BCMI_QTC_XGXS_READ_UC_DATARAM_CTL1r
#define WRITE_UC_DATARAM_CTL1r BCMI_QTC_XGXS_WRITE_UC_DATARAM_CTL1r
#define MODIFY_UC_DATARAM_CTL1r BCMI_QTC_XGXS_MODIFY_UC_DATARAM_CTL1r
#define READLN_UC_DATARAM_CTL1r BCMI_QTC_XGXS_READLN_UC_DATARAM_CTL1r
#define WRITELN_UC_DATARAM_CTL1r BCMI_QTC_XGXS_WRITELN_UC_DATARAM_CTL1r
#define WRITEALL_UC_DATARAM_CTL1r BCMI_QTC_XGXS_WRITEALL_UC_DATARAM_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_DATARAM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  UC_IRAM_CTL1
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd218
 * DEVAD:    1
 * DESC:     internal ram control 1
 * SIZE:     32
 * FIELDS:
 *     MICRO_IRAM_TM    Test Mode.These pins are used to put the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<9:0>=10'b0. It ishighly recommended that the user has control over all thetm<9:0> inputs. All tm<9:0> inputs are asynchronous. Seethe Test Modes section of the on line M28RF WebSpecification for further details.
 */
#define BCMI_QTC_XGXS_UC_IRAM_CTL1r (0x0001d218 | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_UC_IRAM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_IRAM_CTL1.
 */
typedef union BCMI_QTC_XGXS_UC_IRAM_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_iram_ctl1[1];
	uint32_t _uc_iram_ctl1;
} BCMI_QTC_XGXS_UC_IRAM_CTL1r_t;

#define BCMI_QTC_XGXS_UC_IRAM_CTL1r_CLR(r) (r).uc_iram_ctl1[0] = 0
#define BCMI_QTC_XGXS_UC_IRAM_CTL1r_SET(r,d) (r).uc_iram_ctl1[0] = d
#define BCMI_QTC_XGXS_UC_IRAM_CTL1r_GET(r) (r).uc_iram_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_UC_IRAM_CTL1r_MICRO_IRAM_TMf_GET(r) (((r).uc_iram_ctl1[0]) & 0x3ff)
#define BCMI_QTC_XGXS_UC_IRAM_CTL1r_MICRO_IRAM_TMf_SET(r,f) (r).uc_iram_ctl1[0]=(((r).uc_iram_ctl1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (1023 << 16)

/*
 * These macros can be used to access UC_IRAM_CTL1.
 */
#define BCMI_QTC_XGXS_READ_UC_IRAM_CTL1r(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_IRAM_CTL1r,(_r._uc_iram_ctl1))
#define BCMI_QTC_XGXS_WRITE_UC_IRAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_IRAM_CTL1r,(_r._uc_iram_ctl1)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_UC_IRAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_IRAM_CTL1r,(_r._uc_iram_ctl1))
#define BCMI_QTC_XGXS_READLN_UC_IRAM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_UC_IRAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_iram_ctl1))
#define BCMI_QTC_XGXS_WRITELN_UC_IRAM_CTL1r(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_IRAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_iram_ctl1))
#define BCMI_QTC_XGXS_WRITEALL_UC_IRAM_CTL1r(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_UC_IRAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_iram_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define UC_IRAM_CTL1r BCMI_QTC_XGXS_UC_IRAM_CTL1r
#define UC_IRAM_CTL1r_SIZE BCMI_QTC_XGXS_UC_IRAM_CTL1r_SIZE
typedef BCMI_QTC_XGXS_UC_IRAM_CTL1r_t UC_IRAM_CTL1r_t;
#define UC_IRAM_CTL1r_CLR BCMI_QTC_XGXS_UC_IRAM_CTL1r_CLR
#define UC_IRAM_CTL1r_SET BCMI_QTC_XGXS_UC_IRAM_CTL1r_SET
#define UC_IRAM_CTL1r_GET BCMI_QTC_XGXS_UC_IRAM_CTL1r_GET
#define UC_IRAM_CTL1r_MICRO_IRAM_TMf_GET BCMI_QTC_XGXS_UC_IRAM_CTL1r_MICRO_IRAM_TMf_GET
#define UC_IRAM_CTL1r_MICRO_IRAM_TMf_SET BCMI_QTC_XGXS_UC_IRAM_CTL1r_MICRO_IRAM_TMf_SET
#define READ_UC_IRAM_CTL1r BCMI_QTC_XGXS_READ_UC_IRAM_CTL1r
#define WRITE_UC_IRAM_CTL1r BCMI_QTC_XGXS_WRITE_UC_IRAM_CTL1r
#define MODIFY_UC_IRAM_CTL1r BCMI_QTC_XGXS_MODIFY_UC_IRAM_CTL1r
#define READLN_UC_IRAM_CTL1r BCMI_QTC_XGXS_READLN_UC_IRAM_CTL1r
#define WRITELN_UC_IRAM_CTL1r BCMI_QTC_XGXS_WRITELN_UC_IRAM_CTL1r
#define WRITEALL_UC_IRAM_CTL1r BCMI_QTC_XGXS_WRITEALL_UC_IRAM_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_UC_IRAM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MDIO_MASKDATA
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdb
 * DEVAD:    1
 * DESC:     MDIO write mask register
 * SIZE:     32
 * FIELDS:
 *     MDIO_MASKDATA    mask register for masked writes from mdio port.
 */
#define BCMI_QTC_XGXS_MDIO_MASKDATAr (0x0001ffdb | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MDIO_MASKDATAr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MASKDATA.
 */
typedef union BCMI_QTC_XGXS_MDIO_MASKDATAr_s {
	uint32_t v[1];
	uint32_t mdio_maskdata[1];
	uint32_t _mdio_maskdata;
} BCMI_QTC_XGXS_MDIO_MASKDATAr_t;

#define BCMI_QTC_XGXS_MDIO_MASKDATAr_CLR(r) (r).mdio_maskdata[0] = 0
#define BCMI_QTC_XGXS_MDIO_MASKDATAr_SET(r,d) (r).mdio_maskdata[0] = d
#define BCMI_QTC_XGXS_MDIO_MASKDATAr_GET(r) (r).mdio_maskdata[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_GET(r) (((r).mdio_maskdata[0]) & 0xffff)
#define BCMI_QTC_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_SET(r,f) (r).mdio_maskdata[0]=(((r).mdio_maskdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access MDIO_MASKDATA.
 */
#define BCMI_QTC_XGXS_READ_MDIO_MASKDATAr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_MASKDATAr,(_r._mdio_maskdata))
#define BCMI_QTC_XGXS_WRITE_MDIO_MASKDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MASKDATAr,(_r._mdio_maskdata)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MDIO_MASKDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MASKDATAr,(_r._mdio_maskdata))
#define BCMI_QTC_XGXS_READLN_MDIO_MASKDATAr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_maskdata))
#define BCMI_QTC_XGXS_WRITELN_MDIO_MASKDATAr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_maskdata))
#define BCMI_QTC_XGXS_WRITEALL_MDIO_MASKDATAr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_maskdata))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MASKDATAr BCMI_QTC_XGXS_MDIO_MASKDATAr
#define MDIO_MASKDATAr_SIZE BCMI_QTC_XGXS_MDIO_MASKDATAr_SIZE
typedef BCMI_QTC_XGXS_MDIO_MASKDATAr_t MDIO_MASKDATAr_t;
#define MDIO_MASKDATAr_CLR BCMI_QTC_XGXS_MDIO_MASKDATAr_CLR
#define MDIO_MASKDATAr_SET BCMI_QTC_XGXS_MDIO_MASKDATAr_SET
#define MDIO_MASKDATAr_GET BCMI_QTC_XGXS_MDIO_MASKDATAr_GET
#define MDIO_MASKDATAr_MDIO_MASKDATAf_GET BCMI_QTC_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_GET
#define MDIO_MASKDATAr_MDIO_MASKDATAf_SET BCMI_QTC_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_SET
#define READ_MDIO_MASKDATAr BCMI_QTC_XGXS_READ_MDIO_MASKDATAr
#define WRITE_MDIO_MASKDATAr BCMI_QTC_XGXS_WRITE_MDIO_MASKDATAr
#define MODIFY_MDIO_MASKDATAr BCMI_QTC_XGXS_MODIFY_MDIO_MASKDATAr
#define READLN_MDIO_MASKDATAr BCMI_QTC_XGXS_READLN_MDIO_MASKDATAr
#define WRITELN_MDIO_MASKDATAr BCMI_QTC_XGXS_WRITELN_MDIO_MASKDATAr
#define WRITEALL_MDIO_MASKDATAr BCMI_QTC_XGXS_WRITEALL_MDIO_MASKDATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MDIO_MASKDATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MDIO_BCST_PORT_ADDR
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdc
 * DEVAD:    1
 * DESC:     Broadcast Port Address
 * SIZE:     32
 * FIELDS:
 *     MDIO_BRCST_PORT_ADDR Braodcast port address that can be used to broadcast mdio commandsto multiple controllers connected to the same mdio station manager
 */
#define BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr (0x0001ffdc | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BCST_PORT_ADDR.
 */
typedef union BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_bcst_port_addr[1];
	uint32_t _mdio_bcst_port_addr;
} BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_t;

#define BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_CLR(r) (r).mdio_bcst_port_addr[0] = 0
#define BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_SET(r,d) (r).mdio_bcst_port_addr[0] = d
#define BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_GET(r) (r).mdio_bcst_port_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET(r) (((r).mdio_bcst_port_addr[0]) & 0x1f)
#define BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (31 << 16)

/*
 * These macros can be used to access MDIO_BCST_PORT_ADDR.
 */
#define BCMI_QTC_XGXS_READ_MDIO_BCST_PORT_ADDRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_QTC_XGXS_WRITE_MDIO_BCST_PORT_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_QTC_XGXS_READLN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_QTC_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_QTC_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_bcst_port_addr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BCST_PORT_ADDRr BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr
#define MDIO_BCST_PORT_ADDRr_SIZE BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_SIZE
typedef BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_t MDIO_BCST_PORT_ADDRr_t;
#define MDIO_BCST_PORT_ADDRr_CLR BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_CLR
#define MDIO_BCST_PORT_ADDRr_SET BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_SET
#define MDIO_BCST_PORT_ADDRr_GET BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET
#define READ_MDIO_BCST_PORT_ADDRr BCMI_QTC_XGXS_READ_MDIO_BCST_PORT_ADDRr
#define WRITE_MDIO_BCST_PORT_ADDRr BCMI_QTC_XGXS_WRITE_MDIO_BCST_PORT_ADDRr
#define MODIFY_MDIO_BCST_PORT_ADDRr BCMI_QTC_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr
#define READLN_MDIO_BCST_PORT_ADDRr BCMI_QTC_XGXS_READLN_MDIO_BCST_PORT_ADDRr
#define WRITELN_MDIO_BCST_PORT_ADDRr BCMI_QTC_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr
#define WRITEALL_MDIO_BCST_PORT_ADDRr BCMI_QTC_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MDIO_BCST_PORT_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MDIO_MMD_SEL
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdd
 * DEVAD:    1
 * DESC:     MMD Select
 * SIZE:     32
 * FIELDS:
 *     MDIO_DEV_CL22_EN When set and mdio_multi_mmds_en=1 then CL22 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PMD_EN  When set and mdio_multi_mmds_en=1 then the PMD device=1 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_AN_EN   When set and mdio_multi_mmds_en=1 then the AN device=7 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PHY_EN  When set and mdio_multi_mmds_en=1 then the PHY device=4 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_DTE_EN  When set and mdio_multi_mmds_en=1 then the DTE device=5 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PCS_EN  When set and mdio_multi_mmds_en=1 then the PCS device=3 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_MULTI_MMDS_EN When set enables the multiple MMD functionality.  MD_ST is ignored andeach device can be accessed directly with the appropriate CL22 or CL45protocol.
 *     MDIO_MULTI_PRTS_EN When set enables multiple prtad functionality.  Each of the lanes'mmds can be accessed with consecutive PRTADs.  Lane 0 is accessedwith PRTAD_STRAP, lane 1 with PRTAD_STRAP+1, lane 2 with PRTAD_STRAP+2and lane 3 with PRTAD_STRAP+3.
 */
#define BCMI_QTC_XGXS_MDIO_MMD_SELr (0x0001ffdd | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MDIO_MMD_SELr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MMD_SEL.
 */
typedef union BCMI_QTC_XGXS_MDIO_MMD_SELr_s {
	uint32_t v[1];
	uint32_t mdio_mmd_sel[1];
	uint32_t _mdio_mmd_sel;
} BCMI_QTC_XGXS_MDIO_MMD_SELr_t;

#define BCMI_QTC_XGXS_MDIO_MMD_SELr_CLR(r) (r).mdio_mmd_sel[0] = 0
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_SET(r,d) (r).mdio_mmd_sel[0] = d
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_GET(r) (r).mdio_mmd_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 15) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 14) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 6) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 5) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 4) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 3) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 2) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET(r) (((r).mdio_mmd_sel[0]) & 0x1)
#define BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (1 << 16)

/*
 * These macros can be used to access MDIO_MMD_SEL.
 */
#define BCMI_QTC_XGXS_READ_MDIO_MMD_SELr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_QTC_XGXS_WRITE_MDIO_MMD_SELr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MDIO_MMD_SELr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_QTC_XGXS_READLN_MDIO_MMD_SELr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_QTC_XGXS_WRITELN_MDIO_MMD_SELr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_QTC_XGXS_WRITEALL_MDIO_MMD_SELr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_mmd_sel))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MMD_SELr BCMI_QTC_XGXS_MDIO_MMD_SELr
#define MDIO_MMD_SELr_SIZE BCMI_QTC_XGXS_MDIO_MMD_SELr_SIZE
typedef BCMI_QTC_XGXS_MDIO_MMD_SELr_t MDIO_MMD_SELr_t;
#define MDIO_MMD_SELr_CLR BCMI_QTC_XGXS_MDIO_MMD_SELr_CLR
#define MDIO_MMD_SELr_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_SET
#define MDIO_MMD_SELr_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET BCMI_QTC_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET
#define READ_MDIO_MMD_SELr BCMI_QTC_XGXS_READ_MDIO_MMD_SELr
#define WRITE_MDIO_MMD_SELr BCMI_QTC_XGXS_WRITE_MDIO_MMD_SELr
#define MODIFY_MDIO_MMD_SELr BCMI_QTC_XGXS_MODIFY_MDIO_MMD_SELr
#define READLN_MDIO_MMD_SELr BCMI_QTC_XGXS_READLN_MDIO_MMD_SELr
#define WRITELN_MDIO_MMD_SELr BCMI_QTC_XGXS_WRITELN_MDIO_MMD_SELr
#define WRITEALL_MDIO_MMD_SELr BCMI_QTC_XGXS_WRITEALL_MDIO_MMD_SELr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MDIO_MMD_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MDIO_AER
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffde
 * DEVAD:    1
 * DESC:     AER
 * SIZE:     32
 * FIELDS:
 *     MDIO_AER         Provides upper 16-bits of 32-bit address for mdio transactions.bit 15:11 Selects the indicated internal MMD for a valid DEVAD in the MDIO data stream.MMD device typeCL22    0hPMA_PMD 1hCL73_AN 3hPHY     4hDTE     5hPCS     6hbit 10:0 selects lane numberEach lane specific register can be accessed by setting aer[10:0] = lane offset strap + lane number.Also be set to 11'h1ff to broadcast to all lanes.
 */
#define BCMI_QTC_XGXS_MDIO_AERr (0x0001ffde | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MDIO_AERr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_AER.
 */
typedef union BCMI_QTC_XGXS_MDIO_AERr_s {
	uint32_t v[1];
	uint32_t mdio_aer[1];
	uint32_t _mdio_aer;
} BCMI_QTC_XGXS_MDIO_AERr_t;

#define BCMI_QTC_XGXS_MDIO_AERr_CLR(r) (r).mdio_aer[0] = 0
#define BCMI_QTC_XGXS_MDIO_AERr_SET(r,d) (r).mdio_aer[0] = d
#define BCMI_QTC_XGXS_MDIO_AERr_GET(r) (r).mdio_aer[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MDIO_AERr_MDIO_AERf_GET(r) (((r).mdio_aer[0]) & 0xffff)
#define BCMI_QTC_XGXS_MDIO_AERr_MDIO_AERf_SET(r,f) (r).mdio_aer[0]=(((r).mdio_aer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (65535 << 16)

/*
 * These macros can be used to access MDIO_AER.
 */
#define BCMI_QTC_XGXS_READ_MDIO_AERr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_QTC_XGXS_WRITE_MDIO_AERr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_AERr,(_r._mdio_aer)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MDIO_AERr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_QTC_XGXS_READLN_MDIO_AERr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_QTC_XGXS_WRITELN_MDIO_AERr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_QTC_XGXS_WRITEALL_MDIO_AERr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_aer))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_AERr BCMI_QTC_XGXS_MDIO_AERr
#define MDIO_AERr_SIZE BCMI_QTC_XGXS_MDIO_AERr_SIZE
typedef BCMI_QTC_XGXS_MDIO_AERr_t MDIO_AERr_t;
#define MDIO_AERr_CLR BCMI_QTC_XGXS_MDIO_AERr_CLR
#define MDIO_AERr_SET BCMI_QTC_XGXS_MDIO_AERr_SET
#define MDIO_AERr_GET BCMI_QTC_XGXS_MDIO_AERr_GET
#define MDIO_AERr_MDIO_AERf_GET BCMI_QTC_XGXS_MDIO_AERr_MDIO_AERf_GET
#define MDIO_AERr_MDIO_AERf_SET BCMI_QTC_XGXS_MDIO_AERr_MDIO_AERf_SET
#define READ_MDIO_AERr BCMI_QTC_XGXS_READ_MDIO_AERr
#define WRITE_MDIO_AERr BCMI_QTC_XGXS_WRITE_MDIO_AERr
#define MODIFY_MDIO_AERr BCMI_QTC_XGXS_MODIFY_MDIO_AERr
#define READLN_MDIO_AERr BCMI_QTC_XGXS_READLN_MDIO_AERr
#define WRITELN_MDIO_AERr BCMI_QTC_XGXS_WRITELN_MDIO_AERr
#define WRITEALL_MDIO_AERr BCMI_QTC_XGXS_WRITEALL_MDIO_AERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MDIO_AERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_QTC_XGXS
 * REGISTER:  MDIO_BLK_ADDR
 * BLOCKS:   MDIO_BLK_ADDR_COM
 * REGADDR:  0xffdf
 * DEVAD:    1
 * DESC:     BLK_ADDR
 * SIZE:     32
 * FIELDS:
 *     MDIO_BLK_ADDR    Block address (used for clause 22 transactions to get the address bits 14:4)
 */
#define BCMI_QTC_XGXS_MDIO_BLK_ADDRr (0x0001ffdf | PHY_REG_ACC_TSC_IBLK)

#define BCMI_QTC_XGXS_MDIO_BLK_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BLK_ADDR.
 */
typedef union BCMI_QTC_XGXS_MDIO_BLK_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_blk_addr[1];
	uint32_t _mdio_blk_addr;
} BCMI_QTC_XGXS_MDIO_BLK_ADDRr_t;

#define BCMI_QTC_XGXS_MDIO_BLK_ADDRr_CLR(r) (r).mdio_blk_addr[0] = 0
#define BCMI_QTC_XGXS_MDIO_BLK_ADDRr_SET(r,d) (r).mdio_blk_addr[0] = d
#define BCMI_QTC_XGXS_MDIO_BLK_ADDRr_GET(r) (r).mdio_blk_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_QTC_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_GET(r) ((((r).mdio_blk_addr[0]) >> 4) & 0x7ff)
#define BCMI_QTC_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_SET(r,f) (r).mdio_blk_addr[0]=(((r).mdio_blk_addr[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4)) | (2047 << (16 + 4))

/*
 * These macros can be used to access MDIO_BLK_ADDR.
 */
#define BCMI_QTC_XGXS_READ_MDIO_BLK_ADDRr(_pc,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_BLK_ADDRr,(_r._mdio_blk_addr))
#define BCMI_QTC_XGXS_WRITE_MDIO_BLK_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BLK_ADDRr,(_r._mdio_blk_addr)&0xffff)
#define BCMI_QTC_XGXS_MODIFY_MDIO_BLK_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BLK_ADDRr,(_r._mdio_blk_addr))
#define BCMI_QTC_XGXS_READLN_MDIO_BLK_ADDRr(_pc,_l,_r) qmod_tsc_iblk_read(_pc,BCMI_QTC_XGXS_MDIO_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_blk_addr))
#define BCMI_QTC_XGXS_WRITELN_MDIO_BLK_ADDRr(_pc,_l,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_blk_addr))
#define BCMI_QTC_XGXS_WRITEALL_MDIO_BLK_ADDRr(_pc,_r) qmod_tsc_iblk_write(_pc,BCMI_QTC_XGXS_MDIO_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_blk_addr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BLK_ADDRr BCMI_QTC_XGXS_MDIO_BLK_ADDRr
#define MDIO_BLK_ADDRr_SIZE BCMI_QTC_XGXS_MDIO_BLK_ADDRr_SIZE
typedef BCMI_QTC_XGXS_MDIO_BLK_ADDRr_t MDIO_BLK_ADDRr_t;
#define MDIO_BLK_ADDRr_CLR BCMI_QTC_XGXS_MDIO_BLK_ADDRr_CLR
#define MDIO_BLK_ADDRr_SET BCMI_QTC_XGXS_MDIO_BLK_ADDRr_SET
#define MDIO_BLK_ADDRr_GET BCMI_QTC_XGXS_MDIO_BLK_ADDRr_GET
#define MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_GET BCMI_QTC_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_GET
#define MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_SET BCMI_QTC_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_SET
#define READ_MDIO_BLK_ADDRr BCMI_QTC_XGXS_READ_MDIO_BLK_ADDRr
#define WRITE_MDIO_BLK_ADDRr BCMI_QTC_XGXS_WRITE_MDIO_BLK_ADDRr
#define MODIFY_MDIO_BLK_ADDRr BCMI_QTC_XGXS_MODIFY_MDIO_BLK_ADDRr
#define READLN_MDIO_BLK_ADDRr BCMI_QTC_XGXS_READLN_MDIO_BLK_ADDRr
#define WRITELN_MDIO_BLK_ADDRr BCMI_QTC_XGXS_WRITELN_MDIO_BLK_ADDRr
#define WRITEALL_MDIO_BLK_ADDRr BCMI_QTC_XGXS_WRITEALL_MDIO_BLK_ADDRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_QTC_XGXS_MDIO_BLK_ADDRr'
 */




#endif /* __BCMI_QTC_XGXS_DEFS_H__ */
