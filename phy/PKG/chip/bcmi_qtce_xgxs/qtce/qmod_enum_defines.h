/*----------------------------------------------------------------------
 * : qmod_enum_defines.h,                                           
 * : n *                                                                      
 * Broadcom Corporation                                                 
 * Proprietary and Confidential information                             
 * All rights reserved                                                  
 * This source file is the property of Broadcom Corporation, and        
 * may not be copied or distributed in any isomorphic form without the  
 * prior written consent of Broadcom Corporation.                       
 *--------------------------------------------------------------------- 
 *--------------------------------------------------------------------- 
 ############### THIS FILE IS AUTOMATICALLY GENERATED.  ############### 
 ############### DO !! NOT !! MANUALLY EDIT THIS FILE.  ############### 
 *--------------------------------------------------------------------- 
 * Description: This file contains enums, elems, and doxygen comments   
 * needed for SerDes Configuration programs.                            
 *--------------------------------------------------------------------- 
 * CVS INFORMATION:                                                     
 * Please see inc/enum_desc.txt for CVS information.                    
 *----------------------------------------------------------------------
 */                                                                     
/*                                                                      
8ef This software is governed by the Broadcom Switch APIs license.
8ef This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenMDK/master/Legal/LICENSE file.
8ef 
8ef Copyright 2007-2020 Broadcom Inc. All rights reserved.Copyright:                                                         
 * All Rights Reserved.$                                               
 */                                                                     
/* This file is automatically generated. Do not modify it. Modify the
 * inc/enum_desc.txt to change enums, elems, or comments. For issues about
 * the process that creates this file contact the qmod development team.
 */

#ifndef _TSCMOD_ENUM_DEFINES_H
#define _TSCMOD_ENUM_DEFINES_H

/*! \enum qmod_core_select 

qmod_core_select selects for programming, any combination of 3 core of the PHY.
This is only applicable to the 12x10 version of the TSCE core.
A '1' in the latter part of the enum selects the core.


*/

typedef enum {
  QMOD_CORE_0_0_1           = 0   ,  /*!< Core number  0       selected   */
  QMOD_CORE_0_1_0                 ,  /*!< Core number  1       selected   */
  QMOD_CORE_1_0_0                 ,  /*!< Core number  2       selected   */
  QMOD_CORE_0_1_1                 ,  /*!< Core number  0 & 1   selected   */
  QMOD_CORE_1_0_1                 ,  /*!< Core number  0 & 2   selected   */
  QMOD_CORE_1_1_1                 ,  /*!< Core number  0,1,& 2 selected   */
  QMOD_CORE_ILLEGAL                 /*!< Illegal (programmatic boundary) */
} qmod_core_select;

/*! \def CNT_qmod_core_select Types of enum qmod_core_select */
#define CNT_qmod_core_select 7

/*!
\brief
This array returns the string version of the enum #qmod_core_select when
indexed by the enum var.

*/
extern char* e2s_qmod_core_select [CNT_qmod_core_select];
/*!
\brief
This array associates the enum #qmod_core_select enum with a bit mask.
The index is the #qmod_core_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then core [n] is addressed; if bit [n]
is 0, then core [n] is addressed.

*/
extern int e2n_qmod_core_select [CNT_qmod_core_select];
/*! \enum qmod_lane_select 

qmod_lane_select selects for programming, any combination of 4 lanes of PHY.
A '1' in the latter part of the enum name selects the lane.  Other parameters in
the #qmod_st will decide what to do with the selected lane(s). In most cases
we enable/disable a feature on the selected lanes.

If lane_select is set to QMOD_LANE_BCST for writes we broadcast to all lanes.
You cannot read in broadcast mode.


*/

typedef enum {
  QMOD_LANE_0_0_0_1         = 0   ,  /*!< lane number  0       selected   */
  QMOD_LANE_0_0_1_0               ,  /*!< lane number  1       selected   */
  QMOD_LANE_0_0_1_1               ,  /*!< lane numbers 0,1     selected   */
  QMOD_LANE_0_1_0_0               ,  /*!< lane number  2       selected   */
  QMOD_LANE_0_1_0_1               ,  /*!< lane numbers 2,0     selected   */
  QMOD_LANE_0_1_1_0               ,  /*!< lane numbers 2,1     selected   */
  QMOD_LANE_0_1_1_1               ,  /*!< lane numbers 2,1,0   selected   */
  QMOD_LANE_1_0_0_0               ,  /*!< lane number  3       selected   */
  QMOD_LANE_1_0_0_1               ,  /*!< lane numbers 3,0     selected   */
  QMOD_LANE_1_0_1_0               ,  /*!< lane numbers 3,1     selected   */
  QMOD_LANE_1_0_1_1               ,  /*!< lane numbers 3,1,0   selected   */
  QMOD_LANE_1_1_0_0               ,  /*!< lane numbers 3,2     selected   */
  QMOD_LANE_1_1_0_1               ,  /*!< lane numbers 3,2,0   selected   */
  QMOD_LANE_1_1_1_0               ,  /*!< lane numbers 3,2,1   selected   */
  QMOD_LANE_1_1_1_1               ,  /*!< lane numbers 3,2,1,0 selected   */
  QMOD_LANE_BCST                  ,  /*!< lane numbers 3,2,1,0 BCST       */
  QMOD_LANE_ILLEGAL                 /*!< Illegal (programmatic boundary) */
} qmod_lane_select;

/*! \def CNT_qmod_lane_select Types of enum qmod_lane_select */
#define CNT_qmod_lane_select 17

/*!
\brief
This array returns the string version of the enum #qmod_lane_select when
indexed by the enum var.

*/
extern char* e2s_qmod_lane_select [CNT_qmod_lane_select];
/*!
\brief
This array associates the enum #qmod_lane_select enum with a bit mask.
The index is the #qmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_qmod_lane_select [CNT_qmod_lane_select];
/*! \enum qmod_spd_intfc_type 

All legal speed-interface combination are encapsulated in this enum

There are several speed and interface combinations allowed for a logical PHY
port. Names and speeds are self explanatory.

Speed and interface selection is combined because we don't want the speeds
to be incompatible with interface.

*/

typedef enum {
  QMOD_SPD_ZERO             = 0   ,  /*!< Illegal value (enum boundary)   */
  QMOD_SPD_10_X1_SGMII            ,  /*!< 10Mb SGMII (serial)             */
  QMOD_SPD_100_X1_SGMII           ,  /*!< 100Mb SGMII (serial)            */
  QMOD_SPD_1000_X1_SGMII          ,  /*!< 1Gb SGMII (serial)              */
  QMOD_SPD_2500_X1                ,  /*!< 2.5Gb  based on 1000BASE-X      */
  QMOD_SPD_10_SGMII               ,  /*!< 10Mb SGMII (serial)             */
  QMOD_SPD_100_SGMII              ,  /*!< 100Mb SGMII (serial)            */
  QMOD_SPD_1000_SGMII             ,  /*!< 1Gb SGMII (serial)              */
  QMOD_SPD_2500                   ,  /*!< 2.5Gb  based on 1000BASE-X      */
  QMOD_SPD_5000                   ,  /*!< 5Gb  CL36                       */
  QMOD_SPD_1000_XFI               ,  /*!< 1Gb                             */
  QMOD_SPD_5000_XFI               ,  /*!< 5Gb  CL49                       */
  QMOD_SPD_10000_XFI              ,  /*!< 10Gb serial XFI                 */
  QMOD_SPD_10600_XFI_HG           ,  /*!< 10.5Gb serial XFI (HgSOLO)      */
  QMOD_SPD_10000_HI               ,  /*!< 10Gb XAUI HiG                   */
  QMOD_SPD_10000                  ,  /*!< 10Gb XAUI                       */
  QMOD_SPD_12000_HI               ,  /*!< 12Gb XAUI HiG                   */
  QMOD_SPD_13000                  ,  /*!< 13Gb XAUI                       */
  QMOD_SPD_15000                  ,  /*!< 15Gb XAUI                       */
  QMOD_SPD_16000                  ,  /*!< 16Gb XAUI                       */
  QMOD_SPD_20000                  ,  /*!< 20Gb XAUI                       */
  QMOD_SPD_20000_SCR              ,  /*!< 20Gb XAUI scrambled             */
  QMOD_SPD_21000                  ,  /*!< 21Gb XAUI                       */
  QMOD_SPD_25455                  ,  /*!< 25Gb XAUI  64/66 codec          */
  QMOD_SPD_31500                  ,  /*!< 31.5Gb quad lane XAUI           */
  QMOD_SPD_31500_MLD              ,  /*!< 31.5Gb quad lane MLD            */
  QMOD_SPD_40G_X4                 ,  /*!< 40Gb quad lane XAUI             */
  QMOD_SPD_42G_X4                 ,  /*!< 40Gb quad lane XAUI  HiG        */
  QMOD_SPD_40G_XLAUI              ,  /*!< 40Gb quad lane  MLD             */
  QMOD_SPD_42G_XLAUI              ,  /*!< 42Gb quad lane  MLD             */
  QMOD_SPD_10000_X2               ,  /*!< 10Gb dual lane                  */
  QMOD_SPD_10000_HI_DXGXS         ,  /*!< 10Gb dual lane XGXS HiG         */
  QMOD_SPD_10000_DXGXS            ,  /*!< 10Gb dual lane XGXS             */
  QMOD_SPD_10000_HI_DXGXS_SCR       ,  /*!< 10Gb dual lane,scrambled,HiG    */
  QMOD_SPD_10000_DXGXS_SCR        ,  /*!< 10Gb dual lane scrambled        */
  QMOD_SPD_10500_HI               ,  /*!< 10.5Gb XAUI  lane XGXS HiG      */
  QMOD_SPD_10500_HI_DXGXS         ,  /*!< 10.5Gb  dual lane XGXS HiG      */
  QMOD_SPD_12773_HI_DXGXS         ,  /*!< 12.73Gb dual lane XGXS HiG      */
  QMOD_SPD_12773_DXGXS            ,  /*!< 12.73Gb dual lane XGXS          */
  QMOD_SPD_15750_HI_DXGXS         ,  /*!< 15.75Gb scrambled dual lane HiG */
  QMOD_SPD_20G_MLD_DXGXS          ,  /*!< 20Gb dual lane MLD              */
  QMOD_SPD_21G_HI_MLD_DXGXS       ,  /*!< 20Gb dual lane HiG MLD          */
  QMOD_SPD_20G_DXGXS              ,  /*!< 20Gb dual lane BRCM             */
  QMOD_SPD_21G_HI_DXGXS           ,  /*!< 21.2Gb dual HiG(20+plldiv=70)   */
  QMOD_SPD_100G_CR10              ,  /*!< 100G                            */
  QMOD_SPD_107G_HG_CR10           ,  /*!< 107G                            */
  QMOD_SPD_120G_CR12              ,  /*!< 120G                            */
  QMOD_SPD_127G_HG_CR12           ,  /*!< 127G                            */
  QMOD_SPD_4000                   ,  /*!< 4G QSGMII                       */
  QMOD_SPD_10_X1_10               ,  /*!< 10Mb SGMII (serial) vco 10      */
  QMOD_SPD_100_X1_10              ,  /*!< 100Mb SGMII (serial) vco 10     */
  QMOD_SPD_1000_X1_10             ,  /*!< 1Gb SGMII (serial) vco 10       */
  QMOD_SPD_10_X1_12P5             ,  /*!< 10Mb SGMII (serial) vco 12p5    */
  QMOD_SPD_100_X1_12P5            ,  /*!< 100Mb SGMII (serial) vco 12p5   */
  QMOD_SPD_1000_X1_12P5           ,  /*!< 1Gb SGMII (serial) vco 12p5     */
  QMOD_SPD_2500_X1_12P5           ,  /*!< 2.5Gb  SGMII vco 12p5           */
  QMOD_SPD_ILLEGAL                  /*!< Illegal value (enum boundary)   */
} qmod_spd_intfc_type;

/*! \def CNT_qmod_spd_intfc_type Types of enum qmod_spd_intfc_type */
#define CNT_qmod_spd_intfc_type 57

/*!
\brief
This array returns the string version of the enum #qmod_lane_select when
indexed by the enum var.

*/
extern char* e2s_qmod_spd_intfc_type [CNT_qmod_spd_intfc_type];
/*!
\brief
This array associates the enum #qmod_lane_select enum with a bit mask.
The index is the #qmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_qmod_spd_intfc_type [CNT_qmod_spd_intfc_type];
/*! \enum qmod_regacc_type 

Types of MDIO to access PHY registers. IEEE clause 22 and clause 45 are
supported. The 8 bit parallel TOTSC bus can be used. We may use 

*/

typedef enum {
  QMOD_REGACC_CL22          = 0   ,  /*!< IEEE clause 22 based MDIO (for PMD only) */
  QMOD_REGACC_CL45                ,  /*!< IEEE clause 45 based MDIO (for PMD only) */
  QMOD_REGACC_TOTSC               ,  /*!< Mission Mode. */
  QMOD_REGACC_SBUS_FD             ,  /*!< Probably used in PM testbenches. */
  QMOD_REGACC_SBUS_BD             ,  /*!< Probably used in PM testbenches. */
  QMOD_REGACC_ILLEGAL               /*!< Illegal value (enum boundary) */
} qmod_regacc_type;

/*! \def CNT_qmod_regacc_type Types of enum qmod_regacc_type */
#define CNT_qmod_regacc_type 6

/*!
\brief
This array returns the string version of the enum #qmod_regacc_type when indexed
by the enum var.

*/
extern char* e2s_qmod_regacc_type [CNT_qmod_regacc_type];
/*! \enum qmod_port_type 

This is the port mode type enumeration.

WC can be configured in combo mode (i.e. entire WC is a single port) or
independent mode (i.e. WC has more than one port (2, 3, or 4) that are
controlled individually.

*/

typedef enum {
  QMOD_SINGLE_PORT          = 0   ,  /*!< single port mode: 4 channels as one logical port */
  QMOD_MULTI_PORT                 ,  /*!< Each channel is one logical port */
  QMOD_DXGXS                      ,  /*!< Each paired channel(0-1, 2-3) is one logical port */
  QMOD_TRI1_PORT                  ,  /*!< 3 ports, one of them paird as follows (0,1,2-3) */
  QMOD_TRI2_PORT                  ,  /*!< 3 ports, one of them paird as follows (0-1,2,3) */
  QMOD_PORT_MODE_ILLEGAL            /*!< Illegal value (enum boundary) */
} qmod_port_type;

/*! \def CNT_qmod_port_type Types of enum qmod_port_type */
#define CNT_qmod_port_type 6

/*!
\brief
This array returns the string version of the enum #qmod_port_type when indexed
by the enum var.

*/
extern char* e2s_qmod_port_type [CNT_qmod_port_type];
/*! \enum qmod_diag_type 

qmod_diag_type enumerates categories of diagnostic data.
has many intermediate stages between down and up. This enum is work in progress


<table cellspacing=0>
<tr><td colspan=3><B>'per_lane_control' bit-mappings</B></td></tr>

<tr><td><B>Type</B></td><td><B>Description</B></td><td><B>Scope</B></td></tr>

<tr><td>General</td>
<td> Combo/independent, Device and Revision Id, VCO settings, Firmware state
and version, active/passive lanes, MDIO type. PLL info, Oversampling Info</td>
<td>Device</td></tr>

<tr><td>Link</td>
<td> Speeds, oversampling, interface, forced/Autoneg, link status, sync
status, RX sequencer on/off </td>
<td>Lane</td></tr>

<tr><td>Autoneg</td>
<td> Local and remote advertisement, link status, cl73/37/BAM info </td>
<td>Lane</td></tr>

<tr><td>Internal Traffic</td>
<td> PRBS type, CJPat Type, Prog_data value, Any associated recorded errors,
and misc. info (IPG etc.)</td>
<td>Lane </td></tr>

<tr>
<td>DFE</td>
<td>Equalization info, Tap settings. (pre/post/overrides), peaking filter values </td>
<td>Lane</td></tr>

<tr><td>IEEE info</td>
<td>Clause 72, FEC</td>
<td>Lane</td></tr>

<tr><td>Topology</td>
<td>Looping info (Gloop/rloop), lane swapping, polarity swap info</td>
<td>Device</td></tr>

<tr><td>EEE</td>
<td>EEE full, passthru modes, some window values?</td>
<td>Lane</td></tr>

<tr><td>Eye Margin</td>
<td>Eye margin measurement (readout only)</td>
<td>Lane</td></tr>

<tr><td>All</td>
<td>All of the above. Except eye margin.</td>
<td>Device</td></tr>

</table>


*/

typedef enum {
  QMOD_DIAG_GENERAL         = 0x00000001 ,  /*!< General device wide information.         */
  QMOD_DIAG_TOPOLOGY        = 0x00000002 ,  /*!< Loopbacks etc.                           */
  QMOD_DIAG_LINK            = 0x00000004 ,  /*!< Link specific info.                      */
  QMOD_DIAG_SPEED           = 0x00000008 ,  /*!< sub-category of QMOD_DIAG_LINK(for SDK) */
  QMOD_DIAG_ANEG            = 0x00000010 ,  /*!< Autoneg specific info.                   */
  QMOD_DIAG_TFC             = 0x00000020 ,  /*!< State of tx/rx internal tfc              */
  QMOD_DIAG_AN_TIMERS       = 0x00000040 ,  /*!< AN timers */
  QMOD_DIAG_STATE           = 0x00000080 ,  /*!< Debug state registers */
  QMOD_DIAG_DEBUG           = 0x00000100 ,  /*!< Debug */
  QMOD_DIAG_IEEE            = 0x00000200 ,  /*!< IEEE related info                        */
  QMOD_DIAG_EEE             = 0x00000400 ,  /*!< EEE                                      */
  QMOD_SERDES_DIAG          = 0x00008000 ,  /*!< PMD Triage */
  QMOD_DIAG_BER             = 0x00000800 ,  /*!< BER - PMD bit error rate                 */
  QMOD_DIAG_CFG             = 0x00001000 ,  /*!< CFG - PMD Lane/Core Config               */
  QMOD_DIAG_CL72            = 0x00002000 ,  /*!< CL72 - Status                            */
  QMOD_DIAG_DSC             = 0x00004000 ,  /*!< CL72 - Status                            */
  QMOD_DIAG_ALL             = 0x0000ffff ,  /*!< Everything but eye margin                */
  QMOD_DIAG_ILLEGAL         = 0x00000000   /*!< Illegal value. programmatic boundary.    */
} qmod_diag_type;

/*! \def CNT_qmod_diag_type Types of enum qmod_diag_type */
#define CNT_qmod_diag_type 14

/*!
\brief
This array returns the string version of the enum #qmod_port_type when indexed
by the enum var.

*/
extern char* e2s_qmod_diag_type [CNT_qmod_diag_type];
/*! \enum qmod_pmd_diag_type 

qmod_pmd_diag_type enumerates categories of pmd diagnostic data.
has many intermediate stages between down and up. This enum is work in progress

*/

typedef enum {
  QMOD_SERDES_DIAG_CORE_CONFIG = 0x00000001 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_CORE_STATE = 0x00000002 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_LANE_CONFIG = 0x00000004 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_LANE_DEBUG_STATUS = 0x00000008 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_LANE_STATE = 0x00000010 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_LANE_STATE_HDR = 0x00000020 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_LANE_STATE_LEGEND = 0x00000040 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_CL72_STATUS = 0x00000080 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_DENSITY = 0x00000100 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_SCAN = 0x00000200 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_MEAS_EYE_DENSITY_DATA = 0x00000400 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_MEAS_EYE_SCAN_DONE = 0x00000800 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_MEAS_LOWBER_EYE = 0x00001000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_READ_EYE_SCAN_STRIPE = 0x00002000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_DENSITY_DATA = 0x00004000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_LOWBER_EYE = 0x00008000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_SCAN_VERTICAL = 0x00010000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_SCAN_STRIPE = 0x00020000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_SCAN_HEADER = 0x00040000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_SCAN_FOOTER = 0x00080000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_BER_SCAN_TEST = 0x00100000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_READ_BER_SCAN_DATA = 0x00200000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_EYE_MARGIN_PROJ = 0x00400000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_DIG_LPBK = 0x00800000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_MEAS_EYE_SCAN_START = 0x01000000 ,  /*!< SERDES DIAG */
  QMOD_SERDES_DIAG_ILLEGAL  = 0x00000000   /*!< Illegal value (enum boundary) */
} qmod_pmd_diag_type;

/*! \def CNT_qmod_pmd_diag_type Types of enum qmod_pmd_diag_type */
#define CNT_qmod_pmd_diag_type 26

/*!
\brief
This array returns the string version of the enum #qmod_pmd_diag_type when indexed
by the enum var.

*/
extern char* e2s_qmod_pmd_diag_type [CNT_qmod_pmd_diag_type];
/*! \enum qmod_an_type 

qmod_an_type enumerates different types of autoneg modes in the PHY.

*/

typedef enum {
  QMOD_CL73                 = 0   ,  /*!< PHY autoneg CL73 enable */
  QMOD_CL37                       ,  /*!< PHY autoneg CL37 enable */
  QMOD_CL73_BAM                   ,  /*!< PHY autoneg CL73 enable with Brcm Aneg Mode */
  QMOD_CL37_BAM                   ,  /*!< PHY autoneg CL37 enable with  Brcm Aneg Mode */
  QMOD_CL37_SGMII                 ,  /*!< PHY autoneg for SGMII */
  QMOD_HPAM                       ,  /*!< PHY autoneg for HP aneg */
  QMOD_AN_TYPE_ILLEGAL              /*!< Illegal value. programmatic boundary. */
} qmod_an_type;

/*! \def CNT_qmod_an_type Types of enum qmod_an_type */
#define CNT_qmod_an_type 7

/*!
\brief
This array returns the string version of the enum #qmod_pmd_diag_type when indexed
by the enum var.

*/
extern char* e2s_qmod_an_type [CNT_qmod_an_type];
/*! \enum qmod_eye_direction 

The direction of slicer changing always moves from the middle of the eye.
Currently all speeds have the following bit positions in qmod_st

\li QMOD_EYE_VU: Vertical,   Upward direction
\li QMOD_EYE_VD: Vertical,   Downward direction
\li QMOD_EYE_HL: Horizontal, Left  direction
\li QMOD_EYE_HR: Horizontal, Right direction


*/

typedef enum {
  QMOD_EYE_VU               = 0   ,  /*!< Vertical,   Upward direction */
  QMOD_EYE_VD                     ,  /*!< Vertical,   Downward direction */
  QMOD_EYE_HL                     ,  /*!< Horizontal, Left  direction */
  QMOD_EYE_HR                     ,  /*!< Horizontal, Right direction */
  QMOD_EYE_ILLEGAL                  /*!< Programmatic illegal boundary. */
} qmod_eye_direction;

/*! \def CNT_qmod_eye_direction Types of enum qmod_eye_direction */
#define CNT_qmod_eye_direction 5

/*!
\brief
This array returns the string version of the enum #qmod_pmd_diag_type when indexed
by the enum var.

*/
extern char* e2s_qmod_eye_direction [CNT_qmod_eye_direction];


typedef enum {
  QMOD_ABILITY_1G_KX        = 0   ,  /*!< CL73 speed 1G_KX ease        */
  QMOD_ABILITY_10G_KX4            ,  /*!< please write comments        */
  QMOD_ABILITY_10G_KR             ,  /*!< please write comments        */
  QMOD_ABILITY_40G_KR4            ,  /*!< please write comments        */
  QMOD_ABILITY_40G_CR4            ,  /*!< please write comments        */
  QMOD_ABILITY_100G_CR10          ,  /*!< please write comments        */
  QMOD_ABILITY_20G_KR2            ,  /*!< please write comments        */
  QMOD_ABILITY_20G_CR2            ,  /*!< please write comments        */
  QMOD_ABILITY_ILLEGAL              /*!< please write comments        */
} qmod_tech_ability;

/*! \def CNT_qmod_tech_ability Types of enum qmod_tech_ability */
#define CNT_qmod_tech_ability 9

/*!
\brief
This array returns the string version of the enum #qmod_pmd_diag_type when indexed
by the enum var.

*/
extern char* e2s_qmod_tech_ability [CNT_qmod_tech_ability];
/*!
\brief
This array associates the enum #qmod_lane_select enum with a bit mask.
The index is the #qmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_qmod_tech_ability [CNT_qmod_tech_ability];
/*! \enum qmod_cl37bam_ability 

This array associates the enum #qmod_lane_select enum with a bit mask.
The index is the #qmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  Enabled implies the function under
consideration be enebled for the lane. Disabled means the opposite.  So a value
of 0xF indicates that all lanes or enabled, while 0x5 indicates that only lanes
0 and 2 are enabled.

qmod_cl37bam_ability enumerates different types of speed advertisements in the
basic autoneg page for CL37BAM only.

Currently all speeds have the following bit positions in qmod_st

\li QMOD_BAM37ABL_2P5G             Bit Pos: 0
\li QMOD_BAM37ABL_5G_X4            Bit Pos: 1
\li QMOD_BAM37ABL_6G_X4            Bit Pos: 2
\li QMOD_BAM37ABL_10G_HIGIG        Bit Pos: 3
\li QMOD_BAM37ABL_10G_CX4          Bit Pos: 4
\li QMOD_BAM37ABL_12G_X4           Bit Pos: 5
\li QMOD_BAM37ABL_12P5_X4          Bit Pos: 6
\li QMOD_BAM37ABL_13G_X4           Bit Pos: 7
\li QMOD_BAM37ABL_15G_X4           Bit Pos: 8
\li QMOD_BAM37ABL_16G_X4           Bit Pos: 9
\li QMOD_BAM37ABL_20G_X4_CX4       Bit Pos: 10
\li QMOD_BAM37ABL_20G_X4           Bit Pos: 11
\li QMOD_BAM37ABL_21G_X4           Bit Pos: 12
\li QMOD_BAM37ABL_25P455G          Bit Pos: 13
\li QMOD_BAM37ABL_31P5G            Bit Pos: 14
\li QMOD_BAM37ABL_32P7G            Bit Pos: 15
\li QMOD_BAM37ABL_40G              Bit Pos: 16
\li QMOD_BAM37ABL_10G_X2_CX4       Bit Pos: 17
\li QMOD_BAM37ABL_10G_DXGXS        Bit Pos: 18
\li QMOD_BAM37ABL_10P5G_DXGXS      Bit Pos: 19
\li QMOD_BAM37ABL_12P7_DXGXS       Bit Pos: 20
\li QMOD_BAM37ABL_15P75G_R2        Bit Pos: 21
\li QMOD_BAM37ABL_20G_X2_CX4       Bit Pos: 22
\li QMOD_BAM37ABL_20G_X2           Bit Pos: 23


*/

typedef enum {
  QMOD_BAM37ABL_2P5G        = 0   ,  /*!< X1 BRCM */
  QMOD_BAM37ABL_5G_X4             ,  /*!< BRCM */
  QMOD_BAM37ABL_6G_X4             ,  /*!< BRCM */
  QMOD_BAM37ABL_10G_HIGIG         ,  /*!< HG (10G_X4) */
  QMOD_BAM37ABL_10G_CX4           ,  /*!< (10G_X4_CX4) */
  QMOD_BAM37ABL_12G_X4            ,  /*!< HG */
  QMOD_BAM37ABL_12P5_X4           ,  /*!< HG */
  QMOD_BAM37ABL_13G_X4            ,  /*!< HG */
  QMOD_BAM37ABL_15G_X4            ,  /*!< HG */
  QMOD_BAM37ABL_16G_X4            ,  /*!< HG */
  QMOD_BAM37ABL_20G_X4_CX4        ,  /*!< XAUI 8b10b scram(20G_X4S) */
  QMOD_BAM37ABL_20G_X4            ,  /*!< HG */
  QMOD_BAM37ABL_21G_X4            ,  /*!< HG */
  QMOD_BAM37ABL_25P455G           ,  /*!< X4 HG */
  QMOD_BAM37ABL_31P5G             ,  /*!< X4 HG */
  QMOD_BAM37ABL_32P7G             ,  /*!< X4 HG */
  QMOD_BAM37ABL_40G               ,  /*!< X4 BRCM HG (40G_X4) */
  QMOD_BAM37ABL_10G_X2_CX4        ,  /*!< 10G_X2_CX4 */
  QMOD_BAM37ABL_10G_DXGXS         ,  /*!< 10G_X2 */
  QMOD_BAM37ABL_10P5G_DXGXS       ,  /*!< 10P5_X2 */
  QMOD_BAM37ABL_12P7_DXGXS        ,  /*!< 12P7_X2 */
  QMOD_BAM37ABL_15P75G_R2         ,  /*!< 15P75_X2 */
  QMOD_BAM37ABL_20G_X2_CX4        ,  /*!< 20G_X2_CX4 */
  QMOD_BAM37ABL_20G_X2            ,  /*!< 20G_X2 */
  QMOD_BAM37ABL_ILLEGAL             /*!< Illegal. Programmatic boundary */
} qmod_cl37bam_ability;

/*! \def CNT_qmod_cl37bam_ability Types of enum qmod_cl37bam_ability */
#define CNT_qmod_cl37bam_ability 25

/*!
\brief
This array returns the string version of the enum #qmod_pmd_diag_type when indexed
by the enum var.

*/
extern char* e2s_qmod_cl37bam_ability [CNT_qmod_cl37bam_ability];
/*! \enum qmod_diag_an_type 

This array associates the enum #qmod_lane_select enum with a bit mask.
The index is the #qmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/

typedef enum {
  QMOD_DIAG_AN_DONE         = 0   ,  /*!< AN completion check */
  QMOD_DIAG_AN_HCD                ,  /*!< AN HCD speed check */
  QMOD_DIAG_AN_TYPE_ILLEGAL         /*!< Illegal value. programmatic boundary */
} qmod_diag_an_type;

/*! \def CNT_qmod_diag_an_type Types of enum qmod_diag_an_type */
#define CNT_qmod_diag_an_type 3

/*!
\brief
This array returns the string version of the enum #qmod_pmd_diag_type when indexed
by the enum var.

*/
extern char* e2s_qmod_diag_an_type [CNT_qmod_diag_an_type];
/*! \enum qmod_tier1_function_type 

This array associates the enum #qmod_lane_select enum with a bit mask.
The index is the #qmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/

typedef enum {
  PCS_BYPASS_CTL             = 0   ,  /*!< qmod_pcs_bypass_ctl  */
  INIT_PCS                         ,  /*!< qmod_init_pcs */
  INIT_PMD_SW                      ,  /*!< qmod_init_pmd_sw */
  INIT_PMD                         ,  /*!< qmod_init_pmd */
  PMD_RESET_SEQ                    ,  /*!< qmod_pmd_reset_seq */
  PMD_X4_RESET                     ,  /*!< qmod_pmd_x4_reset */
  WAIT_SC_DONE                     ,  /*!< qmod_wait_sc_done */
  ENABLE_SET                       ,  /*!< qmod_enable_set */
  FECMODE_SET                      ,  /*!< qmod_fecmode_set */
  GET_PCS_LINK_STATUS              ,  /*!< qmod_get_pcs_link_status */
  OVERRIDE_SET                     ,  /*!< qmod_override_set   */
  CREDIT_OVERRIDE_SET              ,  /*!< qmod_credit_override_set   */
  ENCODE_SET                       ,  /*!< qmod_encode_set   */
  DECODE_SET                       ,  /*!< qmod_decode_set */
  CREDIT_CONTROL                   ,  /*!< qmod_credit_control */
  TX_LANE_CONTROL                  ,  /*!< qmod_tx_lane_control */
  RX_LANE_CONTROL                  ,  /*!< qmod_rx_lane_control */
  TX_LANE_DISABLE                  ,  /*!< qmod_tx_lane_disable */
  POWER_CONTROL                    ,  /*!< qmod_power_control */
  AUTONEG_SET                      ,  /*!< qmod_autoneg_set */
  AUTONEG_GET                      ,  /*!< qmod_autoneg_get */
  AUTONEG_CONTROL                  ,  /*!< qmod_autoneg_control */
  TSC12_CONTROL                    ,  /*!< qmod_tsc12_control */
  CHECK_SC_STATS                   ,  /*!< qmod_check_sc_stats */
  REG_READ                         ,  /*!< qmod_reg_read */
  REG_WRITE                        ,  /*!< qmod_reg_write */
  PRBS_CHECK                       ,  /*!< qmod_prbs_check */
  CJPAT_CRPAT_MODE_SET             ,  /*!< qmod_cjpat_crpat_mode_set */
  CJPAT_CRPAT_CHECK                ,  /*!< qmod_cjpat_crpat_check */
  QMOD_DIAG                       ,  /*!< qmod_diag */
  PCS_LANE_SWAP                    ,  /*!< qmod_pcs_lane_swap */
  PMD_LANE_SWAP                    ,  /*!< qmod_pmd_lane_swap */
  PMD_LANE_SWAP_TX                 ,  /*!< qmod_pmd_lane_swap_tx */
  PARALLEL_DETECT_CONTROL          ,  /*!< qmod_parallel_detect_control */
  REVID_READ                       ,  /*!< qmod_revid_read */
  SOFT_RESET                       ,  /*!< qmod_soft_reset */
  SET_SPD_INTF                     ,  /*!< qmod_set_spd_intf */
  SET_PORT_MODE                    ,  /*!< qmod_set_port_mode */
  EEE_PASSTHRU_SET                 ,  /*!< qmod_EEE_pass_thru_set */
  EEE_PASSTHRU_GET                 ,  /*!< qmod_EEE_pass_thru_get */
  FEC_CONTROL                      ,  /*!< qmod_FEC_control */
  HIGIG2_CONTROL                   ,  /*!< qmod_HIGIG2_control */
  LF_RF_CONTROL                    ,  /*!< qmod_LF_RF_control */
  RX_FAST_LOCK_CONTROL             ,  /*!< qmod_rx_fast_lock_control */
  PMD_CORE_RESET                   ,  /*!< qmod_pmd_core_reset */
  PMD_LANE_RESET                   ,  /*!< qmod_pmd_lane_reset */
  AFE_SPEED_UP_DSC_VGA             ,  /*!< qmod_afe_speed_up_dsc_vga */
  CLAUSE_72_CONTROL                ,  /*!< qmod_clause72_control */
  PLL_SEQUENCER_CONTROL            ,  /*!< qmod_pll_sequencer_control */
  PLL_LOCK_WAIT                    ,  /*!< qmod_pll_lock_wait */
  PROG_DATA                        ,  /*!< qmod_prog_data */
  RX_SEQ_CONTROL                   ,  /*!< qmod_rx_seq_control */
  SET_POLARITY                     ,  /*!< qmod_tx_rx_polarity */
  PRBS_CONTROL                     ,  /*!< qmod_prbs_control */
  PRBS_MODE                        ,  /*!< qmod_prbs_mode */
  RX_PF_CONTROL                    ,  /*!< qmod_rx_PF_control */
  RX_VGA_CONTROL                   ,  /*!< qmod_rx_VGA_control */
  CJPAT_CRPAT_CONTROL              ,  /*!< qmod_cjpat_crpat_control */
  TX_LOOPBACK_CONTROL              ,  /*!< qmod_tx_loopback_control */
  TX_PMD_LOOPBACK_CONTROL          ,  /*!< qmod_tx_pmd_loopback_control */
  RX_LOOPBACK_CONTROL              ,  /*!< qmod_rx_loopback_control */
  RX_P1_SLICER_CONTROL             ,  /*!< qmod_rx_p1_slicer_control */
  RX_M1_SLICER_CONTROL             ,  /*!< qmod_rx_m1_slicer_control */
  RX_D_SLICER_CONTROL              ,  /*!< qmod_rx_d_slicer_control */
  WAIT_PMD_LOCK                    ,  /*!< qmod_wait_pmd_lock */
  FIRMWARE_SET                     ,  /*!< qmod_firmware_set */
  PMD_RESET_BYPASS                 ,  /*!< qmod_pmd_reset_bypass */
  PMD_OVERRIDE_CONTROL             ,  /*!< qmod_pmd_override_control */
  SET_QPORT_SPD                    ,  /*!< qmod_set_qport_spd */
  SET_QSGMII_EN                    ,  /*!< qmod_set_qsgmii_en */
  QMODE_DISABLE_SET                ,  /*!< qmod_disable_set */
  PLL_LOCK_GET                     ,  /*!< qmod_pll_lock_get */
  PMD_LOCK_GET                     ,  /*!< qmod_pmd_lock_get */
  AUTONEG_SET_INIT                 ,  /*!< qmod_autonet_set_init */
  AUTONEG_ABILITIES_CONTROL        ,  /*!< qmod_autonet_abilities_controls */
  AUTONEG_CL37_BASE_ABILITIES       ,  /*!< qmod_autoneg_cl37_base_abilities */
  AUTONEG_CL37_BAM_OVER1G_ABILITIES       ,  /*!< qmod_autoneg_cl37_bam_over1g_abilities */
  AUTONEG_AUTONEG_CONTROL_GET       ,  /*!< qmod_autoneg_control_get */
  AUTONEG_AUTONEG_LOCAL_ABILITY_GET       ,  /*!< qmod_autoneg_local_ability_get */
  AUTONEG_AUTONEG_REMOTE_ABILITY_GET       ,  /*!< qmod_autoneg_remote_ability_get */
  AUTONEG_AN_ABILITIES_ENABLES       ,  /*!< qmod_an_abilities_enables */
  AUTONEG_GET_HT_ENTRIES           ,  /*!< qmod_get_ht_entries */
  UPDATE_PORT_MODE_SELECT          ,  /*!< qmod_update_port_mode_select */
  TX_RX_POLARITY_SET               ,  /*!< qmod_tx_rx_polarity_set */
  TX_RX_POLARITY_GET               ,  /*!< qmod_tx_rx_polarity_get */
  TX_PI_CONTROL_GET                ,  /*!< qmod_tx_pi_control_get */
  TX_LANE_DISABLE_SET              ,  /*!< qmod_tx_lane_disable_set */
  TX_LANE_DISABLE_GET              ,  /*!< qmod_tx_lane_disable_get */
  SPEED_ID_GET                     ,  /*!< qmod_speed_id_get */
  PMD_LANE_SWAP_TX_GET             ,  /*!< qmod_pmd_lane_swap_tx_get */
  PLL_RESET_ENABLE_SET             ,  /*!< qmod_pll_reset_enable_set */
  PLL_MODE_SET                     ,  /*!< qmod_pll_mode_set */
  PCS_LANE_SWAP_GET                ,  /*!< qmod_pcs_lane_swap_get */
  OSMODE_SET                       ,  /*!< qmod_osmode_set */
  MASTER_PORT_NUM_SET              ,  /*!< qmod_master_port_num_set */
  GET_PLLDIV                       ,  /*!< qmod_get_plldiv */
  DISABLE_GET                      ,  /*!< qmod_disable_get */
  FIRMWARE_LOAD                    ,  /*!< qmod_firmware_load */
  PRBS_RX_POLYNOMIAL_SET           ,  /*!< qmod_prbs_rx_polynomial_set */
  RX_LANE_CONTROL_SET              ,  /*!< qmod_rx_lane_control_set */
  RX_LANE_CONTROL_GET              ,  /*!< qmod_rx_lane_control_get */
  TRIGGER_SPEED_CHANGE             ,  /*!< qmod_trigger_speed_change */
  TIER1_FUNCTION_ILLEGAL             /*!< always last  */
} qmod_tier1_function_type;

/*! \def CNT_qmod_tier1_function_type Types of enum qmod_tier1_function_type */
#define CNT_qmod_tier1_function_type 103

/*!
\brief
This array returns the string version of the enum #qmod_pmd_diag_type when indexed
by the enum var.

*/
extern char* e2s_qmod_tier1_function_type [CNT_qmod_tier1_function_type];

/*! \def CNT_sc_mode_type Types of enum sc_mode_type */
#define CNT_sc_mode_type 8

/*!
\brief
This array returns the string version of the enum
#qmod_core_select when
indexed by the enum var.

*/
extern char* e2s_sc_mode_type [CNT_sc_mode_type];

/*! \enum qmod_pll_mode_type 
qmod_pll_mode_type divides the PLL to get a clock which is a multiple of the
refernce clock. This clock runs all the digital logic in the MAC and PHY layers
and is referred to as TSC_CLK. To get the TSC_CLK, you simply multiply the
reference clock by the pll divider value (not the reg. bit location)

*/

typedef enum {
  QMOD_PLL_MODE_DIV_ZERO    = 0   ,  /*!< Illegal PLL Divider Number      */
  QMOD_PLL_MODE_DIV_40      = 2   ,  /*!< Multiply ref. clk by 40         */
  QMOD_PLL_MODE_DIV_42      = 3   ,  /*!< Multiply ref. clk by 42         */
  QMOD_PLL_MODE_DIV_48      = 4   ,  /*!< Multiply ref. clk by 48         */
  QMOD_PLL_MODE_DIV_52      = 6   ,  /*!< Multiply ref. clk by 52         */
  QMOD_PLL_MODE_DIV_54      = 7   ,  /*!< Multiply ref. clk by 54         */
  QMOD_PLL_MODE_DIV_60      = 8   ,  /*!< Multiply ref. clk by 60         */
  QMOD_PLL_MODE_DIV_64      = 9   ,  /*!< Multiply ref. clk by 64         */
  QMOD_PLL_MODE_DIV_66      = 10  ,  /*!< Multiply ref. clk by 66         */
  QMOD_PLL_MODE_DIV_70      = 12  ,  /*!< Multiply ref. clk by 70         */
  QMOD_PLL_MODE_DIV_80      = 13  ,  /*!< Multiply ref. clk by 80         */
  QMOD_PLL_MODE_DIV_92      = 14  ,  /*!< Multiply ref. clk by 92         */
  QMOD_PLL_MODE_DIV_ILLEGAL         /*!< Illegal (programmatic boundary) */
} qmod_pll_mode_type;

/*! \def CNT_qmod_pll_mode_type Types of enum qmod_pll_mode_type */
#define CNT_qmod_pll_mode_type 13

/*!
\brief
This array returns the string of #qmod_pll_mode_type when indexed by the enum.

*/
extern char* e2s_qmod_pll_mode_type [CNT_qmod_pll_mode_type];
/*!
\brief
This array returns the clock multiplier of #qmod_pll_mode_type when indexed by the enum.

*/
extern int e2n_qmod_pll_mode_type [CNT_qmod_pll_mode_type];
/*! \enum qmod_os_mode_type 


The oversampling mode means that bits are sent out more than once to reduce
the effective frequency of data transfer. For example you can send 5G bits
over a 10G bit lane by sending every bit twice, or OS=2. When the OS is 3.3
it's a bit tricky, we send bits 3 or 4 times in a pattern like so
3,3,3,4,3,3,3,4,... Similarly for OS = 8, we send 8,8,8,9,8,8,8,9,...


*/

typedef enum {
  QMOD_PMA_OS_MODE_1        = 0   ,  /*!< Over sampling Mode 1         */
  QMOD_PMA_OS_MODE_2        = 1   ,  /*!< Over sampling Mode 2         */
  QMOD_PMA_OS_MODE_3        = 2   ,  /*!< Over sampling Mode 3         */
  QMOD_PMA_OS_MODE_3_3      = 3   ,  /*!< Over sampling Mode 3.3       */
  QMOD_PMA_OS_MODE_4        = 4   ,  /*!< Over sampling Mode 4         */
  QMOD_PMA_OS_MODE_5        = 5   ,  /*!< Over sampling Mode 5         */
  QMOD_PMA_OS_MODE_7_25     = 6   ,  /*!< Over sampling Mode 7.25      */
  QMOD_PMA_OS_MODE_8        = 7   ,  /*!< Over sampling Mode 8         */
  QMOD_PMA_OS_MODE_8_25     = 8   ,  /*!< Over sampling Mode 8.25      */
  QMOD_PMA_OS_MODE_10       = 9   ,  /*!< Over sampling Mode 10        */
  QMOD_PMA_OS_MODE_ILLEGAL  = 15    /*!< Over sampling Mode Illegal   */
} qmod_os_mode_type;

/*! \def CNT_qmod_os_mode_type Types of enum qmod_os_mode_type */
#define CNT_qmod_os_mode_type 11

/*!
\brief
This array returns the string of #qmod_os_mode when indexed by the enum.

*/
extern char* e2s_qmod_os_mode_type [CNT_qmod_os_mode_type];
/*!
\brief
This array returns the over sampling value of #qmod_os_mode when indexed by
the enum. For floating values 3.3 and 8.25 it returns 33 and 825.

*/
extern int e2n_qmod_os_mode_type [CNT_qmod_os_mode_type];
/*! \enum qmod_scr_mode 

This mode indicates how many bits of a 'frame' will be scrambled. We have either
66 or 80 bits per frame (depending on 8b10b or 64b66b encoding). Normally
scrambling is 

\li bypassed for baud rates under 6.25G (0). 
\li we scramble all 66 bits (1)
\li all 80 bits(2)
\li only 64 of the 66b (3). i.e we don't scramble the 'sync' bits.

*/

typedef enum {
  QMOD_SCR_MODE_BYPASS      = 0   ,  /*!< Scrambling Mode bypassed      */
  QMOD_SCR_MODE_66B         = 1   ,  /*!< Scrambling Mode 66B           */
  QMOD_SCR_MODE_80B         = 2   ,  /*!< Scrambling Mode 80B           */
  QMOD_SCR_MODE_64B         = 3     /*!< Scrambling Mode 64B           */
} qmod_scr_mode;

/*! \def CNT_qmod_scr_mode Types of enum qmod_scr_mode */
#define CNT_qmod_scr_mode 4

/*!
\brief
This array returns the string of #qmod_scr_mode when indexed by the enum.

*/
extern char* e2s_qmod_scr_mode [CNT_qmod_scr_mode];
/*!
\brief
This array returns the scrambling mode of #qmod_scr_mode when indexed by
the enum.

*/
extern int e2n_qmod_scr_mode [CNT_qmod_scr_mode];
/*! \enum qmod_encode_mode 

Serial bits are encoded when transmitted. The encoding depends on the baud rate
and the link type
\li 000 All encoding functions disabled for lane
\li 001 8b10b  (cl48 )
\li 010 8b10b  (cl48 rxaui)
\li 011 8b10b  (cl36 )
\li 100 64b66b (cl82 )
\li 101 64b66b (cl49 )
\li 110 64b66b (brcm )

*/

typedef enum {
  QMOD_ENCODE_MODE_NONE     = 0   ,  /*!< Encoding Mode NONE     */
  QMOD_ENCODE_MODE_CL48     = 1   ,  /*!< Encoding Mode CL48     */
  QMOD_ENCODE_MODE_CL48_2_LANE = 2   ,  /*!< Encoding Mode CL48     */
  QMOD_ENCODE_MODE_CL36     = 3   ,  /*!< Encoding Mode CL36     */
  QMOD_ENCODE_MODE_CL82     = 4   ,  /*!< Encoding Mode CL82     */
  QMOD_ENCODE_MODE_CL49     = 5   ,  /*!< Encoding Mode CL49     */
  QMOD_ENCODE_MODE_BRCM     = 6   ,  /*!< Encoding Mode BRCM     */
  QMOD_ENCODE_MODE_ILLEGAL  = 7     /*!< Encoding Mode Illegal  */
} qmod_encode_mode;

/*! \def CNT_qmod_encode_mode Types of enum qmod_encode_mode */
#define CNT_qmod_encode_mode 8

/*!
\brief
This array returns the string of #qmod_encode_mode when indexed by the enum.

*/
extern char* e2s_qmod_encode_mode [CNT_qmod_encode_mode];
/*!
\brief
This array returns the encoding mode of #qmod_encode_mode when indexed by
the enum.

*/
extern int e2n_qmod_encode_mode [CNT_qmod_encode_mode];
/*! \enum qmod_check_end_mode 

Check end is a disparity based error bit set by the PCS for CL48. The generation
of this error bit depends on the speed.

*/

typedef enum {
  QMOD_CL48_CHECK_END_OFF   = 0   ,  /*!< Don't generate checkend error bit  */
  QMOD_CL48_CHECK_END_ON    = 1     /*!< generate checkend error bit */
} qmod_check_end_mode;

/*! \def CNT_qmod_check_end_mode Types of enum qmod_check_end_mode */
#define CNT_qmod_check_end_mode 2

/*!
\brief
This array returns the string of #qmod_check_end_mode when indexed by the enum.

*/
extern char* e2s_qmod_check_end_mode [CNT_qmod_check_end_mode];
/*! \enum qmod_sigdet_filter 

No documentation available

*/

typedef enum {
  QMOD_SIGDET_FILTER_NONCX4 = 0   ,  /*!< No description available */
  QMOD_SIGDET_FILTER_CX4    = 1     /*!< No description available */
} qmod_sigdet_filter;

/*! \def CNT_qmod_sigdet_filter Types of enum qmod_sigdet_filter */
#define CNT_qmod_sigdet_filter 2

/*!
\brief
This array returns the string of #qmod_sigdet_filter when indexed by the enum.

*/
extern char* e2s_qmod_sigdet_filter [CNT_qmod_sigdet_filter];
/*! \enum qmod_blocksync_mode 

A block is detected in ports with multiple lanes. PCS has to recognize blocks
since the bits may come in skewed in time over lanes. This feature identifies
the block type, which is a feature of the speed.

000 none
001 cl49 mode - enables func_cl49cl82_sync block
010 cl82 mode - enables func_cl49cl82_sync block
011 8b10b mode - enables the func_8b10b_sync block
100 fec mode - enables the func_fec_sync block
101 brcm 64b66b mode

*/

typedef enum {
  QMOD_BLOCKSYNC_MODE_NONE  = 0   ,  /*!< Block sync mode none    */
  QMOD_BLOCKSYNC_MODE_CL49  = 1   ,  /*!< Block sync mode CL49 type    */
  QMOD_BLOCKSYNC_MODE_CL82  = 2   ,  /*!< Block sync mode CL82  type */
  QMOD_BLOCKSYNC_MODE_8B10B = 3   ,  /*!< Block sync mode 8B10B type */
  QMOD_BLOCKSYNC_MODE_FEC   = 4   ,  /*!< Block sync mode FEC   type */
  QMOD_BLOCKSYNC_MODE_BRCM  = 5   ,  /*!< Block sync mode BRCM  type */
  QMOD_BLOCKSYNC_MODE_ILLEGAL = 7     /*!< Block sync mode illegal */
} qmod_blocksync_mode;

/*! \def CNT_qmod_blocksync_mode Types of enum qmod_blocksync_mode */
#define CNT_qmod_blocksync_mode 7

/*!
\brief
This array returns the string of #qmod_blocksync_mode when indexed by the enum.

*/
extern char* e2s_qmod_blocksync_mode [CNT_qmod_blocksync_mode];
/*! \enum qmod_reorder_mode 

Depending on aggregation mode we have various types of reordering of serial
bits. 

*/

typedef enum {
  QMOD_R_REORDER_MODE_NONE  = 0   ,  /*!< Reorder mode NONE type */
  QMOD_R_REORDER_MODE_CL48  = 1   ,  /*!< Reorder mode CL48 type */
  QMOD_R_REORDER_MODE_CL36  = 2   ,  /*!< Reorder mode CL36 type */
  QMOD_R_REORDER_MODE_CL36_CL48 = 3     /*!< Reorder mode CL36_CL48 type */
} qmod_reorder_mode;

/*! \def CNT_qmod_reorder_mode Types of enum qmod_reorder_mode */
#define CNT_qmod_reorder_mode 4

/*!
\brief
This array returns the string of #qmod_reorder_mode when indexed by the enum.

*/
extern char* e2s_qmod_reorder_mode [CNT_qmod_reorder_mode];
/*! \enum qmod_cl36_mode 

Cl36 mode control

*/

typedef enum {
  QMOD_CL36_DISABLE         = 0   ,  /*!<  */
  QMOD_CL36_ENABLE          = 1     /*!<  */
} qmod_cl36_mode;

/*! \def CNT_qmod_cl36_mode Types of enum qmod_cl36_mode */
#define CNT_qmod_cl36_mode 2

/*!
\brief
This array returns the string of #qmod_cl36_mode when indexed by the enum.

*/
extern char* e2s_qmod_cl36_mode [CNT_qmod_cl36_mode];
/*! \enum qmod_descrambler_mode 

The descrambling must match the scrambling done at the transmitting port.

*/

typedef enum {
  QMOD_R_DESCR1_MODE_BYPASS = 0   ,  /*!< No descrambling */
  QMOD_R_DESCR1_MODE_66B    = 1   ,  /*!< 66b descrambling */
  QMOD_R_DESCR1_MODE_10B    = 2   ,  /*!< 10b descrambling */
  QMOD_R_DESCR1_MODE_ILLEGAL = 3     /*!<  */
} qmod_descrambler_mode;

/*! \def CNT_qmod_descrambler_mode Types of enum qmod_descrambler_mode */
#define CNT_qmod_descrambler_mode 4

/*!
\brief
This array returns the string of #qmod_descrambler_mode when indexed by the enum.

*/
extern char* e2s_qmod_descrambler_mode [CNT_qmod_descrambler_mode];
/*! \enum qmod_decoder_mode 

The descrambling must match the scrambling done at the transmitting port.

*/

typedef enum {
  QMOD_DECODER_MODE_NONE    = 0   ,  /*!< decoder mode NONE    */
  QMOD_DECODER_MODE_CL49    = 1   ,  /*!< decoder mode CL49    */
  QMOD_DECODER_MODE_BRCM    = 2   ,  /*!< decoder mode BRCM        */
  QMOD_DECODER_MODE_ALU     = 3   ,  /*!< decoder mode ALU       */
  QMOD_DECODER_MODE_CL48    = 4   ,  /*!< decoder mode CL48      */
  QMOD_DECODER_MODE_CL36    = 5   ,  /*!< decoder mode CL36    */
  QMOD_DECODER_MODE_CL82    = 6   ,  /*!< decoder mode CL82    */
  QMOD_DECODER_MODE_ILLEGAL = 7     /*!< decoder mode ILLEGAL */
} qmod_decoder_mode;

/*! \def CNT_qmod_decoder_mode Types of enum qmod_decoder_mode */
#define CNT_qmod_decoder_mode 8

/*!
\brief
This array returns the string of #qmod_decoder_mode when indexed by the enum.

*/
extern char* e2s_qmod_decoder_mode [CNT_qmod_decoder_mode];
/*! \enum qmod_deskew_mode 

Deskew Mode is a function of speed. 

*/

typedef enum {
  QMOD_R_DESKEW_MODE_BYPASS = 0   ,  /*!< deskew mode BYPASS   */
  QMOD_R_DESKEW_MODE_8B_10B = 1   ,  /*!< deskew mode 8B_10B   */
  QMOD_R_DESKEW_MODE_BRCM_66B = 2   ,  /*!< deskew mode BRCM_66B */
  QMOD_R_DESKEW_MODE_CL82_66B = 3   ,  /*!< deskew mode CL82_66B */
  QMOD_R_DESKEW_MODE_CL36_10B = 4   ,  /*!< deskew mode CL36_10B */
  QMOD_R_DESKEW_MODE_ILLEGAL = 7     /*!< deskew mode ILLEGAL  */
} qmod_deskew_mode;

/*! \def CNT_qmod_deskew_mode Types of enum qmod_deskew_mode */
#define CNT_qmod_deskew_mode 6

/*!
\brief
This array returns the string of #qmod_deskew_mode when indexed by the enum.

*/
extern char* e2s_qmod_deskew_mode [CNT_qmod_deskew_mode];
/*! \enum qmod_descrambler2_mode 

No description 

*/

typedef enum {
  QMOD_DESC2_MODE_NONE      = 0   ,  /*!< Descrambler2 mode NONE    */
  QMOD_DESC2_MODE_CL49      = 1   ,  /*!< Descrambler2 mode CL49    */
  QMOD_DESC2_MODE_BRCM      = 2   ,  /*!< Descrambler2 mode BRCM    */
  QMOD_DESC2_MODE_ALU       = 3   ,  /*!< Descrambler2 mode ALU     */
  QMOD_DESC2_MODE_CL48      = 4   ,  /*!< Descrambler2 mode CL48    */
  QMOD_DESC2_MODE_CL36      = 5   ,  /*!< Descrambler2 mode CL36    */
  QMOD_DESC2_MODE_CL82      = 6   ,  /*!< Descrambler2 mode CL82    */
  QMOD_DESC2_MODE_ILLEGAL   = 7     /*!< Descrambler2 mode ILLEGAL */
} qmod_descrambler2_mode;

/*! \def CNT_qmod_descrambler2_mode Types of enum qmod_descrambler2_mode */
#define CNT_qmod_descrambler2_mode 8

/*!
\brief
This array returns the string of #qmod_descrambler2_mode when indexed by the enum.

*/
extern char* e2s_qmod_descrambler2_mode [CNT_qmod_descrambler2_mode];
/*! \enum qmod_byte_del_mode 

For low speeds, data is duplicted 10 or 100 times to run at higher bauds. For
example in a 10G lane, we duplicate 100M data 100 times. On the receive side
these duplicate bits must be deleted.
\li 0 - 100M mode (Delete 9 out of every 10 bytes)
\li 1 - 10M mode (Delete 99 out of every 100 bytes)
\li 2 - Passthrough (No deletion)


*/

typedef enum {
  QMOD_R_DESC2_BYTE_DELETION_100M = 0   ,  /*!< 100M type Byte deletion */
  QMOD_R_DESC2_BYTE_DELETION_10M = 1   ,  /*!< 10M  type Byte deletion */
  QMOD_R_DESC2_BYTE_DELETION_NONE = 2     /*!< No   Byte deletion */
} qmod_byte_del_mode;

/*! \def CNT_qmod_byte_del_mode Types of enum qmod_byte_del_mode */
#define CNT_qmod_byte_del_mode 3

/*!
\brief
This array returns the string of #qmod_blocksync_mode when indexed by the enum.

*/
extern char* e2s_qmod_byte_del_mode [CNT_qmod_byte_del_mode];
/*! \enum qmod_decode_descr_mode 

No description

*/

typedef enum {
  QMOD_R_DEC1_DESCR_MODE_NONE = 0   ,  /*!<  */
  QMOD_R_DEC1_DESCR_MODE_BRCM64B66B = 1     /*!<  */
} qmod_decode_descr_mode;

/*! \def CNT_qmod_decode_descr_mode Types of enum qmod_decode_descr_mode */
#define CNT_qmod_decode_descr_mode 2

/*!
\brief
This array returns the string of #qmod_decode_descr_mode when indexed by the enum.

*/
extern char* e2s_qmod_decode_descr_mode [CNT_qmod_decode_descr_mode];
/*! \enum an_property_enable 

No description

*/

typedef enum {
  QMOD_AN_PROPERTY_ENABLE_NONE = 0x00000000 ,  /*!<  */
  QMOD_AN_PROPERTY_ENABLE_SGMII_MASTER_MODE = 0x00000001 ,  /*!<  */
  QMOD_AN_PROPERTY_ENABLE_AN_PD_TO_CL37 = 0x00000002 ,  /*!<  */
  QMOD_AN_PROPERTY_ENABLE_SGMII_TO_CL37_AUTO = 0x00000004 ,  /*!<  */
  QMOD_AN_PROPERTY_ENABLE_CL37_BAM_to_SGMII_AUTO = 0x00000008 ,  /*!<  */
  QMOD_AN_PROPERTY_ENABLE_HPAM_TO_CL73_AUTO = 0x00000010 ,  /*!<  */
  QMOD_AN_PROPERTY_ENABLE_CL73_BAM_TO_HPAM_AUTO = 0x00000020 ,  /*!<  */
  QMOD_AN_PROPERTY_ENABLE_ILLEGAL = 0x00000040   /*!<  */
} an_property_enable;

/*! \def CNT_an_property_enable Types of enum an_property_enable */
#define CNT_an_property_enable 8

/*! \enum credit_type_t 

No description

*/

typedef enum {
  QMOD_CREDIT_RESET         = 0x00000000 ,  /*!<  */
  QMOD_CREDIT_TABLE         = 0x00000001 ,  /*!<  */
  QMOD_CREDIT_CLOCK_COUNT_0 = 0x00000002 ,  /*!<  */
  QMOD_CREDIT_CLOCK_COUNT_1 = 0x00000004 ,  /*!<  */
  QMOD_CREDIT_LOOP_COUNT_0  = 0x00000008 ,  /*!<  */
  QMOD_CREDIT_LOOP_COUNT_1  = 0x00000010 ,  /*!<  */
  QMOD_CREDIT_MAC           = 0x00000020 ,  /*!<  */
  QMOD_CREDIT_PCS_CLOCK_COUNT_0 = 0x00000040 ,  /*!<  */
  QMOD_CREDIT_PCS_GEN_COUNT = 0x00000080 ,  /*!<  */
  QMOD_CREDIT_EN            = 0x00000100 ,  /*!<  */
  QMOD_CREDIT_PCS_REPCNT    = 0x00000200 ,  /*!<  */
  QMOD_CREDIT_SGMII_SPD     = 0x00000400 ,  /*!<  */
  QMOD_CREDIT_ILLEGAL       = 0x00000800   /*!<  */
} credit_type_t;

/*! \def CNT_credit_type_t Types of enum credit_type_t */
#define CNT_credit_type_t 13

/*! \enum override_type_t 

No description

*/

typedef enum {
  QMOD_OVERRIDE_RESET       = 0x00000000 ,  /*!<  */
  QMOD_OVERRIDE_QSGMII_EN        = 0x00000003 ,  /*!<  */
  QMOD_OVERRIDE_CL36BYTEDEL_MODE   = 0x00000001 ,  /*!<  */
  QMOD_OVERRIDE_OS_MODE     = 0x00000002 ,  /*!<  */
  QMOD_OVERRIDE_CREDIT_EN      = 0x00000008 ,  /*!<  */
  QMOD_OVERRIDE_ALL         = 0x00008000   /*!<  */
} override_type_t;

/*! \def CNT_override_type_t Types of enum override_type_t */
#define CNT_override_type_t 18

/*! \enum qmod_ref_clk_t 

No description

*/

typedef enum {
  QMODREFCLK156MHZ          = 0x00000000 ,  /*!< 156p25MHz */
  QMODREFCLK125MHZ          = 0x00000001 ,  /*!< 125MHz */
  QMODREFCLKCOUNT           = 0x00000002   /*!<  */
} qmod_ref_clk_t;

/*! \def CNT_qmod_ref_clk_t Types of enum qmod_ref_clk_t */
#define CNT_qmod_ref_clk_t 3

/*!
\brief
This array returns the string of #an_property_enable when indexed by the enum.

*/
extern char* e2s_qmod_ref_clk_t [CNT_qmod_ref_clk_t];
#endif /* _TSCMOD_ENUM_DEFINES_H */
