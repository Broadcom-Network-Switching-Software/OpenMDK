#ifndef __BCM84868_DEFS_H__
#define __BCM84868_DEFS_H__
/*******************************************************************************
 *
 * This software is governed by the Broadcom Switch APIs license.
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenMDK/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCM84868.
 * This file provides all basic definitions required to program the BCM84868.
 *
 * This file is autogenerated. Please do not edit.
 */

#include <phy/phy_brcm_xe.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_CMD
 * BLOCKS:  
 * REGADDR:  0x0000
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CMD              
 */
#define BCM84868_TOP_MCH_CMDr (0x00000000 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_CMDr_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_CMD.
 */
typedef union BCM84868_TOP_MCH_CMDr_s {
	uint32_t v[1];
	uint32_t top_mch_cmd[1];
	uint32_t _top_mch_cmd;
} BCM84868_TOP_MCH_CMDr_t;

#define BCM84868_TOP_MCH_CMDr_CLR(r) (r).top_mch_cmd[0] = 0
#define BCM84868_TOP_MCH_CMDr_SET(r,d) (r).top_mch_cmd[0] = d
#define BCM84868_TOP_MCH_CMDr_GET(r) (r).top_mch_cmd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_CMDr_CMDf_GET(r) (((r).top_mch_cmd[0]) & 0x1)
#define BCM84868_TOP_MCH_CMDr_CMDf_SET(r,f) (r).top_mch_cmd[0]=(((r).top_mch_cmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TOP_MCH_CMD.
 */
#define BCM84868_READ_TOP_MCH_CMDr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_CMDr,(_r._top_mch_cmd))
#define BCM84868_WRITE_TOP_MCH_CMDr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_CMDr,(_r._top_mch_cmd))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_CMDr BCM84868_TOP_MCH_CMDr
#define TOP_MCH_CMDr_SIZE BCM84868_TOP_MCH_CMDr_SIZE
typedef BCM84868_TOP_MCH_CMDr_t TOP_MCH_CMDr_t;
#define TOP_MCH_CMDr_CLR BCM84868_TOP_MCH_CMDr_CLR
#define TOP_MCH_CMDr_SET BCM84868_TOP_MCH_CMDr_SET
#define TOP_MCH_CMDr_GET BCM84868_TOP_MCH_CMDr_GET
#define TOP_MCH_CMDr_CMDf_GET BCM84868_TOP_MCH_CMDr_CMDf_GET
#define TOP_MCH_CMDr_CMDf_SET BCM84868_TOP_MCH_CMDr_CMDf_SET
#define READ_TOP_MCH_CMDr BCM84868_READ_TOP_MCH_CMDr
#define WRITE_TOP_MCH_CMDr BCM84868_WRITE_TOP_MCH_CMDr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_CMDr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_DATA5
 * BLOCKS:  
 * REGADDR:  0x0000
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DATA             
 */
#define BCM84868_TOP_MCH_DATA5r (0x00000000 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_DATA5r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_DATA5.
 */
typedef union BCM84868_TOP_MCH_DATA5r_s {
	uint32_t v[1];
	uint32_t top_mch_data5[1];
	uint32_t _top_mch_data5;
} BCM84868_TOP_MCH_DATA5r_t;

#define BCM84868_TOP_MCH_DATA5r_CLR(r) (r).top_mch_data5[0] = 0
#define BCM84868_TOP_MCH_DATA5r_SET(r,d) (r).top_mch_data5[0] = d
#define BCM84868_TOP_MCH_DATA5r_GET(r) (r).top_mch_data5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_DATA5r_DATAf_GET(r) (((r).top_mch_data5[0]) & 0x1)
#define BCM84868_TOP_MCH_DATA5r_DATAf_SET(r,f) (r).top_mch_data5[0]=(((r).top_mch_data5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TOP_MCH_DATA5.
 */
#define BCM84868_READ_TOP_MCH_DATA5r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_DATA5r,(_r._top_mch_data5))
#define BCM84868_WRITE_TOP_MCH_DATA5r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_DATA5r,(_r._top_mch_data5))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_DATA5r BCM84868_TOP_MCH_DATA5r
#define TOP_MCH_DATA5r_SIZE BCM84868_TOP_MCH_DATA5r_SIZE
typedef BCM84868_TOP_MCH_DATA5r_t TOP_MCH_DATA5r_t;
#define TOP_MCH_DATA5r_CLR BCM84868_TOP_MCH_DATA5r_CLR
#define TOP_MCH_DATA5r_SET BCM84868_TOP_MCH_DATA5r_SET
#define TOP_MCH_DATA5r_GET BCM84868_TOP_MCH_DATA5r_GET
#define TOP_MCH_DATA5r_DATAf_GET BCM84868_TOP_MCH_DATA5r_DATAf_GET
#define TOP_MCH_DATA5r_DATAf_SET BCM84868_TOP_MCH_DATA5r_DATAf_SET
#define READ_TOP_MCH_DATA5r BCM84868_READ_TOP_MCH_DATA5r
#define WRITE_TOP_MCH_DATA5r BCM84868_WRITE_TOP_MCH_DATA5r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_DATA5r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_CTL1
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0000
 * DEVAD:    1
 * DESC:     IEEE PMA/PMD control 1 register
 * SIZE:     32
 * FIELDS:
 *     LPBK             
 *     SPEED_SEL_10G    
 *     SPEED_SEL_1      
 *     LOW_PWR          
 *     SPEED_SEL_0      
 *     RESET            
 */
#define BCM84868_PMAD_IEEE_CTL1r (0x00010000 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_CTL1.
 */
typedef union BCM84868_PMAD_IEEE_CTL1r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_ctl1[1];
	uint32_t _pmad_ieee_ctl1;
} BCM84868_PMAD_IEEE_CTL1r_t;

#define BCM84868_PMAD_IEEE_CTL1r_CLR(r) (r).pmad_ieee_ctl1[0] = 0
#define BCM84868_PMAD_IEEE_CTL1r_SET(r,d) (r).pmad_ieee_ctl1[0] = d
#define BCM84868_PMAD_IEEE_CTL1r_GET(r) (r).pmad_ieee_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_CTL1r_RESETf_GET(r) ((((r).pmad_ieee_ctl1[0]) >> 15) & 0x1)
#define BCM84868_PMAD_IEEE_CTL1r_RESETf_SET(r,f) (r).pmad_ieee_ctl1[0]=(((r).pmad_ieee_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_0f_GET(r) ((((r).pmad_ieee_ctl1[0]) >> 13) & 0x1)
#define BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_0f_SET(r,f) (r).pmad_ieee_ctl1[0]=(((r).pmad_ieee_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PMAD_IEEE_CTL1r_LOW_PWRf_GET(r) ((((r).pmad_ieee_ctl1[0]) >> 11) & 0x1)
#define BCM84868_PMAD_IEEE_CTL1r_LOW_PWRf_SET(r,f) (r).pmad_ieee_ctl1[0]=(((r).pmad_ieee_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_1f_GET(r) ((((r).pmad_ieee_ctl1[0]) >> 6) & 0x1)
#define BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_1f_SET(r,f) (r).pmad_ieee_ctl1[0]=(((r).pmad_ieee_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_10Gf_GET(r) ((((r).pmad_ieee_ctl1[0]) >> 2) & 0xf)
#define BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_10Gf_SET(r,f) (r).pmad_ieee_ctl1[0]=(((r).pmad_ieee_ctl1[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM84868_PMAD_IEEE_CTL1r_LPBKf_GET(r) (((r).pmad_ieee_ctl1[0]) & 0x1)
#define BCM84868_PMAD_IEEE_CTL1r_LPBKf_SET(r,f) (r).pmad_ieee_ctl1[0]=(((r).pmad_ieee_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMAD_IEEE_CTL1.
 */
#define BCM84868_READ_PMAD_IEEE_CTL1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_CTL1r,(_r._pmad_ieee_ctl1))
#define BCM84868_WRITE_PMAD_IEEE_CTL1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_CTL1r,(_r._pmad_ieee_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_CTL1r BCM84868_PMAD_IEEE_CTL1r
#define PMAD_IEEE_CTL1r_SIZE BCM84868_PMAD_IEEE_CTL1r_SIZE
typedef BCM84868_PMAD_IEEE_CTL1r_t PMAD_IEEE_CTL1r_t;
#define PMAD_IEEE_CTL1r_CLR BCM84868_PMAD_IEEE_CTL1r_CLR
#define PMAD_IEEE_CTL1r_SET BCM84868_PMAD_IEEE_CTL1r_SET
#define PMAD_IEEE_CTL1r_GET BCM84868_PMAD_IEEE_CTL1r_GET
#define PMAD_IEEE_CTL1r_RESETf_GET BCM84868_PMAD_IEEE_CTL1r_RESETf_GET
#define PMAD_IEEE_CTL1r_RESETf_SET BCM84868_PMAD_IEEE_CTL1r_RESETf_SET
#define PMAD_IEEE_CTL1r_SPEED_SEL_0f_GET BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_0f_GET
#define PMAD_IEEE_CTL1r_SPEED_SEL_0f_SET BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_0f_SET
#define PMAD_IEEE_CTL1r_LOW_PWRf_GET BCM84868_PMAD_IEEE_CTL1r_LOW_PWRf_GET
#define PMAD_IEEE_CTL1r_LOW_PWRf_SET BCM84868_PMAD_IEEE_CTL1r_LOW_PWRf_SET
#define PMAD_IEEE_CTL1r_SPEED_SEL_1f_GET BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_1f_GET
#define PMAD_IEEE_CTL1r_SPEED_SEL_1f_SET BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_1f_SET
#define PMAD_IEEE_CTL1r_SPEED_SEL_10Gf_GET BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_10Gf_GET
#define PMAD_IEEE_CTL1r_SPEED_SEL_10Gf_SET BCM84868_PMAD_IEEE_CTL1r_SPEED_SEL_10Gf_SET
#define PMAD_IEEE_CTL1r_LPBKf_GET BCM84868_PMAD_IEEE_CTL1r_LPBKf_GET
#define PMAD_IEEE_CTL1r_LPBKf_SET BCM84868_PMAD_IEEE_CTL1r_LPBKf_SET
#define READ_PMAD_IEEE_CTL1r BCM84868_READ_PMAD_IEEE_CTL1r
#define WRITE_PMAD_IEEE_CTL1r BCM84868_WRITE_PMAD_IEEE_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_ST1
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0001
 * DEVAD:    1
 * DESC:     IEEE PMA/PMD status 1 register
 * SIZE:     32
 * FIELDS:
 *     CAP_LOW_PWR      
 *     RCV_LINK_ST      
 *     FAULT            
 */
#define BCM84868_PMAD_IEEE_ST1r (0x00010001 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_ST1r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_ST1.
 */
typedef union BCM84868_PMAD_IEEE_ST1r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_st1[1];
	uint32_t _pmad_ieee_st1;
} BCM84868_PMAD_IEEE_ST1r_t;

#define BCM84868_PMAD_IEEE_ST1r_CLR(r) (r).pmad_ieee_st1[0] = 0
#define BCM84868_PMAD_IEEE_ST1r_SET(r,d) (r).pmad_ieee_st1[0] = d
#define BCM84868_PMAD_IEEE_ST1r_GET(r) (r).pmad_ieee_st1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_ST1r_FAULTf_GET(r) ((((r).pmad_ieee_st1[0]) >> 7) & 0x1)
#define BCM84868_PMAD_IEEE_ST1r_FAULTf_SET(r,f) (r).pmad_ieee_st1[0]=(((r).pmad_ieee_st1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PMAD_IEEE_ST1r_RCV_LINK_STf_GET(r) ((((r).pmad_ieee_st1[0]) >> 2) & 0x1)
#define BCM84868_PMAD_IEEE_ST1r_RCV_LINK_STf_SET(r,f) (r).pmad_ieee_st1[0]=(((r).pmad_ieee_st1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PMAD_IEEE_ST1r_CAP_LOW_PWRf_GET(r) ((((r).pmad_ieee_st1[0]) >> 1) & 0x1)
#define BCM84868_PMAD_IEEE_ST1r_CAP_LOW_PWRf_SET(r,f) (r).pmad_ieee_st1[0]=(((r).pmad_ieee_st1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PMAD_IEEE_ST1.
 */
#define BCM84868_READ_PMAD_IEEE_ST1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_ST1r,(_r._pmad_ieee_st1))
#define BCM84868_WRITE_PMAD_IEEE_ST1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_ST1r,(_r._pmad_ieee_st1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_ST1r BCM84868_PMAD_IEEE_ST1r
#define PMAD_IEEE_ST1r_SIZE BCM84868_PMAD_IEEE_ST1r_SIZE
typedef BCM84868_PMAD_IEEE_ST1r_t PMAD_IEEE_ST1r_t;
#define PMAD_IEEE_ST1r_CLR BCM84868_PMAD_IEEE_ST1r_CLR
#define PMAD_IEEE_ST1r_SET BCM84868_PMAD_IEEE_ST1r_SET
#define PMAD_IEEE_ST1r_GET BCM84868_PMAD_IEEE_ST1r_GET
#define PMAD_IEEE_ST1r_FAULTf_GET BCM84868_PMAD_IEEE_ST1r_FAULTf_GET
#define PMAD_IEEE_ST1r_FAULTf_SET BCM84868_PMAD_IEEE_ST1r_FAULTf_SET
#define PMAD_IEEE_ST1r_RCV_LINK_STf_GET BCM84868_PMAD_IEEE_ST1r_RCV_LINK_STf_GET
#define PMAD_IEEE_ST1r_RCV_LINK_STf_SET BCM84868_PMAD_IEEE_ST1r_RCV_LINK_STf_SET
#define PMAD_IEEE_ST1r_CAP_LOW_PWRf_GET BCM84868_PMAD_IEEE_ST1r_CAP_LOW_PWRf_GET
#define PMAD_IEEE_ST1r_CAP_LOW_PWRf_SET BCM84868_PMAD_IEEE_ST1r_CAP_LOW_PWRf_SET
#define READ_PMAD_IEEE_ST1r BCM84868_READ_PMAD_IEEE_ST1r
#define WRITE_PMAD_IEEE_ST1r BCM84868_WRITE_PMAD_IEEE_ST1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_ST1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_DEV_ID0
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0002
 * DEVAD:    1
 * DESC:     IEEE PMA/PMD device identifier part 0
 * SIZE:     32
 * FIELDS:
 *     DEV_ID0          
 */
#define BCM84868_PMAD_IEEE_DEV_ID0r (0x00010002 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_DEV_ID0r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_DEV_ID0.
 */
typedef union BCM84868_PMAD_IEEE_DEV_ID0r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_dev_id0[1];
	uint32_t _pmad_ieee_dev_id0;
} BCM84868_PMAD_IEEE_DEV_ID0r_t;

#define BCM84868_PMAD_IEEE_DEV_ID0r_CLR(r) (r).pmad_ieee_dev_id0[0] = 0
#define BCM84868_PMAD_IEEE_DEV_ID0r_SET(r,d) (r).pmad_ieee_dev_id0[0] = d
#define BCM84868_PMAD_IEEE_DEV_ID0r_GET(r) (r).pmad_ieee_dev_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_DEV_ID0r_DEV_ID0f_GET(r) (((r).pmad_ieee_dev_id0[0]) & 0xffff)
#define BCM84868_PMAD_IEEE_DEV_ID0r_DEV_ID0f_SET(r,f) (r).pmad_ieee_dev_id0[0]=(((r).pmad_ieee_dev_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMAD_IEEE_DEV_ID0.
 */
#define BCM84868_READ_PMAD_IEEE_DEV_ID0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_DEV_ID0r,(_r._pmad_ieee_dev_id0))
#define BCM84868_WRITE_PMAD_IEEE_DEV_ID0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_DEV_ID0r,(_r._pmad_ieee_dev_id0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_DEV_ID0r BCM84868_PMAD_IEEE_DEV_ID0r
#define PMAD_IEEE_DEV_ID0r_SIZE BCM84868_PMAD_IEEE_DEV_ID0r_SIZE
typedef BCM84868_PMAD_IEEE_DEV_ID0r_t PMAD_IEEE_DEV_ID0r_t;
#define PMAD_IEEE_DEV_ID0r_CLR BCM84868_PMAD_IEEE_DEV_ID0r_CLR
#define PMAD_IEEE_DEV_ID0r_SET BCM84868_PMAD_IEEE_DEV_ID0r_SET
#define PMAD_IEEE_DEV_ID0r_GET BCM84868_PMAD_IEEE_DEV_ID0r_GET
#define PMAD_IEEE_DEV_ID0r_DEV_ID0f_GET BCM84868_PMAD_IEEE_DEV_ID0r_DEV_ID0f_GET
#define PMAD_IEEE_DEV_ID0r_DEV_ID0f_SET BCM84868_PMAD_IEEE_DEV_ID0r_DEV_ID0f_SET
#define READ_PMAD_IEEE_DEV_ID0r BCM84868_READ_PMAD_IEEE_DEV_ID0r
#define WRITE_PMAD_IEEE_DEV_ID0r BCM84868_WRITE_PMAD_IEEE_DEV_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_DEV_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_DEV_ID1
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0003
 * DEVAD:    1
 * DESC:     IEEE PMA/PMD device identifier part 1
 * SIZE:     32
 * FIELDS:
 *     DEV_ID1          
 */
#define BCM84868_PMAD_IEEE_DEV_ID1r (0x00010003 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_DEV_ID1r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_DEV_ID1.
 */
typedef union BCM84868_PMAD_IEEE_DEV_ID1r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_dev_id1[1];
	uint32_t _pmad_ieee_dev_id1;
} BCM84868_PMAD_IEEE_DEV_ID1r_t;

#define BCM84868_PMAD_IEEE_DEV_ID1r_CLR(r) (r).pmad_ieee_dev_id1[0] = 0
#define BCM84868_PMAD_IEEE_DEV_ID1r_SET(r,d) (r).pmad_ieee_dev_id1[0] = d
#define BCM84868_PMAD_IEEE_DEV_ID1r_GET(r) (r).pmad_ieee_dev_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_DEV_ID1r_DEV_ID1f_GET(r) (((r).pmad_ieee_dev_id1[0]) & 0xffff)
#define BCM84868_PMAD_IEEE_DEV_ID1r_DEV_ID1f_SET(r,f) (r).pmad_ieee_dev_id1[0]=(((r).pmad_ieee_dev_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMAD_IEEE_DEV_ID1.
 */
#define BCM84868_READ_PMAD_IEEE_DEV_ID1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_DEV_ID1r,(_r._pmad_ieee_dev_id1))
#define BCM84868_WRITE_PMAD_IEEE_DEV_ID1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_DEV_ID1r,(_r._pmad_ieee_dev_id1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_DEV_ID1r BCM84868_PMAD_IEEE_DEV_ID1r
#define PMAD_IEEE_DEV_ID1r_SIZE BCM84868_PMAD_IEEE_DEV_ID1r_SIZE
typedef BCM84868_PMAD_IEEE_DEV_ID1r_t PMAD_IEEE_DEV_ID1r_t;
#define PMAD_IEEE_DEV_ID1r_CLR BCM84868_PMAD_IEEE_DEV_ID1r_CLR
#define PMAD_IEEE_DEV_ID1r_SET BCM84868_PMAD_IEEE_DEV_ID1r_SET
#define PMAD_IEEE_DEV_ID1r_GET BCM84868_PMAD_IEEE_DEV_ID1r_GET
#define PMAD_IEEE_DEV_ID1r_DEV_ID1f_GET BCM84868_PMAD_IEEE_DEV_ID1r_DEV_ID1f_GET
#define PMAD_IEEE_DEV_ID1r_DEV_ID1f_SET BCM84868_PMAD_IEEE_DEV_ID1r_DEV_ID1f_SET
#define READ_PMAD_IEEE_DEV_ID1r BCM84868_READ_PMAD_IEEE_DEV_ID1r
#define WRITE_PMAD_IEEE_DEV_ID1r BCM84868_WRITE_PMAD_IEEE_DEV_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_DEV_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_SP_CAP
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0004
 * DEVAD:    1
 * DESC:     IEEE PMA/PMD speed ability
 * SIZE:     32
 * FIELDS:
 *     CAP_10G          
 *     CAP_2BASE_TL     
 *     CAP_10PASS_TS    
 *     CAP_1000M        
 *     CAP_100M         
 *     CAP_10M          
 */
#define BCM84868_PMAD_IEEE_SP_CAPr (0x00010004 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_SP_CAPr_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_SP_CAP.
 */
typedef union BCM84868_PMAD_IEEE_SP_CAPr_s {
	uint32_t v[1];
	uint32_t pmad_ieee_sp_cap[1];
	uint32_t _pmad_ieee_sp_cap;
} BCM84868_PMAD_IEEE_SP_CAPr_t;

#define BCM84868_PMAD_IEEE_SP_CAPr_CLR(r) (r).pmad_ieee_sp_cap[0] = 0
#define BCM84868_PMAD_IEEE_SP_CAPr_SET(r,d) (r).pmad_ieee_sp_cap[0] = d
#define BCM84868_PMAD_IEEE_SP_CAPr_GET(r) (r).pmad_ieee_sp_cap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Mf_GET(r) ((((r).pmad_ieee_sp_cap[0]) >> 6) & 0x1)
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Mf_SET(r,f) (r).pmad_ieee_sp_cap[0]=(((r).pmad_ieee_sp_cap[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_100Mf_GET(r) ((((r).pmad_ieee_sp_cap[0]) >> 5) & 0x1)
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_100Mf_SET(r,f) (r).pmad_ieee_sp_cap[0]=(((r).pmad_ieee_sp_cap[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_1000Mf_GET(r) ((((r).pmad_ieee_sp_cap[0]) >> 4) & 0x1)
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_1000Mf_SET(r,f) (r).pmad_ieee_sp_cap[0]=(((r).pmad_ieee_sp_cap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_10PASS_TSf_GET(r) ((((r).pmad_ieee_sp_cap[0]) >> 2) & 0x1)
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_10PASS_TSf_SET(r,f) (r).pmad_ieee_sp_cap[0]=(((r).pmad_ieee_sp_cap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_2BASE_TLf_GET(r) ((((r).pmad_ieee_sp_cap[0]) >> 1) & 0x1)
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_2BASE_TLf_SET(r,f) (r).pmad_ieee_sp_cap[0]=(((r).pmad_ieee_sp_cap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Gf_GET(r) (((r).pmad_ieee_sp_cap[0]) & 0x1)
#define BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Gf_SET(r,f) (r).pmad_ieee_sp_cap[0]=(((r).pmad_ieee_sp_cap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMAD_IEEE_SP_CAP.
 */
#define BCM84868_READ_PMAD_IEEE_SP_CAPr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_SP_CAPr,(_r._pmad_ieee_sp_cap))
#define BCM84868_WRITE_PMAD_IEEE_SP_CAPr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_SP_CAPr,(_r._pmad_ieee_sp_cap))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_SP_CAPr BCM84868_PMAD_IEEE_SP_CAPr
#define PMAD_IEEE_SP_CAPr_SIZE BCM84868_PMAD_IEEE_SP_CAPr_SIZE
typedef BCM84868_PMAD_IEEE_SP_CAPr_t PMAD_IEEE_SP_CAPr_t;
#define PMAD_IEEE_SP_CAPr_CLR BCM84868_PMAD_IEEE_SP_CAPr_CLR
#define PMAD_IEEE_SP_CAPr_SET BCM84868_PMAD_IEEE_SP_CAPr_SET
#define PMAD_IEEE_SP_CAPr_GET BCM84868_PMAD_IEEE_SP_CAPr_GET
#define PMAD_IEEE_SP_CAPr_CAP_10Mf_GET BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Mf_GET
#define PMAD_IEEE_SP_CAPr_CAP_10Mf_SET BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Mf_SET
#define PMAD_IEEE_SP_CAPr_CAP_100Mf_GET BCM84868_PMAD_IEEE_SP_CAPr_CAP_100Mf_GET
#define PMAD_IEEE_SP_CAPr_CAP_100Mf_SET BCM84868_PMAD_IEEE_SP_CAPr_CAP_100Mf_SET
#define PMAD_IEEE_SP_CAPr_CAP_1000Mf_GET BCM84868_PMAD_IEEE_SP_CAPr_CAP_1000Mf_GET
#define PMAD_IEEE_SP_CAPr_CAP_1000Mf_SET BCM84868_PMAD_IEEE_SP_CAPr_CAP_1000Mf_SET
#define PMAD_IEEE_SP_CAPr_CAP_10PASS_TSf_GET BCM84868_PMAD_IEEE_SP_CAPr_CAP_10PASS_TSf_GET
#define PMAD_IEEE_SP_CAPr_CAP_10PASS_TSf_SET BCM84868_PMAD_IEEE_SP_CAPr_CAP_10PASS_TSf_SET
#define PMAD_IEEE_SP_CAPr_CAP_2BASE_TLf_GET BCM84868_PMAD_IEEE_SP_CAPr_CAP_2BASE_TLf_GET
#define PMAD_IEEE_SP_CAPr_CAP_2BASE_TLf_SET BCM84868_PMAD_IEEE_SP_CAPr_CAP_2BASE_TLf_SET
#define PMAD_IEEE_SP_CAPr_CAP_10Gf_GET BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Gf_GET
#define PMAD_IEEE_SP_CAPr_CAP_10Gf_SET BCM84868_PMAD_IEEE_SP_CAPr_CAP_10Gf_SET
#define READ_PMAD_IEEE_SP_CAPr BCM84868_READ_PMAD_IEEE_SP_CAPr
#define WRITE_PMAD_IEEE_SP_CAPr BCM84868_WRITE_PMAD_IEEE_SP_CAPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_SP_CAPr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_DEV0
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0005
 * DEVAD:    1
 * DESC:     Devices in package register part 0
 * SIZE:     32
 * FIELDS:
 *     CLA22_PRE        
 *     PMD_PRE          
 *     WIS_PRE          
 *     PCS_PRE          
 *     PHYXS_PRE        
 *     DTEXS_PRE        
 *     TC_PRE           
 *     AUTONEG_PRE      
 */
#define BCM84868_PMAD_IEEE_DEV0r (0x00010005 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_DEV0r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_DEV0.
 */
typedef union BCM84868_PMAD_IEEE_DEV0r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_dev0[1];
	uint32_t _pmad_ieee_dev0;
} BCM84868_PMAD_IEEE_DEV0r_t;

#define BCM84868_PMAD_IEEE_DEV0r_CLR(r) (r).pmad_ieee_dev0[0] = 0
#define BCM84868_PMAD_IEEE_DEV0r_SET(r,d) (r).pmad_ieee_dev0[0] = d
#define BCM84868_PMAD_IEEE_DEV0r_GET(r) (r).pmad_ieee_dev0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_DEV0r_AUTONEG_PREf_GET(r) ((((r).pmad_ieee_dev0[0]) >> 7) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_AUTONEG_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PMAD_IEEE_DEV0r_TC_PREf_GET(r) ((((r).pmad_ieee_dev0[0]) >> 6) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_TC_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PMAD_IEEE_DEV0r_DTEXS_PREf_GET(r) ((((r).pmad_ieee_dev0[0]) >> 5) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_DTEXS_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PMAD_IEEE_DEV0r_PHYXS_PREf_GET(r) ((((r).pmad_ieee_dev0[0]) >> 4) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_PHYXS_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PMAD_IEEE_DEV0r_PCS_PREf_GET(r) ((((r).pmad_ieee_dev0[0]) >> 3) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_PCS_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PMAD_IEEE_DEV0r_WIS_PREf_GET(r) ((((r).pmad_ieee_dev0[0]) >> 2) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_WIS_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PMAD_IEEE_DEV0r_PMD_PREf_GET(r) ((((r).pmad_ieee_dev0[0]) >> 1) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_PMD_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PMAD_IEEE_DEV0r_CLA22_PREf_GET(r) (((r).pmad_ieee_dev0[0]) & 0x1)
#define BCM84868_PMAD_IEEE_DEV0r_CLA22_PREf_SET(r,f) (r).pmad_ieee_dev0[0]=(((r).pmad_ieee_dev0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMAD_IEEE_DEV0.
 */
#define BCM84868_READ_PMAD_IEEE_DEV0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_DEV0r,(_r._pmad_ieee_dev0))
#define BCM84868_WRITE_PMAD_IEEE_DEV0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_DEV0r,(_r._pmad_ieee_dev0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_DEV0r BCM84868_PMAD_IEEE_DEV0r
#define PMAD_IEEE_DEV0r_SIZE BCM84868_PMAD_IEEE_DEV0r_SIZE
typedef BCM84868_PMAD_IEEE_DEV0r_t PMAD_IEEE_DEV0r_t;
#define PMAD_IEEE_DEV0r_CLR BCM84868_PMAD_IEEE_DEV0r_CLR
#define PMAD_IEEE_DEV0r_SET BCM84868_PMAD_IEEE_DEV0r_SET
#define PMAD_IEEE_DEV0r_GET BCM84868_PMAD_IEEE_DEV0r_GET
#define PMAD_IEEE_DEV0r_AUTONEG_PREf_GET BCM84868_PMAD_IEEE_DEV0r_AUTONEG_PREf_GET
#define PMAD_IEEE_DEV0r_AUTONEG_PREf_SET BCM84868_PMAD_IEEE_DEV0r_AUTONEG_PREf_SET
#define PMAD_IEEE_DEV0r_TC_PREf_GET BCM84868_PMAD_IEEE_DEV0r_TC_PREf_GET
#define PMAD_IEEE_DEV0r_TC_PREf_SET BCM84868_PMAD_IEEE_DEV0r_TC_PREf_SET
#define PMAD_IEEE_DEV0r_DTEXS_PREf_GET BCM84868_PMAD_IEEE_DEV0r_DTEXS_PREf_GET
#define PMAD_IEEE_DEV0r_DTEXS_PREf_SET BCM84868_PMAD_IEEE_DEV0r_DTEXS_PREf_SET
#define PMAD_IEEE_DEV0r_PHYXS_PREf_GET BCM84868_PMAD_IEEE_DEV0r_PHYXS_PREf_GET
#define PMAD_IEEE_DEV0r_PHYXS_PREf_SET BCM84868_PMAD_IEEE_DEV0r_PHYXS_PREf_SET
#define PMAD_IEEE_DEV0r_PCS_PREf_GET BCM84868_PMAD_IEEE_DEV0r_PCS_PREf_GET
#define PMAD_IEEE_DEV0r_PCS_PREf_SET BCM84868_PMAD_IEEE_DEV0r_PCS_PREf_SET
#define PMAD_IEEE_DEV0r_WIS_PREf_GET BCM84868_PMAD_IEEE_DEV0r_WIS_PREf_GET
#define PMAD_IEEE_DEV0r_WIS_PREf_SET BCM84868_PMAD_IEEE_DEV0r_WIS_PREf_SET
#define PMAD_IEEE_DEV0r_PMD_PREf_GET BCM84868_PMAD_IEEE_DEV0r_PMD_PREf_GET
#define PMAD_IEEE_DEV0r_PMD_PREf_SET BCM84868_PMAD_IEEE_DEV0r_PMD_PREf_SET
#define PMAD_IEEE_DEV0r_CLA22_PREf_GET BCM84868_PMAD_IEEE_DEV0r_CLA22_PREf_GET
#define PMAD_IEEE_DEV0r_CLA22_PREf_SET BCM84868_PMAD_IEEE_DEV0r_CLA22_PREf_SET
#define READ_PMAD_IEEE_DEV0r BCM84868_READ_PMAD_IEEE_DEV0r
#define WRITE_PMAD_IEEE_DEV0r BCM84868_WRITE_PMAD_IEEE_DEV0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_DEV0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_DEV1
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0006
 * DEVAD:    1
 * DESC:     Devices in package register part 1
 * SIZE:     32
 * FIELDS:
 *     CLA22_EXT_PRE    
 *     VENSP_DEV1_PRE   
 *     VENSP_DEV2_PRE   
 */
#define BCM84868_PMAD_IEEE_DEV1r (0x00010006 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_DEV1r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_DEV1.
 */
typedef union BCM84868_PMAD_IEEE_DEV1r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_dev1[1];
	uint32_t _pmad_ieee_dev1;
} BCM84868_PMAD_IEEE_DEV1r_t;

#define BCM84868_PMAD_IEEE_DEV1r_CLR(r) (r).pmad_ieee_dev1[0] = 0
#define BCM84868_PMAD_IEEE_DEV1r_SET(r,d) (r).pmad_ieee_dev1[0] = d
#define BCM84868_PMAD_IEEE_DEV1r_GET(r) (r).pmad_ieee_dev1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV2_PREf_GET(r) ((((r).pmad_ieee_dev1[0]) >> 15) & 0x1)
#define BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV2_PREf_SET(r,f) (r).pmad_ieee_dev1[0]=(((r).pmad_ieee_dev1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV1_PREf_GET(r) ((((r).pmad_ieee_dev1[0]) >> 14) & 0x1)
#define BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV1_PREf_SET(r,f) (r).pmad_ieee_dev1[0]=(((r).pmad_ieee_dev1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PMAD_IEEE_DEV1r_CLA22_EXT_PREf_GET(r) ((((r).pmad_ieee_dev1[0]) >> 13) & 0x1)
#define BCM84868_PMAD_IEEE_DEV1r_CLA22_EXT_PREf_SET(r,f) (r).pmad_ieee_dev1[0]=(((r).pmad_ieee_dev1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access PMAD_IEEE_DEV1.
 */
#define BCM84868_READ_PMAD_IEEE_DEV1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_DEV1r,(_r._pmad_ieee_dev1))
#define BCM84868_WRITE_PMAD_IEEE_DEV1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_DEV1r,(_r._pmad_ieee_dev1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_DEV1r BCM84868_PMAD_IEEE_DEV1r
#define PMAD_IEEE_DEV1r_SIZE BCM84868_PMAD_IEEE_DEV1r_SIZE
typedef BCM84868_PMAD_IEEE_DEV1r_t PMAD_IEEE_DEV1r_t;
#define PMAD_IEEE_DEV1r_CLR BCM84868_PMAD_IEEE_DEV1r_CLR
#define PMAD_IEEE_DEV1r_SET BCM84868_PMAD_IEEE_DEV1r_SET
#define PMAD_IEEE_DEV1r_GET BCM84868_PMAD_IEEE_DEV1r_GET
#define PMAD_IEEE_DEV1r_VENSP_DEV2_PREf_GET BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV2_PREf_GET
#define PMAD_IEEE_DEV1r_VENSP_DEV2_PREf_SET BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV2_PREf_SET
#define PMAD_IEEE_DEV1r_VENSP_DEV1_PREf_GET BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV1_PREf_GET
#define PMAD_IEEE_DEV1r_VENSP_DEV1_PREf_SET BCM84868_PMAD_IEEE_DEV1r_VENSP_DEV1_PREf_SET
#define PMAD_IEEE_DEV1r_CLA22_EXT_PREf_GET BCM84868_PMAD_IEEE_DEV1r_CLA22_EXT_PREf_GET
#define PMAD_IEEE_DEV1r_CLA22_EXT_PREf_SET BCM84868_PMAD_IEEE_DEV1r_CLA22_EXT_PREf_SET
#define READ_PMAD_IEEE_DEV1r BCM84868_READ_PMAD_IEEE_DEV1r
#define WRITE_PMAD_IEEE_DEV1r BCM84868_WRITE_PMAD_IEEE_DEV1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_DEV1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_CTL2
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0007
 * DEVAD:    1
 * DESC:     PMA/PMD control 2 register
 * SIZE:     32
 * FIELDS:
 *     TYPE_SEL         
 */
#define BCM84868_PMAD_IEEE_CTL2r (0x00010007 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_CTL2.
 */
typedef union BCM84868_PMAD_IEEE_CTL2r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_ctl2[1];
	uint32_t _pmad_ieee_ctl2;
} BCM84868_PMAD_IEEE_CTL2r_t;

#define BCM84868_PMAD_IEEE_CTL2r_CLR(r) (r).pmad_ieee_ctl2[0] = 0
#define BCM84868_PMAD_IEEE_CTL2r_SET(r,d) (r).pmad_ieee_ctl2[0] = d
#define BCM84868_PMAD_IEEE_CTL2r_GET(r) (r).pmad_ieee_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_CTL2r_TYPE_SELf_GET(r) (((r).pmad_ieee_ctl2[0]) & 0xf)
#define BCM84868_PMAD_IEEE_CTL2r_TYPE_SELf_SET(r,f) (r).pmad_ieee_ctl2[0]=(((r).pmad_ieee_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access PMAD_IEEE_CTL2.
 */
#define BCM84868_READ_PMAD_IEEE_CTL2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_CTL2r,(_r._pmad_ieee_ctl2))
#define BCM84868_WRITE_PMAD_IEEE_CTL2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_CTL2r,(_r._pmad_ieee_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_CTL2r BCM84868_PMAD_IEEE_CTL2r
#define PMAD_IEEE_CTL2r_SIZE BCM84868_PMAD_IEEE_CTL2r_SIZE
typedef BCM84868_PMAD_IEEE_CTL2r_t PMAD_IEEE_CTL2r_t;
#define PMAD_IEEE_CTL2r_CLR BCM84868_PMAD_IEEE_CTL2r_CLR
#define PMAD_IEEE_CTL2r_SET BCM84868_PMAD_IEEE_CTL2r_SET
#define PMAD_IEEE_CTL2r_GET BCM84868_PMAD_IEEE_CTL2r_GET
#define PMAD_IEEE_CTL2r_TYPE_SELf_GET BCM84868_PMAD_IEEE_CTL2r_TYPE_SELf_GET
#define PMAD_IEEE_CTL2r_TYPE_SELf_SET BCM84868_PMAD_IEEE_CTL2r_TYPE_SELf_SET
#define READ_PMAD_IEEE_CTL2r BCM84868_READ_PMAD_IEEE_CTL2r
#define WRITE_PMAD_IEEE_CTL2r BCM84868_WRITE_PMAD_IEEE_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_ST2
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0008
 * DEVAD:    1
 * DESC:     10G PMA/PMD status 2 register
 * SIZE:     32
 * FIELDS:
 *     CAP_LPBK         
 *     CAP_10G_EW       
 *     CAP_10G_LW       
 *     CAP_10G_SW       
 *     CAP_10G_LX4      
 *     CAP_10G_ER       
 *     CAP_10G_LR       
 *     CAP_10G_SR       
 *     CAP_TRAN_DIS     
 *     CAP_EXT          
 *     RCV_FALT         
 *     TRAN_FALT        
 *     CAP_RCV_FALT     
 *     CAP_TRAN_FALT    
 *     DEV_PRE          
 */
#define BCM84868_PMAD_IEEE_ST2r (0x00010008 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_ST2r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_ST2.
 */
typedef union BCM84868_PMAD_IEEE_ST2r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_st2[1];
	uint32_t _pmad_ieee_st2;
} BCM84868_PMAD_IEEE_ST2r_t;

#define BCM84868_PMAD_IEEE_ST2r_CLR(r) (r).pmad_ieee_st2[0] = 0
#define BCM84868_PMAD_IEEE_ST2r_SET(r,d) (r).pmad_ieee_st2[0] = d
#define BCM84868_PMAD_IEEE_ST2r_GET(r) (r).pmad_ieee_st2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_ST2r_DEV_PREf_GET(r) ((((r).pmad_ieee_st2[0]) >> 14) & 0x3)
#define BCM84868_PMAD_IEEE_ST2r_DEV_PREf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_FALTf_GET(r) ((((r).pmad_ieee_st2[0]) >> 13) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_FALTf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PMAD_IEEE_ST2r_CAP_RCV_FALTf_GET(r) ((((r).pmad_ieee_st2[0]) >> 12) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_RCV_FALTf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PMAD_IEEE_ST2r_TRAN_FALTf_GET(r) ((((r).pmad_ieee_st2[0]) >> 11) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_TRAN_FALTf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PMAD_IEEE_ST2r_RCV_FALTf_GET(r) ((((r).pmad_ieee_st2[0]) >> 10) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_RCV_FALTf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PMAD_IEEE_ST2r_CAP_EXTf_GET(r) ((((r).pmad_ieee_st2[0]) >> 9) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_EXTf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_DISf_GET(r) ((((r).pmad_ieee_st2[0]) >> 8) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_DISf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_SRf_GET(r) ((((r).pmad_ieee_st2[0]) >> 7) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_SRf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_LRf_GET(r) ((((r).pmad_ieee_st2[0]) >> 6) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_LRf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_ERf_GET(r) ((((r).pmad_ieee_st2[0]) >> 5) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_ERf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_LX4f_GET(r) ((((r).pmad_ieee_st2[0]) >> 4) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_LX4f_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_SWf_GET(r) ((((r).pmad_ieee_st2[0]) >> 3) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_SWf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_LWf_GET(r) ((((r).pmad_ieee_st2[0]) >> 2) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_LWf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_EWf_GET(r) ((((r).pmad_ieee_st2[0]) >> 1) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_10G_EWf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PMAD_IEEE_ST2r_CAP_LPBKf_GET(r) (((r).pmad_ieee_st2[0]) & 0x1)
#define BCM84868_PMAD_IEEE_ST2r_CAP_LPBKf_SET(r,f) (r).pmad_ieee_st2[0]=(((r).pmad_ieee_st2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMAD_IEEE_ST2.
 */
#define BCM84868_READ_PMAD_IEEE_ST2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_ST2r,(_r._pmad_ieee_st2))
#define BCM84868_WRITE_PMAD_IEEE_ST2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_ST2r,(_r._pmad_ieee_st2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_ST2r BCM84868_PMAD_IEEE_ST2r
#define PMAD_IEEE_ST2r_SIZE BCM84868_PMAD_IEEE_ST2r_SIZE
typedef BCM84868_PMAD_IEEE_ST2r_t PMAD_IEEE_ST2r_t;
#define PMAD_IEEE_ST2r_CLR BCM84868_PMAD_IEEE_ST2r_CLR
#define PMAD_IEEE_ST2r_SET BCM84868_PMAD_IEEE_ST2r_SET
#define PMAD_IEEE_ST2r_GET BCM84868_PMAD_IEEE_ST2r_GET
#define PMAD_IEEE_ST2r_DEV_PREf_GET BCM84868_PMAD_IEEE_ST2r_DEV_PREf_GET
#define PMAD_IEEE_ST2r_DEV_PREf_SET BCM84868_PMAD_IEEE_ST2r_DEV_PREf_SET
#define PMAD_IEEE_ST2r_CAP_TRAN_FALTf_GET BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_FALTf_GET
#define PMAD_IEEE_ST2r_CAP_TRAN_FALTf_SET BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_FALTf_SET
#define PMAD_IEEE_ST2r_CAP_RCV_FALTf_GET BCM84868_PMAD_IEEE_ST2r_CAP_RCV_FALTf_GET
#define PMAD_IEEE_ST2r_CAP_RCV_FALTf_SET BCM84868_PMAD_IEEE_ST2r_CAP_RCV_FALTf_SET
#define PMAD_IEEE_ST2r_TRAN_FALTf_GET BCM84868_PMAD_IEEE_ST2r_TRAN_FALTf_GET
#define PMAD_IEEE_ST2r_TRAN_FALTf_SET BCM84868_PMAD_IEEE_ST2r_TRAN_FALTf_SET
#define PMAD_IEEE_ST2r_RCV_FALTf_GET BCM84868_PMAD_IEEE_ST2r_RCV_FALTf_GET
#define PMAD_IEEE_ST2r_RCV_FALTf_SET BCM84868_PMAD_IEEE_ST2r_RCV_FALTf_SET
#define PMAD_IEEE_ST2r_CAP_EXTf_GET BCM84868_PMAD_IEEE_ST2r_CAP_EXTf_GET
#define PMAD_IEEE_ST2r_CAP_EXTf_SET BCM84868_PMAD_IEEE_ST2r_CAP_EXTf_SET
#define PMAD_IEEE_ST2r_CAP_TRAN_DISf_GET BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_DISf_GET
#define PMAD_IEEE_ST2r_CAP_TRAN_DISf_SET BCM84868_PMAD_IEEE_ST2r_CAP_TRAN_DISf_SET
#define PMAD_IEEE_ST2r_CAP_10G_SRf_GET BCM84868_PMAD_IEEE_ST2r_CAP_10G_SRf_GET
#define PMAD_IEEE_ST2r_CAP_10G_SRf_SET BCM84868_PMAD_IEEE_ST2r_CAP_10G_SRf_SET
#define PMAD_IEEE_ST2r_CAP_10G_LRf_GET BCM84868_PMAD_IEEE_ST2r_CAP_10G_LRf_GET
#define PMAD_IEEE_ST2r_CAP_10G_LRf_SET BCM84868_PMAD_IEEE_ST2r_CAP_10G_LRf_SET
#define PMAD_IEEE_ST2r_CAP_10G_ERf_GET BCM84868_PMAD_IEEE_ST2r_CAP_10G_ERf_GET
#define PMAD_IEEE_ST2r_CAP_10G_ERf_SET BCM84868_PMAD_IEEE_ST2r_CAP_10G_ERf_SET
#define PMAD_IEEE_ST2r_CAP_10G_LX4f_GET BCM84868_PMAD_IEEE_ST2r_CAP_10G_LX4f_GET
#define PMAD_IEEE_ST2r_CAP_10G_LX4f_SET BCM84868_PMAD_IEEE_ST2r_CAP_10G_LX4f_SET
#define PMAD_IEEE_ST2r_CAP_10G_SWf_GET BCM84868_PMAD_IEEE_ST2r_CAP_10G_SWf_GET
#define PMAD_IEEE_ST2r_CAP_10G_SWf_SET BCM84868_PMAD_IEEE_ST2r_CAP_10G_SWf_SET
#define PMAD_IEEE_ST2r_CAP_10G_LWf_GET BCM84868_PMAD_IEEE_ST2r_CAP_10G_LWf_GET
#define PMAD_IEEE_ST2r_CAP_10G_LWf_SET BCM84868_PMAD_IEEE_ST2r_CAP_10G_LWf_SET
#define PMAD_IEEE_ST2r_CAP_10G_EWf_GET BCM84868_PMAD_IEEE_ST2r_CAP_10G_EWf_GET
#define PMAD_IEEE_ST2r_CAP_10G_EWf_SET BCM84868_PMAD_IEEE_ST2r_CAP_10G_EWf_SET
#define PMAD_IEEE_ST2r_CAP_LPBKf_GET BCM84868_PMAD_IEEE_ST2r_CAP_LPBKf_GET
#define PMAD_IEEE_ST2r_CAP_LPBKf_SET BCM84868_PMAD_IEEE_ST2r_CAP_LPBKf_SET
#define READ_PMAD_IEEE_ST2r BCM84868_READ_PMAD_IEEE_ST2r
#define WRITE_PMAD_IEEE_ST2r BCM84868_WRITE_PMAD_IEEE_ST2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_ST2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_TRAN_DIS
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0009
 * DEVAD:    1
 * DESC:     10G PMA/PMD transmit disable
 * SIZE:     32
 * FIELDS:
 *     GLB_TRAN_DIS     
 *     TRAN_DIS1        
 *     TRAN_DIS2        
 *     TRAN_DIS3        
 *     TRAN_DIS4        
 */
#define BCM84868_PMAD_IEEE_TRAN_DISr (0x00010009 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_TRAN_DISr_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_TRAN_DIS.
 */
typedef union BCM84868_PMAD_IEEE_TRAN_DISr_s {
	uint32_t v[1];
	uint32_t pmad_ieee_tran_dis[1];
	uint32_t _pmad_ieee_tran_dis;
} BCM84868_PMAD_IEEE_TRAN_DISr_t;

#define BCM84868_PMAD_IEEE_TRAN_DISr_CLR(r) (r).pmad_ieee_tran_dis[0] = 0
#define BCM84868_PMAD_IEEE_TRAN_DISr_SET(r,d) (r).pmad_ieee_tran_dis[0] = d
#define BCM84868_PMAD_IEEE_TRAN_DISr_GET(r) (r).pmad_ieee_tran_dis[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS4f_GET(r) ((((r).pmad_ieee_tran_dis[0]) >> 4) & 0x1)
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS4f_SET(r,f) (r).pmad_ieee_tran_dis[0]=(((r).pmad_ieee_tran_dis[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS3f_GET(r) ((((r).pmad_ieee_tran_dis[0]) >> 3) & 0x1)
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS3f_SET(r,f) (r).pmad_ieee_tran_dis[0]=(((r).pmad_ieee_tran_dis[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS2f_GET(r) ((((r).pmad_ieee_tran_dis[0]) >> 2) & 0x1)
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS2f_SET(r,f) (r).pmad_ieee_tran_dis[0]=(((r).pmad_ieee_tran_dis[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS1f_GET(r) ((((r).pmad_ieee_tran_dis[0]) >> 1) & 0x1)
#define BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS1f_SET(r,f) (r).pmad_ieee_tran_dis[0]=(((r).pmad_ieee_tran_dis[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PMAD_IEEE_TRAN_DISr_GLB_TRAN_DISf_GET(r) (((r).pmad_ieee_tran_dis[0]) & 0x1)
#define BCM84868_PMAD_IEEE_TRAN_DISr_GLB_TRAN_DISf_SET(r,f) (r).pmad_ieee_tran_dis[0]=(((r).pmad_ieee_tran_dis[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMAD_IEEE_TRAN_DIS.
 */
#define BCM84868_READ_PMAD_IEEE_TRAN_DISr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_TRAN_DISr,(_r._pmad_ieee_tran_dis))
#define BCM84868_WRITE_PMAD_IEEE_TRAN_DISr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_TRAN_DISr,(_r._pmad_ieee_tran_dis))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_TRAN_DISr BCM84868_PMAD_IEEE_TRAN_DISr
#define PMAD_IEEE_TRAN_DISr_SIZE BCM84868_PMAD_IEEE_TRAN_DISr_SIZE
typedef BCM84868_PMAD_IEEE_TRAN_DISr_t PMAD_IEEE_TRAN_DISr_t;
#define PMAD_IEEE_TRAN_DISr_CLR BCM84868_PMAD_IEEE_TRAN_DISr_CLR
#define PMAD_IEEE_TRAN_DISr_SET BCM84868_PMAD_IEEE_TRAN_DISr_SET
#define PMAD_IEEE_TRAN_DISr_GET BCM84868_PMAD_IEEE_TRAN_DISr_GET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS4f_GET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS4f_GET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS4f_SET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS4f_SET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS3f_GET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS3f_GET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS3f_SET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS3f_SET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS2f_GET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS2f_GET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS2f_SET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS2f_SET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS1f_GET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS1f_GET
#define PMAD_IEEE_TRAN_DISr_TRAN_DIS1f_SET BCM84868_PMAD_IEEE_TRAN_DISr_TRAN_DIS1f_SET
#define PMAD_IEEE_TRAN_DISr_GLB_TRAN_DISf_GET BCM84868_PMAD_IEEE_TRAN_DISr_GLB_TRAN_DISf_GET
#define PMAD_IEEE_TRAN_DISr_GLB_TRAN_DISf_SET BCM84868_PMAD_IEEE_TRAN_DISr_GLB_TRAN_DISf_SET
#define READ_PMAD_IEEE_TRAN_DISr BCM84868_READ_PMAD_IEEE_TRAN_DISr
#define WRITE_PMAD_IEEE_TRAN_DISr BCM84868_WRITE_PMAD_IEEE_TRAN_DISr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_TRAN_DISr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_RCV_DET
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x000a
 * DEVAD:    1
 * DESC:     10G PMD receive signal detect
 * SIZE:     32
 * FIELDS:
 *     GLB_RCV_DET      
 *     RCV_DET1         
 *     RCV_DET2         
 *     RCV_DET3         
 *     RCV_DET4         
 */
#define BCM84868_PMAD_IEEE_RCV_DETr (0x0001000a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_RCV_DETr_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_RCV_DET.
 */
typedef union BCM84868_PMAD_IEEE_RCV_DETr_s {
	uint32_t v[1];
	uint32_t pmad_ieee_rcv_det[1];
	uint32_t _pmad_ieee_rcv_det;
} BCM84868_PMAD_IEEE_RCV_DETr_t;

#define BCM84868_PMAD_IEEE_RCV_DETr_CLR(r) (r).pmad_ieee_rcv_det[0] = 0
#define BCM84868_PMAD_IEEE_RCV_DETr_SET(r,d) (r).pmad_ieee_rcv_det[0] = d
#define BCM84868_PMAD_IEEE_RCV_DETr_GET(r) (r).pmad_ieee_rcv_det[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET4f_GET(r) ((((r).pmad_ieee_rcv_det[0]) >> 4) & 0x1)
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET4f_SET(r,f) (r).pmad_ieee_rcv_det[0]=(((r).pmad_ieee_rcv_det[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET3f_GET(r) ((((r).pmad_ieee_rcv_det[0]) >> 3) & 0x1)
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET3f_SET(r,f) (r).pmad_ieee_rcv_det[0]=(((r).pmad_ieee_rcv_det[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET2f_GET(r) ((((r).pmad_ieee_rcv_det[0]) >> 2) & 0x1)
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET2f_SET(r,f) (r).pmad_ieee_rcv_det[0]=(((r).pmad_ieee_rcv_det[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET1f_GET(r) ((((r).pmad_ieee_rcv_det[0]) >> 1) & 0x1)
#define BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET1f_SET(r,f) (r).pmad_ieee_rcv_det[0]=(((r).pmad_ieee_rcv_det[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PMAD_IEEE_RCV_DETr_GLB_RCV_DETf_GET(r) (((r).pmad_ieee_rcv_det[0]) & 0x1)
#define BCM84868_PMAD_IEEE_RCV_DETr_GLB_RCV_DETf_SET(r,f) (r).pmad_ieee_rcv_det[0]=(((r).pmad_ieee_rcv_det[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMAD_IEEE_RCV_DET.
 */
#define BCM84868_READ_PMAD_IEEE_RCV_DETr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_RCV_DETr,(_r._pmad_ieee_rcv_det))
#define BCM84868_WRITE_PMAD_IEEE_RCV_DETr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_RCV_DETr,(_r._pmad_ieee_rcv_det))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_RCV_DETr BCM84868_PMAD_IEEE_RCV_DETr
#define PMAD_IEEE_RCV_DETr_SIZE BCM84868_PMAD_IEEE_RCV_DETr_SIZE
typedef BCM84868_PMAD_IEEE_RCV_DETr_t PMAD_IEEE_RCV_DETr_t;
#define PMAD_IEEE_RCV_DETr_CLR BCM84868_PMAD_IEEE_RCV_DETr_CLR
#define PMAD_IEEE_RCV_DETr_SET BCM84868_PMAD_IEEE_RCV_DETr_SET
#define PMAD_IEEE_RCV_DETr_GET BCM84868_PMAD_IEEE_RCV_DETr_GET
#define PMAD_IEEE_RCV_DETr_RCV_DET4f_GET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET4f_GET
#define PMAD_IEEE_RCV_DETr_RCV_DET4f_SET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET4f_SET
#define PMAD_IEEE_RCV_DETr_RCV_DET3f_GET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET3f_GET
#define PMAD_IEEE_RCV_DETr_RCV_DET3f_SET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET3f_SET
#define PMAD_IEEE_RCV_DETr_RCV_DET2f_GET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET2f_GET
#define PMAD_IEEE_RCV_DETr_RCV_DET2f_SET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET2f_SET
#define PMAD_IEEE_RCV_DETr_RCV_DET1f_GET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET1f_GET
#define PMAD_IEEE_RCV_DETr_RCV_DET1f_SET BCM84868_PMAD_IEEE_RCV_DETr_RCV_DET1f_SET
#define PMAD_IEEE_RCV_DETr_GLB_RCV_DETf_GET BCM84868_PMAD_IEEE_RCV_DETr_GLB_RCV_DETf_GET
#define PMAD_IEEE_RCV_DETr_GLB_RCV_DETf_SET BCM84868_PMAD_IEEE_RCV_DETr_GLB_RCV_DETf_SET
#define READ_PMAD_IEEE_RCV_DETr BCM84868_READ_PMAD_IEEE_RCV_DETr
#define WRITE_PMAD_IEEE_RCV_DETr BCM84868_WRITE_PMAD_IEEE_RCV_DETr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_RCV_DETr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_EXT_AB
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x000b
 * DEVAD:    1
 * DESC:     10G PMA/PMD extended ability
 * SIZE:     32
 * FIELDS:
 *     CAP_10GB_CX4     
 *     CAP_10GB_T       
 *     CAP_1000B_T      
 *     CAP_100B_TX      
 *     CAP_10B_T        
 */
#define BCM84868_PMAD_IEEE_EXT_ABr (0x0001000b | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_EXT_ABr_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_EXT_AB.
 */
typedef union BCM84868_PMAD_IEEE_EXT_ABr_s {
	uint32_t v[1];
	uint32_t pmad_ieee_ext_ab[1];
	uint32_t _pmad_ieee_ext_ab;
} BCM84868_PMAD_IEEE_EXT_ABr_t;

#define BCM84868_PMAD_IEEE_EXT_ABr_CLR(r) (r).pmad_ieee_ext_ab[0] = 0
#define BCM84868_PMAD_IEEE_EXT_ABr_SET(r,d) (r).pmad_ieee_ext_ab[0] = d
#define BCM84868_PMAD_IEEE_EXT_ABr_GET(r) (r).pmad_ieee_ext_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_10B_Tf_GET(r) ((((r).pmad_ieee_ext_ab[0]) >> 8) & 0x1)
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_10B_Tf_SET(r,f) (r).pmad_ieee_ext_ab[0]=(((r).pmad_ieee_ext_ab[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_100B_TXf_GET(r) ((((r).pmad_ieee_ext_ab[0]) >> 7) & 0x1)
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_100B_TXf_SET(r,f) (r).pmad_ieee_ext_ab[0]=(((r).pmad_ieee_ext_ab[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_1000B_Tf_GET(r) ((((r).pmad_ieee_ext_ab[0]) >> 5) & 0x1)
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_1000B_Tf_SET(r,f) (r).pmad_ieee_ext_ab[0]=(((r).pmad_ieee_ext_ab[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_Tf_GET(r) ((((r).pmad_ieee_ext_ab[0]) >> 2) & 0x1)
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_Tf_SET(r,f) (r).pmad_ieee_ext_ab[0]=(((r).pmad_ieee_ext_ab[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_CX4f_GET(r) (((r).pmad_ieee_ext_ab[0]) & 0x1)
#define BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_CX4f_SET(r,f) (r).pmad_ieee_ext_ab[0]=(((r).pmad_ieee_ext_ab[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PMAD_IEEE_EXT_AB.
 */
#define BCM84868_READ_PMAD_IEEE_EXT_ABr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_EXT_ABr,(_r._pmad_ieee_ext_ab))
#define BCM84868_WRITE_PMAD_IEEE_EXT_ABr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_EXT_ABr,(_r._pmad_ieee_ext_ab))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_EXT_ABr BCM84868_PMAD_IEEE_EXT_ABr
#define PMAD_IEEE_EXT_ABr_SIZE BCM84868_PMAD_IEEE_EXT_ABr_SIZE
typedef BCM84868_PMAD_IEEE_EXT_ABr_t PMAD_IEEE_EXT_ABr_t;
#define PMAD_IEEE_EXT_ABr_CLR BCM84868_PMAD_IEEE_EXT_ABr_CLR
#define PMAD_IEEE_EXT_ABr_SET BCM84868_PMAD_IEEE_EXT_ABr_SET
#define PMAD_IEEE_EXT_ABr_GET BCM84868_PMAD_IEEE_EXT_ABr_GET
#define PMAD_IEEE_EXT_ABr_CAP_10B_Tf_GET BCM84868_PMAD_IEEE_EXT_ABr_CAP_10B_Tf_GET
#define PMAD_IEEE_EXT_ABr_CAP_10B_Tf_SET BCM84868_PMAD_IEEE_EXT_ABr_CAP_10B_Tf_SET
#define PMAD_IEEE_EXT_ABr_CAP_100B_TXf_GET BCM84868_PMAD_IEEE_EXT_ABr_CAP_100B_TXf_GET
#define PMAD_IEEE_EXT_ABr_CAP_100B_TXf_SET BCM84868_PMAD_IEEE_EXT_ABr_CAP_100B_TXf_SET
#define PMAD_IEEE_EXT_ABr_CAP_1000B_Tf_GET BCM84868_PMAD_IEEE_EXT_ABr_CAP_1000B_Tf_GET
#define PMAD_IEEE_EXT_ABr_CAP_1000B_Tf_SET BCM84868_PMAD_IEEE_EXT_ABr_CAP_1000B_Tf_SET
#define PMAD_IEEE_EXT_ABr_CAP_10GB_Tf_GET BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_Tf_GET
#define PMAD_IEEE_EXT_ABr_CAP_10GB_Tf_SET BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_Tf_SET
#define PMAD_IEEE_EXT_ABr_CAP_10GB_CX4f_GET BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_CX4f_GET
#define PMAD_IEEE_EXT_ABr_CAP_10GB_CX4f_SET BCM84868_PMAD_IEEE_EXT_ABr_CAP_10GB_CX4f_SET
#define READ_PMAD_IEEE_EXT_ABr BCM84868_READ_PMAD_IEEE_EXT_ABr
#define WRITE_PMAD_IEEE_EXT_ABr BCM84868_WRITE_PMAD_IEEE_EXT_ABr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_EXT_ABr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_PKG_ID0
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x000e
 * DEVAD:    1
 * DESC:     PMA/PMD package identifier
 * SIZE:     32
 * FIELDS:
 *     PKG_ID_0         
 */
#define BCM84868_PMAD_IEEE_PKG_ID0r (0x0001000e | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_PKG_ID0r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_PKG_ID0.
 */
typedef union BCM84868_PMAD_IEEE_PKG_ID0r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_pkg_id0[1];
	uint32_t _pmad_ieee_pkg_id0;
} BCM84868_PMAD_IEEE_PKG_ID0r_t;

#define BCM84868_PMAD_IEEE_PKG_ID0r_CLR(r) (r).pmad_ieee_pkg_id0[0] = 0
#define BCM84868_PMAD_IEEE_PKG_ID0r_SET(r,d) (r).pmad_ieee_pkg_id0[0] = d
#define BCM84868_PMAD_IEEE_PKG_ID0r_GET(r) (r).pmad_ieee_pkg_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_PKG_ID0r_PKG_ID_0f_GET(r) (((r).pmad_ieee_pkg_id0[0]) & 0xffff)
#define BCM84868_PMAD_IEEE_PKG_ID0r_PKG_ID_0f_SET(r,f) (r).pmad_ieee_pkg_id0[0]=(((r).pmad_ieee_pkg_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMAD_IEEE_PKG_ID0.
 */
#define BCM84868_READ_PMAD_IEEE_PKG_ID0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_PKG_ID0r,(_r._pmad_ieee_pkg_id0))
#define BCM84868_WRITE_PMAD_IEEE_PKG_ID0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_PKG_ID0r,(_r._pmad_ieee_pkg_id0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_PKG_ID0r BCM84868_PMAD_IEEE_PKG_ID0r
#define PMAD_IEEE_PKG_ID0r_SIZE BCM84868_PMAD_IEEE_PKG_ID0r_SIZE
typedef BCM84868_PMAD_IEEE_PKG_ID0r_t PMAD_IEEE_PKG_ID0r_t;
#define PMAD_IEEE_PKG_ID0r_CLR BCM84868_PMAD_IEEE_PKG_ID0r_CLR
#define PMAD_IEEE_PKG_ID0r_SET BCM84868_PMAD_IEEE_PKG_ID0r_SET
#define PMAD_IEEE_PKG_ID0r_GET BCM84868_PMAD_IEEE_PKG_ID0r_GET
#define PMAD_IEEE_PKG_ID0r_PKG_ID_0f_GET BCM84868_PMAD_IEEE_PKG_ID0r_PKG_ID_0f_GET
#define PMAD_IEEE_PKG_ID0r_PKG_ID_0f_SET BCM84868_PMAD_IEEE_PKG_ID0r_PKG_ID_0f_SET
#define READ_PMAD_IEEE_PKG_ID0r BCM84868_READ_PMAD_IEEE_PKG_ID0r
#define WRITE_PMAD_IEEE_PKG_ID0r BCM84868_WRITE_PMAD_IEEE_PKG_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_PKG_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMAD_IEEE_PKG_ID1
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x000f
 * DEVAD:    1
 * DESC:     PMA/PMD package identifier
 * SIZE:     32
 * FIELDS:
 *     PKG_ID_1         
 */
#define BCM84868_PMAD_IEEE_PKG_ID1r (0x0001000f | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMAD_IEEE_PKG_ID1r_SIZE 4

/*
 * This structure should be used to declare and program PMAD_IEEE_PKG_ID1.
 */
typedef union BCM84868_PMAD_IEEE_PKG_ID1r_s {
	uint32_t v[1];
	uint32_t pmad_ieee_pkg_id1[1];
	uint32_t _pmad_ieee_pkg_id1;
} BCM84868_PMAD_IEEE_PKG_ID1r_t;

#define BCM84868_PMAD_IEEE_PKG_ID1r_CLR(r) (r).pmad_ieee_pkg_id1[0] = 0
#define BCM84868_PMAD_IEEE_PKG_ID1r_SET(r,d) (r).pmad_ieee_pkg_id1[0] = d
#define BCM84868_PMAD_IEEE_PKG_ID1r_GET(r) (r).pmad_ieee_pkg_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMAD_IEEE_PKG_ID1r_PKG_ID_1f_GET(r) (((r).pmad_ieee_pkg_id1[0]) & 0xffff)
#define BCM84868_PMAD_IEEE_PKG_ID1r_PKG_ID_1f_SET(r,f) (r).pmad_ieee_pkg_id1[0]=(((r).pmad_ieee_pkg_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PMAD_IEEE_PKG_ID1.
 */
#define BCM84868_READ_PMAD_IEEE_PKG_ID1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMAD_IEEE_PKG_ID1r,(_r._pmad_ieee_pkg_id1))
#define BCM84868_WRITE_PMAD_IEEE_PKG_ID1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMAD_IEEE_PKG_ID1r,(_r._pmad_ieee_pkg_id1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMAD_IEEE_PKG_ID1r BCM84868_PMAD_IEEE_PKG_ID1r
#define PMAD_IEEE_PKG_ID1r_SIZE BCM84868_PMAD_IEEE_PKG_ID1r_SIZE
typedef BCM84868_PMAD_IEEE_PKG_ID1r_t PMAD_IEEE_PKG_ID1r_t;
#define PMAD_IEEE_PKG_ID1r_CLR BCM84868_PMAD_IEEE_PKG_ID1r_CLR
#define PMAD_IEEE_PKG_ID1r_SET BCM84868_PMAD_IEEE_PKG_ID1r_SET
#define PMAD_IEEE_PKG_ID1r_GET BCM84868_PMAD_IEEE_PKG_ID1r_GET
#define PMAD_IEEE_PKG_ID1r_PKG_ID_1f_GET BCM84868_PMAD_IEEE_PKG_ID1r_PKG_ID_1f_GET
#define PMAD_IEEE_PKG_ID1r_PKG_ID_1f_SET BCM84868_PMAD_IEEE_PKG_ID1r_PKG_ID_1f_SET
#define READ_PMAD_IEEE_PKG_ID1r BCM84868_READ_PMAD_IEEE_PKG_ID1r
#define WRITE_PMAD_IEEE_PKG_ID1r BCM84868_WRITE_PMAD_IEEE_PKG_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMAD_IEEE_PKG_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PMD_IEEE_TST_MODE_10G
 * BLOCKS:   PMD_IEEE
 * REGADDR:  0x0084
 * DEVAD:    1
 * DESC:     10GBASE-T test mode
 * SIZE:     32
 * FIELDS:
 *     EEE_TST_MODE_CTL 
 *     TRN_TEST_FREQ    
 *     TST_MODE_CTL     
 */
#define BCM84868_PMD_IEEE_TST_MODE_10Gr (0x00010084 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PMD_IEEE_TST_MODE_10Gr_SIZE 4

/*
 * This structure should be used to declare and program PMD_IEEE_TST_MODE_10G.
 */
typedef union BCM84868_PMD_IEEE_TST_MODE_10Gr_s {
	uint32_t v[1];
	uint32_t pmd_ieee_tst_mode_10g[1];
	uint32_t _pmd_ieee_tst_mode_10g;
} BCM84868_PMD_IEEE_TST_MODE_10Gr_t;

#define BCM84868_PMD_IEEE_TST_MODE_10Gr_CLR(r) (r).pmd_ieee_tst_mode_10g[0] = 0
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_SET(r,d) (r).pmd_ieee_tst_mode_10g[0] = d
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_GET(r) (r).pmd_ieee_tst_mode_10g[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_TST_MODE_CTLf_GET(r) ((((r).pmd_ieee_tst_mode_10g[0]) >> 13) & 0x7)
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_TST_MODE_CTLf_SET(r,f) (r).pmd_ieee_tst_mode_10g[0]=(((r).pmd_ieee_tst_mode_10g[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_TRN_TEST_FREQf_GET(r) ((((r).pmd_ieee_tst_mode_10g[0]) >> 10) & 0x7)
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_TRN_TEST_FREQf_SET(r,f) (r).pmd_ieee_tst_mode_10g[0]=(((r).pmd_ieee_tst_mode_10g[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_EEE_TST_MODE_CTLf_GET(r) ((((r).pmd_ieee_tst_mode_10g[0]) >> 8) & 0x3)
#define BCM84868_PMD_IEEE_TST_MODE_10Gr_EEE_TST_MODE_CTLf_SET(r,f) (r).pmd_ieee_tst_mode_10g[0]=(((r).pmd_ieee_tst_mode_10g[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))

/*
 * These macros can be used to access PMD_IEEE_TST_MODE_10G.
 */
#define BCM84868_READ_PMD_IEEE_TST_MODE_10Gr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PMD_IEEE_TST_MODE_10Gr,(_r._pmd_ieee_tst_mode_10g))
#define BCM84868_WRITE_PMD_IEEE_TST_MODE_10Gr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PMD_IEEE_TST_MODE_10Gr,(_r._pmd_ieee_tst_mode_10g))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PMD_IEEE_TST_MODE_10Gr BCM84868_PMD_IEEE_TST_MODE_10Gr
#define PMD_IEEE_TST_MODE_10Gr_SIZE BCM84868_PMD_IEEE_TST_MODE_10Gr_SIZE
typedef BCM84868_PMD_IEEE_TST_MODE_10Gr_t PMD_IEEE_TST_MODE_10Gr_t;
#define PMD_IEEE_TST_MODE_10Gr_CLR BCM84868_PMD_IEEE_TST_MODE_10Gr_CLR
#define PMD_IEEE_TST_MODE_10Gr_SET BCM84868_PMD_IEEE_TST_MODE_10Gr_SET
#define PMD_IEEE_TST_MODE_10Gr_GET BCM84868_PMD_IEEE_TST_MODE_10Gr_GET
#define PMD_IEEE_TST_MODE_10Gr_TST_MODE_CTLf_GET BCM84868_PMD_IEEE_TST_MODE_10Gr_TST_MODE_CTLf_GET
#define PMD_IEEE_TST_MODE_10Gr_TST_MODE_CTLf_SET BCM84868_PMD_IEEE_TST_MODE_10Gr_TST_MODE_CTLf_SET
#define PMD_IEEE_TST_MODE_10Gr_TRN_TEST_FREQf_GET BCM84868_PMD_IEEE_TST_MODE_10Gr_TRN_TEST_FREQf_GET
#define PMD_IEEE_TST_MODE_10Gr_TRN_TEST_FREQf_SET BCM84868_PMD_IEEE_TST_MODE_10Gr_TRN_TEST_FREQf_SET
#define PMD_IEEE_TST_MODE_10Gr_EEE_TST_MODE_CTLf_GET BCM84868_PMD_IEEE_TST_MODE_10Gr_EEE_TST_MODE_CTLf_GET
#define PMD_IEEE_TST_MODE_10Gr_EEE_TST_MODE_CTLf_SET BCM84868_PMD_IEEE_TST_MODE_10Gr_EEE_TST_MODE_CTLf_SET
#define READ_PMD_IEEE_TST_MODE_10Gr BCM84868_READ_PMD_IEEE_TST_MODE_10Gr
#define WRITE_PMD_IEEE_TST_MODE_10Gr BCM84868_WRITE_PMD_IEEE_TST_MODE_10Gr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PMD_IEEE_TST_MODE_10Gr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO2ARM_ADDR_LOW
 * BLOCKS:   PHYC_CTL
 * REGADDR:  0xa819
 * DEVAD:    1
 * DESC:     Mdio2Arm Low Address Value
 * SIZE:     32
 * FIELDS:
 *     MDIO2ARM_ADDR_LOW 
 */
#define BCM84868_MDIO2ARM_ADDR_LOWr (0x0001a819 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO2ARM_ADDR_LOWr_SIZE 4

/*
 * This structure should be used to declare and program MDIO2ARM_ADDR_LOW.
 */
typedef union BCM84868_MDIO2ARM_ADDR_LOWr_s {
	uint32_t v[1];
	uint32_t mdio2arm_addr_low[1];
	uint32_t _mdio2arm_addr_low;
} BCM84868_MDIO2ARM_ADDR_LOWr_t;

#define BCM84868_MDIO2ARM_ADDR_LOWr_CLR(r) (r).mdio2arm_addr_low[0] = 0
#define BCM84868_MDIO2ARM_ADDR_LOWr_SET(r,d) (r).mdio2arm_addr_low[0] = d
#define BCM84868_MDIO2ARM_ADDR_LOWr_GET(r) (r).mdio2arm_addr_low[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO2ARM_ADDR_LOWr_MDIO2ARM_ADDR_LOWf_GET(r) (((r).mdio2arm_addr_low[0]) & 0xffff)
#define BCM84868_MDIO2ARM_ADDR_LOWr_MDIO2ARM_ADDR_LOWf_SET(r,f) (r).mdio2arm_addr_low[0]=(((r).mdio2arm_addr_low[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO2ARM_ADDR_LOW.
 */
#define BCM84868_READ_MDIO2ARM_ADDR_LOWr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO2ARM_ADDR_LOWr,(_r._mdio2arm_addr_low))
#define BCM84868_WRITE_MDIO2ARM_ADDR_LOWr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO2ARM_ADDR_LOWr,(_r._mdio2arm_addr_low))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO2ARM_ADDR_LOWr BCM84868_MDIO2ARM_ADDR_LOWr
#define MDIO2ARM_ADDR_LOWr_SIZE BCM84868_MDIO2ARM_ADDR_LOWr_SIZE
typedef BCM84868_MDIO2ARM_ADDR_LOWr_t MDIO2ARM_ADDR_LOWr_t;
#define MDIO2ARM_ADDR_LOWr_CLR BCM84868_MDIO2ARM_ADDR_LOWr_CLR
#define MDIO2ARM_ADDR_LOWr_SET BCM84868_MDIO2ARM_ADDR_LOWr_SET
#define MDIO2ARM_ADDR_LOWr_GET BCM84868_MDIO2ARM_ADDR_LOWr_GET
#define MDIO2ARM_ADDR_LOWr_MDIO2ARM_ADDR_LOWf_GET BCM84868_MDIO2ARM_ADDR_LOWr_MDIO2ARM_ADDR_LOWf_GET
#define MDIO2ARM_ADDR_LOWr_MDIO2ARM_ADDR_LOWf_SET BCM84868_MDIO2ARM_ADDR_LOWr_MDIO2ARM_ADDR_LOWf_SET
#define READ_MDIO2ARM_ADDR_LOWr BCM84868_READ_MDIO2ARM_ADDR_LOWr
#define WRITE_MDIO2ARM_ADDR_LOWr BCM84868_WRITE_MDIO2ARM_ADDR_LOWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO2ARM_ADDR_LOWr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO2ARM_ADDR_HIGH
 * BLOCKS:   PHYC_CTL
 * REGADDR:  0xa81a
 * DEVAD:    1
 * DESC:     Mdio2Arm High Address Value
 * SIZE:     32
 * FIELDS:
 *     MDIO2ARM_ADDR_HIGH 
 */
#define BCM84868_MDIO2ARM_ADDR_HIGHr (0x0001a81a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO2ARM_ADDR_HIGHr_SIZE 4

/*
 * This structure should be used to declare and program MDIO2ARM_ADDR_HIGH.
 */
typedef union BCM84868_MDIO2ARM_ADDR_HIGHr_s {
	uint32_t v[1];
	uint32_t mdio2arm_addr_high[1];
	uint32_t _mdio2arm_addr_high;
} BCM84868_MDIO2ARM_ADDR_HIGHr_t;

#define BCM84868_MDIO2ARM_ADDR_HIGHr_CLR(r) (r).mdio2arm_addr_high[0] = 0
#define BCM84868_MDIO2ARM_ADDR_HIGHr_SET(r,d) (r).mdio2arm_addr_high[0] = d
#define BCM84868_MDIO2ARM_ADDR_HIGHr_GET(r) (r).mdio2arm_addr_high[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO2ARM_ADDR_HIGHr_MDIO2ARM_ADDR_HIGHf_GET(r) (((r).mdio2arm_addr_high[0]) & 0xffff)
#define BCM84868_MDIO2ARM_ADDR_HIGHr_MDIO2ARM_ADDR_HIGHf_SET(r,f) (r).mdio2arm_addr_high[0]=(((r).mdio2arm_addr_high[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO2ARM_ADDR_HIGH.
 */
#define BCM84868_READ_MDIO2ARM_ADDR_HIGHr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO2ARM_ADDR_HIGHr,(_r._mdio2arm_addr_high))
#define BCM84868_WRITE_MDIO2ARM_ADDR_HIGHr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO2ARM_ADDR_HIGHr,(_r._mdio2arm_addr_high))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO2ARM_ADDR_HIGHr BCM84868_MDIO2ARM_ADDR_HIGHr
#define MDIO2ARM_ADDR_HIGHr_SIZE BCM84868_MDIO2ARM_ADDR_HIGHr_SIZE
typedef BCM84868_MDIO2ARM_ADDR_HIGHr_t MDIO2ARM_ADDR_HIGHr_t;
#define MDIO2ARM_ADDR_HIGHr_CLR BCM84868_MDIO2ARM_ADDR_HIGHr_CLR
#define MDIO2ARM_ADDR_HIGHr_SET BCM84868_MDIO2ARM_ADDR_HIGHr_SET
#define MDIO2ARM_ADDR_HIGHr_GET BCM84868_MDIO2ARM_ADDR_HIGHr_GET
#define MDIO2ARM_ADDR_HIGHr_MDIO2ARM_ADDR_HIGHf_GET BCM84868_MDIO2ARM_ADDR_HIGHr_MDIO2ARM_ADDR_HIGHf_GET
#define MDIO2ARM_ADDR_HIGHr_MDIO2ARM_ADDR_HIGHf_SET BCM84868_MDIO2ARM_ADDR_HIGHr_MDIO2ARM_ADDR_HIGHf_SET
#define READ_MDIO2ARM_ADDR_HIGHr BCM84868_READ_MDIO2ARM_ADDR_HIGHr
#define WRITE_MDIO2ARM_ADDR_HIGHr BCM84868_WRITE_MDIO2ARM_ADDR_HIGHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO2ARM_ADDR_HIGHr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO2ARM_DATA_LOW
 * BLOCKS:   PHYC_CTL
 * REGADDR:  0xa81b
 * DEVAD:    1
 * DESC:     Mdio2Arm Low Data Value
 * SIZE:     32
 * FIELDS:
 *     MDIO2ARM_DATA_LOW 
 */
#define BCM84868_MDIO2ARM_DATA_LOWr (0x0001a81b | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO2ARM_DATA_LOWr_SIZE 4

/*
 * This structure should be used to declare and program MDIO2ARM_DATA_LOW.
 */
typedef union BCM84868_MDIO2ARM_DATA_LOWr_s {
	uint32_t v[1];
	uint32_t mdio2arm_data_low[1];
	uint32_t _mdio2arm_data_low;
} BCM84868_MDIO2ARM_DATA_LOWr_t;

#define BCM84868_MDIO2ARM_DATA_LOWr_CLR(r) (r).mdio2arm_data_low[0] = 0
#define BCM84868_MDIO2ARM_DATA_LOWr_SET(r,d) (r).mdio2arm_data_low[0] = d
#define BCM84868_MDIO2ARM_DATA_LOWr_GET(r) (r).mdio2arm_data_low[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO2ARM_DATA_LOWr_MDIO2ARM_DATA_LOWf_GET(r) (((r).mdio2arm_data_low[0]) & 0xffff)
#define BCM84868_MDIO2ARM_DATA_LOWr_MDIO2ARM_DATA_LOWf_SET(r,f) (r).mdio2arm_data_low[0]=(((r).mdio2arm_data_low[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO2ARM_DATA_LOW.
 */
#define BCM84868_READ_MDIO2ARM_DATA_LOWr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO2ARM_DATA_LOWr,(_r._mdio2arm_data_low))
#define BCM84868_WRITE_MDIO2ARM_DATA_LOWr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO2ARM_DATA_LOWr,(_r._mdio2arm_data_low))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO2ARM_DATA_LOWr BCM84868_MDIO2ARM_DATA_LOWr
#define MDIO2ARM_DATA_LOWr_SIZE BCM84868_MDIO2ARM_DATA_LOWr_SIZE
typedef BCM84868_MDIO2ARM_DATA_LOWr_t MDIO2ARM_DATA_LOWr_t;
#define MDIO2ARM_DATA_LOWr_CLR BCM84868_MDIO2ARM_DATA_LOWr_CLR
#define MDIO2ARM_DATA_LOWr_SET BCM84868_MDIO2ARM_DATA_LOWr_SET
#define MDIO2ARM_DATA_LOWr_GET BCM84868_MDIO2ARM_DATA_LOWr_GET
#define MDIO2ARM_DATA_LOWr_MDIO2ARM_DATA_LOWf_GET BCM84868_MDIO2ARM_DATA_LOWr_MDIO2ARM_DATA_LOWf_GET
#define MDIO2ARM_DATA_LOWr_MDIO2ARM_DATA_LOWf_SET BCM84868_MDIO2ARM_DATA_LOWr_MDIO2ARM_DATA_LOWf_SET
#define READ_MDIO2ARM_DATA_LOWr BCM84868_READ_MDIO2ARM_DATA_LOWr
#define WRITE_MDIO2ARM_DATA_LOWr BCM84868_WRITE_MDIO2ARM_DATA_LOWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO2ARM_DATA_LOWr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO2ARM_DATA_HIGH
 * BLOCKS:   PHYC_CTL
 * REGADDR:  0xa81c
 * DEVAD:    1
 * DESC:     Mdio2Arm High Data Value
 * SIZE:     32
 * FIELDS:
 *     MDIO2ARM_DATA_HIGH 
 */
#define BCM84868_MDIO2ARM_DATA_HIGHr (0x0001a81c | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO2ARM_DATA_HIGHr_SIZE 4

/*
 * This structure should be used to declare and program MDIO2ARM_DATA_HIGH.
 */
typedef union BCM84868_MDIO2ARM_DATA_HIGHr_s {
	uint32_t v[1];
	uint32_t mdio2arm_data_high[1];
	uint32_t _mdio2arm_data_high;
} BCM84868_MDIO2ARM_DATA_HIGHr_t;

#define BCM84868_MDIO2ARM_DATA_HIGHr_CLR(r) (r).mdio2arm_data_high[0] = 0
#define BCM84868_MDIO2ARM_DATA_HIGHr_SET(r,d) (r).mdio2arm_data_high[0] = d
#define BCM84868_MDIO2ARM_DATA_HIGHr_GET(r) (r).mdio2arm_data_high[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO2ARM_DATA_HIGHr_MDIO2ARM_DATA_HIGHf_GET(r) (((r).mdio2arm_data_high[0]) & 0xffff)
#define BCM84868_MDIO2ARM_DATA_HIGHr_MDIO2ARM_DATA_HIGHf_SET(r,f) (r).mdio2arm_data_high[0]=(((r).mdio2arm_data_high[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO2ARM_DATA_HIGH.
 */
#define BCM84868_READ_MDIO2ARM_DATA_HIGHr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO2ARM_DATA_HIGHr,(_r._mdio2arm_data_high))
#define BCM84868_WRITE_MDIO2ARM_DATA_HIGHr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO2ARM_DATA_HIGHr,(_r._mdio2arm_data_high))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO2ARM_DATA_HIGHr BCM84868_MDIO2ARM_DATA_HIGHr
#define MDIO2ARM_DATA_HIGHr_SIZE BCM84868_MDIO2ARM_DATA_HIGHr_SIZE
typedef BCM84868_MDIO2ARM_DATA_HIGHr_t MDIO2ARM_DATA_HIGHr_t;
#define MDIO2ARM_DATA_HIGHr_CLR BCM84868_MDIO2ARM_DATA_HIGHr_CLR
#define MDIO2ARM_DATA_HIGHr_SET BCM84868_MDIO2ARM_DATA_HIGHr_SET
#define MDIO2ARM_DATA_HIGHr_GET BCM84868_MDIO2ARM_DATA_HIGHr_GET
#define MDIO2ARM_DATA_HIGHr_MDIO2ARM_DATA_HIGHf_GET BCM84868_MDIO2ARM_DATA_HIGHr_MDIO2ARM_DATA_HIGHf_GET
#define MDIO2ARM_DATA_HIGHr_MDIO2ARM_DATA_HIGHf_SET BCM84868_MDIO2ARM_DATA_HIGHr_MDIO2ARM_DATA_HIGHf_SET
#define READ_MDIO2ARM_DATA_HIGHr BCM84868_READ_MDIO2ARM_DATA_HIGHr
#define WRITE_MDIO2ARM_DATA_HIGHr BCM84868_WRITE_MDIO2ARM_DATA_HIGHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO2ARM_DATA_HIGHr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHYC_CTL_CABLE_DIAG_RESULT
 * BLOCKS:   PHYC
 * REGADDR:  0xa896
 * DEVAD:    1
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     PHYC_CTL_CABLE_DIAG_RESULT_REG 
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr (0x0001a896 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_SIZE 4

/*
 * This structure should be used to declare and program PHYC_CTL_CABLE_DIAG_RESULT.
 */
typedef union BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_s {
	uint32_t v[1];
	uint32_t phyc_ctl_cable_diag_result[1];
	uint32_t _phyc_ctl_cable_diag_result;
} BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_t;

#define BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_CLR(r) (r).phyc_ctl_cable_diag_result[0] = 0
#define BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_SET(r,d) (r).phyc_ctl_cable_diag_result[0] = d
#define BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_GET(r) (r).phyc_ctl_cable_diag_result[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_PHYC_CTL_CABLE_DIAG_RESULT_REGf_GET(r) (((r).phyc_ctl_cable_diag_result[0]) & 0xffff)
#define BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_PHYC_CTL_CABLE_DIAG_RESULT_REGf_SET(r,f) (r).phyc_ctl_cable_diag_result[0]=(((r).phyc_ctl_cable_diag_result[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYC_CTL_CABLE_DIAG_RESULT.
 */
#define BCM84868_READ_PHYC_CTL_CABLE_DIAG_RESULTr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr,(_r._phyc_ctl_cable_diag_result))
#define BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_RESULTr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr,(_r._phyc_ctl_cable_diag_result))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHYC_CTL_CABLE_DIAG_RESULTr BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr
#define PHYC_CTL_CABLE_DIAG_RESULTr_SIZE BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_SIZE
typedef BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_t PHYC_CTL_CABLE_DIAG_RESULTr_t;
#define PHYC_CTL_CABLE_DIAG_RESULTr_CLR BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_CLR
#define PHYC_CTL_CABLE_DIAG_RESULTr_SET BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_SET
#define PHYC_CTL_CABLE_DIAG_RESULTr_GET BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_GET
#define PHYC_CTL_CABLE_DIAG_RESULTr_PHYC_CTL_CABLE_DIAG_RESULT_REGf_GET BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_PHYC_CTL_CABLE_DIAG_RESULT_REGf_GET
#define PHYC_CTL_CABLE_DIAG_RESULTr_PHYC_CTL_CABLE_DIAG_RESULT_REGf_SET BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr_PHYC_CTL_CABLE_DIAG_RESULT_REGf_SET
#define READ_PHYC_CTL_CABLE_DIAG_RESULTr BCM84868_READ_PHYC_CTL_CABLE_DIAG_RESULTr
#define WRITE_PHYC_CTL_CABLE_DIAG_RESULTr BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_RESULTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHYC_CTL_CABLE_DIAG_RESULTr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHYC_CTL_CABLE_DIAG_PAIR12_LEN
 * BLOCKS:   PHYC
 * REGADDR:  0xa897
 * DEVAD:    1
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     PHYC_CTL_CABLE_DIAG_PAIR12_LEN_REG 
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr (0x0001a897 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_SIZE 4

/*
 * This structure should be used to declare and program PHYC_CTL_CABLE_DIAG_PAIR12_LEN.
 */
typedef union BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_s {
	uint32_t v[1];
	uint32_t phyc_ctl_cable_diag_pair12_len[1];
	uint32_t _phyc_ctl_cable_diag_pair12_len;
} BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_t;

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_CLR(r) (r).phyc_ctl_cable_diag_pair12_len[0] = 0
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_SET(r,d) (r).phyc_ctl_cable_diag_pair12_len[0] = d
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_GET(r) (r).phyc_ctl_cable_diag_pair12_len[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_PHYC_CTL_CABLE_DIAG_PAIR12_LEN_REGf_GET(r) (((r).phyc_ctl_cable_diag_pair12_len[0]) & 0xffff)
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_PHYC_CTL_CABLE_DIAG_PAIR12_LEN_REGf_SET(r,f) (r).phyc_ctl_cable_diag_pair12_len[0]=(((r).phyc_ctl_cable_diag_pair12_len[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYC_CTL_CABLE_DIAG_PAIR12_LEN.
 */
#define BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR12_LENr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr,(_r._phyc_ctl_cable_diag_pair12_len))
#define BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR12_LENr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr,(_r._phyc_ctl_cable_diag_pair12_len))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHYC_CTL_CABLE_DIAG_PAIR12_LENr BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr
#define PHYC_CTL_CABLE_DIAG_PAIR12_LENr_SIZE BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_SIZE
typedef BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_t PHYC_CTL_CABLE_DIAG_PAIR12_LENr_t;
#define PHYC_CTL_CABLE_DIAG_PAIR12_LENr_CLR BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_CLR
#define PHYC_CTL_CABLE_DIAG_PAIR12_LENr_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_SET
#define PHYC_CTL_CABLE_DIAG_PAIR12_LENr_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_GET
#define PHYC_CTL_CABLE_DIAG_PAIR12_LENr_PHYC_CTL_CABLE_DIAG_PAIR12_LEN_REGf_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_PHYC_CTL_CABLE_DIAG_PAIR12_LEN_REGf_GET
#define PHYC_CTL_CABLE_DIAG_PAIR12_LENr_PHYC_CTL_CABLE_DIAG_PAIR12_LEN_REGf_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr_PHYC_CTL_CABLE_DIAG_PAIR12_LEN_REGf_SET
#define READ_PHYC_CTL_CABLE_DIAG_PAIR12_LENr BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR12_LENr
#define WRITE_PHYC_CTL_CABLE_DIAG_PAIR12_LENr BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR12_LENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHYC_CTL_CABLE_DIAG_PAIR12_LENr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHYC_CTL_CABLE_DIAG_PAIR34_LEN
 * BLOCKS:   PHYC
 * REGADDR:  0xa898
 * DEVAD:    1
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     PHYC_CTL_CABLE_DIAG_PAIR34_LEN_REG 
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr (0x0001a898 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_SIZE 4

/*
 * This structure should be used to declare and program PHYC_CTL_CABLE_DIAG_PAIR34_LEN.
 */
typedef union BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_s {
	uint32_t v[1];
	uint32_t phyc_ctl_cable_diag_pair34_len[1];
	uint32_t _phyc_ctl_cable_diag_pair34_len;
} BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_t;

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_CLR(r) (r).phyc_ctl_cable_diag_pair34_len[0] = 0
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_SET(r,d) (r).phyc_ctl_cable_diag_pair34_len[0] = d
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_GET(r) (r).phyc_ctl_cable_diag_pair34_len[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_PHYC_CTL_CABLE_DIAG_PAIR34_LEN_REGf_GET(r) (((r).phyc_ctl_cable_diag_pair34_len[0]) & 0xffff)
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_PHYC_CTL_CABLE_DIAG_PAIR34_LEN_REGf_SET(r,f) (r).phyc_ctl_cable_diag_pair34_len[0]=(((r).phyc_ctl_cable_diag_pair34_len[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYC_CTL_CABLE_DIAG_PAIR34_LEN.
 */
#define BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR34_LENr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr,(_r._phyc_ctl_cable_diag_pair34_len))
#define BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR34_LENr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr,(_r._phyc_ctl_cable_diag_pair34_len))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHYC_CTL_CABLE_DIAG_PAIR34_LENr BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr
#define PHYC_CTL_CABLE_DIAG_PAIR34_LENr_SIZE BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_SIZE
typedef BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_t PHYC_CTL_CABLE_DIAG_PAIR34_LENr_t;
#define PHYC_CTL_CABLE_DIAG_PAIR34_LENr_CLR BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_CLR
#define PHYC_CTL_CABLE_DIAG_PAIR34_LENr_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_SET
#define PHYC_CTL_CABLE_DIAG_PAIR34_LENr_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_GET
#define PHYC_CTL_CABLE_DIAG_PAIR34_LENr_PHYC_CTL_CABLE_DIAG_PAIR34_LEN_REGf_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_PHYC_CTL_CABLE_DIAG_PAIR34_LEN_REGf_GET
#define PHYC_CTL_CABLE_DIAG_PAIR34_LENr_PHYC_CTL_CABLE_DIAG_PAIR34_LEN_REGf_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr_PHYC_CTL_CABLE_DIAG_PAIR34_LEN_REGf_SET
#define READ_PHYC_CTL_CABLE_DIAG_PAIR34_LENr BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR34_LENr
#define WRITE_PHYC_CTL_CABLE_DIAG_PAIR34_LENr BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR34_LENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHYC_CTL_CABLE_DIAG_PAIR34_LENr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHYC_CTL_CABLE_DIAG_PAIR56_LEN
 * BLOCKS:   PHYC
 * REGADDR:  0xa899
 * DEVAD:    1
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     PHYC_CTL_CABLE_DIAG_PAIR56_LEN_REG 
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr (0x0001a899 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_SIZE 4

/*
 * This structure should be used to declare and program PHYC_CTL_CABLE_DIAG_PAIR56_LEN.
 */
typedef union BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_s {
	uint32_t v[1];
	uint32_t phyc_ctl_cable_diag_pair56_len[1];
	uint32_t _phyc_ctl_cable_diag_pair56_len;
} BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_t;

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_CLR(r) (r).phyc_ctl_cable_diag_pair56_len[0] = 0
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_SET(r,d) (r).phyc_ctl_cable_diag_pair56_len[0] = d
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_GET(r) (r).phyc_ctl_cable_diag_pair56_len[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_PHYC_CTL_CABLE_DIAG_PAIR56_LEN_REGf_GET(r) (((r).phyc_ctl_cable_diag_pair56_len[0]) & 0xffff)
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_PHYC_CTL_CABLE_DIAG_PAIR56_LEN_REGf_SET(r,f) (r).phyc_ctl_cable_diag_pair56_len[0]=(((r).phyc_ctl_cable_diag_pair56_len[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYC_CTL_CABLE_DIAG_PAIR56_LEN.
 */
#define BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR56_LENr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr,(_r._phyc_ctl_cable_diag_pair56_len))
#define BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR56_LENr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr,(_r._phyc_ctl_cable_diag_pair56_len))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHYC_CTL_CABLE_DIAG_PAIR56_LENr BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr
#define PHYC_CTL_CABLE_DIAG_PAIR56_LENr_SIZE BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_SIZE
typedef BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_t PHYC_CTL_CABLE_DIAG_PAIR56_LENr_t;
#define PHYC_CTL_CABLE_DIAG_PAIR56_LENr_CLR BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_CLR
#define PHYC_CTL_CABLE_DIAG_PAIR56_LENr_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_SET
#define PHYC_CTL_CABLE_DIAG_PAIR56_LENr_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_GET
#define PHYC_CTL_CABLE_DIAG_PAIR56_LENr_PHYC_CTL_CABLE_DIAG_PAIR56_LEN_REGf_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_PHYC_CTL_CABLE_DIAG_PAIR56_LEN_REGf_GET
#define PHYC_CTL_CABLE_DIAG_PAIR56_LENr_PHYC_CTL_CABLE_DIAG_PAIR56_LEN_REGf_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr_PHYC_CTL_CABLE_DIAG_PAIR56_LEN_REGf_SET
#define READ_PHYC_CTL_CABLE_DIAG_PAIR56_LENr BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR56_LENr
#define WRITE_PHYC_CTL_CABLE_DIAG_PAIR56_LENr BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR56_LENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHYC_CTL_CABLE_DIAG_PAIR56_LENr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHYC_CTL_CABLE_DIAG_PAIR78_LEN
 * BLOCKS:   PHYC
 * REGADDR:  0xa89a
 * DEVAD:    1
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     PHYC_CTL_CABLE_DIAG_PAIR78_LEN_REG 
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr (0x0001a89a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_SIZE 4

/*
 * This structure should be used to declare and program PHYC_CTL_CABLE_DIAG_PAIR78_LEN.
 */
typedef union BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_s {
	uint32_t v[1];
	uint32_t phyc_ctl_cable_diag_pair78_len[1];
	uint32_t _phyc_ctl_cable_diag_pair78_len;
} BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_t;

#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_CLR(r) (r).phyc_ctl_cable_diag_pair78_len[0] = 0
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_SET(r,d) (r).phyc_ctl_cable_diag_pair78_len[0] = d
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_GET(r) (r).phyc_ctl_cable_diag_pair78_len[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_PHYC_CTL_CABLE_DIAG_PAIR78_LEN_REGf_GET(r) (((r).phyc_ctl_cable_diag_pair78_len[0]) & 0xffff)
#define BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_PHYC_CTL_CABLE_DIAG_PAIR78_LEN_REGf_SET(r,f) (r).phyc_ctl_cable_diag_pair78_len[0]=(((r).phyc_ctl_cable_diag_pair78_len[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYC_CTL_CABLE_DIAG_PAIR78_LEN.
 */
#define BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR78_LENr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr,(_r._phyc_ctl_cable_diag_pair78_len))
#define BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR78_LENr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr,(_r._phyc_ctl_cable_diag_pair78_len))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHYC_CTL_CABLE_DIAG_PAIR78_LENr BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr
#define PHYC_CTL_CABLE_DIAG_PAIR78_LENr_SIZE BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_SIZE
typedef BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_t PHYC_CTL_CABLE_DIAG_PAIR78_LENr_t;
#define PHYC_CTL_CABLE_DIAG_PAIR78_LENr_CLR BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_CLR
#define PHYC_CTL_CABLE_DIAG_PAIR78_LENr_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_SET
#define PHYC_CTL_CABLE_DIAG_PAIR78_LENr_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_GET
#define PHYC_CTL_CABLE_DIAG_PAIR78_LENr_PHYC_CTL_CABLE_DIAG_PAIR78_LEN_REGf_GET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_PHYC_CTL_CABLE_DIAG_PAIR78_LEN_REGf_GET
#define PHYC_CTL_CABLE_DIAG_PAIR78_LENr_PHYC_CTL_CABLE_DIAG_PAIR78_LEN_REGf_SET BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr_PHYC_CTL_CABLE_DIAG_PAIR78_LEN_REGf_SET
#define READ_PHYC_CTL_CABLE_DIAG_PAIR78_LENr BCM84868_READ_PHYC_CTL_CABLE_DIAG_PAIR78_LENr
#define WRITE_PHYC_CTL_CABLE_DIAG_PAIR78_LENr BCM84868_WRITE_PHYC_CTL_CABLE_DIAG_PAIR78_LENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHYC_CTL_CABLE_DIAG_PAIR78_LENr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_INT_EN
 * BLOCKS:   PTP
 * REGADDR:  0xd808
 * DEVAD:    1
 * DESC:     PTP_INT_EN
 * SIZE:     32
 * FIELDS:
 *     FSYNC_EN         
 *     PIC_EN           
 */
#define BCM84868_PTP_INT_ENr (0x0001d808 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_INT_ENr_SIZE 4

/*
 * This structure should be used to declare and program PTP_INT_EN.
 */
typedef union BCM84868_PTP_INT_ENr_s {
	uint32_t v[1];
	uint32_t ptp_int_en[1];
	uint32_t _ptp_int_en;
} BCM84868_PTP_INT_ENr_t;

#define BCM84868_PTP_INT_ENr_CLR(r) (r).ptp_int_en[0] = 0
#define BCM84868_PTP_INT_ENr_SET(r,d) (r).ptp_int_en[0] = d
#define BCM84868_PTP_INT_ENr_GET(r) (r).ptp_int_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_INT_ENr_PIC_ENf_GET(r) ((((r).ptp_int_en[0]) >> 1) & 0x1)
#define BCM84868_PTP_INT_ENr_PIC_ENf_SET(r,f) (r).ptp_int_en[0]=(((r).ptp_int_en[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PTP_INT_ENr_FSYNC_ENf_GET(r) (((r).ptp_int_en[0]) & 0x1)
#define BCM84868_PTP_INT_ENr_FSYNC_ENf_SET(r,f) (r).ptp_int_en[0]=(((r).ptp_int_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PTP_INT_EN.
 */
#define BCM84868_READ_PTP_INT_ENr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_INT_ENr,(_r._ptp_int_en))
#define BCM84868_WRITE_PTP_INT_ENr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_INT_ENr,(_r._ptp_int_en))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_INT_ENr BCM84868_PTP_INT_ENr
#define PTP_INT_ENr_SIZE BCM84868_PTP_INT_ENr_SIZE
typedef BCM84868_PTP_INT_ENr_t PTP_INT_ENr_t;
#define PTP_INT_ENr_CLR BCM84868_PTP_INT_ENr_CLR
#define PTP_INT_ENr_SET BCM84868_PTP_INT_ENr_SET
#define PTP_INT_ENr_GET BCM84868_PTP_INT_ENr_GET
#define PTP_INT_ENr_PIC_ENf_GET BCM84868_PTP_INT_ENr_PIC_ENf_GET
#define PTP_INT_ENr_PIC_ENf_SET BCM84868_PTP_INT_ENr_PIC_ENf_SET
#define PTP_INT_ENr_FSYNC_ENf_GET BCM84868_PTP_INT_ENr_FSYNC_ENf_GET
#define PTP_INT_ENr_FSYNC_ENf_SET BCM84868_PTP_INT_ENr_FSYNC_ENf_SET
#define READ_PTP_INT_ENr BCM84868_READ_PTP_INT_ENr
#define WRITE_PTP_INT_ENr BCM84868_WRITE_PTP_INT_ENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_INT_ENr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_INT_STATUS
 * BLOCKS:   PTP
 * REGADDR:  0xd809
 * DEVAD:    1
 * DESC:     Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     FSYNC            
 *     PIC              
 */
#define BCM84868_PTP_INT_STATUSr (0x0001d809 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_INT_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program PTP_INT_STATUS.
 */
typedef union BCM84868_PTP_INT_STATUSr_s {
	uint32_t v[1];
	uint32_t ptp_int_status[1];
	uint32_t _ptp_int_status;
} BCM84868_PTP_INT_STATUSr_t;

#define BCM84868_PTP_INT_STATUSr_CLR(r) (r).ptp_int_status[0] = 0
#define BCM84868_PTP_INT_STATUSr_SET(r,d) (r).ptp_int_status[0] = d
#define BCM84868_PTP_INT_STATUSr_GET(r) (r).ptp_int_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_INT_STATUSr_PICf_GET(r) ((((r).ptp_int_status[0]) >> 1) & 0x1)
#define BCM84868_PTP_INT_STATUSr_PICf_SET(r,f) (r).ptp_int_status[0]=(((r).ptp_int_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PTP_INT_STATUSr_FSYNCf_GET(r) (((r).ptp_int_status[0]) & 0x1)
#define BCM84868_PTP_INT_STATUSr_FSYNCf_SET(r,f) (r).ptp_int_status[0]=(((r).ptp_int_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PTP_INT_STATUS.
 */
#define BCM84868_READ_PTP_INT_STATUSr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_INT_STATUSr,(_r._ptp_int_status))
#define BCM84868_WRITE_PTP_INT_STATUSr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_INT_STATUSr,(_r._ptp_int_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_INT_STATUSr BCM84868_PTP_INT_STATUSr
#define PTP_INT_STATUSr_SIZE BCM84868_PTP_INT_STATUSr_SIZE
typedef BCM84868_PTP_INT_STATUSr_t PTP_INT_STATUSr_t;
#define PTP_INT_STATUSr_CLR BCM84868_PTP_INT_STATUSr_CLR
#define PTP_INT_STATUSr_SET BCM84868_PTP_INT_STATUSr_SET
#define PTP_INT_STATUSr_GET BCM84868_PTP_INT_STATUSr_GET
#define PTP_INT_STATUSr_PICf_GET BCM84868_PTP_INT_STATUSr_PICf_GET
#define PTP_INT_STATUSr_PICf_SET BCM84868_PTP_INT_STATUSr_PICf_SET
#define PTP_INT_STATUSr_FSYNCf_GET BCM84868_PTP_INT_STATUSr_FSYNCf_GET
#define PTP_INT_STATUSr_FSYNCf_SET BCM84868_PTP_INT_STATUSr_FSYNCf_SET
#define READ_PTP_INT_STATUSr BCM84868_READ_PTP_INT_STATUSr
#define WRITE_PTP_INT_STATUSr BCM84868_WRITE_PTP_INT_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_INT_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_INT_CLEAR
 * BLOCKS:   PTP
 * REGADDR:  0xd80a
 * DEVAD:    1
 * DESC:     Interrupt Clear Register
 * SIZE:     32
 * FIELDS:
 *     FSYNC            
 *     PIC              
 */
#define BCM84868_PTP_INT_CLEARr (0x0001d80a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_INT_CLEARr_SIZE 4

/*
 * This structure should be used to declare and program PTP_INT_CLEAR.
 */
typedef union BCM84868_PTP_INT_CLEARr_s {
	uint32_t v[1];
	uint32_t ptp_int_clear[1];
	uint32_t _ptp_int_clear;
} BCM84868_PTP_INT_CLEARr_t;

#define BCM84868_PTP_INT_CLEARr_CLR(r) (r).ptp_int_clear[0] = 0
#define BCM84868_PTP_INT_CLEARr_SET(r,d) (r).ptp_int_clear[0] = d
#define BCM84868_PTP_INT_CLEARr_GET(r) (r).ptp_int_clear[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_INT_CLEARr_PICf_GET(r) ((((r).ptp_int_clear[0]) >> 1) & 0x1)
#define BCM84868_PTP_INT_CLEARr_PICf_SET(r,f) (r).ptp_int_clear[0]=(((r).ptp_int_clear[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PTP_INT_CLEARr_FSYNCf_GET(r) (((r).ptp_int_clear[0]) & 0x1)
#define BCM84868_PTP_INT_CLEARr_FSYNCf_SET(r,f) (r).ptp_int_clear[0]=(((r).ptp_int_clear[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PTP_INT_CLEAR.
 */
#define BCM84868_READ_PTP_INT_CLEARr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_INT_CLEARr,(_r._ptp_int_clear))
#define BCM84868_WRITE_PTP_INT_CLEARr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_INT_CLEARr,(_r._ptp_int_clear))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_INT_CLEARr BCM84868_PTP_INT_CLEARr
#define PTP_INT_CLEARr_SIZE BCM84868_PTP_INT_CLEARr_SIZE
typedef BCM84868_PTP_INT_CLEARr_t PTP_INT_CLEARr_t;
#define PTP_INT_CLEARr_CLR BCM84868_PTP_INT_CLEARr_CLR
#define PTP_INT_CLEARr_SET BCM84868_PTP_INT_CLEARr_SET
#define PTP_INT_CLEARr_GET BCM84868_PTP_INT_CLEARr_GET
#define PTP_INT_CLEARr_PICf_GET BCM84868_PTP_INT_CLEARr_PICf_GET
#define PTP_INT_CLEARr_PICf_SET BCM84868_PTP_INT_CLEARr_PICf_SET
#define PTP_INT_CLEARr_FSYNCf_GET BCM84868_PTP_INT_CLEARr_FSYNCf_GET
#define PTP_INT_CLEARr_FSYNCf_SET BCM84868_PTP_INT_CLEARr_FSYNCf_SET
#define READ_PTP_INT_CLEARr BCM84868_READ_PTP_INT_CLEARr
#define WRITE_PTP_INT_CLEARr BCM84868_WRITE_PTP_INT_CLEARr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_INT_CLEARr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_CTL
 * BLOCKS:   PTP
 * REGADDR:  0xd882
 * DEVAD:    1
 * DESC:     NSE Shadow Control Register
 * SIZE:     32
 * FIELDS:
 *     ORIG_TS          
 *     NEG_CORR         
 *     SYNC_DIV         
 *     SYNCOUT          
 *     DPLL_GAIN1       
 *     DPLL_GAIN2       
 *     DPLL_GAIN3       
 *     REF_PERIOD       
 *     REF_PHASE        
 *     DPLL_FCW         
 *     NCO_FCW          
 *     COUNT_LOW        
 *     COUNT_HIGH       
 *     TIME             
 *     NTP_TIME         
 */
#define BCM84868_PTP_NSE_SHDW_CTLr (0x0001d882 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_CTL.
 */
typedef union BCM84868_PTP_NSE_SHDW_CTLr_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_ctl[1];
	uint32_t _ptp_nse_shdw_ctl;
} BCM84868_PTP_NSE_SHDW_CTLr_t;

#define BCM84868_PTP_NSE_SHDW_CTLr_CLR(r) (r).ptp_nse_shdw_ctl[0] = 0
#define BCM84868_PTP_NSE_SHDW_CTLr_SET(r,d) (r).ptp_nse_shdw_ctl[0] = d
#define BCM84868_PTP_NSE_SHDW_CTLr_GET(r) (r).ptp_nse_shdw_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_CTLr_NTP_TIMEf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 14) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_NTP_TIMEf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PTP_NSE_SHDW_CTLr_TIMEf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 13) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_TIMEf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PTP_NSE_SHDW_CTLr_COUNT_HIGHf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 12) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_COUNT_HIGHf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PTP_NSE_SHDW_CTLr_COUNT_LOWf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 11) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_COUNT_LOWf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PTP_NSE_SHDW_CTLr_NCO_FCWf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 10) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_NCO_FCWf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_FCWf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 9) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_FCWf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_PTP_NSE_SHDW_CTLr_REF_PHASEf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 8) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_REF_PHASEf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_PTP_NSE_SHDW_CTLr_REF_PERIODf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 7) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_REF_PERIODf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN3f_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 6) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN3f_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN2f_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 5) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN2f_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN1f_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 4) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN1f_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PTP_NSE_SHDW_CTLr_SYNCOUTf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 3) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_SYNCOUTf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PTP_NSE_SHDW_CTLr_SYNC_DIVf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 2) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_SYNC_DIVf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PTP_NSE_SHDW_CTLr_NEG_CORRf_GET(r) ((((r).ptp_nse_shdw_ctl[0]) >> 1) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_NEG_CORRf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PTP_NSE_SHDW_CTLr_ORIG_TSf_GET(r) (((r).ptp_nse_shdw_ctl[0]) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CTLr_ORIG_TSf_SET(r,f) (r).ptp_nse_shdw_ctl[0]=(((r).ptp_nse_shdw_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PTP_NSE_SHDW_CTL.
 */
#define BCM84868_READ_PTP_NSE_SHDW_CTLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_CTLr,(_r._ptp_nse_shdw_ctl))
#define BCM84868_WRITE_PTP_NSE_SHDW_CTLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_CTLr,(_r._ptp_nse_shdw_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_CTLr BCM84868_PTP_NSE_SHDW_CTLr
#define PTP_NSE_SHDW_CTLr_SIZE BCM84868_PTP_NSE_SHDW_CTLr_SIZE
typedef BCM84868_PTP_NSE_SHDW_CTLr_t PTP_NSE_SHDW_CTLr_t;
#define PTP_NSE_SHDW_CTLr_CLR BCM84868_PTP_NSE_SHDW_CTLr_CLR
#define PTP_NSE_SHDW_CTLr_SET BCM84868_PTP_NSE_SHDW_CTLr_SET
#define PTP_NSE_SHDW_CTLr_GET BCM84868_PTP_NSE_SHDW_CTLr_GET
#define PTP_NSE_SHDW_CTLr_NTP_TIMEf_GET BCM84868_PTP_NSE_SHDW_CTLr_NTP_TIMEf_GET
#define PTP_NSE_SHDW_CTLr_NTP_TIMEf_SET BCM84868_PTP_NSE_SHDW_CTLr_NTP_TIMEf_SET
#define PTP_NSE_SHDW_CTLr_TIMEf_GET BCM84868_PTP_NSE_SHDW_CTLr_TIMEf_GET
#define PTP_NSE_SHDW_CTLr_TIMEf_SET BCM84868_PTP_NSE_SHDW_CTLr_TIMEf_SET
#define PTP_NSE_SHDW_CTLr_COUNT_HIGHf_GET BCM84868_PTP_NSE_SHDW_CTLr_COUNT_HIGHf_GET
#define PTP_NSE_SHDW_CTLr_COUNT_HIGHf_SET BCM84868_PTP_NSE_SHDW_CTLr_COUNT_HIGHf_SET
#define PTP_NSE_SHDW_CTLr_COUNT_LOWf_GET BCM84868_PTP_NSE_SHDW_CTLr_COUNT_LOWf_GET
#define PTP_NSE_SHDW_CTLr_COUNT_LOWf_SET BCM84868_PTP_NSE_SHDW_CTLr_COUNT_LOWf_SET
#define PTP_NSE_SHDW_CTLr_NCO_FCWf_GET BCM84868_PTP_NSE_SHDW_CTLr_NCO_FCWf_GET
#define PTP_NSE_SHDW_CTLr_NCO_FCWf_SET BCM84868_PTP_NSE_SHDW_CTLr_NCO_FCWf_SET
#define PTP_NSE_SHDW_CTLr_DPLL_FCWf_GET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_FCWf_GET
#define PTP_NSE_SHDW_CTLr_DPLL_FCWf_SET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_FCWf_SET
#define PTP_NSE_SHDW_CTLr_REF_PHASEf_GET BCM84868_PTP_NSE_SHDW_CTLr_REF_PHASEf_GET
#define PTP_NSE_SHDW_CTLr_REF_PHASEf_SET BCM84868_PTP_NSE_SHDW_CTLr_REF_PHASEf_SET
#define PTP_NSE_SHDW_CTLr_REF_PERIODf_GET BCM84868_PTP_NSE_SHDW_CTLr_REF_PERIODf_GET
#define PTP_NSE_SHDW_CTLr_REF_PERIODf_SET BCM84868_PTP_NSE_SHDW_CTLr_REF_PERIODf_SET
#define PTP_NSE_SHDW_CTLr_DPLL_GAIN3f_GET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN3f_GET
#define PTP_NSE_SHDW_CTLr_DPLL_GAIN3f_SET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN3f_SET
#define PTP_NSE_SHDW_CTLr_DPLL_GAIN2f_GET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN2f_GET
#define PTP_NSE_SHDW_CTLr_DPLL_GAIN2f_SET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN2f_SET
#define PTP_NSE_SHDW_CTLr_DPLL_GAIN1f_GET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN1f_GET
#define PTP_NSE_SHDW_CTLr_DPLL_GAIN1f_SET BCM84868_PTP_NSE_SHDW_CTLr_DPLL_GAIN1f_SET
#define PTP_NSE_SHDW_CTLr_SYNCOUTf_GET BCM84868_PTP_NSE_SHDW_CTLr_SYNCOUTf_GET
#define PTP_NSE_SHDW_CTLr_SYNCOUTf_SET BCM84868_PTP_NSE_SHDW_CTLr_SYNCOUTf_SET
#define PTP_NSE_SHDW_CTLr_SYNC_DIVf_GET BCM84868_PTP_NSE_SHDW_CTLr_SYNC_DIVf_GET
#define PTP_NSE_SHDW_CTLr_SYNC_DIVf_SET BCM84868_PTP_NSE_SHDW_CTLr_SYNC_DIVf_SET
#define PTP_NSE_SHDW_CTLr_NEG_CORRf_GET BCM84868_PTP_NSE_SHDW_CTLr_NEG_CORRf_GET
#define PTP_NSE_SHDW_CTLr_NEG_CORRf_SET BCM84868_PTP_NSE_SHDW_CTLr_NEG_CORRf_SET
#define PTP_NSE_SHDW_CTLr_ORIG_TSf_GET BCM84868_PTP_NSE_SHDW_CTLr_ORIG_TSf_GET
#define PTP_NSE_SHDW_CTLr_ORIG_TSf_SET BCM84868_PTP_NSE_SHDW_CTLr_ORIG_TSf_SET
#define READ_PTP_NSE_SHDW_CTLr BCM84868_READ_PTP_NSE_SHDW_CTLr
#define WRITE_PTP_NSE_SHDW_CTLr BCM84868_WRITE_PTP_NSE_SHDW_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_CLR
 * BLOCKS:   PTP
 * REGADDR:  0xd883
 * DEVAD:    1
 * DESC:     NSE Shadow Clear Register
 * SIZE:     32
 * FIELDS:
 *     ORIG_TS          
 *     NEG_CORR         
 *     SYNC_DIV         
 *     SYNCOUT          
 *     DPLL_GAIN1       
 *     DPLL_GAIN2       
 *     DPLL_GAIN3       
 *     REF_PERIOD       
 *     REF_PHASE        
 *     DPLL_FCW         
 *     NCO_FCW          
 *     COUNT_LOW        
 *     COUNT_HIGH       
 *     TIME             
 *     NTP_TIME         
 */
#define BCM84868_PTP_NSE_SHDW_CLRr (0x0001d883 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_CLRr_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_CLR.
 */
typedef union BCM84868_PTP_NSE_SHDW_CLRr_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_clr[1];
	uint32_t _ptp_nse_shdw_clr;
} BCM84868_PTP_NSE_SHDW_CLRr_t;

#define BCM84868_PTP_NSE_SHDW_CLRr_CLR(r) (r).ptp_nse_shdw_clr[0] = 0
#define BCM84868_PTP_NSE_SHDW_CLRr_SET(r,d) (r).ptp_nse_shdw_clr[0] = d
#define BCM84868_PTP_NSE_SHDW_CLRr_GET(r) (r).ptp_nse_shdw_clr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_CLRr_NTP_TIMEf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 14) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_NTP_TIMEf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PTP_NSE_SHDW_CLRr_TIMEf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 13) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_TIMEf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PTP_NSE_SHDW_CLRr_COUNT_HIGHf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 12) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_COUNT_HIGHf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PTP_NSE_SHDW_CLRr_COUNT_LOWf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 11) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_COUNT_LOWf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PTP_NSE_SHDW_CLRr_NCO_FCWf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 10) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_NCO_FCWf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_FCWf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 9) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_FCWf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_PTP_NSE_SHDW_CLRr_REF_PHASEf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 8) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_REF_PHASEf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_PTP_NSE_SHDW_CLRr_REF_PERIODf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 7) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_REF_PERIODf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN3f_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 6) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN3f_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN2f_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 5) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN2f_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN1f_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 4) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN1f_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PTP_NSE_SHDW_CLRr_SYNCOUTf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 3) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_SYNCOUTf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PTP_NSE_SHDW_CLRr_SYNC_DIVf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 2) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_SYNC_DIVf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PTP_NSE_SHDW_CLRr_NEG_CORRf_GET(r) ((((r).ptp_nse_shdw_clr[0]) >> 1) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_NEG_CORRf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PTP_NSE_SHDW_CLRr_ORIG_TSf_GET(r) (((r).ptp_nse_shdw_clr[0]) & 0x1)
#define BCM84868_PTP_NSE_SHDW_CLRr_ORIG_TSf_SET(r,f) (r).ptp_nse_shdw_clr[0]=(((r).ptp_nse_shdw_clr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PTP_NSE_SHDW_CLR.
 */
#define BCM84868_READ_PTP_NSE_SHDW_CLRr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_CLRr,(_r._ptp_nse_shdw_clr))
#define BCM84868_WRITE_PTP_NSE_SHDW_CLRr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_CLRr,(_r._ptp_nse_shdw_clr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_CLRr BCM84868_PTP_NSE_SHDW_CLRr
#define PTP_NSE_SHDW_CLRr_SIZE BCM84868_PTP_NSE_SHDW_CLRr_SIZE
typedef BCM84868_PTP_NSE_SHDW_CLRr_t PTP_NSE_SHDW_CLRr_t;
#define PTP_NSE_SHDW_CLRr_CLR BCM84868_PTP_NSE_SHDW_CLRr_CLR
#define PTP_NSE_SHDW_CLRr_SET BCM84868_PTP_NSE_SHDW_CLRr_SET
#define PTP_NSE_SHDW_CLRr_GET BCM84868_PTP_NSE_SHDW_CLRr_GET
#define PTP_NSE_SHDW_CLRr_NTP_TIMEf_GET BCM84868_PTP_NSE_SHDW_CLRr_NTP_TIMEf_GET
#define PTP_NSE_SHDW_CLRr_NTP_TIMEf_SET BCM84868_PTP_NSE_SHDW_CLRr_NTP_TIMEf_SET
#define PTP_NSE_SHDW_CLRr_TIMEf_GET BCM84868_PTP_NSE_SHDW_CLRr_TIMEf_GET
#define PTP_NSE_SHDW_CLRr_TIMEf_SET BCM84868_PTP_NSE_SHDW_CLRr_TIMEf_SET
#define PTP_NSE_SHDW_CLRr_COUNT_HIGHf_GET BCM84868_PTP_NSE_SHDW_CLRr_COUNT_HIGHf_GET
#define PTP_NSE_SHDW_CLRr_COUNT_HIGHf_SET BCM84868_PTP_NSE_SHDW_CLRr_COUNT_HIGHf_SET
#define PTP_NSE_SHDW_CLRr_COUNT_LOWf_GET BCM84868_PTP_NSE_SHDW_CLRr_COUNT_LOWf_GET
#define PTP_NSE_SHDW_CLRr_COUNT_LOWf_SET BCM84868_PTP_NSE_SHDW_CLRr_COUNT_LOWf_SET
#define PTP_NSE_SHDW_CLRr_NCO_FCWf_GET BCM84868_PTP_NSE_SHDW_CLRr_NCO_FCWf_GET
#define PTP_NSE_SHDW_CLRr_NCO_FCWf_SET BCM84868_PTP_NSE_SHDW_CLRr_NCO_FCWf_SET
#define PTP_NSE_SHDW_CLRr_DPLL_FCWf_GET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_FCWf_GET
#define PTP_NSE_SHDW_CLRr_DPLL_FCWf_SET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_FCWf_SET
#define PTP_NSE_SHDW_CLRr_REF_PHASEf_GET BCM84868_PTP_NSE_SHDW_CLRr_REF_PHASEf_GET
#define PTP_NSE_SHDW_CLRr_REF_PHASEf_SET BCM84868_PTP_NSE_SHDW_CLRr_REF_PHASEf_SET
#define PTP_NSE_SHDW_CLRr_REF_PERIODf_GET BCM84868_PTP_NSE_SHDW_CLRr_REF_PERIODf_GET
#define PTP_NSE_SHDW_CLRr_REF_PERIODf_SET BCM84868_PTP_NSE_SHDW_CLRr_REF_PERIODf_SET
#define PTP_NSE_SHDW_CLRr_DPLL_GAIN3f_GET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN3f_GET
#define PTP_NSE_SHDW_CLRr_DPLL_GAIN3f_SET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN3f_SET
#define PTP_NSE_SHDW_CLRr_DPLL_GAIN2f_GET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN2f_GET
#define PTP_NSE_SHDW_CLRr_DPLL_GAIN2f_SET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN2f_SET
#define PTP_NSE_SHDW_CLRr_DPLL_GAIN1f_GET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN1f_GET
#define PTP_NSE_SHDW_CLRr_DPLL_GAIN1f_SET BCM84868_PTP_NSE_SHDW_CLRr_DPLL_GAIN1f_SET
#define PTP_NSE_SHDW_CLRr_SYNCOUTf_GET BCM84868_PTP_NSE_SHDW_CLRr_SYNCOUTf_GET
#define PTP_NSE_SHDW_CLRr_SYNCOUTf_SET BCM84868_PTP_NSE_SHDW_CLRr_SYNCOUTf_SET
#define PTP_NSE_SHDW_CLRr_SYNC_DIVf_GET BCM84868_PTP_NSE_SHDW_CLRr_SYNC_DIVf_GET
#define PTP_NSE_SHDW_CLRr_SYNC_DIVf_SET BCM84868_PTP_NSE_SHDW_CLRr_SYNC_DIVf_SET
#define PTP_NSE_SHDW_CLRr_NEG_CORRf_GET BCM84868_PTP_NSE_SHDW_CLRr_NEG_CORRf_GET
#define PTP_NSE_SHDW_CLRr_NEG_CORRf_SET BCM84868_PTP_NSE_SHDW_CLRr_NEG_CORRf_SET
#define PTP_NSE_SHDW_CLRr_ORIG_TSf_GET BCM84868_PTP_NSE_SHDW_CLRr_ORIG_TSf_GET
#define PTP_NSE_SHDW_CLRr_ORIG_TSf_SET BCM84868_PTP_NSE_SHDW_CLRr_ORIG_TSf_SET
#define READ_PTP_NSE_SHDW_CLRr BCM84868_READ_PTP_NSE_SHDW_CLRr
#define WRITE_PTP_NSE_SHDW_CLRr BCM84868_WRITE_PTP_NSE_SHDW_CLRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_CLRr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_ORG_TS_0
 * BLOCKS:   PTP
 * REGADDR:  0xd890
 * DEVAD:    1
 * DESC:     NSE Origin Timestamp Bits[15:0] Register
 * SIZE:     32
 * FIELDS:
 *     ORIGIN_TIMESTAMP 
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_0r (0x0001d890 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_ORG_TS_0r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_ORG_TS_0.
 */
typedef union BCM84868_PTP_NSE_SHDW_ORG_TS_0r_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_org_ts_0[1];
	uint32_t _ptp_nse_shdw_org_ts_0;
} BCM84868_PTP_NSE_SHDW_ORG_TS_0r_t;

#define BCM84868_PTP_NSE_SHDW_ORG_TS_0r_CLR(r) (r).ptp_nse_shdw_org_ts_0[0] = 0
#define BCM84868_PTP_NSE_SHDW_ORG_TS_0r_SET(r,d) (r).ptp_nse_shdw_org_ts_0[0] = d
#define BCM84868_PTP_NSE_SHDW_ORG_TS_0r_GET(r) (r).ptp_nse_shdw_org_ts_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_0r_ORIGIN_TIMESTAMPf_GET(r) (((r).ptp_nse_shdw_org_ts_0[0]) & 0xffff)
#define BCM84868_PTP_NSE_SHDW_ORG_TS_0r_ORIGIN_TIMESTAMPf_SET(r,f) (r).ptp_nse_shdw_org_ts_0[0]=(((r).ptp_nse_shdw_org_ts_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SHDW_ORG_TS_0.
 */
#define BCM84868_READ_PTP_NSE_SHDW_ORG_TS_0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_0r,(_r._ptp_nse_shdw_org_ts_0))
#define BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_0r,(_r._ptp_nse_shdw_org_ts_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_ORG_TS_0r BCM84868_PTP_NSE_SHDW_ORG_TS_0r
#define PTP_NSE_SHDW_ORG_TS_0r_SIZE BCM84868_PTP_NSE_SHDW_ORG_TS_0r_SIZE
typedef BCM84868_PTP_NSE_SHDW_ORG_TS_0r_t PTP_NSE_SHDW_ORG_TS_0r_t;
#define PTP_NSE_SHDW_ORG_TS_0r_CLR BCM84868_PTP_NSE_SHDW_ORG_TS_0r_CLR
#define PTP_NSE_SHDW_ORG_TS_0r_SET BCM84868_PTP_NSE_SHDW_ORG_TS_0r_SET
#define PTP_NSE_SHDW_ORG_TS_0r_GET BCM84868_PTP_NSE_SHDW_ORG_TS_0r_GET
#define PTP_NSE_SHDW_ORG_TS_0r_ORIGIN_TIMESTAMPf_GET BCM84868_PTP_NSE_SHDW_ORG_TS_0r_ORIGIN_TIMESTAMPf_GET
#define PTP_NSE_SHDW_ORG_TS_0r_ORIGIN_TIMESTAMPf_SET BCM84868_PTP_NSE_SHDW_ORG_TS_0r_ORIGIN_TIMESTAMPf_SET
#define READ_PTP_NSE_SHDW_ORG_TS_0r BCM84868_READ_PTP_NSE_SHDW_ORG_TS_0r
#define WRITE_PTP_NSE_SHDW_ORG_TS_0r BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_ORG_TS_0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_ORG_TS_1
 * BLOCKS:   PTP
 * REGADDR:  0xd891
 * DEVAD:    1
 * DESC:     NSE Origin Timestamp Bits[31:16] Register
 * SIZE:     32
 * FIELDS:
 *     ORIGIN_TIMESTAMP 
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_1r (0x0001d891 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_ORG_TS_1r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_ORG_TS_1.
 */
typedef union BCM84868_PTP_NSE_SHDW_ORG_TS_1r_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_org_ts_1[1];
	uint32_t _ptp_nse_shdw_org_ts_1;
} BCM84868_PTP_NSE_SHDW_ORG_TS_1r_t;

#define BCM84868_PTP_NSE_SHDW_ORG_TS_1r_CLR(r) (r).ptp_nse_shdw_org_ts_1[0] = 0
#define BCM84868_PTP_NSE_SHDW_ORG_TS_1r_SET(r,d) (r).ptp_nse_shdw_org_ts_1[0] = d
#define BCM84868_PTP_NSE_SHDW_ORG_TS_1r_GET(r) (r).ptp_nse_shdw_org_ts_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_1r_ORIGIN_TIMESTAMPf_GET(r) (((r).ptp_nse_shdw_org_ts_1[0]) & 0xffff)
#define BCM84868_PTP_NSE_SHDW_ORG_TS_1r_ORIGIN_TIMESTAMPf_SET(r,f) (r).ptp_nse_shdw_org_ts_1[0]=(((r).ptp_nse_shdw_org_ts_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SHDW_ORG_TS_1.
 */
#define BCM84868_READ_PTP_NSE_SHDW_ORG_TS_1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_1r,(_r._ptp_nse_shdw_org_ts_1))
#define BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_1r,(_r._ptp_nse_shdw_org_ts_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_ORG_TS_1r BCM84868_PTP_NSE_SHDW_ORG_TS_1r
#define PTP_NSE_SHDW_ORG_TS_1r_SIZE BCM84868_PTP_NSE_SHDW_ORG_TS_1r_SIZE
typedef BCM84868_PTP_NSE_SHDW_ORG_TS_1r_t PTP_NSE_SHDW_ORG_TS_1r_t;
#define PTP_NSE_SHDW_ORG_TS_1r_CLR BCM84868_PTP_NSE_SHDW_ORG_TS_1r_CLR
#define PTP_NSE_SHDW_ORG_TS_1r_SET BCM84868_PTP_NSE_SHDW_ORG_TS_1r_SET
#define PTP_NSE_SHDW_ORG_TS_1r_GET BCM84868_PTP_NSE_SHDW_ORG_TS_1r_GET
#define PTP_NSE_SHDW_ORG_TS_1r_ORIGIN_TIMESTAMPf_GET BCM84868_PTP_NSE_SHDW_ORG_TS_1r_ORIGIN_TIMESTAMPf_GET
#define PTP_NSE_SHDW_ORG_TS_1r_ORIGIN_TIMESTAMPf_SET BCM84868_PTP_NSE_SHDW_ORG_TS_1r_ORIGIN_TIMESTAMPf_SET
#define READ_PTP_NSE_SHDW_ORG_TS_1r BCM84868_READ_PTP_NSE_SHDW_ORG_TS_1r
#define WRITE_PTP_NSE_SHDW_ORG_TS_1r BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_ORG_TS_1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_ORG_TS_2
 * BLOCKS:   PTP
 * REGADDR:  0xd892
 * DEVAD:    1
 * DESC:     NSE Origin Timestamp Bits[47:32] Register
 * SIZE:     32
 * FIELDS:
 *     ORIGIN_TIMESTAMP 
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_2r (0x0001d892 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_ORG_TS_2r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_ORG_TS_2.
 */
typedef union BCM84868_PTP_NSE_SHDW_ORG_TS_2r_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_org_ts_2[1];
	uint32_t _ptp_nse_shdw_org_ts_2;
} BCM84868_PTP_NSE_SHDW_ORG_TS_2r_t;

#define BCM84868_PTP_NSE_SHDW_ORG_TS_2r_CLR(r) (r).ptp_nse_shdw_org_ts_2[0] = 0
#define BCM84868_PTP_NSE_SHDW_ORG_TS_2r_SET(r,d) (r).ptp_nse_shdw_org_ts_2[0] = d
#define BCM84868_PTP_NSE_SHDW_ORG_TS_2r_GET(r) (r).ptp_nse_shdw_org_ts_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_2r_ORIGIN_TIMESTAMPf_GET(r) (((r).ptp_nse_shdw_org_ts_2[0]) & 0xffff)
#define BCM84868_PTP_NSE_SHDW_ORG_TS_2r_ORIGIN_TIMESTAMPf_SET(r,f) (r).ptp_nse_shdw_org_ts_2[0]=(((r).ptp_nse_shdw_org_ts_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SHDW_ORG_TS_2.
 */
#define BCM84868_READ_PTP_NSE_SHDW_ORG_TS_2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_2r,(_r._ptp_nse_shdw_org_ts_2))
#define BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_2r,(_r._ptp_nse_shdw_org_ts_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_ORG_TS_2r BCM84868_PTP_NSE_SHDW_ORG_TS_2r
#define PTP_NSE_SHDW_ORG_TS_2r_SIZE BCM84868_PTP_NSE_SHDW_ORG_TS_2r_SIZE
typedef BCM84868_PTP_NSE_SHDW_ORG_TS_2r_t PTP_NSE_SHDW_ORG_TS_2r_t;
#define PTP_NSE_SHDW_ORG_TS_2r_CLR BCM84868_PTP_NSE_SHDW_ORG_TS_2r_CLR
#define PTP_NSE_SHDW_ORG_TS_2r_SET BCM84868_PTP_NSE_SHDW_ORG_TS_2r_SET
#define PTP_NSE_SHDW_ORG_TS_2r_GET BCM84868_PTP_NSE_SHDW_ORG_TS_2r_GET
#define PTP_NSE_SHDW_ORG_TS_2r_ORIGIN_TIMESTAMPf_GET BCM84868_PTP_NSE_SHDW_ORG_TS_2r_ORIGIN_TIMESTAMPf_GET
#define PTP_NSE_SHDW_ORG_TS_2r_ORIGIN_TIMESTAMPf_SET BCM84868_PTP_NSE_SHDW_ORG_TS_2r_ORIGIN_TIMESTAMPf_SET
#define READ_PTP_NSE_SHDW_ORG_TS_2r BCM84868_READ_PTP_NSE_SHDW_ORG_TS_2r
#define WRITE_PTP_NSE_SHDW_ORG_TS_2r BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_ORG_TS_2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_ORG_TS_3
 * BLOCKS:   PTP
 * REGADDR:  0xd893
 * DEVAD:    1
 * DESC:     NSE Origin Timestamp Bits[63:48] Register
 * SIZE:     32
 * FIELDS:
 *     ORIGIN_TIMESTAMP 
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_3r (0x0001d893 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_ORG_TS_3r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_ORG_TS_3.
 */
typedef union BCM84868_PTP_NSE_SHDW_ORG_TS_3r_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_org_ts_3[1];
	uint32_t _ptp_nse_shdw_org_ts_3;
} BCM84868_PTP_NSE_SHDW_ORG_TS_3r_t;

#define BCM84868_PTP_NSE_SHDW_ORG_TS_3r_CLR(r) (r).ptp_nse_shdw_org_ts_3[0] = 0
#define BCM84868_PTP_NSE_SHDW_ORG_TS_3r_SET(r,d) (r).ptp_nse_shdw_org_ts_3[0] = d
#define BCM84868_PTP_NSE_SHDW_ORG_TS_3r_GET(r) (r).ptp_nse_shdw_org_ts_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_3r_ORIGIN_TIMESTAMPf_GET(r) (((r).ptp_nse_shdw_org_ts_3[0]) & 0xffff)
#define BCM84868_PTP_NSE_SHDW_ORG_TS_3r_ORIGIN_TIMESTAMPf_SET(r,f) (r).ptp_nse_shdw_org_ts_3[0]=(((r).ptp_nse_shdw_org_ts_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SHDW_ORG_TS_3.
 */
#define BCM84868_READ_PTP_NSE_SHDW_ORG_TS_3r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_3r,(_r._ptp_nse_shdw_org_ts_3))
#define BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_3r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_3r,(_r._ptp_nse_shdw_org_ts_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_ORG_TS_3r BCM84868_PTP_NSE_SHDW_ORG_TS_3r
#define PTP_NSE_SHDW_ORG_TS_3r_SIZE BCM84868_PTP_NSE_SHDW_ORG_TS_3r_SIZE
typedef BCM84868_PTP_NSE_SHDW_ORG_TS_3r_t PTP_NSE_SHDW_ORG_TS_3r_t;
#define PTP_NSE_SHDW_ORG_TS_3r_CLR BCM84868_PTP_NSE_SHDW_ORG_TS_3r_CLR
#define PTP_NSE_SHDW_ORG_TS_3r_SET BCM84868_PTP_NSE_SHDW_ORG_TS_3r_SET
#define PTP_NSE_SHDW_ORG_TS_3r_GET BCM84868_PTP_NSE_SHDW_ORG_TS_3r_GET
#define PTP_NSE_SHDW_ORG_TS_3r_ORIGIN_TIMESTAMPf_GET BCM84868_PTP_NSE_SHDW_ORG_TS_3r_ORIGIN_TIMESTAMPf_GET
#define PTP_NSE_SHDW_ORG_TS_3r_ORIGIN_TIMESTAMPf_SET BCM84868_PTP_NSE_SHDW_ORG_TS_3r_ORIGIN_TIMESTAMPf_SET
#define READ_PTP_NSE_SHDW_ORG_TS_3r BCM84868_READ_PTP_NSE_SHDW_ORG_TS_3r
#define WRITE_PTP_NSE_SHDW_ORG_TS_3r BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_ORG_TS_3r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_ORG_TS_4
 * BLOCKS:   PTP
 * REGADDR:  0xd894
 * DEVAD:    1
 * DESC:     NSE Origin Timestamp Bits[79:64] Register
 * SIZE:     32
 * FIELDS:
 *     ORIGIN_TIMESTAMP 
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_4r (0x0001d894 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_ORG_TS_4r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_ORG_TS_4.
 */
typedef union BCM84868_PTP_NSE_SHDW_ORG_TS_4r_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_org_ts_4[1];
	uint32_t _ptp_nse_shdw_org_ts_4;
} BCM84868_PTP_NSE_SHDW_ORG_TS_4r_t;

#define BCM84868_PTP_NSE_SHDW_ORG_TS_4r_CLR(r) (r).ptp_nse_shdw_org_ts_4[0] = 0
#define BCM84868_PTP_NSE_SHDW_ORG_TS_4r_SET(r,d) (r).ptp_nse_shdw_org_ts_4[0] = d
#define BCM84868_PTP_NSE_SHDW_ORG_TS_4r_GET(r) (r).ptp_nse_shdw_org_ts_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_ORG_TS_4r_ORIGIN_TIMESTAMPf_GET(r) (((r).ptp_nse_shdw_org_ts_4[0]) & 0xffff)
#define BCM84868_PTP_NSE_SHDW_ORG_TS_4r_ORIGIN_TIMESTAMPf_SET(r,f) (r).ptp_nse_shdw_org_ts_4[0]=(((r).ptp_nse_shdw_org_ts_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SHDW_ORG_TS_4.
 */
#define BCM84868_READ_PTP_NSE_SHDW_ORG_TS_4r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_4r,(_r._ptp_nse_shdw_org_ts_4))
#define BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_4r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_ORG_TS_4r,(_r._ptp_nse_shdw_org_ts_4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_ORG_TS_4r BCM84868_PTP_NSE_SHDW_ORG_TS_4r
#define PTP_NSE_SHDW_ORG_TS_4r_SIZE BCM84868_PTP_NSE_SHDW_ORG_TS_4r_SIZE
typedef BCM84868_PTP_NSE_SHDW_ORG_TS_4r_t PTP_NSE_SHDW_ORG_TS_4r_t;
#define PTP_NSE_SHDW_ORG_TS_4r_CLR BCM84868_PTP_NSE_SHDW_ORG_TS_4r_CLR
#define PTP_NSE_SHDW_ORG_TS_4r_SET BCM84868_PTP_NSE_SHDW_ORG_TS_4r_SET
#define PTP_NSE_SHDW_ORG_TS_4r_GET BCM84868_PTP_NSE_SHDW_ORG_TS_4r_GET
#define PTP_NSE_SHDW_ORG_TS_4r_ORIGIN_TIMESTAMPf_GET BCM84868_PTP_NSE_SHDW_ORG_TS_4r_ORIGIN_TIMESTAMPf_GET
#define PTP_NSE_SHDW_ORG_TS_4r_ORIGIN_TIMESTAMPf_SET BCM84868_PTP_NSE_SHDW_ORG_TS_4r_ORIGIN_TIMESTAMPf_SET
#define READ_PTP_NSE_SHDW_ORG_TS_4r BCM84868_READ_PTP_NSE_SHDW_ORG_TS_4r
#define WRITE_PTP_NSE_SHDW_ORG_TS_4r BCM84868_WRITE_PTP_NSE_SHDW_ORG_TS_4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_ORG_TS_4r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SC_CFG
 * BLOCKS:   PTP
 * REGADDR:  0xd8a0
 * DEVAD:    1
 * DESC:     NSE SC Configuration Register
 * SIZE:     32
 * FIELDS:
 *     GS_MODE          
 *     SI_MODE          
 *     SO_MODE          
 *     FSYNC_EN         
 *     FSYNC_TS_EN      
 */
#define BCM84868_PTP_NSE_SC_CFGr (0x0001d8a0 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SC_CFG.
 */
typedef union BCM84868_PTP_NSE_SC_CFGr_s {
	uint32_t v[1];
	uint32_t ptp_nse_sc_cfg[1];
	uint32_t _ptp_nse_sc_cfg;
} BCM84868_PTP_NSE_SC_CFGr_t;

#define BCM84868_PTP_NSE_SC_CFGr_CLR(r) (r).ptp_nse_sc_cfg[0] = 0
#define BCM84868_PTP_NSE_SC_CFGr_SET(r,d) (r).ptp_nse_sc_cfg[0] = d
#define BCM84868_PTP_NSE_SC_CFGr_GET(r) (r).ptp_nse_sc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SC_CFGr_FSYNC_TS_ENf_GET(r) ((((r).ptp_nse_sc_cfg[0]) >> 13) & 0x1)
#define BCM84868_PTP_NSE_SC_CFGr_FSYNC_TS_ENf_SET(r,f) (r).ptp_nse_sc_cfg[0]=(((r).ptp_nse_sc_cfg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PTP_NSE_SC_CFGr_FSYNC_ENf_GET(r) ((((r).ptp_nse_sc_cfg[0]) >> 12) & 0x1)
#define BCM84868_PTP_NSE_SC_CFGr_FSYNC_ENf_SET(r,f) (r).ptp_nse_sc_cfg[0]=(((r).ptp_nse_sc_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PTP_NSE_SC_CFGr_SO_MODEf_GET(r) ((((r).ptp_nse_sc_cfg[0]) >> 8) & 0x3)
#define BCM84868_PTP_NSE_SC_CFGr_SO_MODEf_SET(r,f) (r).ptp_nse_sc_cfg[0]=(((r).ptp_nse_sc_cfg[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM84868_PTP_NSE_SC_CFGr_SI_MODEf_GET(r) ((((r).ptp_nse_sc_cfg[0]) >> 4) & 0x7)
#define BCM84868_PTP_NSE_SC_CFGr_SI_MODEf_SET(r,f) (r).ptp_nse_sc_cfg[0]=(((r).ptp_nse_sc_cfg[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM84868_PTP_NSE_SC_CFGr_GS_MODEf_GET(r) (((r).ptp_nse_sc_cfg[0]) & 0x3)
#define BCM84868_PTP_NSE_SC_CFGr_GS_MODEf_SET(r,f) (r).ptp_nse_sc_cfg[0]=(((r).ptp_nse_sc_cfg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access PTP_NSE_SC_CFG.
 */
#define BCM84868_READ_PTP_NSE_SC_CFGr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SC_CFGr,(_r._ptp_nse_sc_cfg))
#define BCM84868_WRITE_PTP_NSE_SC_CFGr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SC_CFGr,(_r._ptp_nse_sc_cfg))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SC_CFGr BCM84868_PTP_NSE_SC_CFGr
#define PTP_NSE_SC_CFGr_SIZE BCM84868_PTP_NSE_SC_CFGr_SIZE
typedef BCM84868_PTP_NSE_SC_CFGr_t PTP_NSE_SC_CFGr_t;
#define PTP_NSE_SC_CFGr_CLR BCM84868_PTP_NSE_SC_CFGr_CLR
#define PTP_NSE_SC_CFGr_SET BCM84868_PTP_NSE_SC_CFGr_SET
#define PTP_NSE_SC_CFGr_GET BCM84868_PTP_NSE_SC_CFGr_GET
#define PTP_NSE_SC_CFGr_FSYNC_TS_ENf_GET BCM84868_PTP_NSE_SC_CFGr_FSYNC_TS_ENf_GET
#define PTP_NSE_SC_CFGr_FSYNC_TS_ENf_SET BCM84868_PTP_NSE_SC_CFGr_FSYNC_TS_ENf_SET
#define PTP_NSE_SC_CFGr_FSYNC_ENf_GET BCM84868_PTP_NSE_SC_CFGr_FSYNC_ENf_GET
#define PTP_NSE_SC_CFGr_FSYNC_ENf_SET BCM84868_PTP_NSE_SC_CFGr_FSYNC_ENf_SET
#define PTP_NSE_SC_CFGr_SO_MODEf_GET BCM84868_PTP_NSE_SC_CFGr_SO_MODEf_GET
#define PTP_NSE_SC_CFGr_SO_MODEf_SET BCM84868_PTP_NSE_SC_CFGr_SO_MODEf_SET
#define PTP_NSE_SC_CFGr_SI_MODEf_GET BCM84868_PTP_NSE_SC_CFGr_SI_MODEf_GET
#define PTP_NSE_SC_CFGr_SI_MODEf_SET BCM84868_PTP_NSE_SC_CFGr_SI_MODEf_SET
#define PTP_NSE_SC_CFGr_GS_MODEf_GET BCM84868_PTP_NSE_SC_CFGr_GS_MODEf_GET
#define PTP_NSE_SC_CFGr_GS_MODEf_SET BCM84868_PTP_NSE_SC_CFGr_GS_MODEf_SET
#define READ_PTP_NSE_SC_CFGr BCM84868_READ_PTP_NSE_SC_CFGr
#define WRITE_PTP_NSE_SC_CFGr BCM84868_WRITE_PTP_NSE_SC_CFGr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SYNCIN_FSYNC_LEN_0
 * BLOCKS:   PTP
 * REGADDR:  0xd8a1
 * DEVAD:    1
 * DESC:     NSE SC Syncin Frame Sync LengthBits [15:0] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCIN_FSYNC_LEN 
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r (0x0001d8a1 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SYNCIN_FSYNC_LEN_0.
 */
typedef union BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_s {
	uint32_t v[1];
	uint32_t ptp_nse_syncin_fsync_len_0[1];
	uint32_t _ptp_nse_syncin_fsync_len_0;
} BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_t;

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_CLR(r) (r).ptp_nse_syncin_fsync_len_0[0] = 0
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SET(r,d) (r).ptp_nse_syncin_fsync_len_0[0] = d
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_GET(r) (r).ptp_nse_syncin_fsync_len_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SYNCIN_FSYNC_LENf_GET(r) (((r).ptp_nse_syncin_fsync_len_0[0]) & 0xffff)
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SYNCIN_FSYNC_LENf_SET(r,f) (r).ptp_nse_syncin_fsync_len_0[0]=(((r).ptp_nse_syncin_fsync_len_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SYNCIN_FSYNC_LEN_0.
 */
#define BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_LEN_0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r,(_r._ptp_nse_syncin_fsync_len_0))
#define BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_LEN_0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r,(_r._ptp_nse_syncin_fsync_len_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SYNCIN_FSYNC_LEN_0r BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r
#define PTP_NSE_SYNCIN_FSYNC_LEN_0r_SIZE BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SIZE
typedef BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_t PTP_NSE_SYNCIN_FSYNC_LEN_0r_t;
#define PTP_NSE_SYNCIN_FSYNC_LEN_0r_CLR BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_CLR
#define PTP_NSE_SYNCIN_FSYNC_LEN_0r_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SET
#define PTP_NSE_SYNCIN_FSYNC_LEN_0r_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_GET
#define PTP_NSE_SYNCIN_FSYNC_LEN_0r_SYNCIN_FSYNC_LENf_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SYNCIN_FSYNC_LENf_GET
#define PTP_NSE_SYNCIN_FSYNC_LEN_0r_SYNCIN_FSYNC_LENf_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r_SYNCIN_FSYNC_LENf_SET
#define READ_PTP_NSE_SYNCIN_FSYNC_LEN_0r BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_LEN_0r
#define WRITE_PTP_NSE_SYNCIN_FSYNC_LEN_0r BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_LEN_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SYNCIN_FSYNC_LEN_1
 * BLOCKS:   PTP
 * REGADDR:  0xd8a2
 * DEVAD:    1
 * DESC:     NSE SC Syncin Frame Sync LengthBits [18:16] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCIN_FSYNC_LEN 
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r (0x0001d8a2 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SYNCIN_FSYNC_LEN_1.
 */
typedef union BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_s {
	uint32_t v[1];
	uint32_t ptp_nse_syncin_fsync_len_1[1];
	uint32_t _ptp_nse_syncin_fsync_len_1;
} BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_t;

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_CLR(r) (r).ptp_nse_syncin_fsync_len_1[0] = 0
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SET(r,d) (r).ptp_nse_syncin_fsync_len_1[0] = d
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_GET(r) (r).ptp_nse_syncin_fsync_len_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SYNCIN_FSYNC_LENf_GET(r) (((r).ptp_nse_syncin_fsync_len_1[0]) & 0x7)
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SYNCIN_FSYNC_LENf_SET(r,f) (r).ptp_nse_syncin_fsync_len_1[0]=(((r).ptp_nse_syncin_fsync_len_1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access PTP_NSE_SYNCIN_FSYNC_LEN_1.
 */
#define BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_LEN_1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r,(_r._ptp_nse_syncin_fsync_len_1))
#define BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_LEN_1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r,(_r._ptp_nse_syncin_fsync_len_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SYNCIN_FSYNC_LEN_1r BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r
#define PTP_NSE_SYNCIN_FSYNC_LEN_1r_SIZE BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SIZE
typedef BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_t PTP_NSE_SYNCIN_FSYNC_LEN_1r_t;
#define PTP_NSE_SYNCIN_FSYNC_LEN_1r_CLR BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_CLR
#define PTP_NSE_SYNCIN_FSYNC_LEN_1r_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SET
#define PTP_NSE_SYNCIN_FSYNC_LEN_1r_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_GET
#define PTP_NSE_SYNCIN_FSYNC_LEN_1r_SYNCIN_FSYNC_LENf_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SYNCIN_FSYNC_LENf_GET
#define PTP_NSE_SYNCIN_FSYNC_LEN_1r_SYNCIN_FSYNC_LENf_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r_SYNCIN_FSYNC_LENf_SET
#define READ_PTP_NSE_SYNCIN_FSYNC_LEN_1r BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_LEN_1r
#define WRITE_PTP_NSE_SYNCIN_FSYNC_LEN_1r BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_LEN_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SYNCIN_FSYNC_LEN_1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SYNCIN_FSYNC_DLY_0
 * BLOCKS:   PTP
 * REGADDR:  0xd8a3
 * DEVAD:    1
 * DESC:     NSE SC Syncin Frame Sync DelayBits [15:0] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCIN_FSYNC_DLY 
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r (0x0001d8a3 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SYNCIN_FSYNC_DLY_0.
 */
typedef union BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_s {
	uint32_t v[1];
	uint32_t ptp_nse_syncin_fsync_dly_0[1];
	uint32_t _ptp_nse_syncin_fsync_dly_0;
} BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_t;

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_CLR(r) (r).ptp_nse_syncin_fsync_dly_0[0] = 0
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SET(r,d) (r).ptp_nse_syncin_fsync_dly_0[0] = d
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_GET(r) (r).ptp_nse_syncin_fsync_dly_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SYNCIN_FSYNC_DLYf_GET(r) (((r).ptp_nse_syncin_fsync_dly_0[0]) & 0xffff)
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SYNCIN_FSYNC_DLYf_SET(r,f) (r).ptp_nse_syncin_fsync_dly_0[0]=(((r).ptp_nse_syncin_fsync_dly_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SYNCIN_FSYNC_DLY_0.
 */
#define BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_DLY_0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r,(_r._ptp_nse_syncin_fsync_dly_0))
#define BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_DLY_0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r,(_r._ptp_nse_syncin_fsync_dly_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SYNCIN_FSYNC_DLY_0r BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r
#define PTP_NSE_SYNCIN_FSYNC_DLY_0r_SIZE BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SIZE
typedef BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_t PTP_NSE_SYNCIN_FSYNC_DLY_0r_t;
#define PTP_NSE_SYNCIN_FSYNC_DLY_0r_CLR BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_CLR
#define PTP_NSE_SYNCIN_FSYNC_DLY_0r_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SET
#define PTP_NSE_SYNCIN_FSYNC_DLY_0r_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_GET
#define PTP_NSE_SYNCIN_FSYNC_DLY_0r_SYNCIN_FSYNC_DLYf_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SYNCIN_FSYNC_DLYf_GET
#define PTP_NSE_SYNCIN_FSYNC_DLY_0r_SYNCIN_FSYNC_DLYf_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r_SYNCIN_FSYNC_DLYf_SET
#define READ_PTP_NSE_SYNCIN_FSYNC_DLY_0r BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_DLY_0r
#define WRITE_PTP_NSE_SYNCIN_FSYNC_DLY_0r BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_DLY_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SYNCIN_FSYNC_DLY_1
 * BLOCKS:   PTP
 * REGADDR:  0xd8a4
 * DEVAD:    1
 * DESC:     NSE SC Syncin Frame Sync DelayBits [18:16] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCIN_FSYNC_DLY 
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r (0x0001d8a4 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SYNCIN_FSYNC_DLY_1.
 */
typedef union BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_s {
	uint32_t v[1];
	uint32_t ptp_nse_syncin_fsync_dly_1[1];
	uint32_t _ptp_nse_syncin_fsync_dly_1;
} BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_t;

#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_CLR(r) (r).ptp_nse_syncin_fsync_dly_1[0] = 0
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SET(r,d) (r).ptp_nse_syncin_fsync_dly_1[0] = d
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_GET(r) (r).ptp_nse_syncin_fsync_dly_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SYNCIN_FSYNC_DLYf_GET(r) (((r).ptp_nse_syncin_fsync_dly_1[0]) & 0x7)
#define BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SYNCIN_FSYNC_DLYf_SET(r,f) (r).ptp_nse_syncin_fsync_dly_1[0]=(((r).ptp_nse_syncin_fsync_dly_1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access PTP_NSE_SYNCIN_FSYNC_DLY_1.
 */
#define BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_DLY_1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r,(_r._ptp_nse_syncin_fsync_dly_1))
#define BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_DLY_1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r,(_r._ptp_nse_syncin_fsync_dly_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SYNCIN_FSYNC_DLY_1r BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r
#define PTP_NSE_SYNCIN_FSYNC_DLY_1r_SIZE BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SIZE
typedef BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_t PTP_NSE_SYNCIN_FSYNC_DLY_1r_t;
#define PTP_NSE_SYNCIN_FSYNC_DLY_1r_CLR BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_CLR
#define PTP_NSE_SYNCIN_FSYNC_DLY_1r_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SET
#define PTP_NSE_SYNCIN_FSYNC_DLY_1r_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_GET
#define PTP_NSE_SYNCIN_FSYNC_DLY_1r_SYNCIN_FSYNC_DLYf_GET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SYNCIN_FSYNC_DLYf_GET
#define PTP_NSE_SYNCIN_FSYNC_DLY_1r_SYNCIN_FSYNC_DLYf_SET BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r_SYNCIN_FSYNC_DLYf_SET
#define READ_PTP_NSE_SYNCIN_FSYNC_DLY_1r BCM84868_READ_PTP_NSE_SYNCIN_FSYNC_DLY_1r
#define WRITE_PTP_NSE_SYNCIN_FSYNC_DLY_1r BCM84868_WRITE_PTP_NSE_SYNCIN_FSYNC_DLY_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SYNCIN_FSYNC_DLY_1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SOUT_TS_CMP_0
 * BLOCKS:   PTP
 * REGADDR:  0xd8a5
 * DEVAD:    1
 * DESC:     NSE SC SyncoutTimestamp Compare Bits [15:0] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCOUT_TIMESTAMP_CMP 
 */
#define BCM84868_PTP_NSE_SOUT_TS_CMP_0r (0x0001d8a5 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SOUT_TS_CMP_0.
 */
typedef union BCM84868_PTP_NSE_SOUT_TS_CMP_0r_s {
	uint32_t v[1];
	uint32_t ptp_nse_sout_ts_cmp_0[1];
	uint32_t _ptp_nse_sout_ts_cmp_0;
} BCM84868_PTP_NSE_SOUT_TS_CMP_0r_t;

#define BCM84868_PTP_NSE_SOUT_TS_CMP_0r_CLR(r) (r).ptp_nse_sout_ts_cmp_0[0] = 0
#define BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SET(r,d) (r).ptp_nse_sout_ts_cmp_0[0] = d
#define BCM84868_PTP_NSE_SOUT_TS_CMP_0r_GET(r) (r).ptp_nse_sout_ts_cmp_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SYNCOUT_TIMESTAMP_CMPf_GET(r) (((r).ptp_nse_sout_ts_cmp_0[0]) & 0xffff)
#define BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SYNCOUT_TIMESTAMP_CMPf_SET(r,f) (r).ptp_nse_sout_ts_cmp_0[0]=(((r).ptp_nse_sout_ts_cmp_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SOUT_TS_CMP_0.
 */
#define BCM84868_READ_PTP_NSE_SOUT_TS_CMP_0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SOUT_TS_CMP_0r,(_r._ptp_nse_sout_ts_cmp_0))
#define BCM84868_WRITE_PTP_NSE_SOUT_TS_CMP_0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SOUT_TS_CMP_0r,(_r._ptp_nse_sout_ts_cmp_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SOUT_TS_CMP_0r BCM84868_PTP_NSE_SOUT_TS_CMP_0r
#define PTP_NSE_SOUT_TS_CMP_0r_SIZE BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SIZE
typedef BCM84868_PTP_NSE_SOUT_TS_CMP_0r_t PTP_NSE_SOUT_TS_CMP_0r_t;
#define PTP_NSE_SOUT_TS_CMP_0r_CLR BCM84868_PTP_NSE_SOUT_TS_CMP_0r_CLR
#define PTP_NSE_SOUT_TS_CMP_0r_SET BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SET
#define PTP_NSE_SOUT_TS_CMP_0r_GET BCM84868_PTP_NSE_SOUT_TS_CMP_0r_GET
#define PTP_NSE_SOUT_TS_CMP_0r_SYNCOUT_TIMESTAMP_CMPf_GET BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SYNCOUT_TIMESTAMP_CMPf_GET
#define PTP_NSE_SOUT_TS_CMP_0r_SYNCOUT_TIMESTAMP_CMPf_SET BCM84868_PTP_NSE_SOUT_TS_CMP_0r_SYNCOUT_TIMESTAMP_CMPf_SET
#define READ_PTP_NSE_SOUT_TS_CMP_0r BCM84868_READ_PTP_NSE_SOUT_TS_CMP_0r
#define WRITE_PTP_NSE_SOUT_TS_CMP_0r BCM84868_WRITE_PTP_NSE_SOUT_TS_CMP_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SOUT_TS_CMP_0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SOUT_TS_CMP_1
 * BLOCKS:   PTP
 * REGADDR:  0xd8a6
 * DEVAD:    1
 * DESC:     NSE SC SyncoutTimestamp Compare Bits [31:16] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCOUT_TIMESTAMP_CMP 
 */
#define BCM84868_PTP_NSE_SOUT_TS_CMP_1r (0x0001d8a6 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SOUT_TS_CMP_1.
 */
typedef union BCM84868_PTP_NSE_SOUT_TS_CMP_1r_s {
	uint32_t v[1];
	uint32_t ptp_nse_sout_ts_cmp_1[1];
	uint32_t _ptp_nse_sout_ts_cmp_1;
} BCM84868_PTP_NSE_SOUT_TS_CMP_1r_t;

#define BCM84868_PTP_NSE_SOUT_TS_CMP_1r_CLR(r) (r).ptp_nse_sout_ts_cmp_1[0] = 0
#define BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SET(r,d) (r).ptp_nse_sout_ts_cmp_1[0] = d
#define BCM84868_PTP_NSE_SOUT_TS_CMP_1r_GET(r) (r).ptp_nse_sout_ts_cmp_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SYNCOUT_TIMESTAMP_CMPf_GET(r) (((r).ptp_nse_sout_ts_cmp_1[0]) & 0xffff)
#define BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SYNCOUT_TIMESTAMP_CMPf_SET(r,f) (r).ptp_nse_sout_ts_cmp_1[0]=(((r).ptp_nse_sout_ts_cmp_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SOUT_TS_CMP_1.
 */
#define BCM84868_READ_PTP_NSE_SOUT_TS_CMP_1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SOUT_TS_CMP_1r,(_r._ptp_nse_sout_ts_cmp_1))
#define BCM84868_WRITE_PTP_NSE_SOUT_TS_CMP_1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SOUT_TS_CMP_1r,(_r._ptp_nse_sout_ts_cmp_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SOUT_TS_CMP_1r BCM84868_PTP_NSE_SOUT_TS_CMP_1r
#define PTP_NSE_SOUT_TS_CMP_1r_SIZE BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SIZE
typedef BCM84868_PTP_NSE_SOUT_TS_CMP_1r_t PTP_NSE_SOUT_TS_CMP_1r_t;
#define PTP_NSE_SOUT_TS_CMP_1r_CLR BCM84868_PTP_NSE_SOUT_TS_CMP_1r_CLR
#define PTP_NSE_SOUT_TS_CMP_1r_SET BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SET
#define PTP_NSE_SOUT_TS_CMP_1r_GET BCM84868_PTP_NSE_SOUT_TS_CMP_1r_GET
#define PTP_NSE_SOUT_TS_CMP_1r_SYNCOUT_TIMESTAMP_CMPf_GET BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SYNCOUT_TIMESTAMP_CMPf_GET
#define PTP_NSE_SOUT_TS_CMP_1r_SYNCOUT_TIMESTAMP_CMPf_SET BCM84868_PTP_NSE_SOUT_TS_CMP_1r_SYNCOUT_TIMESTAMP_CMPf_SET
#define READ_PTP_NSE_SOUT_TS_CMP_1r BCM84868_READ_PTP_NSE_SOUT_TS_CMP_1r
#define WRITE_PTP_NSE_SOUT_TS_CMP_1r BCM84868_WRITE_PTP_NSE_SOUT_TS_CMP_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SOUT_TS_CMP_1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SOUT_TS_CMP_2
 * BLOCKS:   PTP
 * REGADDR:  0xd8a7
 * DEVAD:    1
 * DESC:     NSE SC SyncoutTimestamp Compare Bits [47:32] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCOUT_TIMESTAMP_CMP 
 */
#define BCM84868_PTP_NSE_SOUT_TS_CMP_2r (0x0001d8a7 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SOUT_TS_CMP_2.
 */
typedef union BCM84868_PTP_NSE_SOUT_TS_CMP_2r_s {
	uint32_t v[1];
	uint32_t ptp_nse_sout_ts_cmp_2[1];
	uint32_t _ptp_nse_sout_ts_cmp_2;
} BCM84868_PTP_NSE_SOUT_TS_CMP_2r_t;

#define BCM84868_PTP_NSE_SOUT_TS_CMP_2r_CLR(r) (r).ptp_nse_sout_ts_cmp_2[0] = 0
#define BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SET(r,d) (r).ptp_nse_sout_ts_cmp_2[0] = d
#define BCM84868_PTP_NSE_SOUT_TS_CMP_2r_GET(r) (r).ptp_nse_sout_ts_cmp_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SYNCOUT_TIMESTAMP_CMPf_GET(r) (((r).ptp_nse_sout_ts_cmp_2[0]) & 0xffff)
#define BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SYNCOUT_TIMESTAMP_CMPf_SET(r,f) (r).ptp_nse_sout_ts_cmp_2[0]=(((r).ptp_nse_sout_ts_cmp_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SOUT_TS_CMP_2.
 */
#define BCM84868_READ_PTP_NSE_SOUT_TS_CMP_2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SOUT_TS_CMP_2r,(_r._ptp_nse_sout_ts_cmp_2))
#define BCM84868_WRITE_PTP_NSE_SOUT_TS_CMP_2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SOUT_TS_CMP_2r,(_r._ptp_nse_sout_ts_cmp_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SOUT_TS_CMP_2r BCM84868_PTP_NSE_SOUT_TS_CMP_2r
#define PTP_NSE_SOUT_TS_CMP_2r_SIZE BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SIZE
typedef BCM84868_PTP_NSE_SOUT_TS_CMP_2r_t PTP_NSE_SOUT_TS_CMP_2r_t;
#define PTP_NSE_SOUT_TS_CMP_2r_CLR BCM84868_PTP_NSE_SOUT_TS_CMP_2r_CLR
#define PTP_NSE_SOUT_TS_CMP_2r_SET BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SET
#define PTP_NSE_SOUT_TS_CMP_2r_GET BCM84868_PTP_NSE_SOUT_TS_CMP_2r_GET
#define PTP_NSE_SOUT_TS_CMP_2r_SYNCOUT_TIMESTAMP_CMPf_GET BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SYNCOUT_TIMESTAMP_CMPf_GET
#define PTP_NSE_SOUT_TS_CMP_2r_SYNCOUT_TIMESTAMP_CMPf_SET BCM84868_PTP_NSE_SOUT_TS_CMP_2r_SYNCOUT_TIMESTAMP_CMPf_SET
#define READ_PTP_NSE_SOUT_TS_CMP_2r BCM84868_READ_PTP_NSE_SOUT_TS_CMP_2r
#define WRITE_PTP_NSE_SOUT_TS_CMP_2r BCM84868_WRITE_PTP_NSE_SOUT_TS_CMP_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SOUT_TS_CMP_2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_DPLL_SYNC_DIV
 * BLOCKS:   PTP
 * REGADDR:  0xd8a8
 * DEVAD:    1
 * DESC:     NSE SC Shadow DPLL SyncDivider Register
 * SIZE:     32
 * FIELDS:
 *     DPLL_SYNC_DIV    
 */
#define BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr (0x0001d8a8 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_DPLL_SYNC_DIV.
 */
typedef union BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_dpll_sync_div[1];
	uint32_t _ptp_nse_shdw_dpll_sync_div;
} BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_t;

#define BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_CLR(r) (r).ptp_nse_shdw_dpll_sync_div[0] = 0
#define BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_SET(r,d) (r).ptp_nse_shdw_dpll_sync_div[0] = d
#define BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_GET(r) (r).ptp_nse_shdw_dpll_sync_div[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_DPLL_SYNC_DIVf_GET(r) (((r).ptp_nse_shdw_dpll_sync_div[0]) & 0xfff)
#define BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_DPLL_SYNC_DIVf_SET(r,f) (r).ptp_nse_shdw_dpll_sync_div[0]=(((r).ptp_nse_shdw_dpll_sync_div[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PTP_NSE_SHDW_DPLL_SYNC_DIV.
 */
#define BCM84868_READ_PTP_NSE_SHDW_DPLL_SYNC_DIVr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr,(_r._ptp_nse_shdw_dpll_sync_div))
#define BCM84868_WRITE_PTP_NSE_SHDW_DPLL_SYNC_DIVr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr,(_r._ptp_nse_shdw_dpll_sync_div))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_DPLL_SYNC_DIVr BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr
#define PTP_NSE_SHDW_DPLL_SYNC_DIVr_SIZE BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_SIZE
typedef BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_t PTP_NSE_SHDW_DPLL_SYNC_DIVr_t;
#define PTP_NSE_SHDW_DPLL_SYNC_DIVr_CLR BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_CLR
#define PTP_NSE_SHDW_DPLL_SYNC_DIVr_SET BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_SET
#define PTP_NSE_SHDW_DPLL_SYNC_DIVr_GET BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_GET
#define PTP_NSE_SHDW_DPLL_SYNC_DIVr_DPLL_SYNC_DIVf_GET BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_DPLL_SYNC_DIVf_GET
#define PTP_NSE_SHDW_DPLL_SYNC_DIVr_DPLL_SYNC_DIVf_SET BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr_DPLL_SYNC_DIVf_SET
#define READ_PTP_NSE_SHDW_DPLL_SYNC_DIVr BCM84868_READ_PTP_NSE_SHDW_DPLL_SYNC_DIVr
#define WRITE_PTP_NSE_SHDW_DPLL_SYNC_DIVr BCM84868_WRITE_PTP_NSE_SHDW_DPLL_SYNC_DIVr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_DPLL_SYNC_DIVr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SHDW_SOUT_INTERVAL_0
 * BLOCKS:   PTP
 * REGADDR:  0xd8a9
 * DEVAD:    1
 * DESC:     NSE SC ShadowSyncout Interval Bits [15:0] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCOUT_INTERVAL 
 */
#define BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r (0x0001d8a9 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SHDW_SOUT_INTERVAL_0.
 */
typedef union BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_s {
	uint32_t v[1];
	uint32_t ptp_nse_shdw_sout_interval_0[1];
	uint32_t _ptp_nse_shdw_sout_interval_0;
} BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_t;

#define BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_CLR(r) (r).ptp_nse_shdw_sout_interval_0[0] = 0
#define BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SET(r,d) (r).ptp_nse_shdw_sout_interval_0[0] = d
#define BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_GET(r) (r).ptp_nse_shdw_sout_interval_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SYNCOUT_INTERVALf_GET(r) (((r).ptp_nse_shdw_sout_interval_0[0]) & 0xffff)
#define BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SYNCOUT_INTERVALf_SET(r,f) (r).ptp_nse_shdw_sout_interval_0[0]=(((r).ptp_nse_shdw_sout_interval_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SHDW_SOUT_INTERVAL_0.
 */
#define BCM84868_READ_PTP_NSE_SHDW_SOUT_INTERVAL_0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r,(_r._ptp_nse_shdw_sout_interval_0))
#define BCM84868_WRITE_PTP_NSE_SHDW_SOUT_INTERVAL_0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r,(_r._ptp_nse_shdw_sout_interval_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SHDW_SOUT_INTERVAL_0r BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r
#define PTP_NSE_SHDW_SOUT_INTERVAL_0r_SIZE BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SIZE
typedef BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_t PTP_NSE_SHDW_SOUT_INTERVAL_0r_t;
#define PTP_NSE_SHDW_SOUT_INTERVAL_0r_CLR BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_CLR
#define PTP_NSE_SHDW_SOUT_INTERVAL_0r_SET BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SET
#define PTP_NSE_SHDW_SOUT_INTERVAL_0r_GET BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_GET
#define PTP_NSE_SHDW_SOUT_INTERVAL_0r_SYNCOUT_INTERVALf_GET BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SYNCOUT_INTERVALf_GET
#define PTP_NSE_SHDW_SOUT_INTERVAL_0r_SYNCOUT_INTERVALf_SET BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r_SYNCOUT_INTERVALf_SET
#define READ_PTP_NSE_SHDW_SOUT_INTERVAL_0r BCM84868_READ_PTP_NSE_SHDW_SOUT_INTERVAL_0r
#define WRITE_PTP_NSE_SHDW_SOUT_INTERVAL_0r BCM84868_WRITE_PTP_NSE_SHDW_SOUT_INTERVAL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SHDW_SOUT_INTERVAL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1
 * BLOCKS:   PTP
 * REGADDR:  0xd8aa
 * DEVAD:    1
 * DESC:     NSE SC ShadowSyncout Interval Bits [31:16] Register
 * SIZE:     32
 * FIELDS:
 *     SYNCOUT_INTERVAL 
 */
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r (0x0001d8aa | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1.
 */
typedef union BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_s {
	uint32_t v[1];
	uint32_t ptp_nse_sc_shadow_syncout_interval_1[1];
	uint32_t _ptp_nse_sc_shadow_syncout_interval_1;
} BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_t;

#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_CLR(r) (r).ptp_nse_sc_shadow_syncout_interval_1[0] = 0
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SET(r,d) (r).ptp_nse_sc_shadow_syncout_interval_1[0] = d
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_GET(r) (r).ptp_nse_sc_shadow_syncout_interval_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SYNCOUT_INTERVALf_GET(r) (((r).ptp_nse_sc_shadow_syncout_interval_1[0]) & 0xffff)
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SYNCOUT_INTERVALf_SET(r,f) (r).ptp_nse_sc_shadow_syncout_interval_1[0]=(((r).ptp_nse_sc_shadow_syncout_interval_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1.
 */
#define BCM84868_READ_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r,(_r._ptp_nse_sc_shadow_syncout_interval_1))
#define BCM84868_WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r,(_r._ptp_nse_sc_shadow_syncout_interval_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r
#define PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SIZE BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SIZE
typedef BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_t PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_t;
#define PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_CLR BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_CLR
#define PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SET
#define PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_GET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_GET
#define PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SYNCOUT_INTERVALf_GET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SYNCOUT_INTERVALf_GET
#define PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SYNCOUT_INTERVALf_SET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r_SYNCOUT_INTERVALf_SET
#define READ_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r BCM84868_READ_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r
#define WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r BCM84868_WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_INTERVAL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LEN
 * BLOCKS:   PTP
 * REGADDR:  0xd8ab
 * DEVAD:    1
 * DESC:     NSE SC ShadowSyncout Pulse1 Length Register
 * SIZE:     32
 * FIELDS:
 *     SYNCOUT_PULSE1_LEN 
 */
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr (0x0001d8ab | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LEN.
 */
typedef union BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_s {
	uint32_t v[1];
	uint32_t ptp_nse_sc_shadow_syncout_pulse1_len[1];
	uint32_t _ptp_nse_sc_shadow_syncout_pulse1_len;
} BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_t;

#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_CLR(r) (r).ptp_nse_sc_shadow_syncout_pulse1_len[0] = 0
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SET(r,d) (r).ptp_nse_sc_shadow_syncout_pulse1_len[0] = d
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_GET(r) (r).ptp_nse_sc_shadow_syncout_pulse1_len[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SYNCOUT_PULSE1_LENf_GET(r) (((r).ptp_nse_sc_shadow_syncout_pulse1_len[0]) & 0xfff)
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SYNCOUT_PULSE1_LENf_SET(r,f) (r).ptp_nse_sc_shadow_syncout_pulse1_len[0]=(((r).ptp_nse_sc_shadow_syncout_pulse1_len[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LEN.
 */
#define BCM84868_READ_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr,(_r._ptp_nse_sc_shadow_syncout_pulse1_len))
#define BCM84868_WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr,(_r._ptp_nse_sc_shadow_syncout_pulse1_len))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SIZE BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SIZE
typedef BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_t PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_t;
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_CLR BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_CLR
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SET
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_GET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_GET
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SYNCOUT_PULSE1_LENf_GET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SYNCOUT_PULSE1_LENf_GET
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SYNCOUT_PULSE1_LENf_SET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr_SYNCOUT_PULSE1_LENf_SET
#define READ_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr BCM84868_READ_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr
#define WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr BCM84868_WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE1_LENr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LEN
 * BLOCKS:   PTP
 * REGADDR:  0xd8ac
 * DEVAD:    1
 * DESC:     NSE SC ShadowSyncout Pulse2 Length Register
 * SIZE:     32
 * FIELDS:
 *     SYNCOUT_PULSE2_LEN 
 */
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr (0x0001d8ac | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SIZE 4

/*
 * This structure should be used to declare and program PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LEN.
 */
typedef union BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_s {
	uint32_t v[1];
	uint32_t ptp_nse_sc_shadow_syncout_pulse2_len[1];
	uint32_t _ptp_nse_sc_shadow_syncout_pulse2_len;
} BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_t;

#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_CLR(r) (r).ptp_nse_sc_shadow_syncout_pulse2_len[0] = 0
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SET(r,d) (r).ptp_nse_sc_shadow_syncout_pulse2_len[0] = d
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_GET(r) (r).ptp_nse_sc_shadow_syncout_pulse2_len[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SYNCOUT_PULSE2_LENf_GET(r) (((r).ptp_nse_sc_shadow_syncout_pulse2_len[0]) & 0xfff)
#define BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SYNCOUT_PULSE2_LENf_SET(r,f) (r).ptp_nse_sc_shadow_syncout_pulse2_len[0]=(((r).ptp_nse_sc_shadow_syncout_pulse2_len[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LEN.
 */
#define BCM84868_READ_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr,(_r._ptp_nse_sc_shadow_syncout_pulse2_len))
#define BCM84868_WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr,(_r._ptp_nse_sc_shadow_syncout_pulse2_len))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SIZE BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SIZE
typedef BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_t PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_t;
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_CLR BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_CLR
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SET
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_GET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_GET
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SYNCOUT_PULSE2_LENf_GET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SYNCOUT_PULSE2_LENf_GET
#define PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SYNCOUT_PULSE2_LENf_SET BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr_SYNCOUT_PULSE2_LENf_SET
#define READ_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr BCM84868_READ_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr
#define WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr BCM84868_WRITE_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PTP_NSE_SC_SHADOW_SYNCOUT_PULSE2_LENr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_CTL1
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0000
 * DEVAD:    3
 * DESC:     IEEE PCS control 1 register
 * SIZE:     32
 * FIELDS:
 *     SPEED_SEL_10G    
 *     SPEED_SEL_1      
 *     CLK_STOPPABLE    
 *     LOW_PWR          
 *     SPEED_SEL_0      
 *     LPBK             
 *     RESET            
 */
#define BCM84868_PCS_IEEE_CTL1r (0x00030000 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_CTL1.
 */
typedef union BCM84868_PCS_IEEE_CTL1r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_ctl1[1];
	uint32_t _pcs_ieee_ctl1;
} BCM84868_PCS_IEEE_CTL1r_t;

#define BCM84868_PCS_IEEE_CTL1r_CLR(r) (r).pcs_ieee_ctl1[0] = 0
#define BCM84868_PCS_IEEE_CTL1r_SET(r,d) (r).pcs_ieee_ctl1[0] = d
#define BCM84868_PCS_IEEE_CTL1r_GET(r) (r).pcs_ieee_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_CTL1r_RESETf_GET(r) ((((r).pcs_ieee_ctl1[0]) >> 15) & 0x1)
#define BCM84868_PCS_IEEE_CTL1r_RESETf_SET(r,f) (r).pcs_ieee_ctl1[0]=(((r).pcs_ieee_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PCS_IEEE_CTL1r_LPBKf_GET(r) ((((r).pcs_ieee_ctl1[0]) >> 14) & 0x1)
#define BCM84868_PCS_IEEE_CTL1r_LPBKf_SET(r,f) (r).pcs_ieee_ctl1[0]=(((r).pcs_ieee_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_0f_GET(r) ((((r).pcs_ieee_ctl1[0]) >> 13) & 0x1)
#define BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_0f_SET(r,f) (r).pcs_ieee_ctl1[0]=(((r).pcs_ieee_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PCS_IEEE_CTL1r_LOW_PWRf_GET(r) ((((r).pcs_ieee_ctl1[0]) >> 11) & 0x1)
#define BCM84868_PCS_IEEE_CTL1r_LOW_PWRf_SET(r,f) (r).pcs_ieee_ctl1[0]=(((r).pcs_ieee_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PCS_IEEE_CTL1r_CLK_STOPPABLEf_GET(r) ((((r).pcs_ieee_ctl1[0]) >> 10) & 0x1)
#define BCM84868_PCS_IEEE_CTL1r_CLK_STOPPABLEf_SET(r,f) (r).pcs_ieee_ctl1[0]=(((r).pcs_ieee_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_1f_GET(r) ((((r).pcs_ieee_ctl1[0]) >> 6) & 0x1)
#define BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_1f_SET(r,f) (r).pcs_ieee_ctl1[0]=(((r).pcs_ieee_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_10Gf_GET(r) ((((r).pcs_ieee_ctl1[0]) >> 2) & 0xf)
#define BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_10Gf_SET(r,f) (r).pcs_ieee_ctl1[0]=(((r).pcs_ieee_ctl1[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))

/*
 * These macros can be used to access PCS_IEEE_CTL1.
 */
#define BCM84868_READ_PCS_IEEE_CTL1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_CTL1r,(_r._pcs_ieee_ctl1))
#define BCM84868_WRITE_PCS_IEEE_CTL1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_CTL1r,(_r._pcs_ieee_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_CTL1r BCM84868_PCS_IEEE_CTL1r
#define PCS_IEEE_CTL1r_SIZE BCM84868_PCS_IEEE_CTL1r_SIZE
typedef BCM84868_PCS_IEEE_CTL1r_t PCS_IEEE_CTL1r_t;
#define PCS_IEEE_CTL1r_CLR BCM84868_PCS_IEEE_CTL1r_CLR
#define PCS_IEEE_CTL1r_SET BCM84868_PCS_IEEE_CTL1r_SET
#define PCS_IEEE_CTL1r_GET BCM84868_PCS_IEEE_CTL1r_GET
#define PCS_IEEE_CTL1r_RESETf_GET BCM84868_PCS_IEEE_CTL1r_RESETf_GET
#define PCS_IEEE_CTL1r_RESETf_SET BCM84868_PCS_IEEE_CTL1r_RESETf_SET
#define PCS_IEEE_CTL1r_LPBKf_GET BCM84868_PCS_IEEE_CTL1r_LPBKf_GET
#define PCS_IEEE_CTL1r_LPBKf_SET BCM84868_PCS_IEEE_CTL1r_LPBKf_SET
#define PCS_IEEE_CTL1r_SPEED_SEL_0f_GET BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_0f_GET
#define PCS_IEEE_CTL1r_SPEED_SEL_0f_SET BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_0f_SET
#define PCS_IEEE_CTL1r_LOW_PWRf_GET BCM84868_PCS_IEEE_CTL1r_LOW_PWRf_GET
#define PCS_IEEE_CTL1r_LOW_PWRf_SET BCM84868_PCS_IEEE_CTL1r_LOW_PWRf_SET
#define PCS_IEEE_CTL1r_CLK_STOPPABLEf_GET BCM84868_PCS_IEEE_CTL1r_CLK_STOPPABLEf_GET
#define PCS_IEEE_CTL1r_CLK_STOPPABLEf_SET BCM84868_PCS_IEEE_CTL1r_CLK_STOPPABLEf_SET
#define PCS_IEEE_CTL1r_SPEED_SEL_1f_GET BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_1f_GET
#define PCS_IEEE_CTL1r_SPEED_SEL_1f_SET BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_1f_SET
#define PCS_IEEE_CTL1r_SPEED_SEL_10Gf_GET BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_10Gf_GET
#define PCS_IEEE_CTL1r_SPEED_SEL_10Gf_SET BCM84868_PCS_IEEE_CTL1r_SPEED_SEL_10Gf_SET
#define READ_PCS_IEEE_CTL1r BCM84868_READ_PCS_IEEE_CTL1r
#define WRITE_PCS_IEEE_CTL1r BCM84868_WRITE_PCS_IEEE_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_ST1
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0001
 * DEVAD:    3
 * DESC:     IEEE PCS status 1 register
 * SIZE:     32
 * FIELDS:
 *     LOW_PWR_AB       
 *     PCS_RCV_LINK_ST  
 *     FAULT            
 *     RX_LPI_INDCT     
 *     TX_LPI_INDCT     
 *     RX_LPI_RCVD      
 *     TX_LPI_RCVD      
 */
#define BCM84868_PCS_IEEE_ST1r (0x00030001 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_ST1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_ST1.
 */
typedef union BCM84868_PCS_IEEE_ST1r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_st1[1];
	uint32_t _pcs_ieee_st1;
} BCM84868_PCS_IEEE_ST1r_t;

#define BCM84868_PCS_IEEE_ST1r_CLR(r) (r).pcs_ieee_st1[0] = 0
#define BCM84868_PCS_IEEE_ST1r_SET(r,d) (r).pcs_ieee_st1[0] = d
#define BCM84868_PCS_IEEE_ST1r_GET(r) (r).pcs_ieee_st1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_ST1r_TX_LPI_RCVDf_GET(r) ((((r).pcs_ieee_st1[0]) >> 11) & 0x1)
#define BCM84868_PCS_IEEE_ST1r_TX_LPI_RCVDf_SET(r,f) (r).pcs_ieee_st1[0]=(((r).pcs_ieee_st1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PCS_IEEE_ST1r_RX_LPI_RCVDf_GET(r) ((((r).pcs_ieee_st1[0]) >> 10) & 0x1)
#define BCM84868_PCS_IEEE_ST1r_RX_LPI_RCVDf_SET(r,f) (r).pcs_ieee_st1[0]=(((r).pcs_ieee_st1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PCS_IEEE_ST1r_TX_LPI_INDCTf_GET(r) ((((r).pcs_ieee_st1[0]) >> 9) & 0x1)
#define BCM84868_PCS_IEEE_ST1r_TX_LPI_INDCTf_SET(r,f) (r).pcs_ieee_st1[0]=(((r).pcs_ieee_st1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_PCS_IEEE_ST1r_RX_LPI_INDCTf_GET(r) ((((r).pcs_ieee_st1[0]) >> 8) & 0x1)
#define BCM84868_PCS_IEEE_ST1r_RX_LPI_INDCTf_SET(r,f) (r).pcs_ieee_st1[0]=(((r).pcs_ieee_st1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_PCS_IEEE_ST1r_FAULTf_GET(r) ((((r).pcs_ieee_st1[0]) >> 7) & 0x1)
#define BCM84868_PCS_IEEE_ST1r_FAULTf_SET(r,f) (r).pcs_ieee_st1[0]=(((r).pcs_ieee_st1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PCS_IEEE_ST1r_PCS_RCV_LINK_STf_GET(r) ((((r).pcs_ieee_st1[0]) >> 2) & 0x1)
#define BCM84868_PCS_IEEE_ST1r_PCS_RCV_LINK_STf_SET(r,f) (r).pcs_ieee_st1[0]=(((r).pcs_ieee_st1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PCS_IEEE_ST1r_LOW_PWR_ABf_GET(r) ((((r).pcs_ieee_st1[0]) >> 1) & 0x1)
#define BCM84868_PCS_IEEE_ST1r_LOW_PWR_ABf_SET(r,f) (r).pcs_ieee_st1[0]=(((r).pcs_ieee_st1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PCS_IEEE_ST1.
 */
#define BCM84868_READ_PCS_IEEE_ST1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_ST1r,(_r._pcs_ieee_st1))
#define BCM84868_WRITE_PCS_IEEE_ST1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_ST1r,(_r._pcs_ieee_st1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_ST1r BCM84868_PCS_IEEE_ST1r
#define PCS_IEEE_ST1r_SIZE BCM84868_PCS_IEEE_ST1r_SIZE
typedef BCM84868_PCS_IEEE_ST1r_t PCS_IEEE_ST1r_t;
#define PCS_IEEE_ST1r_CLR BCM84868_PCS_IEEE_ST1r_CLR
#define PCS_IEEE_ST1r_SET BCM84868_PCS_IEEE_ST1r_SET
#define PCS_IEEE_ST1r_GET BCM84868_PCS_IEEE_ST1r_GET
#define PCS_IEEE_ST1r_TX_LPI_RCVDf_GET BCM84868_PCS_IEEE_ST1r_TX_LPI_RCVDf_GET
#define PCS_IEEE_ST1r_TX_LPI_RCVDf_SET BCM84868_PCS_IEEE_ST1r_TX_LPI_RCVDf_SET
#define PCS_IEEE_ST1r_RX_LPI_RCVDf_GET BCM84868_PCS_IEEE_ST1r_RX_LPI_RCVDf_GET
#define PCS_IEEE_ST1r_RX_LPI_RCVDf_SET BCM84868_PCS_IEEE_ST1r_RX_LPI_RCVDf_SET
#define PCS_IEEE_ST1r_TX_LPI_INDCTf_GET BCM84868_PCS_IEEE_ST1r_TX_LPI_INDCTf_GET
#define PCS_IEEE_ST1r_TX_LPI_INDCTf_SET BCM84868_PCS_IEEE_ST1r_TX_LPI_INDCTf_SET
#define PCS_IEEE_ST1r_RX_LPI_INDCTf_GET BCM84868_PCS_IEEE_ST1r_RX_LPI_INDCTf_GET
#define PCS_IEEE_ST1r_RX_LPI_INDCTf_SET BCM84868_PCS_IEEE_ST1r_RX_LPI_INDCTf_SET
#define PCS_IEEE_ST1r_FAULTf_GET BCM84868_PCS_IEEE_ST1r_FAULTf_GET
#define PCS_IEEE_ST1r_FAULTf_SET BCM84868_PCS_IEEE_ST1r_FAULTf_SET
#define PCS_IEEE_ST1r_PCS_RCV_LINK_STf_GET BCM84868_PCS_IEEE_ST1r_PCS_RCV_LINK_STf_GET
#define PCS_IEEE_ST1r_PCS_RCV_LINK_STf_SET BCM84868_PCS_IEEE_ST1r_PCS_RCV_LINK_STf_SET
#define PCS_IEEE_ST1r_LOW_PWR_ABf_GET BCM84868_PCS_IEEE_ST1r_LOW_PWR_ABf_GET
#define PCS_IEEE_ST1r_LOW_PWR_ABf_SET BCM84868_PCS_IEEE_ST1r_LOW_PWR_ABf_SET
#define READ_PCS_IEEE_ST1r BCM84868_READ_PCS_IEEE_ST1r
#define WRITE_PCS_IEEE_ST1r BCM84868_WRITE_PCS_IEEE_ST1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_ST1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_DEV_ID0
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0002
 * DEVAD:    3
 * DESC:     IEEE PCS device identifier part 0
 * SIZE:     32
 * FIELDS:
 *     DEV_ID0          
 */
#define BCM84868_PCS_IEEE_DEV_ID0r (0x00030002 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_DEV_ID0r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_DEV_ID0.
 */
typedef union BCM84868_PCS_IEEE_DEV_ID0r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_dev_id0[1];
	uint32_t _pcs_ieee_dev_id0;
} BCM84868_PCS_IEEE_DEV_ID0r_t;

#define BCM84868_PCS_IEEE_DEV_ID0r_CLR(r) (r).pcs_ieee_dev_id0[0] = 0
#define BCM84868_PCS_IEEE_DEV_ID0r_SET(r,d) (r).pcs_ieee_dev_id0[0] = d
#define BCM84868_PCS_IEEE_DEV_ID0r_GET(r) (r).pcs_ieee_dev_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_DEV_ID0r_DEV_ID0f_GET(r) (((r).pcs_ieee_dev_id0[0]) & 0xffff)
#define BCM84868_PCS_IEEE_DEV_ID0r_DEV_ID0f_SET(r,f) (r).pcs_ieee_dev_id0[0]=(((r).pcs_ieee_dev_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_IEEE_DEV_ID0.
 */
#define BCM84868_READ_PCS_IEEE_DEV_ID0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_DEV_ID0r,(_r._pcs_ieee_dev_id0))
#define BCM84868_WRITE_PCS_IEEE_DEV_ID0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_DEV_ID0r,(_r._pcs_ieee_dev_id0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_DEV_ID0r BCM84868_PCS_IEEE_DEV_ID0r
#define PCS_IEEE_DEV_ID0r_SIZE BCM84868_PCS_IEEE_DEV_ID0r_SIZE
typedef BCM84868_PCS_IEEE_DEV_ID0r_t PCS_IEEE_DEV_ID0r_t;
#define PCS_IEEE_DEV_ID0r_CLR BCM84868_PCS_IEEE_DEV_ID0r_CLR
#define PCS_IEEE_DEV_ID0r_SET BCM84868_PCS_IEEE_DEV_ID0r_SET
#define PCS_IEEE_DEV_ID0r_GET BCM84868_PCS_IEEE_DEV_ID0r_GET
#define PCS_IEEE_DEV_ID0r_DEV_ID0f_GET BCM84868_PCS_IEEE_DEV_ID0r_DEV_ID0f_GET
#define PCS_IEEE_DEV_ID0r_DEV_ID0f_SET BCM84868_PCS_IEEE_DEV_ID0r_DEV_ID0f_SET
#define READ_PCS_IEEE_DEV_ID0r BCM84868_READ_PCS_IEEE_DEV_ID0r
#define WRITE_PCS_IEEE_DEV_ID0r BCM84868_WRITE_PCS_IEEE_DEV_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_DEV_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_DEV_ID1
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0003
 * DEVAD:    3
 * DESC:     IEEE PCS device identifier part 1
 * SIZE:     32
 * FIELDS:
 *     DEV_ID1          
 */
#define BCM84868_PCS_IEEE_DEV_ID1r (0x00030003 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_DEV_ID1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_DEV_ID1.
 */
typedef union BCM84868_PCS_IEEE_DEV_ID1r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_dev_id1[1];
	uint32_t _pcs_ieee_dev_id1;
} BCM84868_PCS_IEEE_DEV_ID1r_t;

#define BCM84868_PCS_IEEE_DEV_ID1r_CLR(r) (r).pcs_ieee_dev_id1[0] = 0
#define BCM84868_PCS_IEEE_DEV_ID1r_SET(r,d) (r).pcs_ieee_dev_id1[0] = d
#define BCM84868_PCS_IEEE_DEV_ID1r_GET(r) (r).pcs_ieee_dev_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_DEV_ID1r_DEV_ID1f_GET(r) (((r).pcs_ieee_dev_id1[0]) & 0xffff)
#define BCM84868_PCS_IEEE_DEV_ID1r_DEV_ID1f_SET(r,f) (r).pcs_ieee_dev_id1[0]=(((r).pcs_ieee_dev_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_IEEE_DEV_ID1.
 */
#define BCM84868_READ_PCS_IEEE_DEV_ID1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_DEV_ID1r,(_r._pcs_ieee_dev_id1))
#define BCM84868_WRITE_PCS_IEEE_DEV_ID1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_DEV_ID1r,(_r._pcs_ieee_dev_id1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_DEV_ID1r BCM84868_PCS_IEEE_DEV_ID1r
#define PCS_IEEE_DEV_ID1r_SIZE BCM84868_PCS_IEEE_DEV_ID1r_SIZE
typedef BCM84868_PCS_IEEE_DEV_ID1r_t PCS_IEEE_DEV_ID1r_t;
#define PCS_IEEE_DEV_ID1r_CLR BCM84868_PCS_IEEE_DEV_ID1r_CLR
#define PCS_IEEE_DEV_ID1r_SET BCM84868_PCS_IEEE_DEV_ID1r_SET
#define PCS_IEEE_DEV_ID1r_GET BCM84868_PCS_IEEE_DEV_ID1r_GET
#define PCS_IEEE_DEV_ID1r_DEV_ID1f_GET BCM84868_PCS_IEEE_DEV_ID1r_DEV_ID1f_GET
#define PCS_IEEE_DEV_ID1r_DEV_ID1f_SET BCM84868_PCS_IEEE_DEV_ID1r_DEV_ID1f_SET
#define READ_PCS_IEEE_DEV_ID1r BCM84868_READ_PCS_IEEE_DEV_ID1r
#define WRITE_PCS_IEEE_DEV_ID1r BCM84868_WRITE_PCS_IEEE_DEV_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_DEV_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_SP_CAP
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0004
 * DEVAD:    3
 * DESC:     IEEE PCS speed ability
 * SIZE:     32
 * FIELDS:
 *     CAP_10G          
 *     CAP_10P2B        
 */
#define BCM84868_PCS_IEEE_SP_CAPr (0x00030004 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_SP_CAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_SP_CAP.
 */
typedef union BCM84868_PCS_IEEE_SP_CAPr_s {
	uint32_t v[1];
	uint32_t pcs_ieee_sp_cap[1];
	uint32_t _pcs_ieee_sp_cap;
} BCM84868_PCS_IEEE_SP_CAPr_t;

#define BCM84868_PCS_IEEE_SP_CAPr_CLR(r) (r).pcs_ieee_sp_cap[0] = 0
#define BCM84868_PCS_IEEE_SP_CAPr_SET(r,d) (r).pcs_ieee_sp_cap[0] = d
#define BCM84868_PCS_IEEE_SP_CAPr_GET(r) (r).pcs_ieee_sp_cap[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_SP_CAPr_CAP_10P2Bf_GET(r) ((((r).pcs_ieee_sp_cap[0]) >> 1) & 0x1)
#define BCM84868_PCS_IEEE_SP_CAPr_CAP_10P2Bf_SET(r,f) (r).pcs_ieee_sp_cap[0]=(((r).pcs_ieee_sp_cap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PCS_IEEE_SP_CAPr_CAP_10Gf_GET(r) (((r).pcs_ieee_sp_cap[0]) & 0x1)
#define BCM84868_PCS_IEEE_SP_CAPr_CAP_10Gf_SET(r,f) (r).pcs_ieee_sp_cap[0]=(((r).pcs_ieee_sp_cap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PCS_IEEE_SP_CAP.
 */
#define BCM84868_READ_PCS_IEEE_SP_CAPr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_SP_CAPr,(_r._pcs_ieee_sp_cap))
#define BCM84868_WRITE_PCS_IEEE_SP_CAPr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_SP_CAPr,(_r._pcs_ieee_sp_cap))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_SP_CAPr BCM84868_PCS_IEEE_SP_CAPr
#define PCS_IEEE_SP_CAPr_SIZE BCM84868_PCS_IEEE_SP_CAPr_SIZE
typedef BCM84868_PCS_IEEE_SP_CAPr_t PCS_IEEE_SP_CAPr_t;
#define PCS_IEEE_SP_CAPr_CLR BCM84868_PCS_IEEE_SP_CAPr_CLR
#define PCS_IEEE_SP_CAPr_SET BCM84868_PCS_IEEE_SP_CAPr_SET
#define PCS_IEEE_SP_CAPr_GET BCM84868_PCS_IEEE_SP_CAPr_GET
#define PCS_IEEE_SP_CAPr_CAP_10P2Bf_GET BCM84868_PCS_IEEE_SP_CAPr_CAP_10P2Bf_GET
#define PCS_IEEE_SP_CAPr_CAP_10P2Bf_SET BCM84868_PCS_IEEE_SP_CAPr_CAP_10P2Bf_SET
#define PCS_IEEE_SP_CAPr_CAP_10Gf_GET BCM84868_PCS_IEEE_SP_CAPr_CAP_10Gf_GET
#define PCS_IEEE_SP_CAPr_CAP_10Gf_SET BCM84868_PCS_IEEE_SP_CAPr_CAP_10Gf_SET
#define READ_PCS_IEEE_SP_CAPr BCM84868_READ_PCS_IEEE_SP_CAPr
#define WRITE_PCS_IEEE_SP_CAPr BCM84868_WRITE_PCS_IEEE_SP_CAPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_SP_CAPr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_DEV0
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0005
 * DEVAD:    3
 * DESC:     Devices in package register part 0
 * SIZE:     32
 * FIELDS:
 *     CLA22_PRE        
 *     PMD_PRE          
 *     WIS_PRE          
 *     PCS_PRE          
 *     PHYXS_PRE        
 *     DTEXS_PRE        
 *     TC_PRE           
 *     AUTONEG_PRE      
 */
#define BCM84868_PCS_IEEE_DEV0r (0x00030005 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_DEV0r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_DEV0.
 */
typedef union BCM84868_PCS_IEEE_DEV0r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_dev0[1];
	uint32_t _pcs_ieee_dev0;
} BCM84868_PCS_IEEE_DEV0r_t;

#define BCM84868_PCS_IEEE_DEV0r_CLR(r) (r).pcs_ieee_dev0[0] = 0
#define BCM84868_PCS_IEEE_DEV0r_SET(r,d) (r).pcs_ieee_dev0[0] = d
#define BCM84868_PCS_IEEE_DEV0r_GET(r) (r).pcs_ieee_dev0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_DEV0r_AUTONEG_PREf_GET(r) ((((r).pcs_ieee_dev0[0]) >> 7) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_AUTONEG_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PCS_IEEE_DEV0r_TC_PREf_GET(r) ((((r).pcs_ieee_dev0[0]) >> 6) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_TC_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PCS_IEEE_DEV0r_DTEXS_PREf_GET(r) ((((r).pcs_ieee_dev0[0]) >> 5) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_DTEXS_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PCS_IEEE_DEV0r_PHYXS_PREf_GET(r) ((((r).pcs_ieee_dev0[0]) >> 4) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_PHYXS_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PCS_IEEE_DEV0r_PCS_PREf_GET(r) ((((r).pcs_ieee_dev0[0]) >> 3) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_PCS_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PCS_IEEE_DEV0r_WIS_PREf_GET(r) ((((r).pcs_ieee_dev0[0]) >> 2) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_WIS_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PCS_IEEE_DEV0r_PMD_PREf_GET(r) ((((r).pcs_ieee_dev0[0]) >> 1) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_PMD_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PCS_IEEE_DEV0r_CLA22_PREf_GET(r) (((r).pcs_ieee_dev0[0]) & 0x1)
#define BCM84868_PCS_IEEE_DEV0r_CLA22_PREf_SET(r,f) (r).pcs_ieee_dev0[0]=(((r).pcs_ieee_dev0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PCS_IEEE_DEV0.
 */
#define BCM84868_READ_PCS_IEEE_DEV0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_DEV0r,(_r._pcs_ieee_dev0))
#define BCM84868_WRITE_PCS_IEEE_DEV0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_DEV0r,(_r._pcs_ieee_dev0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_DEV0r BCM84868_PCS_IEEE_DEV0r
#define PCS_IEEE_DEV0r_SIZE BCM84868_PCS_IEEE_DEV0r_SIZE
typedef BCM84868_PCS_IEEE_DEV0r_t PCS_IEEE_DEV0r_t;
#define PCS_IEEE_DEV0r_CLR BCM84868_PCS_IEEE_DEV0r_CLR
#define PCS_IEEE_DEV0r_SET BCM84868_PCS_IEEE_DEV0r_SET
#define PCS_IEEE_DEV0r_GET BCM84868_PCS_IEEE_DEV0r_GET
#define PCS_IEEE_DEV0r_AUTONEG_PREf_GET BCM84868_PCS_IEEE_DEV0r_AUTONEG_PREf_GET
#define PCS_IEEE_DEV0r_AUTONEG_PREf_SET BCM84868_PCS_IEEE_DEV0r_AUTONEG_PREf_SET
#define PCS_IEEE_DEV0r_TC_PREf_GET BCM84868_PCS_IEEE_DEV0r_TC_PREf_GET
#define PCS_IEEE_DEV0r_TC_PREf_SET BCM84868_PCS_IEEE_DEV0r_TC_PREf_SET
#define PCS_IEEE_DEV0r_DTEXS_PREf_GET BCM84868_PCS_IEEE_DEV0r_DTEXS_PREf_GET
#define PCS_IEEE_DEV0r_DTEXS_PREf_SET BCM84868_PCS_IEEE_DEV0r_DTEXS_PREf_SET
#define PCS_IEEE_DEV0r_PHYXS_PREf_GET BCM84868_PCS_IEEE_DEV0r_PHYXS_PREf_GET
#define PCS_IEEE_DEV0r_PHYXS_PREf_SET BCM84868_PCS_IEEE_DEV0r_PHYXS_PREf_SET
#define PCS_IEEE_DEV0r_PCS_PREf_GET BCM84868_PCS_IEEE_DEV0r_PCS_PREf_GET
#define PCS_IEEE_DEV0r_PCS_PREf_SET BCM84868_PCS_IEEE_DEV0r_PCS_PREf_SET
#define PCS_IEEE_DEV0r_WIS_PREf_GET BCM84868_PCS_IEEE_DEV0r_WIS_PREf_GET
#define PCS_IEEE_DEV0r_WIS_PREf_SET BCM84868_PCS_IEEE_DEV0r_WIS_PREf_SET
#define PCS_IEEE_DEV0r_PMD_PREf_GET BCM84868_PCS_IEEE_DEV0r_PMD_PREf_GET
#define PCS_IEEE_DEV0r_PMD_PREf_SET BCM84868_PCS_IEEE_DEV0r_PMD_PREf_SET
#define PCS_IEEE_DEV0r_CLA22_PREf_GET BCM84868_PCS_IEEE_DEV0r_CLA22_PREf_GET
#define PCS_IEEE_DEV0r_CLA22_PREf_SET BCM84868_PCS_IEEE_DEV0r_CLA22_PREf_SET
#define READ_PCS_IEEE_DEV0r BCM84868_READ_PCS_IEEE_DEV0r
#define WRITE_PCS_IEEE_DEV0r BCM84868_WRITE_PCS_IEEE_DEV0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_DEV0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_DEV1
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0006
 * DEVAD:    3
 * DESC:     Devices in package register part 1
 * SIZE:     32
 * FIELDS:
 *     CLA22_EXT_PRE    
 *     VENSP_DEV1_PRE   
 *     VENSP_DEV2_PRE   
 */
#define BCM84868_PCS_IEEE_DEV1r (0x00030006 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_DEV1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_DEV1.
 */
typedef union BCM84868_PCS_IEEE_DEV1r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_dev1[1];
	uint32_t _pcs_ieee_dev1;
} BCM84868_PCS_IEEE_DEV1r_t;

#define BCM84868_PCS_IEEE_DEV1r_CLR(r) (r).pcs_ieee_dev1[0] = 0
#define BCM84868_PCS_IEEE_DEV1r_SET(r,d) (r).pcs_ieee_dev1[0] = d
#define BCM84868_PCS_IEEE_DEV1r_GET(r) (r).pcs_ieee_dev1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_DEV1r_VENSP_DEV2_PREf_GET(r) ((((r).pcs_ieee_dev1[0]) >> 15) & 0x1)
#define BCM84868_PCS_IEEE_DEV1r_VENSP_DEV2_PREf_SET(r,f) (r).pcs_ieee_dev1[0]=(((r).pcs_ieee_dev1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PCS_IEEE_DEV1r_VENSP_DEV1_PREf_GET(r) ((((r).pcs_ieee_dev1[0]) >> 14) & 0x1)
#define BCM84868_PCS_IEEE_DEV1r_VENSP_DEV1_PREf_SET(r,f) (r).pcs_ieee_dev1[0]=(((r).pcs_ieee_dev1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PCS_IEEE_DEV1r_CLA22_EXT_PREf_GET(r) ((((r).pcs_ieee_dev1[0]) >> 13) & 0x1)
#define BCM84868_PCS_IEEE_DEV1r_CLA22_EXT_PREf_SET(r,f) (r).pcs_ieee_dev1[0]=(((r).pcs_ieee_dev1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access PCS_IEEE_DEV1.
 */
#define BCM84868_READ_PCS_IEEE_DEV1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_DEV1r,(_r._pcs_ieee_dev1))
#define BCM84868_WRITE_PCS_IEEE_DEV1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_DEV1r,(_r._pcs_ieee_dev1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_DEV1r BCM84868_PCS_IEEE_DEV1r
#define PCS_IEEE_DEV1r_SIZE BCM84868_PCS_IEEE_DEV1r_SIZE
typedef BCM84868_PCS_IEEE_DEV1r_t PCS_IEEE_DEV1r_t;
#define PCS_IEEE_DEV1r_CLR BCM84868_PCS_IEEE_DEV1r_CLR
#define PCS_IEEE_DEV1r_SET BCM84868_PCS_IEEE_DEV1r_SET
#define PCS_IEEE_DEV1r_GET BCM84868_PCS_IEEE_DEV1r_GET
#define PCS_IEEE_DEV1r_VENSP_DEV2_PREf_GET BCM84868_PCS_IEEE_DEV1r_VENSP_DEV2_PREf_GET
#define PCS_IEEE_DEV1r_VENSP_DEV2_PREf_SET BCM84868_PCS_IEEE_DEV1r_VENSP_DEV2_PREf_SET
#define PCS_IEEE_DEV1r_VENSP_DEV1_PREf_GET BCM84868_PCS_IEEE_DEV1r_VENSP_DEV1_PREf_GET
#define PCS_IEEE_DEV1r_VENSP_DEV1_PREf_SET BCM84868_PCS_IEEE_DEV1r_VENSP_DEV1_PREf_SET
#define PCS_IEEE_DEV1r_CLA22_EXT_PREf_GET BCM84868_PCS_IEEE_DEV1r_CLA22_EXT_PREf_GET
#define PCS_IEEE_DEV1r_CLA22_EXT_PREf_SET BCM84868_PCS_IEEE_DEV1r_CLA22_EXT_PREf_SET
#define READ_PCS_IEEE_DEV1r BCM84868_READ_PCS_IEEE_DEV1r
#define WRITE_PCS_IEEE_DEV1r BCM84868_WRITE_PCS_IEEE_DEV1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_DEV1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_CTL2
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0007
 * DEVAD:    3
 * DESC:     PCS control 2 register
 * SIZE:     32
 * FIELDS:
 *     TYPE_SEL         
 */
#define BCM84868_PCS_IEEE_CTL2r (0x00030007 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_CTL2.
 */
typedef union BCM84868_PCS_IEEE_CTL2r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_ctl2[1];
	uint32_t _pcs_ieee_ctl2;
} BCM84868_PCS_IEEE_CTL2r_t;

#define BCM84868_PCS_IEEE_CTL2r_CLR(r) (r).pcs_ieee_ctl2[0] = 0
#define BCM84868_PCS_IEEE_CTL2r_SET(r,d) (r).pcs_ieee_ctl2[0] = d
#define BCM84868_PCS_IEEE_CTL2r_GET(r) (r).pcs_ieee_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_CTL2r_TYPE_SELf_GET(r) (((r).pcs_ieee_ctl2[0]) & 0x3)
#define BCM84868_PCS_IEEE_CTL2r_TYPE_SELf_SET(r,f) (r).pcs_ieee_ctl2[0]=(((r).pcs_ieee_ctl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access PCS_IEEE_CTL2.
 */
#define BCM84868_READ_PCS_IEEE_CTL2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_CTL2r,(_r._pcs_ieee_ctl2))
#define BCM84868_WRITE_PCS_IEEE_CTL2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_CTL2r,(_r._pcs_ieee_ctl2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_CTL2r BCM84868_PCS_IEEE_CTL2r
#define PCS_IEEE_CTL2r_SIZE BCM84868_PCS_IEEE_CTL2r_SIZE
typedef BCM84868_PCS_IEEE_CTL2r_t PCS_IEEE_CTL2r_t;
#define PCS_IEEE_CTL2r_CLR BCM84868_PCS_IEEE_CTL2r_CLR
#define PCS_IEEE_CTL2r_SET BCM84868_PCS_IEEE_CTL2r_SET
#define PCS_IEEE_CTL2r_GET BCM84868_PCS_IEEE_CTL2r_GET
#define PCS_IEEE_CTL2r_TYPE_SELf_GET BCM84868_PCS_IEEE_CTL2r_TYPE_SELf_GET
#define PCS_IEEE_CTL2r_TYPE_SELf_SET BCM84868_PCS_IEEE_CTL2r_TYPE_SELf_SET
#define READ_PCS_IEEE_CTL2r BCM84868_READ_PCS_IEEE_CTL2r
#define WRITE_PCS_IEEE_CTL2r BCM84868_WRITE_PCS_IEEE_CTL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_ST2
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0008
 * DEVAD:    3
 * DESC:     10G PCS status 2 register
 * SIZE:     32
 * FIELDS:
 *     CAP_10G_R        
 *     CAP_10G_X        
 *     CAP_10G_W        
 *     CAP_10G_T        
 *     RCV_FALT         
 *     TRAN_FALT        
 *     DEV_PRE          
 */
#define BCM84868_PCS_IEEE_ST2r (0x00030008 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_ST2r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_ST2.
 */
typedef union BCM84868_PCS_IEEE_ST2r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_st2[1];
	uint32_t _pcs_ieee_st2;
} BCM84868_PCS_IEEE_ST2r_t;

#define BCM84868_PCS_IEEE_ST2r_CLR(r) (r).pcs_ieee_st2[0] = 0
#define BCM84868_PCS_IEEE_ST2r_SET(r,d) (r).pcs_ieee_st2[0] = d
#define BCM84868_PCS_IEEE_ST2r_GET(r) (r).pcs_ieee_st2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_ST2r_DEV_PREf_GET(r) ((((r).pcs_ieee_st2[0]) >> 14) & 0x3)
#define BCM84868_PCS_IEEE_ST2r_DEV_PREf_SET(r,f) (r).pcs_ieee_st2[0]=(((r).pcs_ieee_st2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM84868_PCS_IEEE_ST2r_TRAN_FALTf_GET(r) ((((r).pcs_ieee_st2[0]) >> 11) & 0x1)
#define BCM84868_PCS_IEEE_ST2r_TRAN_FALTf_SET(r,f) (r).pcs_ieee_st2[0]=(((r).pcs_ieee_st2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PCS_IEEE_ST2r_RCV_FALTf_GET(r) ((((r).pcs_ieee_st2[0]) >> 10) & 0x1)
#define BCM84868_PCS_IEEE_ST2r_RCV_FALTf_SET(r,f) (r).pcs_ieee_st2[0]=(((r).pcs_ieee_st2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Tf_GET(r) ((((r).pcs_ieee_st2[0]) >> 3) & 0x1)
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Tf_SET(r,f) (r).pcs_ieee_st2[0]=(((r).pcs_ieee_st2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Wf_GET(r) ((((r).pcs_ieee_st2[0]) >> 2) & 0x1)
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Wf_SET(r,f) (r).pcs_ieee_st2[0]=(((r).pcs_ieee_st2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Xf_GET(r) ((((r).pcs_ieee_st2[0]) >> 1) & 0x1)
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Xf_SET(r,f) (r).pcs_ieee_st2[0]=(((r).pcs_ieee_st2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Rf_GET(r) (((r).pcs_ieee_st2[0]) & 0x1)
#define BCM84868_PCS_IEEE_ST2r_CAP_10G_Rf_SET(r,f) (r).pcs_ieee_st2[0]=(((r).pcs_ieee_st2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PCS_IEEE_ST2.
 */
#define BCM84868_READ_PCS_IEEE_ST2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_ST2r,(_r._pcs_ieee_st2))
#define BCM84868_WRITE_PCS_IEEE_ST2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_ST2r,(_r._pcs_ieee_st2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_ST2r BCM84868_PCS_IEEE_ST2r
#define PCS_IEEE_ST2r_SIZE BCM84868_PCS_IEEE_ST2r_SIZE
typedef BCM84868_PCS_IEEE_ST2r_t PCS_IEEE_ST2r_t;
#define PCS_IEEE_ST2r_CLR BCM84868_PCS_IEEE_ST2r_CLR
#define PCS_IEEE_ST2r_SET BCM84868_PCS_IEEE_ST2r_SET
#define PCS_IEEE_ST2r_GET BCM84868_PCS_IEEE_ST2r_GET
#define PCS_IEEE_ST2r_DEV_PREf_GET BCM84868_PCS_IEEE_ST2r_DEV_PREf_GET
#define PCS_IEEE_ST2r_DEV_PREf_SET BCM84868_PCS_IEEE_ST2r_DEV_PREf_SET
#define PCS_IEEE_ST2r_TRAN_FALTf_GET BCM84868_PCS_IEEE_ST2r_TRAN_FALTf_GET
#define PCS_IEEE_ST2r_TRAN_FALTf_SET BCM84868_PCS_IEEE_ST2r_TRAN_FALTf_SET
#define PCS_IEEE_ST2r_RCV_FALTf_GET BCM84868_PCS_IEEE_ST2r_RCV_FALTf_GET
#define PCS_IEEE_ST2r_RCV_FALTf_SET BCM84868_PCS_IEEE_ST2r_RCV_FALTf_SET
#define PCS_IEEE_ST2r_CAP_10G_Tf_GET BCM84868_PCS_IEEE_ST2r_CAP_10G_Tf_GET
#define PCS_IEEE_ST2r_CAP_10G_Tf_SET BCM84868_PCS_IEEE_ST2r_CAP_10G_Tf_SET
#define PCS_IEEE_ST2r_CAP_10G_Wf_GET BCM84868_PCS_IEEE_ST2r_CAP_10G_Wf_GET
#define PCS_IEEE_ST2r_CAP_10G_Wf_SET BCM84868_PCS_IEEE_ST2r_CAP_10G_Wf_SET
#define PCS_IEEE_ST2r_CAP_10G_Xf_GET BCM84868_PCS_IEEE_ST2r_CAP_10G_Xf_GET
#define PCS_IEEE_ST2r_CAP_10G_Xf_SET BCM84868_PCS_IEEE_ST2r_CAP_10G_Xf_SET
#define PCS_IEEE_ST2r_CAP_10G_Rf_GET BCM84868_PCS_IEEE_ST2r_CAP_10G_Rf_GET
#define PCS_IEEE_ST2r_CAP_10G_Rf_SET BCM84868_PCS_IEEE_ST2r_CAP_10G_Rf_SET
#define READ_PCS_IEEE_ST2r BCM84868_READ_PCS_IEEE_ST2r
#define WRITE_PCS_IEEE_ST2r BCM84868_WRITE_PCS_IEEE_ST2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_ST2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_PKG_ID0
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x000e
 * DEVAD:    3
 * DESC:     PCS package identifier
 * SIZE:     32
 * FIELDS:
 *     PKG_ID_0         
 */
#define BCM84868_PCS_IEEE_PKG_ID0r (0x0003000e | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_PKG_ID0r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_PKG_ID0.
 */
typedef union BCM84868_PCS_IEEE_PKG_ID0r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_pkg_id0[1];
	uint32_t _pcs_ieee_pkg_id0;
} BCM84868_PCS_IEEE_PKG_ID0r_t;

#define BCM84868_PCS_IEEE_PKG_ID0r_CLR(r) (r).pcs_ieee_pkg_id0[0] = 0
#define BCM84868_PCS_IEEE_PKG_ID0r_SET(r,d) (r).pcs_ieee_pkg_id0[0] = d
#define BCM84868_PCS_IEEE_PKG_ID0r_GET(r) (r).pcs_ieee_pkg_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_PKG_ID0r_PKG_ID_0f_GET(r) (((r).pcs_ieee_pkg_id0[0]) & 0xffff)
#define BCM84868_PCS_IEEE_PKG_ID0r_PKG_ID_0f_SET(r,f) (r).pcs_ieee_pkg_id0[0]=(((r).pcs_ieee_pkg_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_IEEE_PKG_ID0.
 */
#define BCM84868_READ_PCS_IEEE_PKG_ID0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_PKG_ID0r,(_r._pcs_ieee_pkg_id0))
#define BCM84868_WRITE_PCS_IEEE_PKG_ID0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_PKG_ID0r,(_r._pcs_ieee_pkg_id0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_PKG_ID0r BCM84868_PCS_IEEE_PKG_ID0r
#define PCS_IEEE_PKG_ID0r_SIZE BCM84868_PCS_IEEE_PKG_ID0r_SIZE
typedef BCM84868_PCS_IEEE_PKG_ID0r_t PCS_IEEE_PKG_ID0r_t;
#define PCS_IEEE_PKG_ID0r_CLR BCM84868_PCS_IEEE_PKG_ID0r_CLR
#define PCS_IEEE_PKG_ID0r_SET BCM84868_PCS_IEEE_PKG_ID0r_SET
#define PCS_IEEE_PKG_ID0r_GET BCM84868_PCS_IEEE_PKG_ID0r_GET
#define PCS_IEEE_PKG_ID0r_PKG_ID_0f_GET BCM84868_PCS_IEEE_PKG_ID0r_PKG_ID_0f_GET
#define PCS_IEEE_PKG_ID0r_PKG_ID_0f_SET BCM84868_PCS_IEEE_PKG_ID0r_PKG_ID_0f_SET
#define READ_PCS_IEEE_PKG_ID0r BCM84868_READ_PCS_IEEE_PKG_ID0r
#define WRITE_PCS_IEEE_PKG_ID0r BCM84868_WRITE_PCS_IEEE_PKG_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_PKG_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_PKG_ID1
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x000f
 * DEVAD:    3
 * DESC:     PCS package identifier
 * SIZE:     32
 * FIELDS:
 *     PKG_ID_1         
 */
#define BCM84868_PCS_IEEE_PKG_ID1r (0x0003000f | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_PKG_ID1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_PKG_ID1.
 */
typedef union BCM84868_PCS_IEEE_PKG_ID1r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_pkg_id1[1];
	uint32_t _pcs_ieee_pkg_id1;
} BCM84868_PCS_IEEE_PKG_ID1r_t;

#define BCM84868_PCS_IEEE_PKG_ID1r_CLR(r) (r).pcs_ieee_pkg_id1[0] = 0
#define BCM84868_PCS_IEEE_PKG_ID1r_SET(r,d) (r).pcs_ieee_pkg_id1[0] = d
#define BCM84868_PCS_IEEE_PKG_ID1r_GET(r) (r).pcs_ieee_pkg_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_PKG_ID1r_PKG_ID_1f_GET(r) (((r).pcs_ieee_pkg_id1[0]) & 0xffff)
#define BCM84868_PCS_IEEE_PKG_ID1r_PKG_ID_1f_SET(r,f) (r).pcs_ieee_pkg_id1[0]=(((r).pcs_ieee_pkg_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PCS_IEEE_PKG_ID1.
 */
#define BCM84868_READ_PCS_IEEE_PKG_ID1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_PKG_ID1r,(_r._pcs_ieee_pkg_id1))
#define BCM84868_WRITE_PCS_IEEE_PKG_ID1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_PKG_ID1r,(_r._pcs_ieee_pkg_id1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_PKG_ID1r BCM84868_PCS_IEEE_PKG_ID1r
#define PCS_IEEE_PKG_ID1r_SIZE BCM84868_PCS_IEEE_PKG_ID1r_SIZE
typedef BCM84868_PCS_IEEE_PKG_ID1r_t PCS_IEEE_PKG_ID1r_t;
#define PCS_IEEE_PKG_ID1r_CLR BCM84868_PCS_IEEE_PKG_ID1r_CLR
#define PCS_IEEE_PKG_ID1r_SET BCM84868_PCS_IEEE_PKG_ID1r_SET
#define PCS_IEEE_PKG_ID1r_GET BCM84868_PCS_IEEE_PKG_ID1r_GET
#define PCS_IEEE_PKG_ID1r_PKG_ID_1f_GET BCM84868_PCS_IEEE_PKG_ID1r_PKG_ID_1f_GET
#define PCS_IEEE_PKG_ID1r_PKG_ID_1f_SET BCM84868_PCS_IEEE_PKG_ID1r_PKG_ID_1f_SET
#define READ_PCS_IEEE_PKG_ID1r BCM84868_READ_PCS_IEEE_PKG_ID1r
#define WRITE_PCS_IEEE_PKG_ID1r BCM84868_WRITE_PCS_IEEE_PKG_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_PKG_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_RT_10G_ST1
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0020
 * DEVAD:    3
 * DESC:     10GBASE_R & 10GBASE_T PCS status 1
 * SIZE:     32
 * FIELDS:
 *     BLK_LOCK         
 *     HBER             
 *     PRBS31_CAP       
 *     RCV_LINK_STS     
 */
#define BCM84868_PCS_IEEE_RT_10G_ST1r (0x00030020 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_RT_10G_ST1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_RT_10G_ST1.
 */
typedef union BCM84868_PCS_IEEE_RT_10G_ST1r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_rt_10g_st1[1];
	uint32_t _pcs_ieee_rt_10g_st1;
} BCM84868_PCS_IEEE_RT_10G_ST1r_t;

#define BCM84868_PCS_IEEE_RT_10G_ST1r_CLR(r) (r).pcs_ieee_rt_10g_st1[0] = 0
#define BCM84868_PCS_IEEE_RT_10G_ST1r_SET(r,d) (r).pcs_ieee_rt_10g_st1[0] = d
#define BCM84868_PCS_IEEE_RT_10G_ST1r_GET(r) (r).pcs_ieee_rt_10g_st1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_RT_10G_ST1r_RCV_LINK_STSf_GET(r) ((((r).pcs_ieee_rt_10g_st1[0]) >> 12) & 0x1)
#define BCM84868_PCS_IEEE_RT_10G_ST1r_RCV_LINK_STSf_SET(r,f) (r).pcs_ieee_rt_10g_st1[0]=(((r).pcs_ieee_rt_10g_st1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PCS_IEEE_RT_10G_ST1r_PRBS31_CAPf_GET(r) ((((r).pcs_ieee_rt_10g_st1[0]) >> 2) & 0x1)
#define BCM84868_PCS_IEEE_RT_10G_ST1r_PRBS31_CAPf_SET(r,f) (r).pcs_ieee_rt_10g_st1[0]=(((r).pcs_ieee_rt_10g_st1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PCS_IEEE_RT_10G_ST1r_HBERf_GET(r) ((((r).pcs_ieee_rt_10g_st1[0]) >> 1) & 0x1)
#define BCM84868_PCS_IEEE_RT_10G_ST1r_HBERf_SET(r,f) (r).pcs_ieee_rt_10g_st1[0]=(((r).pcs_ieee_rt_10g_st1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PCS_IEEE_RT_10G_ST1r_BLK_LOCKf_GET(r) (((r).pcs_ieee_rt_10g_st1[0]) & 0x1)
#define BCM84868_PCS_IEEE_RT_10G_ST1r_BLK_LOCKf_SET(r,f) (r).pcs_ieee_rt_10g_st1[0]=(((r).pcs_ieee_rt_10g_st1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PCS_IEEE_RT_10G_ST1.
 */
#define BCM84868_READ_PCS_IEEE_RT_10G_ST1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_RT_10G_ST1r,(_r._pcs_ieee_rt_10g_st1))
#define BCM84868_WRITE_PCS_IEEE_RT_10G_ST1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_RT_10G_ST1r,(_r._pcs_ieee_rt_10g_st1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_RT_10G_ST1r BCM84868_PCS_IEEE_RT_10G_ST1r
#define PCS_IEEE_RT_10G_ST1r_SIZE BCM84868_PCS_IEEE_RT_10G_ST1r_SIZE
typedef BCM84868_PCS_IEEE_RT_10G_ST1r_t PCS_IEEE_RT_10G_ST1r_t;
#define PCS_IEEE_RT_10G_ST1r_CLR BCM84868_PCS_IEEE_RT_10G_ST1r_CLR
#define PCS_IEEE_RT_10G_ST1r_SET BCM84868_PCS_IEEE_RT_10G_ST1r_SET
#define PCS_IEEE_RT_10G_ST1r_GET BCM84868_PCS_IEEE_RT_10G_ST1r_GET
#define PCS_IEEE_RT_10G_ST1r_RCV_LINK_STSf_GET BCM84868_PCS_IEEE_RT_10G_ST1r_RCV_LINK_STSf_GET
#define PCS_IEEE_RT_10G_ST1r_RCV_LINK_STSf_SET BCM84868_PCS_IEEE_RT_10G_ST1r_RCV_LINK_STSf_SET
#define PCS_IEEE_RT_10G_ST1r_PRBS31_CAPf_GET BCM84868_PCS_IEEE_RT_10G_ST1r_PRBS31_CAPf_GET
#define PCS_IEEE_RT_10G_ST1r_PRBS31_CAPf_SET BCM84868_PCS_IEEE_RT_10G_ST1r_PRBS31_CAPf_SET
#define PCS_IEEE_RT_10G_ST1r_HBERf_GET BCM84868_PCS_IEEE_RT_10G_ST1r_HBERf_GET
#define PCS_IEEE_RT_10G_ST1r_HBERf_SET BCM84868_PCS_IEEE_RT_10G_ST1r_HBERf_SET
#define PCS_IEEE_RT_10G_ST1r_BLK_LOCKf_GET BCM84868_PCS_IEEE_RT_10G_ST1r_BLK_LOCKf_GET
#define PCS_IEEE_RT_10G_ST1r_BLK_LOCKf_SET BCM84868_PCS_IEEE_RT_10G_ST1r_BLK_LOCKf_SET
#define READ_PCS_IEEE_RT_10G_ST1r BCM84868_READ_PCS_IEEE_RT_10G_ST1r
#define WRITE_PCS_IEEE_RT_10G_ST1r BCM84868_WRITE_PCS_IEEE_RT_10G_ST1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_RT_10G_ST1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PCS_IEEE_RT_10G_ST2
 * BLOCKS:   PCS_IEEE
 * REGADDR:  0x0021
 * DEVAD:    3
 * DESC:     10GBASE_R & 10GBASE_T PCS status 2
 * SIZE:     32
 * FIELDS:
 *     ERR_BLK_CNT      
 *     BER              
 *     HBER_L           
 *     BLK_LOCK_L       
 */
#define BCM84868_PCS_IEEE_RT_10G_ST2r (0x00030021 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PCS_IEEE_RT_10G_ST2r_SIZE 4

/*
 * This structure should be used to declare and program PCS_IEEE_RT_10G_ST2.
 */
typedef union BCM84868_PCS_IEEE_RT_10G_ST2r_s {
	uint32_t v[1];
	uint32_t pcs_ieee_rt_10g_st2[1];
	uint32_t _pcs_ieee_rt_10g_st2;
} BCM84868_PCS_IEEE_RT_10G_ST2r_t;

#define BCM84868_PCS_IEEE_RT_10G_ST2r_CLR(r) (r).pcs_ieee_rt_10g_st2[0] = 0
#define BCM84868_PCS_IEEE_RT_10G_ST2r_SET(r,d) (r).pcs_ieee_rt_10g_st2[0] = d
#define BCM84868_PCS_IEEE_RT_10G_ST2r_GET(r) (r).pcs_ieee_rt_10g_st2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PCS_IEEE_RT_10G_ST2r_BLK_LOCK_Lf_GET(r) ((((r).pcs_ieee_rt_10g_st2[0]) >> 15) & 0x1)
#define BCM84868_PCS_IEEE_RT_10G_ST2r_BLK_LOCK_Lf_SET(r,f) (r).pcs_ieee_rt_10g_st2[0]=(((r).pcs_ieee_rt_10g_st2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PCS_IEEE_RT_10G_ST2r_HBER_Lf_GET(r) ((((r).pcs_ieee_rt_10g_st2[0]) >> 14) & 0x1)
#define BCM84868_PCS_IEEE_RT_10G_ST2r_HBER_Lf_SET(r,f) (r).pcs_ieee_rt_10g_st2[0]=(((r).pcs_ieee_rt_10g_st2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PCS_IEEE_RT_10G_ST2r_BERf_GET(r) ((((r).pcs_ieee_rt_10g_st2[0]) >> 8) & 0x3f)
#define BCM84868_PCS_IEEE_RT_10G_ST2r_BERf_SET(r,f) (r).pcs_ieee_rt_10g_st2[0]=(((r).pcs_ieee_rt_10g_st2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM84868_PCS_IEEE_RT_10G_ST2r_ERR_BLK_CNTf_GET(r) (((r).pcs_ieee_rt_10g_st2[0]) & 0xff)
#define BCM84868_PCS_IEEE_RT_10G_ST2r_ERR_BLK_CNTf_SET(r,f) (r).pcs_ieee_rt_10g_st2[0]=(((r).pcs_ieee_rt_10g_st2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PCS_IEEE_RT_10G_ST2.
 */
#define BCM84868_READ_PCS_IEEE_RT_10G_ST2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PCS_IEEE_RT_10G_ST2r,(_r._pcs_ieee_rt_10g_st2))
#define BCM84868_WRITE_PCS_IEEE_RT_10G_ST2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PCS_IEEE_RT_10G_ST2r,(_r._pcs_ieee_rt_10g_st2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PCS_IEEE_RT_10G_ST2r BCM84868_PCS_IEEE_RT_10G_ST2r
#define PCS_IEEE_RT_10G_ST2r_SIZE BCM84868_PCS_IEEE_RT_10G_ST2r_SIZE
typedef BCM84868_PCS_IEEE_RT_10G_ST2r_t PCS_IEEE_RT_10G_ST2r_t;
#define PCS_IEEE_RT_10G_ST2r_CLR BCM84868_PCS_IEEE_RT_10G_ST2r_CLR
#define PCS_IEEE_RT_10G_ST2r_SET BCM84868_PCS_IEEE_RT_10G_ST2r_SET
#define PCS_IEEE_RT_10G_ST2r_GET BCM84868_PCS_IEEE_RT_10G_ST2r_GET
#define PCS_IEEE_RT_10G_ST2r_BLK_LOCK_Lf_GET BCM84868_PCS_IEEE_RT_10G_ST2r_BLK_LOCK_Lf_GET
#define PCS_IEEE_RT_10G_ST2r_BLK_LOCK_Lf_SET BCM84868_PCS_IEEE_RT_10G_ST2r_BLK_LOCK_Lf_SET
#define PCS_IEEE_RT_10G_ST2r_HBER_Lf_GET BCM84868_PCS_IEEE_RT_10G_ST2r_HBER_Lf_GET
#define PCS_IEEE_RT_10G_ST2r_HBER_Lf_SET BCM84868_PCS_IEEE_RT_10G_ST2r_HBER_Lf_SET
#define PCS_IEEE_RT_10G_ST2r_BERf_GET BCM84868_PCS_IEEE_RT_10G_ST2r_BERf_GET
#define PCS_IEEE_RT_10G_ST2r_BERf_SET BCM84868_PCS_IEEE_RT_10G_ST2r_BERf_SET
#define PCS_IEEE_RT_10G_ST2r_ERR_BLK_CNTf_GET BCM84868_PCS_IEEE_RT_10G_ST2r_ERR_BLK_CNTf_GET
#define PCS_IEEE_RT_10G_ST2r_ERR_BLK_CNTf_SET BCM84868_PCS_IEEE_RT_10G_ST2r_ERR_BLK_CNTf_SET
#define READ_PCS_IEEE_RT_10G_ST2r BCM84868_READ_PCS_IEEE_RT_10G_ST2r
#define WRITE_PCS_IEEE_RT_10G_ST2r BCM84868_WRITE_PCS_IEEE_RT_10G_ST2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PCS_IEEE_RT_10G_ST2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_CTL1
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0000
 * DEVAD:    4
 * DESC:     IEEE PCS control 1 register
 * SIZE:     32
 * FIELDS:
 *     SPEED_SEL_10G    
 *     SPEED_SEL_1      
 *     CLK_STOPPABLE    
 *     LOW_PWR          
 *     SPEED_SEL_0      
 *     LPBK             
 *     RESET            
 */
#define BCM84868_XGXS_IEEE_M_CTL1r (0x00040000 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_CTL1.
 */
typedef union BCM84868_XGXS_IEEE_M_CTL1r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_ctl1[1];
	uint32_t _xgxs_ieee_m_ctl1;
} BCM84868_XGXS_IEEE_M_CTL1r_t;

#define BCM84868_XGXS_IEEE_M_CTL1r_CLR(r) (r).xgxs_ieee_m_ctl1[0] = 0
#define BCM84868_XGXS_IEEE_M_CTL1r_SET(r,d) (r).xgxs_ieee_m_ctl1[0] = d
#define BCM84868_XGXS_IEEE_M_CTL1r_GET(r) (r).xgxs_ieee_m_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_CTL1r_RESETf_GET(r) ((((r).xgxs_ieee_m_ctl1[0]) >> 15) & 0x1)
#define BCM84868_XGXS_IEEE_M_CTL1r_RESETf_SET(r,f) (r).xgxs_ieee_m_ctl1[0]=(((r).xgxs_ieee_m_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_XGXS_IEEE_M_CTL1r_LPBKf_GET(r) ((((r).xgxs_ieee_m_ctl1[0]) >> 14) & 0x1)
#define BCM84868_XGXS_IEEE_M_CTL1r_LPBKf_SET(r,f) (r).xgxs_ieee_m_ctl1[0]=(((r).xgxs_ieee_m_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_0f_GET(r) ((((r).xgxs_ieee_m_ctl1[0]) >> 13) & 0x1)
#define BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_0f_SET(r,f) (r).xgxs_ieee_m_ctl1[0]=(((r).xgxs_ieee_m_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_XGXS_IEEE_M_CTL1r_LOW_PWRf_GET(r) ((((r).xgxs_ieee_m_ctl1[0]) >> 11) & 0x1)
#define BCM84868_XGXS_IEEE_M_CTL1r_LOW_PWRf_SET(r,f) (r).xgxs_ieee_m_ctl1[0]=(((r).xgxs_ieee_m_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_XGXS_IEEE_M_CTL1r_CLK_STOPPABLEf_GET(r) ((((r).xgxs_ieee_m_ctl1[0]) >> 10) & 0x1)
#define BCM84868_XGXS_IEEE_M_CTL1r_CLK_STOPPABLEf_SET(r,f) (r).xgxs_ieee_m_ctl1[0]=(((r).xgxs_ieee_m_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_1f_GET(r) ((((r).xgxs_ieee_m_ctl1[0]) >> 6) & 0x1)
#define BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_1f_SET(r,f) (r).xgxs_ieee_m_ctl1[0]=(((r).xgxs_ieee_m_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_10Gf_GET(r) ((((r).xgxs_ieee_m_ctl1[0]) >> 2) & 0xf)
#define BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_10Gf_SET(r,f) (r).xgxs_ieee_m_ctl1[0]=(((r).xgxs_ieee_m_ctl1[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))

/*
 * These macros can be used to access XGXS_IEEE_M_CTL1.
 */
#define BCM84868_READ_XGXS_IEEE_M_CTL1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_CTL1r,(_r._xgxs_ieee_m_ctl1))
#define BCM84868_WRITE_XGXS_IEEE_M_CTL1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_CTL1r,(_r._xgxs_ieee_m_ctl1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_CTL1r BCM84868_XGXS_IEEE_M_CTL1r
#define XGXS_IEEE_M_CTL1r_SIZE BCM84868_XGXS_IEEE_M_CTL1r_SIZE
typedef BCM84868_XGXS_IEEE_M_CTL1r_t XGXS_IEEE_M_CTL1r_t;
#define XGXS_IEEE_M_CTL1r_CLR BCM84868_XGXS_IEEE_M_CTL1r_CLR
#define XGXS_IEEE_M_CTL1r_SET BCM84868_XGXS_IEEE_M_CTL1r_SET
#define XGXS_IEEE_M_CTL1r_GET BCM84868_XGXS_IEEE_M_CTL1r_GET
#define XGXS_IEEE_M_CTL1r_RESETf_GET BCM84868_XGXS_IEEE_M_CTL1r_RESETf_GET
#define XGXS_IEEE_M_CTL1r_RESETf_SET BCM84868_XGXS_IEEE_M_CTL1r_RESETf_SET
#define XGXS_IEEE_M_CTL1r_LPBKf_GET BCM84868_XGXS_IEEE_M_CTL1r_LPBKf_GET
#define XGXS_IEEE_M_CTL1r_LPBKf_SET BCM84868_XGXS_IEEE_M_CTL1r_LPBKf_SET
#define XGXS_IEEE_M_CTL1r_SPEED_SEL_0f_GET BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_0f_GET
#define XGXS_IEEE_M_CTL1r_SPEED_SEL_0f_SET BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_0f_SET
#define XGXS_IEEE_M_CTL1r_LOW_PWRf_GET BCM84868_XGXS_IEEE_M_CTL1r_LOW_PWRf_GET
#define XGXS_IEEE_M_CTL1r_LOW_PWRf_SET BCM84868_XGXS_IEEE_M_CTL1r_LOW_PWRf_SET
#define XGXS_IEEE_M_CTL1r_CLK_STOPPABLEf_GET BCM84868_XGXS_IEEE_M_CTL1r_CLK_STOPPABLEf_GET
#define XGXS_IEEE_M_CTL1r_CLK_STOPPABLEf_SET BCM84868_XGXS_IEEE_M_CTL1r_CLK_STOPPABLEf_SET
#define XGXS_IEEE_M_CTL1r_SPEED_SEL_1f_GET BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_1f_GET
#define XGXS_IEEE_M_CTL1r_SPEED_SEL_1f_SET BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_1f_SET
#define XGXS_IEEE_M_CTL1r_SPEED_SEL_10Gf_GET BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_10Gf_GET
#define XGXS_IEEE_M_CTL1r_SPEED_SEL_10Gf_SET BCM84868_XGXS_IEEE_M_CTL1r_SPEED_SEL_10Gf_SET
#define READ_XGXS_IEEE_M_CTL1r BCM84868_READ_XGXS_IEEE_M_CTL1r
#define WRITE_XGXS_IEEE_M_CTL1r BCM84868_WRITE_XGXS_IEEE_M_CTL1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_ST1
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0001
 * DEVAD:    4
 * DESC:     IEEE PCS status 1 register
 * SIZE:     32
 * FIELDS:
 *     LOW_PWR_AB       
 *     PCS_RCV_LINK_ST  
 *     FAULT            
 *     RX_LPI_INDCT     
 *     TX_LPI_INDCT     
 *     RX_LPI_RCVD      
 *     TX_LPI_RCVD      
 */
#define BCM84868_XGXS_IEEE_M_ST1r (0x00040001 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_ST1r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_ST1.
 */
typedef union BCM84868_XGXS_IEEE_M_ST1r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_st1[1];
	uint32_t _xgxs_ieee_m_st1;
} BCM84868_XGXS_IEEE_M_ST1r_t;

#define BCM84868_XGXS_IEEE_M_ST1r_CLR(r) (r).xgxs_ieee_m_st1[0] = 0
#define BCM84868_XGXS_IEEE_M_ST1r_SET(r,d) (r).xgxs_ieee_m_st1[0] = d
#define BCM84868_XGXS_IEEE_M_ST1r_GET(r) (r).xgxs_ieee_m_st1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_RCVDf_GET(r) ((((r).xgxs_ieee_m_st1[0]) >> 11) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_RCVDf_SET(r,f) (r).xgxs_ieee_m_st1[0]=(((r).xgxs_ieee_m_st1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_RCVDf_GET(r) ((((r).xgxs_ieee_m_st1[0]) >> 10) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_RCVDf_SET(r,f) (r).xgxs_ieee_m_st1[0]=(((r).xgxs_ieee_m_st1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_INDCTf_GET(r) ((((r).xgxs_ieee_m_st1[0]) >> 9) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_INDCTf_SET(r,f) (r).xgxs_ieee_m_st1[0]=(((r).xgxs_ieee_m_st1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_INDCTf_GET(r) ((((r).xgxs_ieee_m_st1[0]) >> 8) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_INDCTf_SET(r,f) (r).xgxs_ieee_m_st1[0]=(((r).xgxs_ieee_m_st1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_XGXS_IEEE_M_ST1r_FAULTf_GET(r) ((((r).xgxs_ieee_m_st1[0]) >> 7) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST1r_FAULTf_SET(r,f) (r).xgxs_ieee_m_st1[0]=(((r).xgxs_ieee_m_st1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_XGXS_IEEE_M_ST1r_PCS_RCV_LINK_STf_GET(r) ((((r).xgxs_ieee_m_st1[0]) >> 2) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST1r_PCS_RCV_LINK_STf_SET(r,f) (r).xgxs_ieee_m_st1[0]=(((r).xgxs_ieee_m_st1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_XGXS_IEEE_M_ST1r_LOW_PWR_ABf_GET(r) ((((r).xgxs_ieee_m_st1[0]) >> 1) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST1r_LOW_PWR_ABf_SET(r,f) (r).xgxs_ieee_m_st1[0]=(((r).xgxs_ieee_m_st1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access XGXS_IEEE_M_ST1.
 */
#define BCM84868_READ_XGXS_IEEE_M_ST1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_ST1r,(_r._xgxs_ieee_m_st1))
#define BCM84868_WRITE_XGXS_IEEE_M_ST1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_ST1r,(_r._xgxs_ieee_m_st1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_ST1r BCM84868_XGXS_IEEE_M_ST1r
#define XGXS_IEEE_M_ST1r_SIZE BCM84868_XGXS_IEEE_M_ST1r_SIZE
typedef BCM84868_XGXS_IEEE_M_ST1r_t XGXS_IEEE_M_ST1r_t;
#define XGXS_IEEE_M_ST1r_CLR BCM84868_XGXS_IEEE_M_ST1r_CLR
#define XGXS_IEEE_M_ST1r_SET BCM84868_XGXS_IEEE_M_ST1r_SET
#define XGXS_IEEE_M_ST1r_GET BCM84868_XGXS_IEEE_M_ST1r_GET
#define XGXS_IEEE_M_ST1r_TX_LPI_RCVDf_GET BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_RCVDf_GET
#define XGXS_IEEE_M_ST1r_TX_LPI_RCVDf_SET BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_RCVDf_SET
#define XGXS_IEEE_M_ST1r_RX_LPI_RCVDf_GET BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_RCVDf_GET
#define XGXS_IEEE_M_ST1r_RX_LPI_RCVDf_SET BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_RCVDf_SET
#define XGXS_IEEE_M_ST1r_TX_LPI_INDCTf_GET BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_INDCTf_GET
#define XGXS_IEEE_M_ST1r_TX_LPI_INDCTf_SET BCM84868_XGXS_IEEE_M_ST1r_TX_LPI_INDCTf_SET
#define XGXS_IEEE_M_ST1r_RX_LPI_INDCTf_GET BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_INDCTf_GET
#define XGXS_IEEE_M_ST1r_RX_LPI_INDCTf_SET BCM84868_XGXS_IEEE_M_ST1r_RX_LPI_INDCTf_SET
#define XGXS_IEEE_M_ST1r_FAULTf_GET BCM84868_XGXS_IEEE_M_ST1r_FAULTf_GET
#define XGXS_IEEE_M_ST1r_FAULTf_SET BCM84868_XGXS_IEEE_M_ST1r_FAULTf_SET
#define XGXS_IEEE_M_ST1r_PCS_RCV_LINK_STf_GET BCM84868_XGXS_IEEE_M_ST1r_PCS_RCV_LINK_STf_GET
#define XGXS_IEEE_M_ST1r_PCS_RCV_LINK_STf_SET BCM84868_XGXS_IEEE_M_ST1r_PCS_RCV_LINK_STf_SET
#define XGXS_IEEE_M_ST1r_LOW_PWR_ABf_GET BCM84868_XGXS_IEEE_M_ST1r_LOW_PWR_ABf_GET
#define XGXS_IEEE_M_ST1r_LOW_PWR_ABf_SET BCM84868_XGXS_IEEE_M_ST1r_LOW_PWR_ABf_SET
#define READ_XGXS_IEEE_M_ST1r BCM84868_READ_XGXS_IEEE_M_ST1r
#define WRITE_XGXS_IEEE_M_ST1r BCM84868_WRITE_XGXS_IEEE_M_ST1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_ST1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_ID0
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0002
 * DEVAD:    4
 * DESC:     IEEE PCS device identifier part 0
 * SIZE:     32
 * FIELDS:
 *     DEV_ID0          
 */
#define BCM84868_XGXS_IEEE_M_ID0r (0x00040002 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_ID0r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_ID0.
 */
typedef union BCM84868_XGXS_IEEE_M_ID0r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_id0[1];
	uint32_t _xgxs_ieee_m_id0;
} BCM84868_XGXS_IEEE_M_ID0r_t;

#define BCM84868_XGXS_IEEE_M_ID0r_CLR(r) (r).xgxs_ieee_m_id0[0] = 0
#define BCM84868_XGXS_IEEE_M_ID0r_SET(r,d) (r).xgxs_ieee_m_id0[0] = d
#define BCM84868_XGXS_IEEE_M_ID0r_GET(r) (r).xgxs_ieee_m_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_ID0r_DEV_ID0f_GET(r) (((r).xgxs_ieee_m_id0[0]) & 0xffff)
#define BCM84868_XGXS_IEEE_M_ID0r_DEV_ID0f_SET(r,f) (r).xgxs_ieee_m_id0[0]=(((r).xgxs_ieee_m_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGXS_IEEE_M_ID0.
 */
#define BCM84868_READ_XGXS_IEEE_M_ID0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_ID0r,(_r._xgxs_ieee_m_id0))
#define BCM84868_WRITE_XGXS_IEEE_M_ID0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_ID0r,(_r._xgxs_ieee_m_id0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_ID0r BCM84868_XGXS_IEEE_M_ID0r
#define XGXS_IEEE_M_ID0r_SIZE BCM84868_XGXS_IEEE_M_ID0r_SIZE
typedef BCM84868_XGXS_IEEE_M_ID0r_t XGXS_IEEE_M_ID0r_t;
#define XGXS_IEEE_M_ID0r_CLR BCM84868_XGXS_IEEE_M_ID0r_CLR
#define XGXS_IEEE_M_ID0r_SET BCM84868_XGXS_IEEE_M_ID0r_SET
#define XGXS_IEEE_M_ID0r_GET BCM84868_XGXS_IEEE_M_ID0r_GET
#define XGXS_IEEE_M_ID0r_DEV_ID0f_GET BCM84868_XGXS_IEEE_M_ID0r_DEV_ID0f_GET
#define XGXS_IEEE_M_ID0r_DEV_ID0f_SET BCM84868_XGXS_IEEE_M_ID0r_DEV_ID0f_SET
#define READ_XGXS_IEEE_M_ID0r BCM84868_READ_XGXS_IEEE_M_ID0r
#define WRITE_XGXS_IEEE_M_ID0r BCM84868_WRITE_XGXS_IEEE_M_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_M_IEEE_ID1
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0003
 * DEVAD:    4
 * DESC:     IEEE PCS device identifier part 1
 * SIZE:     32
 * FIELDS:
 *     DEV_ID1          
 */
#define BCM84868_XGXS_M_IEEE_ID1r (0x00040003 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_M_IEEE_ID1r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_M_IEEE_ID1.
 */
typedef union BCM84868_XGXS_M_IEEE_ID1r_s {
	uint32_t v[1];
	uint32_t xgxs_m_ieee_id1[1];
	uint32_t _xgxs_m_ieee_id1;
} BCM84868_XGXS_M_IEEE_ID1r_t;

#define BCM84868_XGXS_M_IEEE_ID1r_CLR(r) (r).xgxs_m_ieee_id1[0] = 0
#define BCM84868_XGXS_M_IEEE_ID1r_SET(r,d) (r).xgxs_m_ieee_id1[0] = d
#define BCM84868_XGXS_M_IEEE_ID1r_GET(r) (r).xgxs_m_ieee_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_M_IEEE_ID1r_DEV_ID1f_GET(r) (((r).xgxs_m_ieee_id1[0]) & 0xffff)
#define BCM84868_XGXS_M_IEEE_ID1r_DEV_ID1f_SET(r,f) (r).xgxs_m_ieee_id1[0]=(((r).xgxs_m_ieee_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGXS_M_IEEE_ID1.
 */
#define BCM84868_READ_XGXS_M_IEEE_ID1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_M_IEEE_ID1r,(_r._xgxs_m_ieee_id1))
#define BCM84868_WRITE_XGXS_M_IEEE_ID1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_M_IEEE_ID1r,(_r._xgxs_m_ieee_id1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_M_IEEE_ID1r BCM84868_XGXS_M_IEEE_ID1r
#define XGXS_M_IEEE_ID1r_SIZE BCM84868_XGXS_M_IEEE_ID1r_SIZE
typedef BCM84868_XGXS_M_IEEE_ID1r_t XGXS_M_IEEE_ID1r_t;
#define XGXS_M_IEEE_ID1r_CLR BCM84868_XGXS_M_IEEE_ID1r_CLR
#define XGXS_M_IEEE_ID1r_SET BCM84868_XGXS_M_IEEE_ID1r_SET
#define XGXS_M_IEEE_ID1r_GET BCM84868_XGXS_M_IEEE_ID1r_GET
#define XGXS_M_IEEE_ID1r_DEV_ID1f_GET BCM84868_XGXS_M_IEEE_ID1r_DEV_ID1f_GET
#define XGXS_M_IEEE_ID1r_DEV_ID1f_SET BCM84868_XGXS_M_IEEE_ID1r_DEV_ID1f_SET
#define READ_XGXS_M_IEEE_ID1r BCM84868_READ_XGXS_M_IEEE_ID1r
#define WRITE_XGXS_M_IEEE_ID1r BCM84868_WRITE_XGXS_M_IEEE_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_M_IEEE_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_SP_AB
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0004
 * DEVAD:    4
 * DESC:     IEEE PCS speed ability
 * SIZE:     32
 * FIELDS:
 *     CAP_10G          
 *     CAP_10P2B        
 */
#define BCM84868_XGXS_IEEE_M_SP_ABr (0x00040004 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_SP_ABr_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_SP_AB.
 */
typedef union BCM84868_XGXS_IEEE_M_SP_ABr_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_sp_ab[1];
	uint32_t _xgxs_ieee_m_sp_ab;
} BCM84868_XGXS_IEEE_M_SP_ABr_t;

#define BCM84868_XGXS_IEEE_M_SP_ABr_CLR(r) (r).xgxs_ieee_m_sp_ab[0] = 0
#define BCM84868_XGXS_IEEE_M_SP_ABr_SET(r,d) (r).xgxs_ieee_m_sp_ab[0] = d
#define BCM84868_XGXS_IEEE_M_SP_ABr_GET(r) (r).xgxs_ieee_m_sp_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10P2Bf_GET(r) ((((r).xgxs_ieee_m_sp_ab[0]) >> 1) & 0x1)
#define BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10P2Bf_SET(r,f) (r).xgxs_ieee_m_sp_ab[0]=(((r).xgxs_ieee_m_sp_ab[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10Gf_GET(r) (((r).xgxs_ieee_m_sp_ab[0]) & 0x1)
#define BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10Gf_SET(r,f) (r).xgxs_ieee_m_sp_ab[0]=(((r).xgxs_ieee_m_sp_ab[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XGXS_IEEE_M_SP_AB.
 */
#define BCM84868_READ_XGXS_IEEE_M_SP_ABr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_SP_ABr,(_r._xgxs_ieee_m_sp_ab))
#define BCM84868_WRITE_XGXS_IEEE_M_SP_ABr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_SP_ABr,(_r._xgxs_ieee_m_sp_ab))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_SP_ABr BCM84868_XGXS_IEEE_M_SP_ABr
#define XGXS_IEEE_M_SP_ABr_SIZE BCM84868_XGXS_IEEE_M_SP_ABr_SIZE
typedef BCM84868_XGXS_IEEE_M_SP_ABr_t XGXS_IEEE_M_SP_ABr_t;
#define XGXS_IEEE_M_SP_ABr_CLR BCM84868_XGXS_IEEE_M_SP_ABr_CLR
#define XGXS_IEEE_M_SP_ABr_SET BCM84868_XGXS_IEEE_M_SP_ABr_SET
#define XGXS_IEEE_M_SP_ABr_GET BCM84868_XGXS_IEEE_M_SP_ABr_GET
#define XGXS_IEEE_M_SP_ABr_CAP_10P2Bf_GET BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10P2Bf_GET
#define XGXS_IEEE_M_SP_ABr_CAP_10P2Bf_SET BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10P2Bf_SET
#define XGXS_IEEE_M_SP_ABr_CAP_10Gf_GET BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10Gf_GET
#define XGXS_IEEE_M_SP_ABr_CAP_10Gf_SET BCM84868_XGXS_IEEE_M_SP_ABr_CAP_10Gf_SET
#define READ_XGXS_IEEE_M_SP_ABr BCM84868_READ_XGXS_IEEE_M_SP_ABr
#define WRITE_XGXS_IEEE_M_SP_ABr BCM84868_WRITE_XGXS_IEEE_M_SP_ABr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_SP_ABr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_DEV_IN_PKG2
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0005
 * DEVAD:    4
 * DESC:     Devices in package register part 0
 * SIZE:     32
 * FIELDS:
 *     CLA22_PRE        
 *     PMD_PRE          
 *     WIS_PRE          
 *     PCS_PRE          
 *     PHYXS_PRE        
 *     DTEXS_PRE        
 *     TC_PRE           
 *     AUTONEG_PRE      
 */
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r (0x00040005 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_DEV_IN_PKG2.
 */
typedef union BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_dev_in_pkg2[1];
	uint32_t _xgxs_ieee_m_dev_in_pkg2;
} BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_t;

#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_CLR(r) (r).xgxs_ieee_m_dev_in_pkg2[0] = 0
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_SET(r,d) (r).xgxs_ieee_m_dev_in_pkg2[0] = d
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_GET(r) (r).xgxs_ieee_m_dev_in_pkg2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_AUTONEG_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg2[0]) >> 7) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_AUTONEG_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_TC_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg2[0]) >> 6) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_TC_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_DTEXS_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg2[0]) >> 5) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_DTEXS_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PHYXS_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg2[0]) >> 4) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PHYXS_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PCS_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg2[0]) >> 3) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PCS_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_WIS_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg2[0]) >> 2) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_WIS_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PMD_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg2[0]) >> 1) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PMD_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_CLA22_PREf_GET(r) (((r).xgxs_ieee_m_dev_in_pkg2[0]) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_CLA22_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg2[0]=(((r).xgxs_ieee_m_dev_in_pkg2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XGXS_IEEE_M_DEV_IN_PKG2.
 */
#define BCM84868_READ_XGXS_IEEE_M_DEV_IN_PKG2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r,(_r._xgxs_ieee_m_dev_in_pkg2))
#define BCM84868_WRITE_XGXS_IEEE_M_DEV_IN_PKG2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r,(_r._xgxs_ieee_m_dev_in_pkg2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_DEV_IN_PKG2r BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r
#define XGXS_IEEE_M_DEV_IN_PKG2r_SIZE BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_SIZE
typedef BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_t XGXS_IEEE_M_DEV_IN_PKG2r_t;
#define XGXS_IEEE_M_DEV_IN_PKG2r_CLR BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_CLR
#define XGXS_IEEE_M_DEV_IN_PKG2r_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_AUTONEG_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_AUTONEG_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_AUTONEG_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_AUTONEG_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_TC_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_TC_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_TC_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_TC_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_DTEXS_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_DTEXS_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_DTEXS_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_DTEXS_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_PHYXS_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PHYXS_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_PHYXS_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PHYXS_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_PCS_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PCS_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_PCS_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PCS_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_WIS_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_WIS_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_WIS_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_WIS_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_PMD_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PMD_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_PMD_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_PMD_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG2r_CLA22_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_CLA22_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG2r_CLA22_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r_CLA22_PREf_SET
#define READ_XGXS_IEEE_M_DEV_IN_PKG2r BCM84868_READ_XGXS_IEEE_M_DEV_IN_PKG2r
#define WRITE_XGXS_IEEE_M_DEV_IN_PKG2r BCM84868_WRITE_XGXS_IEEE_M_DEV_IN_PKG2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_DEV_IN_PKG2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_DEV_IN_PKG1
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0006
 * DEVAD:    4
 * DESC:     Devices in package register part 1
 * SIZE:     32
 * FIELDS:
 *     CLA22_EXT_PRE    
 *     VENSP_DEV1_PRE   
 *     VENSP_DEV2_PRE   
 */
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r (0x00040006 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_DEV_IN_PKG1.
 */
typedef union BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_dev_in_pkg1[1];
	uint32_t _xgxs_ieee_m_dev_in_pkg1;
} BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_t;

#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_CLR(r) (r).xgxs_ieee_m_dev_in_pkg1[0] = 0
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_SET(r,d) (r).xgxs_ieee_m_dev_in_pkg1[0] = d
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_GET(r) (r).xgxs_ieee_m_dev_in_pkg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV2_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg1[0]) >> 15) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV2_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg1[0]=(((r).xgxs_ieee_m_dev_in_pkg1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV1_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg1[0]) >> 14) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV1_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg1[0]=(((r).xgxs_ieee_m_dev_in_pkg1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_CLA22_EXT_PREf_GET(r) ((((r).xgxs_ieee_m_dev_in_pkg1[0]) >> 13) & 0x1)
#define BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_CLA22_EXT_PREf_SET(r,f) (r).xgxs_ieee_m_dev_in_pkg1[0]=(((r).xgxs_ieee_m_dev_in_pkg1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access XGXS_IEEE_M_DEV_IN_PKG1.
 */
#define BCM84868_READ_XGXS_IEEE_M_DEV_IN_PKG1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r,(_r._xgxs_ieee_m_dev_in_pkg1))
#define BCM84868_WRITE_XGXS_IEEE_M_DEV_IN_PKG1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r,(_r._xgxs_ieee_m_dev_in_pkg1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_DEV_IN_PKG1r BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r
#define XGXS_IEEE_M_DEV_IN_PKG1r_SIZE BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_SIZE
typedef BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_t XGXS_IEEE_M_DEV_IN_PKG1r_t;
#define XGXS_IEEE_M_DEV_IN_PKG1r_CLR BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_CLR
#define XGXS_IEEE_M_DEV_IN_PKG1r_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_SET
#define XGXS_IEEE_M_DEV_IN_PKG1r_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_GET
#define XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV2_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV2_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV2_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV2_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV1_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV1_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV1_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_VENSP_DEV1_PREf_SET
#define XGXS_IEEE_M_DEV_IN_PKG1r_CLA22_EXT_PREf_GET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_CLA22_EXT_PREf_GET
#define XGXS_IEEE_M_DEV_IN_PKG1r_CLA22_EXT_PREf_SET BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r_CLA22_EXT_PREf_SET
#define READ_XGXS_IEEE_M_DEV_IN_PKG1r BCM84868_READ_XGXS_IEEE_M_DEV_IN_PKG1r
#define WRITE_XGXS_IEEE_M_DEV_IN_PKG1r BCM84868_WRITE_XGXS_IEEE_M_DEV_IN_PKG1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_DEV_IN_PKG1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_ST2
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x0008
 * DEVAD:    4
 * DESC:     10G PCS status 2 register
 * SIZE:     32
 * FIELDS:
 *     CAP_10G_R        
 *     CAP_10G_X        
 *     CAP_10G_W        
 *     CAP_10G_T        
 *     RCV_FALT         
 *     TRAN_FALT        
 *     DEV_PRE          
 */
#define BCM84868_XGXS_IEEE_M_ST2r (0x00040008 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_ST2r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_ST2.
 */
typedef union BCM84868_XGXS_IEEE_M_ST2r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_st2[1];
	uint32_t _xgxs_ieee_m_st2;
} BCM84868_XGXS_IEEE_M_ST2r_t;

#define BCM84868_XGXS_IEEE_M_ST2r_CLR(r) (r).xgxs_ieee_m_st2[0] = 0
#define BCM84868_XGXS_IEEE_M_ST2r_SET(r,d) (r).xgxs_ieee_m_st2[0] = d
#define BCM84868_XGXS_IEEE_M_ST2r_GET(r) (r).xgxs_ieee_m_st2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_ST2r_DEV_PREf_GET(r) ((((r).xgxs_ieee_m_st2[0]) >> 14) & 0x3)
#define BCM84868_XGXS_IEEE_M_ST2r_DEV_PREf_SET(r,f) (r).xgxs_ieee_m_st2[0]=(((r).xgxs_ieee_m_st2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM84868_XGXS_IEEE_M_ST2r_TRAN_FALTf_GET(r) ((((r).xgxs_ieee_m_st2[0]) >> 11) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST2r_TRAN_FALTf_SET(r,f) (r).xgxs_ieee_m_st2[0]=(((r).xgxs_ieee_m_st2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_XGXS_IEEE_M_ST2r_RCV_FALTf_GET(r) ((((r).xgxs_ieee_m_st2[0]) >> 10) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST2r_RCV_FALTf_SET(r,f) (r).xgxs_ieee_m_st2[0]=(((r).xgxs_ieee_m_st2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Tf_GET(r) ((((r).xgxs_ieee_m_st2[0]) >> 3) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Tf_SET(r,f) (r).xgxs_ieee_m_st2[0]=(((r).xgxs_ieee_m_st2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Wf_GET(r) ((((r).xgxs_ieee_m_st2[0]) >> 2) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Wf_SET(r,f) (r).xgxs_ieee_m_st2[0]=(((r).xgxs_ieee_m_st2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Xf_GET(r) ((((r).xgxs_ieee_m_st2[0]) >> 1) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Xf_SET(r,f) (r).xgxs_ieee_m_st2[0]=(((r).xgxs_ieee_m_st2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Rf_GET(r) (((r).xgxs_ieee_m_st2[0]) & 0x1)
#define BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Rf_SET(r,f) (r).xgxs_ieee_m_st2[0]=(((r).xgxs_ieee_m_st2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XGXS_IEEE_M_ST2.
 */
#define BCM84868_READ_XGXS_IEEE_M_ST2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_ST2r,(_r._xgxs_ieee_m_st2))
#define BCM84868_WRITE_XGXS_IEEE_M_ST2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_ST2r,(_r._xgxs_ieee_m_st2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_ST2r BCM84868_XGXS_IEEE_M_ST2r
#define XGXS_IEEE_M_ST2r_SIZE BCM84868_XGXS_IEEE_M_ST2r_SIZE
typedef BCM84868_XGXS_IEEE_M_ST2r_t XGXS_IEEE_M_ST2r_t;
#define XGXS_IEEE_M_ST2r_CLR BCM84868_XGXS_IEEE_M_ST2r_CLR
#define XGXS_IEEE_M_ST2r_SET BCM84868_XGXS_IEEE_M_ST2r_SET
#define XGXS_IEEE_M_ST2r_GET BCM84868_XGXS_IEEE_M_ST2r_GET
#define XGXS_IEEE_M_ST2r_DEV_PREf_GET BCM84868_XGXS_IEEE_M_ST2r_DEV_PREf_GET
#define XGXS_IEEE_M_ST2r_DEV_PREf_SET BCM84868_XGXS_IEEE_M_ST2r_DEV_PREf_SET
#define XGXS_IEEE_M_ST2r_TRAN_FALTf_GET BCM84868_XGXS_IEEE_M_ST2r_TRAN_FALTf_GET
#define XGXS_IEEE_M_ST2r_TRAN_FALTf_SET BCM84868_XGXS_IEEE_M_ST2r_TRAN_FALTf_SET
#define XGXS_IEEE_M_ST2r_RCV_FALTf_GET BCM84868_XGXS_IEEE_M_ST2r_RCV_FALTf_GET
#define XGXS_IEEE_M_ST2r_RCV_FALTf_SET BCM84868_XGXS_IEEE_M_ST2r_RCV_FALTf_SET
#define XGXS_IEEE_M_ST2r_CAP_10G_Tf_GET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Tf_GET
#define XGXS_IEEE_M_ST2r_CAP_10G_Tf_SET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Tf_SET
#define XGXS_IEEE_M_ST2r_CAP_10G_Wf_GET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Wf_GET
#define XGXS_IEEE_M_ST2r_CAP_10G_Wf_SET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Wf_SET
#define XGXS_IEEE_M_ST2r_CAP_10G_Xf_GET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Xf_GET
#define XGXS_IEEE_M_ST2r_CAP_10G_Xf_SET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Xf_SET
#define XGXS_IEEE_M_ST2r_CAP_10G_Rf_GET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Rf_GET
#define XGXS_IEEE_M_ST2r_CAP_10G_Rf_SET BCM84868_XGXS_IEEE_M_ST2r_CAP_10G_Rf_SET
#define READ_XGXS_IEEE_M_ST2r BCM84868_READ_XGXS_IEEE_M_ST2r
#define WRITE_XGXS_IEEE_M_ST2r BCM84868_WRITE_XGXS_IEEE_M_ST2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_ST2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_OUID1
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x000e
 * DEVAD:    4
 * DESC:     PCS package identifier
 * SIZE:     32
 * FIELDS:
 *     PKG_ID_0         
 */
#define BCM84868_XGXS_IEEE_M_OUID1r (0x0004000e | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_OUID1r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_OUID1.
 */
typedef union BCM84868_XGXS_IEEE_M_OUID1r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_ouid1[1];
	uint32_t _xgxs_ieee_m_ouid1;
} BCM84868_XGXS_IEEE_M_OUID1r_t;

#define BCM84868_XGXS_IEEE_M_OUID1r_CLR(r) (r).xgxs_ieee_m_ouid1[0] = 0
#define BCM84868_XGXS_IEEE_M_OUID1r_SET(r,d) (r).xgxs_ieee_m_ouid1[0] = d
#define BCM84868_XGXS_IEEE_M_OUID1r_GET(r) (r).xgxs_ieee_m_ouid1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_OUID1r_PKG_ID_0f_GET(r) (((r).xgxs_ieee_m_ouid1[0]) & 0xffff)
#define BCM84868_XGXS_IEEE_M_OUID1r_PKG_ID_0f_SET(r,f) (r).xgxs_ieee_m_ouid1[0]=(((r).xgxs_ieee_m_ouid1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGXS_IEEE_M_OUID1.
 */
#define BCM84868_READ_XGXS_IEEE_M_OUID1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_OUID1r,(_r._xgxs_ieee_m_ouid1))
#define BCM84868_WRITE_XGXS_IEEE_M_OUID1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_OUID1r,(_r._xgxs_ieee_m_ouid1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_OUID1r BCM84868_XGXS_IEEE_M_OUID1r
#define XGXS_IEEE_M_OUID1r_SIZE BCM84868_XGXS_IEEE_M_OUID1r_SIZE
typedef BCM84868_XGXS_IEEE_M_OUID1r_t XGXS_IEEE_M_OUID1r_t;
#define XGXS_IEEE_M_OUID1r_CLR BCM84868_XGXS_IEEE_M_OUID1r_CLR
#define XGXS_IEEE_M_OUID1r_SET BCM84868_XGXS_IEEE_M_OUID1r_SET
#define XGXS_IEEE_M_OUID1r_GET BCM84868_XGXS_IEEE_M_OUID1r_GET
#define XGXS_IEEE_M_OUID1r_PKG_ID_0f_GET BCM84868_XGXS_IEEE_M_OUID1r_PKG_ID_0f_GET
#define XGXS_IEEE_M_OUID1r_PKG_ID_0f_SET BCM84868_XGXS_IEEE_M_OUID1r_PKG_ID_0f_SET
#define READ_XGXS_IEEE_M_OUID1r BCM84868_READ_XGXS_IEEE_M_OUID1r
#define WRITE_XGXS_IEEE_M_OUID1r BCM84868_WRITE_XGXS_IEEE_M_OUID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_OUID1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGXS_IEEE_M_OUID2
 * BLOCKS:   XGXS_IEEE
 * REGADDR:  0x000f
 * DEVAD:    4
 * DESC:     PCS package identifier
 * SIZE:     32
 * FIELDS:
 *     PKG_ID_1         
 */
#define BCM84868_XGXS_IEEE_M_OUID2r (0x0004000f | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGXS_IEEE_M_OUID2r_SIZE 4

/*
 * This structure should be used to declare and program XGXS_IEEE_M_OUID2.
 */
typedef union BCM84868_XGXS_IEEE_M_OUID2r_s {
	uint32_t v[1];
	uint32_t xgxs_ieee_m_ouid2[1];
	uint32_t _xgxs_ieee_m_ouid2;
} BCM84868_XGXS_IEEE_M_OUID2r_t;

#define BCM84868_XGXS_IEEE_M_OUID2r_CLR(r) (r).xgxs_ieee_m_ouid2[0] = 0
#define BCM84868_XGXS_IEEE_M_OUID2r_SET(r,d) (r).xgxs_ieee_m_ouid2[0] = d
#define BCM84868_XGXS_IEEE_M_OUID2r_GET(r) (r).xgxs_ieee_m_ouid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGXS_IEEE_M_OUID2r_PKG_ID_1f_GET(r) (((r).xgxs_ieee_m_ouid2[0]) & 0xffff)
#define BCM84868_XGXS_IEEE_M_OUID2r_PKG_ID_1f_SET(r,f) (r).xgxs_ieee_m_ouid2[0]=(((r).xgxs_ieee_m_ouid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XGXS_IEEE_M_OUID2.
 */
#define BCM84868_READ_XGXS_IEEE_M_OUID2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGXS_IEEE_M_OUID2r,(_r._xgxs_ieee_m_ouid2))
#define BCM84868_WRITE_XGXS_IEEE_M_OUID2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGXS_IEEE_M_OUID2r,(_r._xgxs_ieee_m_ouid2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGXS_IEEE_M_OUID2r BCM84868_XGXS_IEEE_M_OUID2r
#define XGXS_IEEE_M_OUID2r_SIZE BCM84868_XGXS_IEEE_M_OUID2r_SIZE
typedef BCM84868_XGXS_IEEE_M_OUID2r_t XGXS_IEEE_M_OUID2r_t;
#define XGXS_IEEE_M_OUID2r_CLR BCM84868_XGXS_IEEE_M_OUID2r_CLR
#define XGXS_IEEE_M_OUID2r_SET BCM84868_XGXS_IEEE_M_OUID2r_SET
#define XGXS_IEEE_M_OUID2r_GET BCM84868_XGXS_IEEE_M_OUID2r_GET
#define XGXS_IEEE_M_OUID2r_PKG_ID_1f_GET BCM84868_XGXS_IEEE_M_OUID2r_PKG_ID_1f_GET
#define XGXS_IEEE_M_OUID2r_PKG_ID_1f_SET BCM84868_XGXS_IEEE_M_OUID2r_PKG_ID_1f_SET
#define READ_XGXS_IEEE_M_OUID2r BCM84868_READ_XGXS_IEEE_M_OUID2r
#define WRITE_XGXS_IEEE_M_OUID2r BCM84868_WRITE_XGXS_IEEE_M_OUID2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGXS_IEEE_M_OUID2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_CTRL
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0000
 * DEVAD:    7
 * DESC:     AutoNegCtrl Register
 * SIZE:     32
 * FIELDS:
 *     AN_RESTART       
 *     AN_ENA           
 *     EXT_NXT_PAGE     
 *     AN_RESET         
 */
#define BCM84868_AN_CTRLr (0x00070000 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program AN_CTRL.
 */
typedef union BCM84868_AN_CTRLr_s {
	uint32_t v[1];
	uint32_t an_ctrl[1];
	uint32_t _an_ctrl;
} BCM84868_AN_CTRLr_t;

#define BCM84868_AN_CTRLr_CLR(r) (r).an_ctrl[0] = 0
#define BCM84868_AN_CTRLr_SET(r,d) (r).an_ctrl[0] = d
#define BCM84868_AN_CTRLr_GET(r) (r).an_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_CTRLr_AN_RESETf_GET(r) ((((r).an_ctrl[0]) >> 15) & 0x1)
#define BCM84868_AN_CTRLr_AN_RESETf_SET(r,f) (r).an_ctrl[0]=(((r).an_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_AN_CTRLr_EXT_NXT_PAGEf_GET(r) ((((r).an_ctrl[0]) >> 13) & 0x1)
#define BCM84868_AN_CTRLr_EXT_NXT_PAGEf_SET(r,f) (r).an_ctrl[0]=(((r).an_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_AN_CTRLr_AN_ENAf_GET(r) ((((r).an_ctrl[0]) >> 12) & 0x1)
#define BCM84868_AN_CTRLr_AN_ENAf_SET(r,f) (r).an_ctrl[0]=(((r).an_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_AN_CTRLr_AN_RESTARTf_GET(r) ((((r).an_ctrl[0]) >> 9) & 0x1)
#define BCM84868_AN_CTRLr_AN_RESTARTf_SET(r,f) (r).an_ctrl[0]=(((r).an_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access AN_CTRL.
 */
#define BCM84868_READ_AN_CTRLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_CTRLr,(_r._an_ctrl))
#define BCM84868_WRITE_AN_CTRLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_CTRLr,(_r._an_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_CTRLr BCM84868_AN_CTRLr
#define AN_CTRLr_SIZE BCM84868_AN_CTRLr_SIZE
typedef BCM84868_AN_CTRLr_t AN_CTRLr_t;
#define AN_CTRLr_CLR BCM84868_AN_CTRLr_CLR
#define AN_CTRLr_SET BCM84868_AN_CTRLr_SET
#define AN_CTRLr_GET BCM84868_AN_CTRLr_GET
#define AN_CTRLr_AN_RESETf_GET BCM84868_AN_CTRLr_AN_RESETf_GET
#define AN_CTRLr_AN_RESETf_SET BCM84868_AN_CTRLr_AN_RESETf_SET
#define AN_CTRLr_EXT_NXT_PAGEf_GET BCM84868_AN_CTRLr_EXT_NXT_PAGEf_GET
#define AN_CTRLr_EXT_NXT_PAGEf_SET BCM84868_AN_CTRLr_EXT_NXT_PAGEf_SET
#define AN_CTRLr_AN_ENAf_GET BCM84868_AN_CTRLr_AN_ENAf_GET
#define AN_CTRLr_AN_ENAf_SET BCM84868_AN_CTRLr_AN_ENAf_SET
#define AN_CTRLr_AN_RESTARTf_GET BCM84868_AN_CTRLr_AN_RESTARTf_GET
#define AN_CTRLr_AN_RESTARTf_SET BCM84868_AN_CTRLr_AN_RESTARTf_SET
#define READ_AN_CTRLr BCM84868_READ_AN_CTRLr
#define WRITE_AN_CTRLr BCM84868_WRITE_AN_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_STAT
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0001
 * DEVAD:    7
 * DESC:     AutoNegStat Register
 * SIZE:     32
 * FIELDS:
 *     LP_AUTONEG_ABIL  
 *     LINK_STATUS      
 *     AUTONEG_ABIL     
 *     REMOTE_FAULT     
 *     AN_DONE          
 *     PAGE_RECEIVED    
 *     EXTENDED_NEXT_PAGE_STAT 
 *     PARALLEL_DETECTION_FAULT 
 */
#define BCM84868_AN_STATr (0x00070001 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_STATr_SIZE 4

/*
 * This structure should be used to declare and program AN_STAT.
 */
typedef union BCM84868_AN_STATr_s {
	uint32_t v[1];
	uint32_t an_stat[1];
	uint32_t _an_stat;
} BCM84868_AN_STATr_t;

#define BCM84868_AN_STATr_CLR(r) (r).an_stat[0] = 0
#define BCM84868_AN_STATr_SET(r,d) (r).an_stat[0] = d
#define BCM84868_AN_STATr_GET(r) (r).an_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_STATr_PARALLEL_DETECTION_FAULTf_GET(r) ((((r).an_stat[0]) >> 9) & 0x1)
#define BCM84868_AN_STATr_PARALLEL_DETECTION_FAULTf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_AN_STATr_EXTENDED_NEXT_PAGE_STATf_GET(r) ((((r).an_stat[0]) >> 7) & 0x1)
#define BCM84868_AN_STATr_EXTENDED_NEXT_PAGE_STATf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_AN_STATr_PAGE_RECEIVEDf_GET(r) ((((r).an_stat[0]) >> 6) & 0x1)
#define BCM84868_AN_STATr_PAGE_RECEIVEDf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_AN_STATr_AN_DONEf_GET(r) ((((r).an_stat[0]) >> 5) & 0x1)
#define BCM84868_AN_STATr_AN_DONEf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_AN_STATr_REMOTE_FAULTf_GET(r) ((((r).an_stat[0]) >> 4) & 0x1)
#define BCM84868_AN_STATr_REMOTE_FAULTf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_AN_STATr_AUTONEG_ABILf_GET(r) ((((r).an_stat[0]) >> 3) & 0x1)
#define BCM84868_AN_STATr_AUTONEG_ABILf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_AN_STATr_LINK_STATUSf_GET(r) ((((r).an_stat[0]) >> 2) & 0x1)
#define BCM84868_AN_STATr_LINK_STATUSf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_AN_STATr_LP_AUTONEG_ABILf_GET(r) (((r).an_stat[0]) & 0x1)
#define BCM84868_AN_STATr_LP_AUTONEG_ABILf_SET(r,f) (r).an_stat[0]=(((r).an_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access AN_STAT.
 */
#define BCM84868_READ_AN_STATr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_STATr,(_r._an_stat))
#define BCM84868_WRITE_AN_STATr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_STATr,(_r._an_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_STATr BCM84868_AN_STATr
#define AN_STATr_SIZE BCM84868_AN_STATr_SIZE
typedef BCM84868_AN_STATr_t AN_STATr_t;
#define AN_STATr_CLR BCM84868_AN_STATr_CLR
#define AN_STATr_SET BCM84868_AN_STATr_SET
#define AN_STATr_GET BCM84868_AN_STATr_GET
#define AN_STATr_PARALLEL_DETECTION_FAULTf_GET BCM84868_AN_STATr_PARALLEL_DETECTION_FAULTf_GET
#define AN_STATr_PARALLEL_DETECTION_FAULTf_SET BCM84868_AN_STATr_PARALLEL_DETECTION_FAULTf_SET
#define AN_STATr_EXTENDED_NEXT_PAGE_STATf_GET BCM84868_AN_STATr_EXTENDED_NEXT_PAGE_STATf_GET
#define AN_STATr_EXTENDED_NEXT_PAGE_STATf_SET BCM84868_AN_STATr_EXTENDED_NEXT_PAGE_STATf_SET
#define AN_STATr_PAGE_RECEIVEDf_GET BCM84868_AN_STATr_PAGE_RECEIVEDf_GET
#define AN_STATr_PAGE_RECEIVEDf_SET BCM84868_AN_STATr_PAGE_RECEIVEDf_SET
#define AN_STATr_AN_DONEf_GET BCM84868_AN_STATr_AN_DONEf_GET
#define AN_STATr_AN_DONEf_SET BCM84868_AN_STATr_AN_DONEf_SET
#define AN_STATr_REMOTE_FAULTf_GET BCM84868_AN_STATr_REMOTE_FAULTf_GET
#define AN_STATr_REMOTE_FAULTf_SET BCM84868_AN_STATr_REMOTE_FAULTf_SET
#define AN_STATr_AUTONEG_ABILf_GET BCM84868_AN_STATr_AUTONEG_ABILf_GET
#define AN_STATr_AUTONEG_ABILf_SET BCM84868_AN_STATr_AUTONEG_ABILf_SET
#define AN_STATr_LINK_STATUSf_GET BCM84868_AN_STATr_LINK_STATUSf_GET
#define AN_STATr_LINK_STATUSf_SET BCM84868_AN_STATr_LINK_STATUSf_SET
#define AN_STATr_LP_AUTONEG_ABILf_GET BCM84868_AN_STATr_LP_AUTONEG_ABILf_GET
#define AN_STATr_LP_AUTONEG_ABILf_SET BCM84868_AN_STATr_LP_AUTONEG_ABILf_SET
#define READ_AN_STATr BCM84868_READ_AN_STATr
#define WRITE_AN_STATr BCM84868_WRITE_AN_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_DEV_ID_LSB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0002
 * DEVAD:    7
 * DESC:     AutoNegDevID0 Register
 * SIZE:     32
 * FIELDS:
 *     AUTONEGDEVID0    
 */
#define BCM84868_AN_IEEE_DEV_ID_LSBr (0x00070002 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_DEV_ID_LSBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_DEV_ID_LSB.
 */
typedef union BCM84868_AN_IEEE_DEV_ID_LSBr_s {
	uint32_t v[1];
	uint32_t an_ieee_dev_id_lsb[1];
	uint32_t _an_ieee_dev_id_lsb;
} BCM84868_AN_IEEE_DEV_ID_LSBr_t;

#define BCM84868_AN_IEEE_DEV_ID_LSBr_CLR(r) (r).an_ieee_dev_id_lsb[0] = 0
#define BCM84868_AN_IEEE_DEV_ID_LSBr_SET(r,d) (r).an_ieee_dev_id_lsb[0] = d
#define BCM84868_AN_IEEE_DEV_ID_LSBr_GET(r) (r).an_ieee_dev_id_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_DEV_ID_LSBr_AUTONEGDEVID0f_GET(r) (((r).an_ieee_dev_id_lsb[0]) & 0xffff)
#define BCM84868_AN_IEEE_DEV_ID_LSBr_AUTONEGDEVID0f_SET(r,f) (r).an_ieee_dev_id_lsb[0]=(((r).an_ieee_dev_id_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_DEV_ID_LSB.
 */
#define BCM84868_READ_AN_IEEE_DEV_ID_LSBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_DEV_ID_LSBr,(_r._an_ieee_dev_id_lsb))
#define BCM84868_WRITE_AN_IEEE_DEV_ID_LSBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_DEV_ID_LSBr,(_r._an_ieee_dev_id_lsb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_DEV_ID_LSBr BCM84868_AN_IEEE_DEV_ID_LSBr
#define AN_IEEE_DEV_ID_LSBr_SIZE BCM84868_AN_IEEE_DEV_ID_LSBr_SIZE
typedef BCM84868_AN_IEEE_DEV_ID_LSBr_t AN_IEEE_DEV_ID_LSBr_t;
#define AN_IEEE_DEV_ID_LSBr_CLR BCM84868_AN_IEEE_DEV_ID_LSBr_CLR
#define AN_IEEE_DEV_ID_LSBr_SET BCM84868_AN_IEEE_DEV_ID_LSBr_SET
#define AN_IEEE_DEV_ID_LSBr_GET BCM84868_AN_IEEE_DEV_ID_LSBr_GET
#define AN_IEEE_DEV_ID_LSBr_AUTONEGDEVID0f_GET BCM84868_AN_IEEE_DEV_ID_LSBr_AUTONEGDEVID0f_GET
#define AN_IEEE_DEV_ID_LSBr_AUTONEGDEVID0f_SET BCM84868_AN_IEEE_DEV_ID_LSBr_AUTONEGDEVID0f_SET
#define READ_AN_IEEE_DEV_ID_LSBr BCM84868_READ_AN_IEEE_DEV_ID_LSBr
#define WRITE_AN_IEEE_DEV_ID_LSBr BCM84868_WRITE_AN_IEEE_DEV_ID_LSBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_DEV_ID_LSBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_DEV_ID_MSB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0003
 * DEVAD:    7
 * DESC:     AutoNegDevID1 Register
 * SIZE:     32
 * FIELDS:
 *     AUTONEGDEVID1    
 */
#define BCM84868_AN_IEEE_DEV_ID_MSBr (0x00070003 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_DEV_ID_MSBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_DEV_ID_MSB.
 */
typedef union BCM84868_AN_IEEE_DEV_ID_MSBr_s {
	uint32_t v[1];
	uint32_t an_ieee_dev_id_msb[1];
	uint32_t _an_ieee_dev_id_msb;
} BCM84868_AN_IEEE_DEV_ID_MSBr_t;

#define BCM84868_AN_IEEE_DEV_ID_MSBr_CLR(r) (r).an_ieee_dev_id_msb[0] = 0
#define BCM84868_AN_IEEE_DEV_ID_MSBr_SET(r,d) (r).an_ieee_dev_id_msb[0] = d
#define BCM84868_AN_IEEE_DEV_ID_MSBr_GET(r) (r).an_ieee_dev_id_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_DEV_ID_MSBr_AUTONEGDEVID1f_GET(r) (((r).an_ieee_dev_id_msb[0]) & 0xffff)
#define BCM84868_AN_IEEE_DEV_ID_MSBr_AUTONEGDEVID1f_SET(r,f) (r).an_ieee_dev_id_msb[0]=(((r).an_ieee_dev_id_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_DEV_ID_MSB.
 */
#define BCM84868_READ_AN_IEEE_DEV_ID_MSBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_DEV_ID_MSBr,(_r._an_ieee_dev_id_msb))
#define BCM84868_WRITE_AN_IEEE_DEV_ID_MSBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_DEV_ID_MSBr,(_r._an_ieee_dev_id_msb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_DEV_ID_MSBr BCM84868_AN_IEEE_DEV_ID_MSBr
#define AN_IEEE_DEV_ID_MSBr_SIZE BCM84868_AN_IEEE_DEV_ID_MSBr_SIZE
typedef BCM84868_AN_IEEE_DEV_ID_MSBr_t AN_IEEE_DEV_ID_MSBr_t;
#define AN_IEEE_DEV_ID_MSBr_CLR BCM84868_AN_IEEE_DEV_ID_MSBr_CLR
#define AN_IEEE_DEV_ID_MSBr_SET BCM84868_AN_IEEE_DEV_ID_MSBr_SET
#define AN_IEEE_DEV_ID_MSBr_GET BCM84868_AN_IEEE_DEV_ID_MSBr_GET
#define AN_IEEE_DEV_ID_MSBr_AUTONEGDEVID1f_GET BCM84868_AN_IEEE_DEV_ID_MSBr_AUTONEGDEVID1f_GET
#define AN_IEEE_DEV_ID_MSBr_AUTONEGDEVID1f_SET BCM84868_AN_IEEE_DEV_ID_MSBr_AUTONEGDEVID1f_SET
#define READ_AN_IEEE_DEV_ID_MSBr BCM84868_READ_AN_IEEE_DEV_ID_MSBr
#define WRITE_AN_IEEE_DEV_ID_MSBr BCM84868_WRITE_AN_IEEE_DEV_ID_MSBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_DEV_ID_MSBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_DEV_IN_PKG_LSB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0005
 * DEVAD:    7
 * DESC:     AutoNegDevInPkg0 Register
 * SIZE:     32
 * FIELDS:
 *     AUTONEGDEVINPKG0 
 */
#define BCM84868_AN_IEEE_DEV_IN_PKG_LSBr (0x00070005 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_DEV_IN_PKG_LSB.
 */
typedef union BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_s {
	uint32_t v[1];
	uint32_t an_ieee_dev_in_pkg_lsb[1];
	uint32_t _an_ieee_dev_in_pkg_lsb;
} BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_t;

#define BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_CLR(r) (r).an_ieee_dev_in_pkg_lsb[0] = 0
#define BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_SET(r,d) (r).an_ieee_dev_in_pkg_lsb[0] = d
#define BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_GET(r) (r).an_ieee_dev_in_pkg_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_AUTONEGDEVINPKG0f_GET(r) (((r).an_ieee_dev_in_pkg_lsb[0]) & 0xffff)
#define BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_AUTONEGDEVINPKG0f_SET(r,f) (r).an_ieee_dev_in_pkg_lsb[0]=(((r).an_ieee_dev_in_pkg_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_DEV_IN_PKG_LSB.
 */
#define BCM84868_READ_AN_IEEE_DEV_IN_PKG_LSBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_DEV_IN_PKG_LSBr,(_r._an_ieee_dev_in_pkg_lsb))
#define BCM84868_WRITE_AN_IEEE_DEV_IN_PKG_LSBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_DEV_IN_PKG_LSBr,(_r._an_ieee_dev_in_pkg_lsb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_DEV_IN_PKG_LSBr BCM84868_AN_IEEE_DEV_IN_PKG_LSBr
#define AN_IEEE_DEV_IN_PKG_LSBr_SIZE BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_SIZE
typedef BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_t AN_IEEE_DEV_IN_PKG_LSBr_t;
#define AN_IEEE_DEV_IN_PKG_LSBr_CLR BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_CLR
#define AN_IEEE_DEV_IN_PKG_LSBr_SET BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_SET
#define AN_IEEE_DEV_IN_PKG_LSBr_GET BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_GET
#define AN_IEEE_DEV_IN_PKG_LSBr_AUTONEGDEVINPKG0f_GET BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_AUTONEGDEVINPKG0f_GET
#define AN_IEEE_DEV_IN_PKG_LSBr_AUTONEGDEVINPKG0f_SET BCM84868_AN_IEEE_DEV_IN_PKG_LSBr_AUTONEGDEVINPKG0f_SET
#define READ_AN_IEEE_DEV_IN_PKG_LSBr BCM84868_READ_AN_IEEE_DEV_IN_PKG_LSBr
#define WRITE_AN_IEEE_DEV_IN_PKG_LSBr BCM84868_WRITE_AN_IEEE_DEV_IN_PKG_LSBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_DEV_IN_PKG_LSBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_DEV_IN_PKG_MSB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0006
 * DEVAD:    7
 * DESC:     AutoNegDevInPkg1 Register
 * SIZE:     32
 * FIELDS:
 *     AUTONEGDEVINPKG1 
 */
#define BCM84868_AN_IEEE_DEV_IN_PKG_MSBr (0x00070006 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_DEV_IN_PKG_MSB.
 */
typedef union BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_s {
	uint32_t v[1];
	uint32_t an_ieee_dev_in_pkg_msb[1];
	uint32_t _an_ieee_dev_in_pkg_msb;
} BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_t;

#define BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_CLR(r) (r).an_ieee_dev_in_pkg_msb[0] = 0
#define BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_SET(r,d) (r).an_ieee_dev_in_pkg_msb[0] = d
#define BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_GET(r) (r).an_ieee_dev_in_pkg_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_AUTONEGDEVINPKG1f_GET(r) (((r).an_ieee_dev_in_pkg_msb[0]) & 0xffff)
#define BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_AUTONEGDEVINPKG1f_SET(r,f) (r).an_ieee_dev_in_pkg_msb[0]=(((r).an_ieee_dev_in_pkg_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_DEV_IN_PKG_MSB.
 */
#define BCM84868_READ_AN_IEEE_DEV_IN_PKG_MSBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_DEV_IN_PKG_MSBr,(_r._an_ieee_dev_in_pkg_msb))
#define BCM84868_WRITE_AN_IEEE_DEV_IN_PKG_MSBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_DEV_IN_PKG_MSBr,(_r._an_ieee_dev_in_pkg_msb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_DEV_IN_PKG_MSBr BCM84868_AN_IEEE_DEV_IN_PKG_MSBr
#define AN_IEEE_DEV_IN_PKG_MSBr_SIZE BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_SIZE
typedef BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_t AN_IEEE_DEV_IN_PKG_MSBr_t;
#define AN_IEEE_DEV_IN_PKG_MSBr_CLR BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_CLR
#define AN_IEEE_DEV_IN_PKG_MSBr_SET BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_SET
#define AN_IEEE_DEV_IN_PKG_MSBr_GET BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_GET
#define AN_IEEE_DEV_IN_PKG_MSBr_AUTONEGDEVINPKG1f_GET BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_AUTONEGDEVINPKG1f_GET
#define AN_IEEE_DEV_IN_PKG_MSBr_AUTONEGDEVINPKG1f_SET BCM84868_AN_IEEE_DEV_IN_PKG_MSBr_AUTONEGDEVINPKG1f_SET
#define READ_AN_IEEE_DEV_IN_PKG_MSBr BCM84868_READ_AN_IEEE_DEV_IN_PKG_MSBr
#define WRITE_AN_IEEE_DEV_IN_PKG_MSBr BCM84868_WRITE_AN_IEEE_DEV_IN_PKG_MSBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_DEV_IN_PKG_MSBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_DEV_PKG_ID_LSB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x000e
 * DEVAD:    7
 * DESC:     AutoNegPkgID0 Register
 * SIZE:     32
 * FIELDS:
 *     AUTONEGPKGID0    
 */
#define BCM84868_AN_IEEE_DEV_PKG_ID_LSBr (0x0007000e | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_DEV_PKG_ID_LSB.
 */
typedef union BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_s {
	uint32_t v[1];
	uint32_t an_ieee_dev_pkg_id_lsb[1];
	uint32_t _an_ieee_dev_pkg_id_lsb;
} BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_t;

#define BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_CLR(r) (r).an_ieee_dev_pkg_id_lsb[0] = 0
#define BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_SET(r,d) (r).an_ieee_dev_pkg_id_lsb[0] = d
#define BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_GET(r) (r).an_ieee_dev_pkg_id_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_AUTONEGPKGID0f_GET(r) (((r).an_ieee_dev_pkg_id_lsb[0]) & 0xffff)
#define BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_AUTONEGPKGID0f_SET(r,f) (r).an_ieee_dev_pkg_id_lsb[0]=(((r).an_ieee_dev_pkg_id_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_DEV_PKG_ID_LSB.
 */
#define BCM84868_READ_AN_IEEE_DEV_PKG_ID_LSBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_DEV_PKG_ID_LSBr,(_r._an_ieee_dev_pkg_id_lsb))
#define BCM84868_WRITE_AN_IEEE_DEV_PKG_ID_LSBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_DEV_PKG_ID_LSBr,(_r._an_ieee_dev_pkg_id_lsb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_DEV_PKG_ID_LSBr BCM84868_AN_IEEE_DEV_PKG_ID_LSBr
#define AN_IEEE_DEV_PKG_ID_LSBr_SIZE BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_SIZE
typedef BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_t AN_IEEE_DEV_PKG_ID_LSBr_t;
#define AN_IEEE_DEV_PKG_ID_LSBr_CLR BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_CLR
#define AN_IEEE_DEV_PKG_ID_LSBr_SET BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_SET
#define AN_IEEE_DEV_PKG_ID_LSBr_GET BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_GET
#define AN_IEEE_DEV_PKG_ID_LSBr_AUTONEGPKGID0f_GET BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_AUTONEGPKGID0f_GET
#define AN_IEEE_DEV_PKG_ID_LSBr_AUTONEGPKGID0f_SET BCM84868_AN_IEEE_DEV_PKG_ID_LSBr_AUTONEGPKGID0f_SET
#define READ_AN_IEEE_DEV_PKG_ID_LSBr BCM84868_READ_AN_IEEE_DEV_PKG_ID_LSBr
#define WRITE_AN_IEEE_DEV_PKG_ID_LSBr BCM84868_WRITE_AN_IEEE_DEV_PKG_ID_LSBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_DEV_PKG_ID_LSBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_DEV_PKG_ID_MSB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x000f
 * DEVAD:    7
 * DESC:     AutoNegPkgID1 Register
 * SIZE:     32
 * FIELDS:
 *     AUTONEGPKGID1    
 */
#define BCM84868_AN_IEEE_DEV_PKG_ID_MSBr (0x0007000f | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_DEV_PKG_ID_MSB.
 */
typedef union BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_s {
	uint32_t v[1];
	uint32_t an_ieee_dev_pkg_id_msb[1];
	uint32_t _an_ieee_dev_pkg_id_msb;
} BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_t;

#define BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_CLR(r) (r).an_ieee_dev_pkg_id_msb[0] = 0
#define BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_SET(r,d) (r).an_ieee_dev_pkg_id_msb[0] = d
#define BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_GET(r) (r).an_ieee_dev_pkg_id_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_AUTONEGPKGID1f_GET(r) (((r).an_ieee_dev_pkg_id_msb[0]) & 0xffff)
#define BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_AUTONEGPKGID1f_SET(r,f) (r).an_ieee_dev_pkg_id_msb[0]=(((r).an_ieee_dev_pkg_id_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_DEV_PKG_ID_MSB.
 */
#define BCM84868_READ_AN_IEEE_DEV_PKG_ID_MSBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_DEV_PKG_ID_MSBr,(_r._an_ieee_dev_pkg_id_msb))
#define BCM84868_WRITE_AN_IEEE_DEV_PKG_ID_MSBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_DEV_PKG_ID_MSBr,(_r._an_ieee_dev_pkg_id_msb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_DEV_PKG_ID_MSBr BCM84868_AN_IEEE_DEV_PKG_ID_MSBr
#define AN_IEEE_DEV_PKG_ID_MSBr_SIZE BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_SIZE
typedef BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_t AN_IEEE_DEV_PKG_ID_MSBr_t;
#define AN_IEEE_DEV_PKG_ID_MSBr_CLR BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_CLR
#define AN_IEEE_DEV_PKG_ID_MSBr_SET BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_SET
#define AN_IEEE_DEV_PKG_ID_MSBr_GET BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_GET
#define AN_IEEE_DEV_PKG_ID_MSBr_AUTONEGPKGID1f_GET BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_AUTONEGPKGID1f_GET
#define AN_IEEE_DEV_PKG_ID_MSBr_AUTONEGPKGID1f_SET BCM84868_AN_IEEE_DEV_PKG_ID_MSBr_AUTONEGPKGID1f_SET
#define READ_AN_IEEE_DEV_PKG_ID_MSBr BCM84868_READ_AN_IEEE_DEV_PKG_ID_MSBr
#define WRITE_AN_IEEE_DEV_PKG_ID_MSBr BCM84868_WRITE_AN_IEEE_DEV_PKG_ID_MSBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_DEV_PKG_ID_MSBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_AD
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0010
 * DEVAD:    7
 * DESC:     AutoNegAdv Register
 * SIZE:     32
 * FIELDS:
 *     SELECTOR         
 *     TECHNOLOGY_ABIL  
 *     XNP              
 *     REMOTE_FAULT     
 *     ACKNOWLEDGE      
 *     NEXT_PAGE        
 */
#define BCM84868_AN_IEEE_ADr (0x00070010 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_ADr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_AD.
 */
typedef union BCM84868_AN_IEEE_ADr_s {
	uint32_t v[1];
	uint32_t an_ieee_ad[1];
	uint32_t _an_ieee_ad;
} BCM84868_AN_IEEE_ADr_t;

#define BCM84868_AN_IEEE_ADr_CLR(r) (r).an_ieee_ad[0] = 0
#define BCM84868_AN_IEEE_ADr_SET(r,d) (r).an_ieee_ad[0] = d
#define BCM84868_AN_IEEE_ADr_GET(r) (r).an_ieee_ad[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_ADr_NEXT_PAGEf_GET(r) ((((r).an_ieee_ad[0]) >> 15) & 0x1)
#define BCM84868_AN_IEEE_ADr_NEXT_PAGEf_SET(r,f) (r).an_ieee_ad[0]=(((r).an_ieee_ad[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_AN_IEEE_ADr_ACKNOWLEDGEf_GET(r) ((((r).an_ieee_ad[0]) >> 14) & 0x1)
#define BCM84868_AN_IEEE_ADr_ACKNOWLEDGEf_SET(r,f) (r).an_ieee_ad[0]=(((r).an_ieee_ad[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_AN_IEEE_ADr_REMOTE_FAULTf_GET(r) ((((r).an_ieee_ad[0]) >> 13) & 0x1)
#define BCM84868_AN_IEEE_ADr_REMOTE_FAULTf_SET(r,f) (r).an_ieee_ad[0]=(((r).an_ieee_ad[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_AN_IEEE_ADr_XNPf_GET(r) ((((r).an_ieee_ad[0]) >> 12) & 0x1)
#define BCM84868_AN_IEEE_ADr_XNPf_SET(r,f) (r).an_ieee_ad[0]=(((r).an_ieee_ad[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_AN_IEEE_ADr_TECHNOLOGY_ABILf_GET(r) ((((r).an_ieee_ad[0]) >> 5) & 0x7f)
#define BCM84868_AN_IEEE_ADr_TECHNOLOGY_ABILf_SET(r,f) (r).an_ieee_ad[0]=(((r).an_ieee_ad[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define BCM84868_AN_IEEE_ADr_SELECTORf_GET(r) (((r).an_ieee_ad[0]) & 0x1f)
#define BCM84868_AN_IEEE_ADr_SELECTORf_SET(r,f) (r).an_ieee_ad[0]=(((r).an_ieee_ad[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access AN_IEEE_AD.
 */
#define BCM84868_READ_AN_IEEE_ADr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_ADr,(_r._an_ieee_ad))
#define BCM84868_WRITE_AN_IEEE_ADr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_ADr,(_r._an_ieee_ad))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_ADr BCM84868_AN_IEEE_ADr
#define AN_IEEE_ADr_SIZE BCM84868_AN_IEEE_ADr_SIZE
typedef BCM84868_AN_IEEE_ADr_t AN_IEEE_ADr_t;
#define AN_IEEE_ADr_CLR BCM84868_AN_IEEE_ADr_CLR
#define AN_IEEE_ADr_SET BCM84868_AN_IEEE_ADr_SET
#define AN_IEEE_ADr_GET BCM84868_AN_IEEE_ADr_GET
#define AN_IEEE_ADr_NEXT_PAGEf_GET BCM84868_AN_IEEE_ADr_NEXT_PAGEf_GET
#define AN_IEEE_ADr_NEXT_PAGEf_SET BCM84868_AN_IEEE_ADr_NEXT_PAGEf_SET
#define AN_IEEE_ADr_ACKNOWLEDGEf_GET BCM84868_AN_IEEE_ADr_ACKNOWLEDGEf_GET
#define AN_IEEE_ADr_ACKNOWLEDGEf_SET BCM84868_AN_IEEE_ADr_ACKNOWLEDGEf_SET
#define AN_IEEE_ADr_REMOTE_FAULTf_GET BCM84868_AN_IEEE_ADr_REMOTE_FAULTf_GET
#define AN_IEEE_ADr_REMOTE_FAULTf_SET BCM84868_AN_IEEE_ADr_REMOTE_FAULTf_SET
#define AN_IEEE_ADr_XNPf_GET BCM84868_AN_IEEE_ADr_XNPf_GET
#define AN_IEEE_ADr_XNPf_SET BCM84868_AN_IEEE_ADr_XNPf_SET
#define AN_IEEE_ADr_TECHNOLOGY_ABILf_GET BCM84868_AN_IEEE_ADr_TECHNOLOGY_ABILf_GET
#define AN_IEEE_ADr_TECHNOLOGY_ABILf_SET BCM84868_AN_IEEE_ADr_TECHNOLOGY_ABILf_SET
#define AN_IEEE_ADr_SELECTORf_GET BCM84868_AN_IEEE_ADr_SELECTORf_GET
#define AN_IEEE_ADr_SELECTORf_SET BCM84868_AN_IEEE_ADr_SELECTORf_SET
#define READ_AN_IEEE_ADr BCM84868_READ_AN_IEEE_ADr
#define WRITE_AN_IEEE_ADr BCM84868_WRITE_AN_IEEE_ADr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_ADr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_ADB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0011
 * DEVAD:    7
 * DESC:     AutoNegAdv2 Register
 * SIZE:     32
 * FIELDS:
 *     TX_NONCE         
 *     TECH_ABIL_10_0   
 */
#define BCM84868_AN_IEEE_ADBr (0x00070011 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_ADBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_ADB.
 */
typedef union BCM84868_AN_IEEE_ADBr_s {
	uint32_t v[1];
	uint32_t an_ieee_adb[1];
	uint32_t _an_ieee_adb;
} BCM84868_AN_IEEE_ADBr_t;

#define BCM84868_AN_IEEE_ADBr_CLR(r) (r).an_ieee_adb[0] = 0
#define BCM84868_AN_IEEE_ADBr_SET(r,d) (r).an_ieee_adb[0] = d
#define BCM84868_AN_IEEE_ADBr_GET(r) (r).an_ieee_adb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_ADBr_TECH_ABIL_10_0f_GET(r) ((((r).an_ieee_adb[0]) >> 5) & 0x7ff)
#define BCM84868_AN_IEEE_ADBr_TECH_ABIL_10_0f_SET(r,f) (r).an_ieee_adb[0]=(((r).an_ieee_adb[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM84868_AN_IEEE_ADBr_TX_NONCEf_GET(r) (((r).an_ieee_adb[0]) & 0x1f)
#define BCM84868_AN_IEEE_ADBr_TX_NONCEf_SET(r,f) (r).an_ieee_adb[0]=(((r).an_ieee_adb[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access AN_IEEE_ADB.
 */
#define BCM84868_READ_AN_IEEE_ADBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_ADBr,(_r._an_ieee_adb))
#define BCM84868_WRITE_AN_IEEE_ADBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_ADBr,(_r._an_ieee_adb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_ADBr BCM84868_AN_IEEE_ADBr
#define AN_IEEE_ADBr_SIZE BCM84868_AN_IEEE_ADBr_SIZE
typedef BCM84868_AN_IEEE_ADBr_t AN_IEEE_ADBr_t;
#define AN_IEEE_ADBr_CLR BCM84868_AN_IEEE_ADBr_CLR
#define AN_IEEE_ADBr_SET BCM84868_AN_IEEE_ADBr_SET
#define AN_IEEE_ADBr_GET BCM84868_AN_IEEE_ADBr_GET
#define AN_IEEE_ADBr_TECH_ABIL_10_0f_GET BCM84868_AN_IEEE_ADBr_TECH_ABIL_10_0f_GET
#define AN_IEEE_ADBr_TECH_ABIL_10_0f_SET BCM84868_AN_IEEE_ADBr_TECH_ABIL_10_0f_SET
#define AN_IEEE_ADBr_TX_NONCEf_GET BCM84868_AN_IEEE_ADBr_TX_NONCEf_GET
#define AN_IEEE_ADBr_TX_NONCEf_SET BCM84868_AN_IEEE_ADBr_TX_NONCEf_SET
#define READ_AN_IEEE_ADBr BCM84868_READ_AN_IEEE_ADBr
#define WRITE_AN_IEEE_ADBr BCM84868_WRITE_AN_IEEE_ADBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_ADBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_ADC
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0012
 * DEVAD:    7
 * DESC:     AutoNegAdv3 Register
 * SIZE:     32
 * FIELDS:
 *     TECH_ABIL_24_11  
 *     FEC_CAP          
 */
#define BCM84868_AN_IEEE_ADCr (0x00070012 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_ADCr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_ADC.
 */
typedef union BCM84868_AN_IEEE_ADCr_s {
	uint32_t v[1];
	uint32_t an_ieee_adc[1];
	uint32_t _an_ieee_adc;
} BCM84868_AN_IEEE_ADCr_t;

#define BCM84868_AN_IEEE_ADCr_CLR(r) (r).an_ieee_adc[0] = 0
#define BCM84868_AN_IEEE_ADCr_SET(r,d) (r).an_ieee_adc[0] = d
#define BCM84868_AN_IEEE_ADCr_GET(r) (r).an_ieee_adc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_ADCr_FEC_CAPf_GET(r) ((((r).an_ieee_adc[0]) >> 14) & 0x3)
#define BCM84868_AN_IEEE_ADCr_FEC_CAPf_SET(r,f) (r).an_ieee_adc[0]=(((r).an_ieee_adc[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM84868_AN_IEEE_ADCr_TECH_ABIL_24_11f_GET(r) (((r).an_ieee_adc[0]) & 0x3fff)
#define BCM84868_AN_IEEE_ADCr_TECH_ABIL_24_11f_SET(r,f) (r).an_ieee_adc[0]=(((r).an_ieee_adc[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access AN_IEEE_ADC.
 */
#define BCM84868_READ_AN_IEEE_ADCr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_ADCr,(_r._an_ieee_adc))
#define BCM84868_WRITE_AN_IEEE_ADCr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_ADCr,(_r._an_ieee_adc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_ADCr BCM84868_AN_IEEE_ADCr
#define AN_IEEE_ADCr_SIZE BCM84868_AN_IEEE_ADCr_SIZE
typedef BCM84868_AN_IEEE_ADCr_t AN_IEEE_ADCr_t;
#define AN_IEEE_ADCr_CLR BCM84868_AN_IEEE_ADCr_CLR
#define AN_IEEE_ADCr_SET BCM84868_AN_IEEE_ADCr_SET
#define AN_IEEE_ADCr_GET BCM84868_AN_IEEE_ADCr_GET
#define AN_IEEE_ADCr_FEC_CAPf_GET BCM84868_AN_IEEE_ADCr_FEC_CAPf_GET
#define AN_IEEE_ADCr_FEC_CAPf_SET BCM84868_AN_IEEE_ADCr_FEC_CAPf_SET
#define AN_IEEE_ADCr_TECH_ABIL_24_11f_GET BCM84868_AN_IEEE_ADCr_TECH_ABIL_24_11f_GET
#define AN_IEEE_ADCr_TECH_ABIL_24_11f_SET BCM84868_AN_IEEE_ADCr_TECH_ABIL_24_11f_SET
#define READ_AN_IEEE_ADCr BCM84868_READ_AN_IEEE_ADCr
#define WRITE_AN_IEEE_ADCr BCM84868_WRITE_AN_IEEE_ADCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_ADCr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_LPA
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0013
 * DEVAD:    7
 * DESC:     AutoNegLpBasePageAbility Register
 * SIZE:     32
 * FIELDS:
 *     AN_LP_BASE_PAGE  
 */
#define BCM84868_AN_IEEE_LPAr (0x00070013 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_LPAr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_LPA.
 */
typedef union BCM84868_AN_IEEE_LPAr_s {
	uint32_t v[1];
	uint32_t an_ieee_lpa[1];
	uint32_t _an_ieee_lpa;
} BCM84868_AN_IEEE_LPAr_t;

#define BCM84868_AN_IEEE_LPAr_CLR(r) (r).an_ieee_lpa[0] = 0
#define BCM84868_AN_IEEE_LPAr_SET(r,d) (r).an_ieee_lpa[0] = d
#define BCM84868_AN_IEEE_LPAr_GET(r) (r).an_ieee_lpa[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_LPAr_AN_LP_BASE_PAGEf_GET(r) (((r).an_ieee_lpa[0]) & 0xffff)
#define BCM84868_AN_IEEE_LPAr_AN_LP_BASE_PAGEf_SET(r,f) (r).an_ieee_lpa[0]=(((r).an_ieee_lpa[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_LPA.
 */
#define BCM84868_READ_AN_IEEE_LPAr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_LPAr,(_r._an_ieee_lpa))
#define BCM84868_WRITE_AN_IEEE_LPAr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_LPAr,(_r._an_ieee_lpa))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_LPAr BCM84868_AN_IEEE_LPAr
#define AN_IEEE_LPAr_SIZE BCM84868_AN_IEEE_LPAr_SIZE
typedef BCM84868_AN_IEEE_LPAr_t AN_IEEE_LPAr_t;
#define AN_IEEE_LPAr_CLR BCM84868_AN_IEEE_LPAr_CLR
#define AN_IEEE_LPAr_SET BCM84868_AN_IEEE_LPAr_SET
#define AN_IEEE_LPAr_GET BCM84868_AN_IEEE_LPAr_GET
#define AN_IEEE_LPAr_AN_LP_BASE_PAGEf_GET BCM84868_AN_IEEE_LPAr_AN_LP_BASE_PAGEf_GET
#define AN_IEEE_LPAr_AN_LP_BASE_PAGEf_SET BCM84868_AN_IEEE_LPAr_AN_LP_BASE_PAGEf_SET
#define READ_AN_IEEE_LPAr BCM84868_READ_AN_IEEE_LPAr
#define WRITE_AN_IEEE_LPAr BCM84868_WRITE_AN_IEEE_LPAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_LPAr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_LPB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0014
 * DEVAD:    7
 * DESC:     AutoNegLpBasePageAbility2 Register
 * SIZE:     32
 * FIELDS:
 *     AN_LP_BASE_PAGE  
 */
#define BCM84868_AN_IEEE_LPBr (0x00070014 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_LPBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_LPB.
 */
typedef union BCM84868_AN_IEEE_LPBr_s {
	uint32_t v[1];
	uint32_t an_ieee_lpb[1];
	uint32_t _an_ieee_lpb;
} BCM84868_AN_IEEE_LPBr_t;

#define BCM84868_AN_IEEE_LPBr_CLR(r) (r).an_ieee_lpb[0] = 0
#define BCM84868_AN_IEEE_LPBr_SET(r,d) (r).an_ieee_lpb[0] = d
#define BCM84868_AN_IEEE_LPBr_GET(r) (r).an_ieee_lpb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_LPBr_AN_LP_BASE_PAGEf_GET(r) (((r).an_ieee_lpb[0]) & 0xffff)
#define BCM84868_AN_IEEE_LPBr_AN_LP_BASE_PAGEf_SET(r,f) (r).an_ieee_lpb[0]=(((r).an_ieee_lpb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_LPB.
 */
#define BCM84868_READ_AN_IEEE_LPBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_LPBr,(_r._an_ieee_lpb))
#define BCM84868_WRITE_AN_IEEE_LPBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_LPBr,(_r._an_ieee_lpb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_LPBr BCM84868_AN_IEEE_LPBr
#define AN_IEEE_LPBr_SIZE BCM84868_AN_IEEE_LPBr_SIZE
typedef BCM84868_AN_IEEE_LPBr_t AN_IEEE_LPBr_t;
#define AN_IEEE_LPBr_CLR BCM84868_AN_IEEE_LPBr_CLR
#define AN_IEEE_LPBr_SET BCM84868_AN_IEEE_LPBr_SET
#define AN_IEEE_LPBr_GET BCM84868_AN_IEEE_LPBr_GET
#define AN_IEEE_LPBr_AN_LP_BASE_PAGEf_GET BCM84868_AN_IEEE_LPBr_AN_LP_BASE_PAGEf_GET
#define AN_IEEE_LPBr_AN_LP_BASE_PAGEf_SET BCM84868_AN_IEEE_LPBr_AN_LP_BASE_PAGEf_SET
#define READ_AN_IEEE_LPBr BCM84868_READ_AN_IEEE_LPBr
#define WRITE_AN_IEEE_LPBr BCM84868_WRITE_AN_IEEE_LPBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_LPBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_LPC
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0015
 * DEVAD:    7
 * DESC:     AutoNegLpBasePageAbility3 Register
 * SIZE:     32
 * FIELDS:
 *     AN_LP_BASE_PAGE  
 */
#define BCM84868_AN_IEEE_LPCr (0x00070015 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_LPCr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_LPC.
 */
typedef union BCM84868_AN_IEEE_LPCr_s {
	uint32_t v[1];
	uint32_t an_ieee_lpc[1];
	uint32_t _an_ieee_lpc;
} BCM84868_AN_IEEE_LPCr_t;

#define BCM84868_AN_IEEE_LPCr_CLR(r) (r).an_ieee_lpc[0] = 0
#define BCM84868_AN_IEEE_LPCr_SET(r,d) (r).an_ieee_lpc[0] = d
#define BCM84868_AN_IEEE_LPCr_GET(r) (r).an_ieee_lpc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_LPCr_AN_LP_BASE_PAGEf_GET(r) (((r).an_ieee_lpc[0]) & 0xffff)
#define BCM84868_AN_IEEE_LPCr_AN_LP_BASE_PAGEf_SET(r,f) (r).an_ieee_lpc[0]=(((r).an_ieee_lpc[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_LPC.
 */
#define BCM84868_READ_AN_IEEE_LPCr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_LPCr,(_r._an_ieee_lpc))
#define BCM84868_WRITE_AN_IEEE_LPCr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_LPCr,(_r._an_ieee_lpc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_LPCr BCM84868_AN_IEEE_LPCr
#define AN_IEEE_LPCr_SIZE BCM84868_AN_IEEE_LPCr_SIZE
typedef BCM84868_AN_IEEE_LPCr_t AN_IEEE_LPCr_t;
#define AN_IEEE_LPCr_CLR BCM84868_AN_IEEE_LPCr_CLR
#define AN_IEEE_LPCr_SET BCM84868_AN_IEEE_LPCr_SET
#define AN_IEEE_LPCr_GET BCM84868_AN_IEEE_LPCr_GET
#define AN_IEEE_LPCr_AN_LP_BASE_PAGEf_GET BCM84868_AN_IEEE_LPCr_AN_LP_BASE_PAGEf_GET
#define AN_IEEE_LPCr_AN_LP_BASE_PAGEf_SET BCM84868_AN_IEEE_LPCr_AN_LP_BASE_PAGEf_SET
#define READ_AN_IEEE_LPCr BCM84868_READ_AN_IEEE_LPCr
#define WRITE_AN_IEEE_LPCr BCM84868_WRITE_AN_IEEE_LPCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_LPCr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_XNPA
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0016
 * DEVAD:    7
 * DESC:     AN_IEEE_XNPA Register
 * SIZE:     32
 * FIELDS:
 *     MESSAGE_UNFORMATTED_CODE 
 *     TOGGLE           
 *     ACKNOWLEDGE2     
 *     MESSAGE_PAGE     
 *     NEXT_PAGE        
 */
#define BCM84868_AN_IEEE_XNPAr (0x00070016 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_XNPAr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_XNPA.
 */
typedef union BCM84868_AN_IEEE_XNPAr_s {
	uint32_t v[1];
	uint32_t an_ieee_xnpa[1];
	uint32_t _an_ieee_xnpa;
} BCM84868_AN_IEEE_XNPAr_t;

#define BCM84868_AN_IEEE_XNPAr_CLR(r) (r).an_ieee_xnpa[0] = 0
#define BCM84868_AN_IEEE_XNPAr_SET(r,d) (r).an_ieee_xnpa[0] = d
#define BCM84868_AN_IEEE_XNPAr_GET(r) (r).an_ieee_xnpa[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_XNPAr_NEXT_PAGEf_GET(r) ((((r).an_ieee_xnpa[0]) >> 15) & 0x1)
#define BCM84868_AN_IEEE_XNPAr_NEXT_PAGEf_SET(r,f) (r).an_ieee_xnpa[0]=(((r).an_ieee_xnpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_AN_IEEE_XNPAr_MESSAGE_PAGEf_GET(r) ((((r).an_ieee_xnpa[0]) >> 13) & 0x1)
#define BCM84868_AN_IEEE_XNPAr_MESSAGE_PAGEf_SET(r,f) (r).an_ieee_xnpa[0]=(((r).an_ieee_xnpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_AN_IEEE_XNPAr_ACKNOWLEDGE2f_GET(r) ((((r).an_ieee_xnpa[0]) >> 12) & 0x1)
#define BCM84868_AN_IEEE_XNPAr_ACKNOWLEDGE2f_SET(r,f) (r).an_ieee_xnpa[0]=(((r).an_ieee_xnpa[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_AN_IEEE_XNPAr_TOGGLEf_GET(r) ((((r).an_ieee_xnpa[0]) >> 11) & 0x1)
#define BCM84868_AN_IEEE_XNPAr_TOGGLEf_SET(r,f) (r).an_ieee_xnpa[0]=(((r).an_ieee_xnpa[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_AN_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_GET(r) (((r).an_ieee_xnpa[0]) & 0x7ff)
#define BCM84868_AN_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_SET(r,f) (r).an_ieee_xnpa[0]=(((r).an_ieee_xnpa[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access AN_IEEE_XNPA.
 */
#define BCM84868_READ_AN_IEEE_XNPAr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_XNPAr,(_r._an_ieee_xnpa))
#define BCM84868_WRITE_AN_IEEE_XNPAr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_XNPAr,(_r._an_ieee_xnpa))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_XNPAr BCM84868_AN_IEEE_XNPAr
#define AN_IEEE_XNPAr_SIZE BCM84868_AN_IEEE_XNPAr_SIZE
typedef BCM84868_AN_IEEE_XNPAr_t AN_IEEE_XNPAr_t;
#define AN_IEEE_XNPAr_CLR BCM84868_AN_IEEE_XNPAr_CLR
#define AN_IEEE_XNPAr_SET BCM84868_AN_IEEE_XNPAr_SET
#define AN_IEEE_XNPAr_GET BCM84868_AN_IEEE_XNPAr_GET
#define AN_IEEE_XNPAr_NEXT_PAGEf_GET BCM84868_AN_IEEE_XNPAr_NEXT_PAGEf_GET
#define AN_IEEE_XNPAr_NEXT_PAGEf_SET BCM84868_AN_IEEE_XNPAr_NEXT_PAGEf_SET
#define AN_IEEE_XNPAr_MESSAGE_PAGEf_GET BCM84868_AN_IEEE_XNPAr_MESSAGE_PAGEf_GET
#define AN_IEEE_XNPAr_MESSAGE_PAGEf_SET BCM84868_AN_IEEE_XNPAr_MESSAGE_PAGEf_SET
#define AN_IEEE_XNPAr_ACKNOWLEDGE2f_GET BCM84868_AN_IEEE_XNPAr_ACKNOWLEDGE2f_GET
#define AN_IEEE_XNPAr_ACKNOWLEDGE2f_SET BCM84868_AN_IEEE_XNPAr_ACKNOWLEDGE2f_SET
#define AN_IEEE_XNPAr_TOGGLEf_GET BCM84868_AN_IEEE_XNPAr_TOGGLEf_GET
#define AN_IEEE_XNPAr_TOGGLEf_SET BCM84868_AN_IEEE_XNPAr_TOGGLEf_SET
#define AN_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_GET BCM84868_AN_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_GET
#define AN_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_SET BCM84868_AN_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_SET
#define READ_AN_IEEE_XNPAr BCM84868_READ_AN_IEEE_XNPAr
#define WRITE_AN_IEEE_XNPAr BCM84868_WRITE_AN_IEEE_XNPAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_XNPAr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_XNPB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0017
 * DEVAD:    7
 * DESC:     AN_IEEE_XNPB Register
 * SIZE:     32
 * FIELDS:
 *     MESSAGE_UNFORMATTED_CODE 
 */
#define BCM84868_AN_IEEE_XNPBr (0x00070017 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_XNPBr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_XNPB.
 */
typedef union BCM84868_AN_IEEE_XNPBr_s {
	uint32_t v[1];
	uint32_t an_ieee_xnpb[1];
	uint32_t _an_ieee_xnpb;
} BCM84868_AN_IEEE_XNPBr_t;

#define BCM84868_AN_IEEE_XNPBr_CLR(r) (r).an_ieee_xnpb[0] = 0
#define BCM84868_AN_IEEE_XNPBr_SET(r,d) (r).an_ieee_xnpb[0] = d
#define BCM84868_AN_IEEE_XNPBr_GET(r) (r).an_ieee_xnpb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_GET(r) (((r).an_ieee_xnpb[0]) & 0xffff)
#define BCM84868_AN_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_SET(r,f) (r).an_ieee_xnpb[0]=(((r).an_ieee_xnpb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_XNPB.
 */
#define BCM84868_READ_AN_IEEE_XNPBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_XNPBr,(_r._an_ieee_xnpb))
#define BCM84868_WRITE_AN_IEEE_XNPBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_XNPBr,(_r._an_ieee_xnpb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_XNPBr BCM84868_AN_IEEE_XNPBr
#define AN_IEEE_XNPBr_SIZE BCM84868_AN_IEEE_XNPBr_SIZE
typedef BCM84868_AN_IEEE_XNPBr_t AN_IEEE_XNPBr_t;
#define AN_IEEE_XNPBr_CLR BCM84868_AN_IEEE_XNPBr_CLR
#define AN_IEEE_XNPBr_SET BCM84868_AN_IEEE_XNPBr_SET
#define AN_IEEE_XNPBr_GET BCM84868_AN_IEEE_XNPBr_GET
#define AN_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_GET BCM84868_AN_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_GET
#define AN_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_SET BCM84868_AN_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_SET
#define READ_AN_IEEE_XNPBr BCM84868_READ_AN_IEEE_XNPBr
#define WRITE_AN_IEEE_XNPBr BCM84868_WRITE_AN_IEEE_XNPBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_XNPBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  AN_IEEE_XNPC
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0018
 * DEVAD:    7
 * DESC:     AN_IEEE_XNPC Register
 * SIZE:     32
 * FIELDS:
 *     MESSAGE_UNFORMATTED_CODE 
 */
#define BCM84868_AN_IEEE_XNPCr (0x00070018 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_AN_IEEE_XNPCr_SIZE 4

/*
 * This structure should be used to declare and program AN_IEEE_XNPC.
 */
typedef union BCM84868_AN_IEEE_XNPCr_s {
	uint32_t v[1];
	uint32_t an_ieee_xnpc[1];
	uint32_t _an_ieee_xnpc;
} BCM84868_AN_IEEE_XNPCr_t;

#define BCM84868_AN_IEEE_XNPCr_CLR(r) (r).an_ieee_xnpc[0] = 0
#define BCM84868_AN_IEEE_XNPCr_SET(r,d) (r).an_ieee_xnpc[0] = d
#define BCM84868_AN_IEEE_XNPCr_GET(r) (r).an_ieee_xnpc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_AN_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_GET(r) (((r).an_ieee_xnpc[0]) & 0xffff)
#define BCM84868_AN_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_SET(r,f) (r).an_ieee_xnpc[0]=(((r).an_ieee_xnpc[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AN_IEEE_XNPC.
 */
#define BCM84868_READ_AN_IEEE_XNPCr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_AN_IEEE_XNPCr,(_r._an_ieee_xnpc))
#define BCM84868_WRITE_AN_IEEE_XNPCr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_AN_IEEE_XNPCr,(_r._an_ieee_xnpc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define AN_IEEE_XNPCr BCM84868_AN_IEEE_XNPCr
#define AN_IEEE_XNPCr_SIZE BCM84868_AN_IEEE_XNPCr_SIZE
typedef BCM84868_AN_IEEE_XNPCr_t AN_IEEE_XNPCr_t;
#define AN_IEEE_XNPCr_CLR BCM84868_AN_IEEE_XNPCr_CLR
#define AN_IEEE_XNPCr_SET BCM84868_AN_IEEE_XNPCr_SET
#define AN_IEEE_XNPCr_GET BCM84868_AN_IEEE_XNPCr_GET
#define AN_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_GET BCM84868_AN_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_GET
#define AN_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_SET BCM84868_AN_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_SET
#define READ_AN_IEEE_XNPCr BCM84868_READ_AN_IEEE_XNPCr
#define WRITE_AN_IEEE_XNPCr BCM84868_WRITE_AN_IEEE_XNPCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_AN_IEEE_XNPCr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  LP_IEEE_XNPA
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0019
 * DEVAD:    7
 * DESC:     AN_LP_XNP_Ability Register
 * SIZE:     32
 * FIELDS:
 *     MESSAGE_UNFORMATTED_CODE 
 *     TOGGLE           
 *     ACKNOWLEDGE2     
 *     MESSAGE_PAGE     
 *     NEXT_PAGE        
 */
#define BCM84868_LP_IEEE_XNPAr (0x00070019 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_LP_IEEE_XNPAr_SIZE 4

/*
 * This structure should be used to declare and program LP_IEEE_XNPA.
 */
typedef union BCM84868_LP_IEEE_XNPAr_s {
	uint32_t v[1];
	uint32_t lp_ieee_xnpa[1];
	uint32_t _lp_ieee_xnpa;
} BCM84868_LP_IEEE_XNPAr_t;

#define BCM84868_LP_IEEE_XNPAr_CLR(r) (r).lp_ieee_xnpa[0] = 0
#define BCM84868_LP_IEEE_XNPAr_SET(r,d) (r).lp_ieee_xnpa[0] = d
#define BCM84868_LP_IEEE_XNPAr_GET(r) (r).lp_ieee_xnpa[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_LP_IEEE_XNPAr_NEXT_PAGEf_GET(r) ((((r).lp_ieee_xnpa[0]) >> 15) & 0x1)
#define BCM84868_LP_IEEE_XNPAr_NEXT_PAGEf_SET(r,f) (r).lp_ieee_xnpa[0]=(((r).lp_ieee_xnpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_LP_IEEE_XNPAr_MESSAGE_PAGEf_GET(r) ((((r).lp_ieee_xnpa[0]) >> 13) & 0x1)
#define BCM84868_LP_IEEE_XNPAr_MESSAGE_PAGEf_SET(r,f) (r).lp_ieee_xnpa[0]=(((r).lp_ieee_xnpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_LP_IEEE_XNPAr_ACKNOWLEDGE2f_GET(r) ((((r).lp_ieee_xnpa[0]) >> 12) & 0x1)
#define BCM84868_LP_IEEE_XNPAr_ACKNOWLEDGE2f_SET(r,f) (r).lp_ieee_xnpa[0]=(((r).lp_ieee_xnpa[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_LP_IEEE_XNPAr_TOGGLEf_GET(r) ((((r).lp_ieee_xnpa[0]) >> 11) & 0x1)
#define BCM84868_LP_IEEE_XNPAr_TOGGLEf_SET(r,f) (r).lp_ieee_xnpa[0]=(((r).lp_ieee_xnpa[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_LP_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_GET(r) (((r).lp_ieee_xnpa[0]) & 0x7ff)
#define BCM84868_LP_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_SET(r,f) (r).lp_ieee_xnpa[0]=(((r).lp_ieee_xnpa[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access LP_IEEE_XNPA.
 */
#define BCM84868_READ_LP_IEEE_XNPAr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_LP_IEEE_XNPAr,(_r._lp_ieee_xnpa))
#define BCM84868_WRITE_LP_IEEE_XNPAr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_LP_IEEE_XNPAr,(_r._lp_ieee_xnpa))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_IEEE_XNPAr BCM84868_LP_IEEE_XNPAr
#define LP_IEEE_XNPAr_SIZE BCM84868_LP_IEEE_XNPAr_SIZE
typedef BCM84868_LP_IEEE_XNPAr_t LP_IEEE_XNPAr_t;
#define LP_IEEE_XNPAr_CLR BCM84868_LP_IEEE_XNPAr_CLR
#define LP_IEEE_XNPAr_SET BCM84868_LP_IEEE_XNPAr_SET
#define LP_IEEE_XNPAr_GET BCM84868_LP_IEEE_XNPAr_GET
#define LP_IEEE_XNPAr_NEXT_PAGEf_GET BCM84868_LP_IEEE_XNPAr_NEXT_PAGEf_GET
#define LP_IEEE_XNPAr_NEXT_PAGEf_SET BCM84868_LP_IEEE_XNPAr_NEXT_PAGEf_SET
#define LP_IEEE_XNPAr_MESSAGE_PAGEf_GET BCM84868_LP_IEEE_XNPAr_MESSAGE_PAGEf_GET
#define LP_IEEE_XNPAr_MESSAGE_PAGEf_SET BCM84868_LP_IEEE_XNPAr_MESSAGE_PAGEf_SET
#define LP_IEEE_XNPAr_ACKNOWLEDGE2f_GET BCM84868_LP_IEEE_XNPAr_ACKNOWLEDGE2f_GET
#define LP_IEEE_XNPAr_ACKNOWLEDGE2f_SET BCM84868_LP_IEEE_XNPAr_ACKNOWLEDGE2f_SET
#define LP_IEEE_XNPAr_TOGGLEf_GET BCM84868_LP_IEEE_XNPAr_TOGGLEf_GET
#define LP_IEEE_XNPAr_TOGGLEf_SET BCM84868_LP_IEEE_XNPAr_TOGGLEf_SET
#define LP_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_GET BCM84868_LP_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_GET
#define LP_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_SET BCM84868_LP_IEEE_XNPAr_MESSAGE_UNFORMATTED_CODEf_SET
#define READ_LP_IEEE_XNPAr BCM84868_READ_LP_IEEE_XNPAr
#define WRITE_LP_IEEE_XNPAr BCM84868_WRITE_LP_IEEE_XNPAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_LP_IEEE_XNPAr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  LP_IEEE_XNPB
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x001a
 * DEVAD:    7
 * DESC:     AN_LP_XNP_Ability2 Register
 * SIZE:     32
 * FIELDS:
 *     MESSAGE_UNFORMATTED_CODE 
 */
#define BCM84868_LP_IEEE_XNPBr (0x0007001a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_LP_IEEE_XNPBr_SIZE 4

/*
 * This structure should be used to declare and program LP_IEEE_XNPB.
 */
typedef union BCM84868_LP_IEEE_XNPBr_s {
	uint32_t v[1];
	uint32_t lp_ieee_xnpb[1];
	uint32_t _lp_ieee_xnpb;
} BCM84868_LP_IEEE_XNPBr_t;

#define BCM84868_LP_IEEE_XNPBr_CLR(r) (r).lp_ieee_xnpb[0] = 0
#define BCM84868_LP_IEEE_XNPBr_SET(r,d) (r).lp_ieee_xnpb[0] = d
#define BCM84868_LP_IEEE_XNPBr_GET(r) (r).lp_ieee_xnpb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_LP_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_GET(r) (((r).lp_ieee_xnpb[0]) & 0xffff)
#define BCM84868_LP_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_SET(r,f) (r).lp_ieee_xnpb[0]=(((r).lp_ieee_xnpb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_IEEE_XNPB.
 */
#define BCM84868_READ_LP_IEEE_XNPBr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_LP_IEEE_XNPBr,(_r._lp_ieee_xnpb))
#define BCM84868_WRITE_LP_IEEE_XNPBr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_LP_IEEE_XNPBr,(_r._lp_ieee_xnpb))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_IEEE_XNPBr BCM84868_LP_IEEE_XNPBr
#define LP_IEEE_XNPBr_SIZE BCM84868_LP_IEEE_XNPBr_SIZE
typedef BCM84868_LP_IEEE_XNPBr_t LP_IEEE_XNPBr_t;
#define LP_IEEE_XNPBr_CLR BCM84868_LP_IEEE_XNPBr_CLR
#define LP_IEEE_XNPBr_SET BCM84868_LP_IEEE_XNPBr_SET
#define LP_IEEE_XNPBr_GET BCM84868_LP_IEEE_XNPBr_GET
#define LP_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_GET BCM84868_LP_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_GET
#define LP_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_SET BCM84868_LP_IEEE_XNPBr_MESSAGE_UNFORMATTED_CODEf_SET
#define READ_LP_IEEE_XNPBr BCM84868_READ_LP_IEEE_XNPBr
#define WRITE_LP_IEEE_XNPBr BCM84868_WRITE_LP_IEEE_XNPBr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_LP_IEEE_XNPBr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  LP_IEEE_XNPC
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x001b
 * DEVAD:    7
 * DESC:     AN_LP_XNP_Ability3 Register
 * SIZE:     32
 * FIELDS:
 *     MESSAGE_UNFORMATTED_CODE 
 */
#define BCM84868_LP_IEEE_XNPCr (0x0007001b | PHY_REG_ACC_BRCM_XE)

#define BCM84868_LP_IEEE_XNPCr_SIZE 4

/*
 * This structure should be used to declare and program LP_IEEE_XNPC.
 */
typedef union BCM84868_LP_IEEE_XNPCr_s {
	uint32_t v[1];
	uint32_t lp_ieee_xnpc[1];
	uint32_t _lp_ieee_xnpc;
} BCM84868_LP_IEEE_XNPCr_t;

#define BCM84868_LP_IEEE_XNPCr_CLR(r) (r).lp_ieee_xnpc[0] = 0
#define BCM84868_LP_IEEE_XNPCr_SET(r,d) (r).lp_ieee_xnpc[0] = d
#define BCM84868_LP_IEEE_XNPCr_GET(r) (r).lp_ieee_xnpc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_LP_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_GET(r) (((r).lp_ieee_xnpc[0]) & 0xffff)
#define BCM84868_LP_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_SET(r,f) (r).lp_ieee_xnpc[0]=(((r).lp_ieee_xnpc[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LP_IEEE_XNPC.
 */
#define BCM84868_READ_LP_IEEE_XNPCr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_LP_IEEE_XNPCr,(_r._lp_ieee_xnpc))
#define BCM84868_WRITE_LP_IEEE_XNPCr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_LP_IEEE_XNPCr,(_r._lp_ieee_xnpc))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define LP_IEEE_XNPCr BCM84868_LP_IEEE_XNPCr
#define LP_IEEE_XNPCr_SIZE BCM84868_LP_IEEE_XNPCr_SIZE
typedef BCM84868_LP_IEEE_XNPCr_t LP_IEEE_XNPCr_t;
#define LP_IEEE_XNPCr_CLR BCM84868_LP_IEEE_XNPCr_CLR
#define LP_IEEE_XNPCr_SET BCM84868_LP_IEEE_XNPCr_SET
#define LP_IEEE_XNPCr_GET BCM84868_LP_IEEE_XNPCr_GET
#define LP_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_GET BCM84868_LP_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_GET
#define LP_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_SET BCM84868_LP_IEEE_XNPCr_MESSAGE_UNFORMATTED_CODEf_SET
#define READ_LP_IEEE_XNPCr BCM84868_READ_LP_IEEE_XNPCr
#define WRITE_LP_IEEE_XNPCr BCM84868_WRITE_LP_IEEE_XNPCr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_LP_IEEE_XNPCr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TENG_AN_CTRL
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0020
 * DEVAD:    7
 * DESC:     10GBaseT_AutoNegCtrl Register
 * SIZE:     32
 * FIELDS:
 *     LD_LOOP_TIMING_ABIL 
 *     LDPMA_TRAINING_RESET_REQUEST 
 *     X10GBT           
 */
#define BCM84868_TENG_AN_CTRLr (0x00070020 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TENG_AN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program TENG_AN_CTRL.
 */
typedef union BCM84868_TENG_AN_CTRLr_s {
	uint32_t v[1];
	uint32_t teng_an_ctrl[1];
	uint32_t _teng_an_ctrl;
} BCM84868_TENG_AN_CTRLr_t;

#define BCM84868_TENG_AN_CTRLr_CLR(r) (r).teng_an_ctrl[0] = 0
#define BCM84868_TENG_AN_CTRLr_SET(r,d) (r).teng_an_ctrl[0] = d
#define BCM84868_TENG_AN_CTRLr_GET(r) (r).teng_an_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TENG_AN_CTRLr_X10GBTf_GET(r) ((((r).teng_an_ctrl[0]) >> 12) & 0x1)
#define BCM84868_TENG_AN_CTRLr_X10GBTf_SET(r,f) (r).teng_an_ctrl[0]=(((r).teng_an_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_TENG_AN_CTRLr_LDPMA_TRAINING_RESET_REQUESTf_GET(r) ((((r).teng_an_ctrl[0]) >> 2) & 0x1)
#define BCM84868_TENG_AN_CTRLr_LDPMA_TRAINING_RESET_REQUESTf_SET(r,f) (r).teng_an_ctrl[0]=(((r).teng_an_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_TENG_AN_CTRLr_LD_LOOP_TIMING_ABILf_GET(r) (((r).teng_an_ctrl[0]) & 0x1)
#define BCM84868_TENG_AN_CTRLr_LD_LOOP_TIMING_ABILf_SET(r,f) (r).teng_an_ctrl[0]=(((r).teng_an_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access TENG_AN_CTRL.
 */
#define BCM84868_READ_TENG_AN_CTRLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TENG_AN_CTRLr,(_r._teng_an_ctrl))
#define BCM84868_WRITE_TENG_AN_CTRLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TENG_AN_CTRLr,(_r._teng_an_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TENG_AN_CTRLr BCM84868_TENG_AN_CTRLr
#define TENG_AN_CTRLr_SIZE BCM84868_TENG_AN_CTRLr_SIZE
typedef BCM84868_TENG_AN_CTRLr_t TENG_AN_CTRLr_t;
#define TENG_AN_CTRLr_CLR BCM84868_TENG_AN_CTRLr_CLR
#define TENG_AN_CTRLr_SET BCM84868_TENG_AN_CTRLr_SET
#define TENG_AN_CTRLr_GET BCM84868_TENG_AN_CTRLr_GET
#define TENG_AN_CTRLr_X10GBTf_GET BCM84868_TENG_AN_CTRLr_X10GBTf_GET
#define TENG_AN_CTRLr_X10GBTf_SET BCM84868_TENG_AN_CTRLr_X10GBTf_SET
#define TENG_AN_CTRLr_LDPMA_TRAINING_RESET_REQUESTf_GET BCM84868_TENG_AN_CTRLr_LDPMA_TRAINING_RESET_REQUESTf_GET
#define TENG_AN_CTRLr_LDPMA_TRAINING_RESET_REQUESTf_SET BCM84868_TENG_AN_CTRLr_LDPMA_TRAINING_RESET_REQUESTf_SET
#define TENG_AN_CTRLr_LD_LOOP_TIMING_ABILf_GET BCM84868_TENG_AN_CTRLr_LD_LOOP_TIMING_ABILf_GET
#define TENG_AN_CTRLr_LD_LOOP_TIMING_ABILf_SET BCM84868_TENG_AN_CTRLr_LD_LOOP_TIMING_ABILf_SET
#define READ_TENG_AN_CTRLr BCM84868_READ_TENG_AN_CTRLr
#define WRITE_TENG_AN_CTRLr BCM84868_WRITE_TENG_AN_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TENG_AN_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TENG_AN_STAT
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x0021
 * DEVAD:    7
 * DESC:     10GBaseT_AutoNegStat Register
 * SIZE:     32
 * FIELDS:
 *     LP_PMA_TRAINING_RESET_REQ 
 *     LP_LOOP_TIMING_ABIL 
 *     LP_10GBT         
 *     REMOTE_RX_STAT   
 *     LOCAL_RX_STAT    
 *     MASTER_SLAVE_CONFIG_RES 
 *     MASTER_SLAVE_CONFIG_FAULT 
 */
#define BCM84868_TENG_AN_STATr (0x00070021 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TENG_AN_STATr_SIZE 4

/*
 * This structure should be used to declare and program TENG_AN_STAT.
 */
typedef union BCM84868_TENG_AN_STATr_s {
	uint32_t v[1];
	uint32_t teng_an_stat[1];
	uint32_t _teng_an_stat;
} BCM84868_TENG_AN_STATr_t;

#define BCM84868_TENG_AN_STATr_CLR(r) (r).teng_an_stat[0] = 0
#define BCM84868_TENG_AN_STATr_SET(r,d) (r).teng_an_stat[0] = d
#define BCM84868_TENG_AN_STATr_GET(r) (r).teng_an_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_FAULTf_GET(r) ((((r).teng_an_stat[0]) >> 15) & 0x1)
#define BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_FAULTf_SET(r,f) (r).teng_an_stat[0]=(((r).teng_an_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_RESf_GET(r) ((((r).teng_an_stat[0]) >> 14) & 0x1)
#define BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_RESf_SET(r,f) (r).teng_an_stat[0]=(((r).teng_an_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_TENG_AN_STATr_LOCAL_RX_STATf_GET(r) ((((r).teng_an_stat[0]) >> 13) & 0x1)
#define BCM84868_TENG_AN_STATr_LOCAL_RX_STATf_SET(r,f) (r).teng_an_stat[0]=(((r).teng_an_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_TENG_AN_STATr_REMOTE_RX_STATf_GET(r) ((((r).teng_an_stat[0]) >> 12) & 0x1)
#define BCM84868_TENG_AN_STATr_REMOTE_RX_STATf_SET(r,f) (r).teng_an_stat[0]=(((r).teng_an_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_TENG_AN_STATr_LP_10GBTf_GET(r) ((((r).teng_an_stat[0]) >> 11) & 0x1)
#define BCM84868_TENG_AN_STATr_LP_10GBTf_SET(r,f) (r).teng_an_stat[0]=(((r).teng_an_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_TENG_AN_STATr_LP_LOOP_TIMING_ABILf_GET(r) ((((r).teng_an_stat[0]) >> 10) & 0x1)
#define BCM84868_TENG_AN_STATr_LP_LOOP_TIMING_ABILf_SET(r,f) (r).teng_an_stat[0]=(((r).teng_an_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_TENG_AN_STATr_LP_PMA_TRAINING_RESET_REQf_GET(r) ((((r).teng_an_stat[0]) >> 9) & 0x1)
#define BCM84868_TENG_AN_STATr_LP_PMA_TRAINING_RESET_REQf_SET(r,f) (r).teng_an_stat[0]=(((r).teng_an_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access TENG_AN_STAT.
 */
#define BCM84868_READ_TENG_AN_STATr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TENG_AN_STATr,(_r._teng_an_stat))
#define BCM84868_WRITE_TENG_AN_STATr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TENG_AN_STATr,(_r._teng_an_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TENG_AN_STATr BCM84868_TENG_AN_STATr
#define TENG_AN_STATr_SIZE BCM84868_TENG_AN_STATr_SIZE
typedef BCM84868_TENG_AN_STATr_t TENG_AN_STATr_t;
#define TENG_AN_STATr_CLR BCM84868_TENG_AN_STATr_CLR
#define TENG_AN_STATr_SET BCM84868_TENG_AN_STATr_SET
#define TENG_AN_STATr_GET BCM84868_TENG_AN_STATr_GET
#define TENG_AN_STATr_MASTER_SLAVE_CONFIG_FAULTf_GET BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_FAULTf_GET
#define TENG_AN_STATr_MASTER_SLAVE_CONFIG_FAULTf_SET BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_FAULTf_SET
#define TENG_AN_STATr_MASTER_SLAVE_CONFIG_RESf_GET BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_RESf_GET
#define TENG_AN_STATr_MASTER_SLAVE_CONFIG_RESf_SET BCM84868_TENG_AN_STATr_MASTER_SLAVE_CONFIG_RESf_SET
#define TENG_AN_STATr_LOCAL_RX_STATf_GET BCM84868_TENG_AN_STATr_LOCAL_RX_STATf_GET
#define TENG_AN_STATr_LOCAL_RX_STATf_SET BCM84868_TENG_AN_STATr_LOCAL_RX_STATf_SET
#define TENG_AN_STATr_REMOTE_RX_STATf_GET BCM84868_TENG_AN_STATr_REMOTE_RX_STATf_GET
#define TENG_AN_STATr_REMOTE_RX_STATf_SET BCM84868_TENG_AN_STATr_REMOTE_RX_STATf_SET
#define TENG_AN_STATr_LP_10GBTf_GET BCM84868_TENG_AN_STATr_LP_10GBTf_GET
#define TENG_AN_STATr_LP_10GBTf_SET BCM84868_TENG_AN_STATr_LP_10GBTf_SET
#define TENG_AN_STATr_LP_LOOP_TIMING_ABILf_GET BCM84868_TENG_AN_STATr_LP_LOOP_TIMING_ABILf_GET
#define TENG_AN_STATr_LP_LOOP_TIMING_ABILf_SET BCM84868_TENG_AN_STATr_LP_LOOP_TIMING_ABILf_SET
#define TENG_AN_STATr_LP_PMA_TRAINING_RESET_REQf_GET BCM84868_TENG_AN_STATr_LP_PMA_TRAINING_RESET_REQf_GET
#define TENG_AN_STATr_LP_PMA_TRAINING_RESET_REQf_SET BCM84868_TENG_AN_STATr_LP_PMA_TRAINING_RESET_REQf_SET
#define READ_TENG_AN_STATr BCM84868_READ_TENG_AN_STATr
#define WRITE_TENG_AN_STATr BCM84868_WRITE_TENG_AN_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TENG_AN_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  EEE_ADV
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x003c
 * DEVAD:    7
 * DESC:     EEE Advertisement Register
 * SIZE:     32
 * FIELDS:
 *     X100B_TX_EEE     
 *     X1000B_T_EEE     
 *     X10GB_T_EEE      
 *     X100B_KX_EEE     
 *     X10GB_KX4_EEE    
 *     X10GB_KR_EEE     
 */
#define BCM84868_EEE_ADVr (0x0007003c | PHY_REG_ACC_BRCM_XE)

#define BCM84868_EEE_ADVr_SIZE 4

/*
 * This structure should be used to declare and program EEE_ADV.
 */
typedef union BCM84868_EEE_ADVr_s {
	uint32_t v[1];
	uint32_t eee_adv[1];
	uint32_t _eee_adv;
} BCM84868_EEE_ADVr_t;

#define BCM84868_EEE_ADVr_CLR(r) (r).eee_adv[0] = 0
#define BCM84868_EEE_ADVr_SET(r,d) (r).eee_adv[0] = d
#define BCM84868_EEE_ADVr_GET(r) (r).eee_adv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_EEE_ADVr_X10GB_KR_EEEf_GET(r) ((((r).eee_adv[0]) >> 6) & 0x1)
#define BCM84868_EEE_ADVr_X10GB_KR_EEEf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_EEE_ADVr_X10GB_KX4_EEEf_GET(r) ((((r).eee_adv[0]) >> 5) & 0x1)
#define BCM84868_EEE_ADVr_X10GB_KX4_EEEf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_EEE_ADVr_X100B_KX_EEEf_GET(r) ((((r).eee_adv[0]) >> 4) & 0x1)
#define BCM84868_EEE_ADVr_X100B_KX_EEEf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_EEE_ADVr_X10GB_T_EEEf_GET(r) ((((r).eee_adv[0]) >> 3) & 0x1)
#define BCM84868_EEE_ADVr_X10GB_T_EEEf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_EEE_ADVr_X1000B_T_EEEf_GET(r) ((((r).eee_adv[0]) >> 2) & 0x1)
#define BCM84868_EEE_ADVr_X1000B_T_EEEf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_EEE_ADVr_X100B_TX_EEEf_GET(r) ((((r).eee_adv[0]) >> 1) & 0x1)
#define BCM84868_EEE_ADVr_X100B_TX_EEEf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EEE_ADV.
 */
#define BCM84868_READ_EEE_ADVr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_EEE_ADVr,(_r._eee_adv))
#define BCM84868_WRITE_EEE_ADVr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_EEE_ADVr,(_r._eee_adv))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EEE_ADVr BCM84868_EEE_ADVr
#define EEE_ADVr_SIZE BCM84868_EEE_ADVr_SIZE
typedef BCM84868_EEE_ADVr_t EEE_ADVr_t;
#define EEE_ADVr_CLR BCM84868_EEE_ADVr_CLR
#define EEE_ADVr_SET BCM84868_EEE_ADVr_SET
#define EEE_ADVr_GET BCM84868_EEE_ADVr_GET
#define EEE_ADVr_X10GB_KR_EEEf_GET BCM84868_EEE_ADVr_X10GB_KR_EEEf_GET
#define EEE_ADVr_X10GB_KR_EEEf_SET BCM84868_EEE_ADVr_X10GB_KR_EEEf_SET
#define EEE_ADVr_X10GB_KX4_EEEf_GET BCM84868_EEE_ADVr_X10GB_KX4_EEEf_GET
#define EEE_ADVr_X10GB_KX4_EEEf_SET BCM84868_EEE_ADVr_X10GB_KX4_EEEf_SET
#define EEE_ADVr_X100B_KX_EEEf_GET BCM84868_EEE_ADVr_X100B_KX_EEEf_GET
#define EEE_ADVr_X100B_KX_EEEf_SET BCM84868_EEE_ADVr_X100B_KX_EEEf_SET
#define EEE_ADVr_X10GB_T_EEEf_GET BCM84868_EEE_ADVr_X10GB_T_EEEf_GET
#define EEE_ADVr_X10GB_T_EEEf_SET BCM84868_EEE_ADVr_X10GB_T_EEEf_SET
#define EEE_ADVr_X1000B_T_EEEf_GET BCM84868_EEE_ADVr_X1000B_T_EEEf_GET
#define EEE_ADVr_X1000B_T_EEEf_SET BCM84868_EEE_ADVr_X1000B_T_EEEf_SET
#define EEE_ADVr_X100B_TX_EEEf_GET BCM84868_EEE_ADVr_X100B_TX_EEEf_GET
#define EEE_ADVr_X100B_TX_EEEf_SET BCM84868_EEE_ADVr_X100B_TX_EEEf_SET
#define READ_EEE_ADVr BCM84868_READ_EEE_ADVr
#define WRITE_EEE_ADVr BCM84868_WRITE_EEE_ADVr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_EEE_ADVr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  EEE_LPABIL
 * BLOCKS:   IEEE_AN
 * REGADDR:  0x003d
 * DEVAD:    7
 * DESC:     EEE Link Partner Advertisement Register
 * SIZE:     32
 * FIELDS:
 *     X100B_TX_EEE     
 *     X1000B_T_EEE     
 *     X10GB_T_EEE      
 *     X100B_KX_EEE     
 *     X10GB_KX4_EEE    
 *     X10GB_KR_EEE     
 */
#define BCM84868_EEE_LPABILr (0x0007003d | PHY_REG_ACC_BRCM_XE)

#define BCM84868_EEE_LPABILr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LPABIL.
 */
typedef union BCM84868_EEE_LPABILr_s {
	uint32_t v[1];
	uint32_t eee_lpabil[1];
	uint32_t _eee_lpabil;
} BCM84868_EEE_LPABILr_t;

#define BCM84868_EEE_LPABILr_CLR(r) (r).eee_lpabil[0] = 0
#define BCM84868_EEE_LPABILr_SET(r,d) (r).eee_lpabil[0] = d
#define BCM84868_EEE_LPABILr_GET(r) (r).eee_lpabil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_EEE_LPABILr_X10GB_KR_EEEf_GET(r) ((((r).eee_lpabil[0]) >> 6) & 0x1)
#define BCM84868_EEE_LPABILr_X10GB_KR_EEEf_SET(r,f) (r).eee_lpabil[0]=(((r).eee_lpabil[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_EEE_LPABILr_X10GB_KX4_EEEf_GET(r) ((((r).eee_lpabil[0]) >> 5) & 0x1)
#define BCM84868_EEE_LPABILr_X10GB_KX4_EEEf_SET(r,f) (r).eee_lpabil[0]=(((r).eee_lpabil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_EEE_LPABILr_X100B_KX_EEEf_GET(r) ((((r).eee_lpabil[0]) >> 4) & 0x1)
#define BCM84868_EEE_LPABILr_X100B_KX_EEEf_SET(r,f) (r).eee_lpabil[0]=(((r).eee_lpabil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_EEE_LPABILr_X10GB_T_EEEf_GET(r) ((((r).eee_lpabil[0]) >> 3) & 0x1)
#define BCM84868_EEE_LPABILr_X10GB_T_EEEf_SET(r,f) (r).eee_lpabil[0]=(((r).eee_lpabil[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_EEE_LPABILr_X1000B_T_EEEf_GET(r) ((((r).eee_lpabil[0]) >> 2) & 0x1)
#define BCM84868_EEE_LPABILr_X1000B_T_EEEf_SET(r,f) (r).eee_lpabil[0]=(((r).eee_lpabil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_EEE_LPABILr_X100B_TX_EEEf_GET(r) ((((r).eee_lpabil[0]) >> 1) & 0x1)
#define BCM84868_EEE_LPABILr_X100B_TX_EEEf_SET(r,f) (r).eee_lpabil[0]=(((r).eee_lpabil[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EEE_LPABIL.
 */
#define BCM84868_READ_EEE_LPABILr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_EEE_LPABILr,(_r._eee_lpabil))
#define BCM84868_WRITE_EEE_LPABILr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_EEE_LPABILr,(_r._eee_lpabil))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define EEE_LPABILr BCM84868_EEE_LPABILr
#define EEE_LPABILr_SIZE BCM84868_EEE_LPABILr_SIZE
typedef BCM84868_EEE_LPABILr_t EEE_LPABILr_t;
#define EEE_LPABILr_CLR BCM84868_EEE_LPABILr_CLR
#define EEE_LPABILr_SET BCM84868_EEE_LPABILr_SET
#define EEE_LPABILr_GET BCM84868_EEE_LPABILr_GET
#define EEE_LPABILr_X10GB_KR_EEEf_GET BCM84868_EEE_LPABILr_X10GB_KR_EEEf_GET
#define EEE_LPABILr_X10GB_KR_EEEf_SET BCM84868_EEE_LPABILr_X10GB_KR_EEEf_SET
#define EEE_LPABILr_X10GB_KX4_EEEf_GET BCM84868_EEE_LPABILr_X10GB_KX4_EEEf_GET
#define EEE_LPABILr_X10GB_KX4_EEEf_SET BCM84868_EEE_LPABILr_X10GB_KX4_EEEf_SET
#define EEE_LPABILr_X100B_KX_EEEf_GET BCM84868_EEE_LPABILr_X100B_KX_EEEf_GET
#define EEE_LPABILr_X100B_KX_EEEf_SET BCM84868_EEE_LPABILr_X100B_KX_EEEf_SET
#define EEE_LPABILr_X10GB_T_EEEf_GET BCM84868_EEE_LPABILr_X10GB_T_EEEf_GET
#define EEE_LPABILr_X10GB_T_EEEf_SET BCM84868_EEE_LPABILr_X10GB_T_EEEf_SET
#define EEE_LPABILr_X1000B_T_EEEf_GET BCM84868_EEE_LPABILr_X1000B_T_EEEf_GET
#define EEE_LPABILr_X1000B_T_EEEf_SET BCM84868_EEE_LPABILr_X1000B_T_EEEf_SET
#define EEE_LPABILr_X100B_TX_EEEf_GET BCM84868_EEE_LPABILr_X100B_TX_EEEf_GET
#define EEE_LPABILr_X100B_TX_EEEf_SET BCM84868_EEE_LPABILr_X100B_TX_EEEf_SET
#define READ_EEE_LPABILr BCM84868_READ_EEE_LPABILr
#define WRITE_EEE_LPABILr BCM84868_WRITE_EEE_LPABILr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_EEE_LPABILr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0xffe0
 * DEVAD:    7
 * DESC:     MII Control Register
 * SIZE:     32
 * FIELDS:
 *     SPEED_SELECT_MSB 
 *     COLLISION_TEST   
 *     DUPLEX_MODE      
 *     RESTART_AUTONEG  
 *     ISOLATE          
 *     POWER_DOWN       
 *     AUTONEG_ENABLE   
 *     SPEED_SELECT_LSB 
 *     LOOPBACK         
 *     RESET            
 */
#define BCM84868_MII_CTRLr (0x0007ffe0 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_CTRL.
 */
typedef union BCM84868_MII_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_ctrl[1];
	uint32_t _mii_ctrl;
} BCM84868_MII_CTRLr_t;

#define BCM84868_MII_CTRLr_CLR(r) (r).mii_ctrl[0] = 0
#define BCM84868_MII_CTRLr_SET(r,d) (r).mii_ctrl[0] = d
#define BCM84868_MII_CTRLr_GET(r) (r).mii_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_CTRLr_RESETf_GET(r) ((((r).mii_ctrl[0]) >> 15) & 0x1)
#define BCM84868_MII_CTRLr_RESETf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_CTRLr_LOOPBACKf_GET(r) ((((r).mii_ctrl[0]) >> 14) & 0x1)
#define BCM84868_MII_CTRLr_LOOPBACKf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_MII_CTRLr_SPEED_SELECT_LSBf_GET(r) ((((r).mii_ctrl[0]) >> 13) & 0x1)
#define BCM84868_MII_CTRLr_SPEED_SELECT_LSBf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_CTRLr_AUTONEG_ENABLEf_GET(r) ((((r).mii_ctrl[0]) >> 12) & 0x1)
#define BCM84868_MII_CTRLr_AUTONEG_ENABLEf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_MII_CTRLr_POWER_DOWNf_GET(r) ((((r).mii_ctrl[0]) >> 11) & 0x1)
#define BCM84868_MII_CTRLr_POWER_DOWNf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_CTRLr_ISOLATEf_GET(r) ((((r).mii_ctrl[0]) >> 10) & 0x1)
#define BCM84868_MII_CTRLr_ISOLATEf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_MII_CTRLr_RESTART_AUTONEGf_GET(r) ((((r).mii_ctrl[0]) >> 9) & 0x1)
#define BCM84868_MII_CTRLr_RESTART_AUTONEGf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_MII_CTRLr_DUPLEX_MODEf_GET(r) ((((r).mii_ctrl[0]) >> 8) & 0x1)
#define BCM84868_MII_CTRLr_DUPLEX_MODEf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_MII_CTRLr_COLLISION_TESTf_GET(r) ((((r).mii_ctrl[0]) >> 7) & 0x1)
#define BCM84868_MII_CTRLr_COLLISION_TESTf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_MII_CTRLr_SPEED_SELECT_MSBf_GET(r) ((((r).mii_ctrl[0]) >> 6) & 0x1)
#define BCM84868_MII_CTRLr_SPEED_SELECT_MSBf_SET(r,f) (r).mii_ctrl[0]=(((r).mii_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access MII_CTRL.
 */
#define BCM84868_READ_MII_CTRLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_CTRLr,(_r._mii_ctrl))
#define BCM84868_WRITE_MII_CTRLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_CTRLr,(_r._mii_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_CTRLr BCM84868_MII_CTRLr
#define MII_CTRLr_SIZE BCM84868_MII_CTRLr_SIZE
typedef BCM84868_MII_CTRLr_t MII_CTRLr_t;
#define MII_CTRLr_CLR BCM84868_MII_CTRLr_CLR
#define MII_CTRLr_SET BCM84868_MII_CTRLr_SET
#define MII_CTRLr_GET BCM84868_MII_CTRLr_GET
#define MII_CTRLr_RESETf_GET BCM84868_MII_CTRLr_RESETf_GET
#define MII_CTRLr_RESETf_SET BCM84868_MII_CTRLr_RESETf_SET
#define MII_CTRLr_LOOPBACKf_GET BCM84868_MII_CTRLr_LOOPBACKf_GET
#define MII_CTRLr_LOOPBACKf_SET BCM84868_MII_CTRLr_LOOPBACKf_SET
#define MII_CTRLr_SPEED_SELECT_LSBf_GET BCM84868_MII_CTRLr_SPEED_SELECT_LSBf_GET
#define MII_CTRLr_SPEED_SELECT_LSBf_SET BCM84868_MII_CTRLr_SPEED_SELECT_LSBf_SET
#define MII_CTRLr_AUTONEG_ENABLEf_GET BCM84868_MII_CTRLr_AUTONEG_ENABLEf_GET
#define MII_CTRLr_AUTONEG_ENABLEf_SET BCM84868_MII_CTRLr_AUTONEG_ENABLEf_SET
#define MII_CTRLr_POWER_DOWNf_GET BCM84868_MII_CTRLr_POWER_DOWNf_GET
#define MII_CTRLr_POWER_DOWNf_SET BCM84868_MII_CTRLr_POWER_DOWNf_SET
#define MII_CTRLr_ISOLATEf_GET BCM84868_MII_CTRLr_ISOLATEf_GET
#define MII_CTRLr_ISOLATEf_SET BCM84868_MII_CTRLr_ISOLATEf_SET
#define MII_CTRLr_RESTART_AUTONEGf_GET BCM84868_MII_CTRLr_RESTART_AUTONEGf_GET
#define MII_CTRLr_RESTART_AUTONEGf_SET BCM84868_MII_CTRLr_RESTART_AUTONEGf_SET
#define MII_CTRLr_DUPLEX_MODEf_GET BCM84868_MII_CTRLr_DUPLEX_MODEf_GET
#define MII_CTRLr_DUPLEX_MODEf_SET BCM84868_MII_CTRLr_DUPLEX_MODEf_SET
#define MII_CTRLr_COLLISION_TESTf_GET BCM84868_MII_CTRLr_COLLISION_TESTf_GET
#define MII_CTRLr_COLLISION_TESTf_SET BCM84868_MII_CTRLr_COLLISION_TESTf_SET
#define MII_CTRLr_SPEED_SELECT_MSBf_GET BCM84868_MII_CTRLr_SPEED_SELECT_MSBf_GET
#define MII_CTRLr_SPEED_SELECT_MSBf_SET BCM84868_MII_CTRLr_SPEED_SELECT_MSBf_SET
#define READ_MII_CTRLr BCM84868_READ_MII_CTRLr
#define WRITE_MII_CTRLr BCM84868_WRITE_MII_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0xffe1
 * DEVAD:    7
 * DESC:     MII Status Register
 * SIZE:     32
 * FIELDS:
 *     EXTENDED_CAP     
 *     JABBER_DETECT    
 *     LINK_STATUS      
 *     AUTONEG_ABIL     
 *     REMOTE_FAULT     
 *     AUTONEG_COMPLETE 
 *     MF_PREAMBLE_SUPPRESSION 
 *     EXTENDED_STATUS  
 *     X100BASE_T2_HALF_DUPLEX_CAP 
 *     X100BASE_T2_FULL_DUPLEX_CAP 
 *     X10BASE_T_HALF_DUPLEX_CAP 
 *     X10BASE_T_FULL_DUPLEX_CAP 
 *     X100BASE_X_HALF_DUPLEX_CAP 
 *     X100BASE_X_FULL_DUPLEX_CAP 
 *     X100BASE_T4_CAP  
 */
#define BCM84868_MII_STATr (0x0007ffe1 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_STAT.
 */
typedef union BCM84868_MII_STATr_s {
	uint32_t v[1];
	uint32_t mii_stat[1];
	uint32_t _mii_stat;
} BCM84868_MII_STATr_t;

#define BCM84868_MII_STATr_CLR(r) (r).mii_stat[0] = 0
#define BCM84868_MII_STATr_SET(r,d) (r).mii_stat[0] = d
#define BCM84868_MII_STATr_GET(r) (r).mii_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_STATr_X100BASE_T4_CAPf_GET(r) ((((r).mii_stat[0]) >> 15) & 0x1)
#define BCM84868_MII_STATr_X100BASE_T4_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_STATr_X100BASE_X_FULL_DUPLEX_CAPf_GET(r) ((((r).mii_stat[0]) >> 14) & 0x1)
#define BCM84868_MII_STATr_X100BASE_X_FULL_DUPLEX_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_MII_STATr_X100BASE_X_HALF_DUPLEX_CAPf_GET(r) ((((r).mii_stat[0]) >> 13) & 0x1)
#define BCM84868_MII_STATr_X100BASE_X_HALF_DUPLEX_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_STATr_X10BASE_T_FULL_DUPLEX_CAPf_GET(r) ((((r).mii_stat[0]) >> 12) & 0x1)
#define BCM84868_MII_STATr_X10BASE_T_FULL_DUPLEX_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_MII_STATr_X10BASE_T_HALF_DUPLEX_CAPf_GET(r) ((((r).mii_stat[0]) >> 11) & 0x1)
#define BCM84868_MII_STATr_X10BASE_T_HALF_DUPLEX_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_STATr_X100BASE_T2_FULL_DUPLEX_CAPf_GET(r) ((((r).mii_stat[0]) >> 10) & 0x1)
#define BCM84868_MII_STATr_X100BASE_T2_FULL_DUPLEX_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_MII_STATr_X100BASE_T2_HALF_DUPLEX_CAPf_GET(r) ((((r).mii_stat[0]) >> 9) & 0x1)
#define BCM84868_MII_STATr_X100BASE_T2_HALF_DUPLEX_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_MII_STATr_EXTENDED_STATUSf_GET(r) ((((r).mii_stat[0]) >> 8) & 0x1)
#define BCM84868_MII_STATr_EXTENDED_STATUSf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_MII_STATr_MF_PREAMBLE_SUPPRESSIONf_GET(r) ((((r).mii_stat[0]) >> 6) & 0x1)
#define BCM84868_MII_STATr_MF_PREAMBLE_SUPPRESSIONf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_MII_STATr_AUTONEG_COMPLETEf_GET(r) ((((r).mii_stat[0]) >> 5) & 0x1)
#define BCM84868_MII_STATr_AUTONEG_COMPLETEf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_MII_STATr_REMOTE_FAULTf_GET(r) ((((r).mii_stat[0]) >> 4) & 0x1)
#define BCM84868_MII_STATr_REMOTE_FAULTf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_MII_STATr_AUTONEG_ABILf_GET(r) ((((r).mii_stat[0]) >> 3) & 0x1)
#define BCM84868_MII_STATr_AUTONEG_ABILf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_MII_STATr_LINK_STATUSf_GET(r) ((((r).mii_stat[0]) >> 2) & 0x1)
#define BCM84868_MII_STATr_LINK_STATUSf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_MII_STATr_JABBER_DETECTf_GET(r) ((((r).mii_stat[0]) >> 1) & 0x1)
#define BCM84868_MII_STATr_JABBER_DETECTf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_MII_STATr_EXTENDED_CAPf_GET(r) (((r).mii_stat[0]) & 0x1)
#define BCM84868_MII_STATr_EXTENDED_CAPf_SET(r,f) (r).mii_stat[0]=(((r).mii_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_STAT.
 */
#define BCM84868_READ_MII_STATr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_STATr,(_r._mii_stat))
#define BCM84868_WRITE_MII_STATr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_STATr,(_r._mii_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_STATr BCM84868_MII_STATr
#define MII_STATr_SIZE BCM84868_MII_STATr_SIZE
typedef BCM84868_MII_STATr_t MII_STATr_t;
#define MII_STATr_CLR BCM84868_MII_STATr_CLR
#define MII_STATr_SET BCM84868_MII_STATr_SET
#define MII_STATr_GET BCM84868_MII_STATr_GET
#define MII_STATr_X100BASE_T4_CAPf_GET BCM84868_MII_STATr_X100BASE_T4_CAPf_GET
#define MII_STATr_X100BASE_T4_CAPf_SET BCM84868_MII_STATr_X100BASE_T4_CAPf_SET
#define MII_STATr_X100BASE_X_FULL_DUPLEX_CAPf_GET BCM84868_MII_STATr_X100BASE_X_FULL_DUPLEX_CAPf_GET
#define MII_STATr_X100BASE_X_FULL_DUPLEX_CAPf_SET BCM84868_MII_STATr_X100BASE_X_FULL_DUPLEX_CAPf_SET
#define MII_STATr_X100BASE_X_HALF_DUPLEX_CAPf_GET BCM84868_MII_STATr_X100BASE_X_HALF_DUPLEX_CAPf_GET
#define MII_STATr_X100BASE_X_HALF_DUPLEX_CAPf_SET BCM84868_MII_STATr_X100BASE_X_HALF_DUPLEX_CAPf_SET
#define MII_STATr_X10BASE_T_FULL_DUPLEX_CAPf_GET BCM84868_MII_STATr_X10BASE_T_FULL_DUPLEX_CAPf_GET
#define MII_STATr_X10BASE_T_FULL_DUPLEX_CAPf_SET BCM84868_MII_STATr_X10BASE_T_FULL_DUPLEX_CAPf_SET
#define MII_STATr_X10BASE_T_HALF_DUPLEX_CAPf_GET BCM84868_MII_STATr_X10BASE_T_HALF_DUPLEX_CAPf_GET
#define MII_STATr_X10BASE_T_HALF_DUPLEX_CAPf_SET BCM84868_MII_STATr_X10BASE_T_HALF_DUPLEX_CAPf_SET
#define MII_STATr_X100BASE_T2_FULL_DUPLEX_CAPf_GET BCM84868_MII_STATr_X100BASE_T2_FULL_DUPLEX_CAPf_GET
#define MII_STATr_X100BASE_T2_FULL_DUPLEX_CAPf_SET BCM84868_MII_STATr_X100BASE_T2_FULL_DUPLEX_CAPf_SET
#define MII_STATr_X100BASE_T2_HALF_DUPLEX_CAPf_GET BCM84868_MII_STATr_X100BASE_T2_HALF_DUPLEX_CAPf_GET
#define MII_STATr_X100BASE_T2_HALF_DUPLEX_CAPf_SET BCM84868_MII_STATr_X100BASE_T2_HALF_DUPLEX_CAPf_SET
#define MII_STATr_EXTENDED_STATUSf_GET BCM84868_MII_STATr_EXTENDED_STATUSf_GET
#define MII_STATr_EXTENDED_STATUSf_SET BCM84868_MII_STATr_EXTENDED_STATUSf_SET
#define MII_STATr_MF_PREAMBLE_SUPPRESSIONf_GET BCM84868_MII_STATr_MF_PREAMBLE_SUPPRESSIONf_GET
#define MII_STATr_MF_PREAMBLE_SUPPRESSIONf_SET BCM84868_MII_STATr_MF_PREAMBLE_SUPPRESSIONf_SET
#define MII_STATr_AUTONEG_COMPLETEf_GET BCM84868_MII_STATr_AUTONEG_COMPLETEf_GET
#define MII_STATr_AUTONEG_COMPLETEf_SET BCM84868_MII_STATr_AUTONEG_COMPLETEf_SET
#define MII_STATr_REMOTE_FAULTf_GET BCM84868_MII_STATr_REMOTE_FAULTf_GET
#define MII_STATr_REMOTE_FAULTf_SET BCM84868_MII_STATr_REMOTE_FAULTf_SET
#define MII_STATr_AUTONEG_ABILf_GET BCM84868_MII_STATr_AUTONEG_ABILf_GET
#define MII_STATr_AUTONEG_ABILf_SET BCM84868_MII_STATr_AUTONEG_ABILf_SET
#define MII_STATr_LINK_STATUSf_GET BCM84868_MII_STATr_LINK_STATUSf_GET
#define MII_STATr_LINK_STATUSf_SET BCM84868_MII_STATr_LINK_STATUSf_SET
#define MII_STATr_JABBER_DETECTf_GET BCM84868_MII_STATr_JABBER_DETECTf_GET
#define MII_STATr_JABBER_DETECTf_SET BCM84868_MII_STATr_JABBER_DETECTf_SET
#define MII_STATr_EXTENDED_CAPf_GET BCM84868_MII_STATr_EXTENDED_CAPf_GET
#define MII_STATr_EXTENDED_CAPf_SET BCM84868_MII_STATr_EXTENDED_CAPf_SET
#define READ_MII_STATr BCM84868_READ_MII_STATr
#define WRITE_MII_STATr BCM84868_WRITE_MII_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_PHY_ID0
 * BLOCKS:   IEEE
 * REGADDR:  0xffe2
 * DEVAD:    7
 * DESC:     PHY ID MSB Register
 * SIZE:     32
 * FIELDS:
 *     OUI              
 */
#define BCM84868_MII_PHY_ID0r (0x0007ffe2 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_PHY_ID0r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID0.
 */
typedef union BCM84868_MII_PHY_ID0r_s {
	uint32_t v[1];
	uint32_t mii_phy_id0[1];
	uint32_t _mii_phy_id0;
} BCM84868_MII_PHY_ID0r_t;

#define BCM84868_MII_PHY_ID0r_CLR(r) (r).mii_phy_id0[0] = 0
#define BCM84868_MII_PHY_ID0r_SET(r,d) (r).mii_phy_id0[0] = d
#define BCM84868_MII_PHY_ID0r_GET(r) (r).mii_phy_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_PHY_ID0r_OUIf_GET(r) (((r).mii_phy_id0[0]) & 0xffff)
#define BCM84868_MII_PHY_ID0r_OUIf_SET(r,f) (r).mii_phy_id0[0]=(((r).mii_phy_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MII_PHY_ID0.
 */
#define BCM84868_READ_MII_PHY_ID0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_PHY_ID0r,(_r._mii_phy_id0))
#define BCM84868_WRITE_MII_PHY_ID0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_PHY_ID0r,(_r._mii_phy_id0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID0r BCM84868_MII_PHY_ID0r
#define MII_PHY_ID0r_SIZE BCM84868_MII_PHY_ID0r_SIZE
typedef BCM84868_MII_PHY_ID0r_t MII_PHY_ID0r_t;
#define MII_PHY_ID0r_CLR BCM84868_MII_PHY_ID0r_CLR
#define MII_PHY_ID0r_SET BCM84868_MII_PHY_ID0r_SET
#define MII_PHY_ID0r_GET BCM84868_MII_PHY_ID0r_GET
#define MII_PHY_ID0r_OUIf_GET BCM84868_MII_PHY_ID0r_OUIf_GET
#define MII_PHY_ID0r_OUIf_SET BCM84868_MII_PHY_ID0r_OUIf_SET
#define READ_MII_PHY_ID0r BCM84868_READ_MII_PHY_ID0r
#define WRITE_MII_PHY_ID0r BCM84868_WRITE_MII_PHY_ID0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_PHY_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_PHY_ID1
 * BLOCKS:   IEEE
 * REGADDR:  0xffe3
 * DEVAD:    7
 * DESC:     PHY ID LSB Register
 * SIZE:     32
 * FIELDS:
 *     REVISION         
 *     MODEL            
 *     OUI              
 */
#define BCM84868_MII_PHY_ID1r (0x0007ffe3 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_PHY_ID1r_SIZE 4

/*
 * This structure should be used to declare and program MII_PHY_ID1.
 */
typedef union BCM84868_MII_PHY_ID1r_s {
	uint32_t v[1];
	uint32_t mii_phy_id1[1];
	uint32_t _mii_phy_id1;
} BCM84868_MII_PHY_ID1r_t;

#define BCM84868_MII_PHY_ID1r_CLR(r) (r).mii_phy_id1[0] = 0
#define BCM84868_MII_PHY_ID1r_SET(r,d) (r).mii_phy_id1[0] = d
#define BCM84868_MII_PHY_ID1r_GET(r) (r).mii_phy_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_PHY_ID1r_OUIf_GET(r) ((((r).mii_phy_id1[0]) >> 10) & 0x3f)
#define BCM84868_MII_PHY_ID1r_OUIf_SET(r,f) (r).mii_phy_id1[0]=(((r).mii_phy_id1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM84868_MII_PHY_ID1r_MODELf_GET(r) ((((r).mii_phy_id1[0]) >> 4) & 0x3f)
#define BCM84868_MII_PHY_ID1r_MODELf_SET(r,f) (r).mii_phy_id1[0]=(((r).mii_phy_id1[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM84868_MII_PHY_ID1r_REVISIONf_GET(r) (((r).mii_phy_id1[0]) & 0xf)
#define BCM84868_MII_PHY_ID1r_REVISIONf_SET(r,f) (r).mii_phy_id1[0]=(((r).mii_phy_id1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access MII_PHY_ID1.
 */
#define BCM84868_READ_MII_PHY_ID1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_PHY_ID1r,(_r._mii_phy_id1))
#define BCM84868_WRITE_MII_PHY_ID1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_PHY_ID1r,(_r._mii_phy_id1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_PHY_ID1r BCM84868_MII_PHY_ID1r
#define MII_PHY_ID1r_SIZE BCM84868_MII_PHY_ID1r_SIZE
typedef BCM84868_MII_PHY_ID1r_t MII_PHY_ID1r_t;
#define MII_PHY_ID1r_CLR BCM84868_MII_PHY_ID1r_CLR
#define MII_PHY_ID1r_SET BCM84868_MII_PHY_ID1r_SET
#define MII_PHY_ID1r_GET BCM84868_MII_PHY_ID1r_GET
#define MII_PHY_ID1r_OUIf_GET BCM84868_MII_PHY_ID1r_OUIf_GET
#define MII_PHY_ID1r_OUIf_SET BCM84868_MII_PHY_ID1r_OUIf_SET
#define MII_PHY_ID1r_MODELf_GET BCM84868_MII_PHY_ID1r_MODELf_GET
#define MII_PHY_ID1r_MODELf_SET BCM84868_MII_PHY_ID1r_MODELf_SET
#define MII_PHY_ID1r_REVISIONf_GET BCM84868_MII_PHY_ID1r_REVISIONf_GET
#define MII_PHY_ID1r_REVISIONf_SET BCM84868_MII_PHY_ID1r_REVISIONf_SET
#define READ_MII_PHY_ID1r BCM84868_READ_MII_PHY_ID1r
#define WRITE_MII_PHY_ID1r BCM84868_WRITE_MII_PHY_ID1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_PHY_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_ANA
 * BLOCKS:   IEEE
 * REGADDR:  0xffe4
 * DEVAD:    7
 * DESC:     Auto-negotiation Advertisement Register
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL_SELECTOR 
 *     X10BASE_T_HALF_DUP_CAP 
 *     X10BASE_T_FULL_DUP_CAP 
 *     X100BASE_TX_HALF_DUP_CAP 
 *     X100BASE_TX_FULL_DUP_CAP 
 *     X100BASE_T4_CAPABLE 
 *     PAUSE_CAPABLE    
 *     ASYMMETRIC_PAUSE 
 *     EXTENDED_NXT_PAGE_ABIL 
 *     REMOTE_FAULT     
 *     NEXT_PAGE        
 */
#define BCM84868_MII_ANAr (0x0007ffe4 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_ANAr_SIZE 4

/*
 * This structure should be used to declare and program MII_ANA.
 */
typedef union BCM84868_MII_ANAr_s {
	uint32_t v[1];
	uint32_t mii_ana[1];
	uint32_t _mii_ana;
} BCM84868_MII_ANAr_t;

#define BCM84868_MII_ANAr_CLR(r) (r).mii_ana[0] = 0
#define BCM84868_MII_ANAr_SET(r,d) (r).mii_ana[0] = d
#define BCM84868_MII_ANAr_GET(r) (r).mii_ana[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_ANAr_NEXT_PAGEf_GET(r) ((((r).mii_ana[0]) >> 15) & 0x1)
#define BCM84868_MII_ANAr_NEXT_PAGEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_ANAr_REMOTE_FAULTf_GET(r) ((((r).mii_ana[0]) >> 13) & 0x1)
#define BCM84868_MII_ANAr_REMOTE_FAULTf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_ANAr_EXTENDED_NXT_PAGE_ABILf_GET(r) ((((r).mii_ana[0]) >> 12) & 0x1)
#define BCM84868_MII_ANAr_EXTENDED_NXT_PAGE_ABILf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_MII_ANAr_ASYMMETRIC_PAUSEf_GET(r) ((((r).mii_ana[0]) >> 11) & 0x1)
#define BCM84868_MII_ANAr_ASYMMETRIC_PAUSEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_ANAr_PAUSE_CAPABLEf_GET(r) ((((r).mii_ana[0]) >> 10) & 0x1)
#define BCM84868_MII_ANAr_PAUSE_CAPABLEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_MII_ANAr_X100BASE_T4_CAPABLEf_GET(r) ((((r).mii_ana[0]) >> 9) & 0x1)
#define BCM84868_MII_ANAr_X100BASE_T4_CAPABLEf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_MII_ANAr_X100BASE_TX_FULL_DUP_CAPf_GET(r) ((((r).mii_ana[0]) >> 8) & 0x1)
#define BCM84868_MII_ANAr_X100BASE_TX_FULL_DUP_CAPf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_MII_ANAr_X100BASE_TX_HALF_DUP_CAPf_GET(r) ((((r).mii_ana[0]) >> 7) & 0x1)
#define BCM84868_MII_ANAr_X100BASE_TX_HALF_DUP_CAPf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_MII_ANAr_X10BASE_T_FULL_DUP_CAPf_GET(r) ((((r).mii_ana[0]) >> 6) & 0x1)
#define BCM84868_MII_ANAr_X10BASE_T_FULL_DUP_CAPf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_MII_ANAr_X10BASE_T_HALF_DUP_CAPf_GET(r) ((((r).mii_ana[0]) >> 5) & 0x1)
#define BCM84868_MII_ANAr_X10BASE_T_HALF_DUP_CAPf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_MII_ANAr_PROTOCOL_SELECTORf_GET(r) (((r).mii_ana[0]) & 0x1f)
#define BCM84868_MII_ANAr_PROTOCOL_SELECTORf_SET(r,f) (r).mii_ana[0]=(((r).mii_ana[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access MII_ANA.
 */
#define BCM84868_READ_MII_ANAr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_ANAr,(_r._mii_ana))
#define BCM84868_WRITE_MII_ANAr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_ANAr,(_r._mii_ana))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ANAr BCM84868_MII_ANAr
#define MII_ANAr_SIZE BCM84868_MII_ANAr_SIZE
typedef BCM84868_MII_ANAr_t MII_ANAr_t;
#define MII_ANAr_CLR BCM84868_MII_ANAr_CLR
#define MII_ANAr_SET BCM84868_MII_ANAr_SET
#define MII_ANAr_GET BCM84868_MII_ANAr_GET
#define MII_ANAr_NEXT_PAGEf_GET BCM84868_MII_ANAr_NEXT_PAGEf_GET
#define MII_ANAr_NEXT_PAGEf_SET BCM84868_MII_ANAr_NEXT_PAGEf_SET
#define MII_ANAr_REMOTE_FAULTf_GET BCM84868_MII_ANAr_REMOTE_FAULTf_GET
#define MII_ANAr_REMOTE_FAULTf_SET BCM84868_MII_ANAr_REMOTE_FAULTf_SET
#define MII_ANAr_EXTENDED_NXT_PAGE_ABILf_GET BCM84868_MII_ANAr_EXTENDED_NXT_PAGE_ABILf_GET
#define MII_ANAr_EXTENDED_NXT_PAGE_ABILf_SET BCM84868_MII_ANAr_EXTENDED_NXT_PAGE_ABILf_SET
#define MII_ANAr_ASYMMETRIC_PAUSEf_GET BCM84868_MII_ANAr_ASYMMETRIC_PAUSEf_GET
#define MII_ANAr_ASYMMETRIC_PAUSEf_SET BCM84868_MII_ANAr_ASYMMETRIC_PAUSEf_SET
#define MII_ANAr_PAUSE_CAPABLEf_GET BCM84868_MII_ANAr_PAUSE_CAPABLEf_GET
#define MII_ANAr_PAUSE_CAPABLEf_SET BCM84868_MII_ANAr_PAUSE_CAPABLEf_SET
#define MII_ANAr_X100BASE_T4_CAPABLEf_GET BCM84868_MII_ANAr_X100BASE_T4_CAPABLEf_GET
#define MII_ANAr_X100BASE_T4_CAPABLEf_SET BCM84868_MII_ANAr_X100BASE_T4_CAPABLEf_SET
#define MII_ANAr_X100BASE_TX_FULL_DUP_CAPf_GET BCM84868_MII_ANAr_X100BASE_TX_FULL_DUP_CAPf_GET
#define MII_ANAr_X100BASE_TX_FULL_DUP_CAPf_SET BCM84868_MII_ANAr_X100BASE_TX_FULL_DUP_CAPf_SET
#define MII_ANAr_X100BASE_TX_HALF_DUP_CAPf_GET BCM84868_MII_ANAr_X100BASE_TX_HALF_DUP_CAPf_GET
#define MII_ANAr_X100BASE_TX_HALF_DUP_CAPf_SET BCM84868_MII_ANAr_X100BASE_TX_HALF_DUP_CAPf_SET
#define MII_ANAr_X10BASE_T_FULL_DUP_CAPf_GET BCM84868_MII_ANAr_X10BASE_T_FULL_DUP_CAPf_GET
#define MII_ANAr_X10BASE_T_FULL_DUP_CAPf_SET BCM84868_MII_ANAr_X10BASE_T_FULL_DUP_CAPf_SET
#define MII_ANAr_X10BASE_T_HALF_DUP_CAPf_GET BCM84868_MII_ANAr_X10BASE_T_HALF_DUP_CAPf_GET
#define MII_ANAr_X10BASE_T_HALF_DUP_CAPf_SET BCM84868_MII_ANAr_X10BASE_T_HALF_DUP_CAPf_SET
#define MII_ANAr_PROTOCOL_SELECTORf_GET BCM84868_MII_ANAr_PROTOCOL_SELECTORf_GET
#define MII_ANAr_PROTOCOL_SELECTORf_SET BCM84868_MII_ANAr_PROTOCOL_SELECTORf_SET
#define READ_MII_ANAr BCM84868_READ_MII_ANAr
#define WRITE_MII_ANAr BCM84868_WRITE_MII_ANAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_ANAr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_ANP
 * BLOCKS:   IEEE
 * REGADDR:  0xffe5
 * DEVAD:    7
 * DESC:     Auto-negotiation Link Partner Ability 1Register
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL_SELECTOR 
 *     X10BASE_T_HALF_DUP_CAP 
 *     X10BASE_T_FULL_DUP_CAP 
 *     X100BASE_TX_HALF_DUP_CAP 
 *     X100BASE_TX_FULL_DUP_CAP 
 *     X100BASE_T4_CAP  
 *     PAUSE_CAPABLE    
 *     LINK_PRTNR_ASYM_PAUSE 
 *     REMOTE_FAULT     
 *     ACKNOWLEDGE      
 *     NEXT_PAGE        
 */
#define BCM84868_MII_ANPr (0x0007ffe5 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_ANPr_SIZE 4

/*
 * This structure should be used to declare and program MII_ANP.
 */
typedef union BCM84868_MII_ANPr_s {
	uint32_t v[1];
	uint32_t mii_anp[1];
	uint32_t _mii_anp;
} BCM84868_MII_ANPr_t;

#define BCM84868_MII_ANPr_CLR(r) (r).mii_anp[0] = 0
#define BCM84868_MII_ANPr_SET(r,d) (r).mii_anp[0] = d
#define BCM84868_MII_ANPr_GET(r) (r).mii_anp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_ANPr_NEXT_PAGEf_GET(r) ((((r).mii_anp[0]) >> 15) & 0x1)
#define BCM84868_MII_ANPr_NEXT_PAGEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_ANPr_ACKNOWLEDGEf_GET(r) ((((r).mii_anp[0]) >> 14) & 0x1)
#define BCM84868_MII_ANPr_ACKNOWLEDGEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_MII_ANPr_REMOTE_FAULTf_GET(r) ((((r).mii_anp[0]) >> 13) & 0x1)
#define BCM84868_MII_ANPr_REMOTE_FAULTf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_ANPr_LINK_PRTNR_ASYM_PAUSEf_GET(r) ((((r).mii_anp[0]) >> 11) & 0x1)
#define BCM84868_MII_ANPr_LINK_PRTNR_ASYM_PAUSEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_ANPr_PAUSE_CAPABLEf_GET(r) ((((r).mii_anp[0]) >> 10) & 0x1)
#define BCM84868_MII_ANPr_PAUSE_CAPABLEf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_MII_ANPr_X100BASE_T4_CAPf_GET(r) ((((r).mii_anp[0]) >> 9) & 0x1)
#define BCM84868_MII_ANPr_X100BASE_T4_CAPf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_MII_ANPr_X100BASE_TX_FULL_DUP_CAPf_GET(r) ((((r).mii_anp[0]) >> 8) & 0x1)
#define BCM84868_MII_ANPr_X100BASE_TX_FULL_DUP_CAPf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_MII_ANPr_X100BASE_TX_HALF_DUP_CAPf_GET(r) ((((r).mii_anp[0]) >> 7) & 0x1)
#define BCM84868_MII_ANPr_X100BASE_TX_HALF_DUP_CAPf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_MII_ANPr_X10BASE_T_FULL_DUP_CAPf_GET(r) ((((r).mii_anp[0]) >> 6) & 0x1)
#define BCM84868_MII_ANPr_X10BASE_T_FULL_DUP_CAPf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_MII_ANPr_X10BASE_T_HALF_DUP_CAPf_GET(r) ((((r).mii_anp[0]) >> 5) & 0x1)
#define BCM84868_MII_ANPr_X10BASE_T_HALF_DUP_CAPf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_MII_ANPr_PROTOCOL_SELECTORf_GET(r) (((r).mii_anp[0]) & 0x1f)
#define BCM84868_MII_ANPr_PROTOCOL_SELECTORf_SET(r,f) (r).mii_anp[0]=(((r).mii_anp[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access MII_ANP.
 */
#define BCM84868_READ_MII_ANPr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_ANPr,(_r._mii_anp))
#define BCM84868_WRITE_MII_ANPr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_ANPr,(_r._mii_anp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ANPr BCM84868_MII_ANPr
#define MII_ANPr_SIZE BCM84868_MII_ANPr_SIZE
typedef BCM84868_MII_ANPr_t MII_ANPr_t;
#define MII_ANPr_CLR BCM84868_MII_ANPr_CLR
#define MII_ANPr_SET BCM84868_MII_ANPr_SET
#define MII_ANPr_GET BCM84868_MII_ANPr_GET
#define MII_ANPr_NEXT_PAGEf_GET BCM84868_MII_ANPr_NEXT_PAGEf_GET
#define MII_ANPr_NEXT_PAGEf_SET BCM84868_MII_ANPr_NEXT_PAGEf_SET
#define MII_ANPr_ACKNOWLEDGEf_GET BCM84868_MII_ANPr_ACKNOWLEDGEf_GET
#define MII_ANPr_ACKNOWLEDGEf_SET BCM84868_MII_ANPr_ACKNOWLEDGEf_SET
#define MII_ANPr_REMOTE_FAULTf_GET BCM84868_MII_ANPr_REMOTE_FAULTf_GET
#define MII_ANPr_REMOTE_FAULTf_SET BCM84868_MII_ANPr_REMOTE_FAULTf_SET
#define MII_ANPr_LINK_PRTNR_ASYM_PAUSEf_GET BCM84868_MII_ANPr_LINK_PRTNR_ASYM_PAUSEf_GET
#define MII_ANPr_LINK_PRTNR_ASYM_PAUSEf_SET BCM84868_MII_ANPr_LINK_PRTNR_ASYM_PAUSEf_SET
#define MII_ANPr_PAUSE_CAPABLEf_GET BCM84868_MII_ANPr_PAUSE_CAPABLEf_GET
#define MII_ANPr_PAUSE_CAPABLEf_SET BCM84868_MII_ANPr_PAUSE_CAPABLEf_SET
#define MII_ANPr_X100BASE_T4_CAPf_GET BCM84868_MII_ANPr_X100BASE_T4_CAPf_GET
#define MII_ANPr_X100BASE_T4_CAPf_SET BCM84868_MII_ANPr_X100BASE_T4_CAPf_SET
#define MII_ANPr_X100BASE_TX_FULL_DUP_CAPf_GET BCM84868_MII_ANPr_X100BASE_TX_FULL_DUP_CAPf_GET
#define MII_ANPr_X100BASE_TX_FULL_DUP_CAPf_SET BCM84868_MII_ANPr_X100BASE_TX_FULL_DUP_CAPf_SET
#define MII_ANPr_X100BASE_TX_HALF_DUP_CAPf_GET BCM84868_MII_ANPr_X100BASE_TX_HALF_DUP_CAPf_GET
#define MII_ANPr_X100BASE_TX_HALF_DUP_CAPf_SET BCM84868_MII_ANPr_X100BASE_TX_HALF_DUP_CAPf_SET
#define MII_ANPr_X10BASE_T_FULL_DUP_CAPf_GET BCM84868_MII_ANPr_X10BASE_T_FULL_DUP_CAPf_GET
#define MII_ANPr_X10BASE_T_FULL_DUP_CAPf_SET BCM84868_MII_ANPr_X10BASE_T_FULL_DUP_CAPf_SET
#define MII_ANPr_X10BASE_T_HALF_DUP_CAPf_GET BCM84868_MII_ANPr_X10BASE_T_HALF_DUP_CAPf_GET
#define MII_ANPr_X10BASE_T_HALF_DUP_CAPf_SET BCM84868_MII_ANPr_X10BASE_T_HALF_DUP_CAPf_SET
#define MII_ANPr_PROTOCOL_SELECTORf_GET BCM84868_MII_ANPr_PROTOCOL_SELECTORf_GET
#define MII_ANPr_PROTOCOL_SELECTORf_SET BCM84868_MII_ANPr_PROTOCOL_SELECTORf_SET
#define READ_MII_ANPr BCM84868_READ_MII_ANPr
#define WRITE_MII_ANPr BCM84868_WRITE_MII_ANPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_ANPr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_AN_EXP
 * BLOCKS:   IEEE
 * REGADDR:  0xffe6
 * DEVAD:    7
 * DESC:     Auto-negotiation Expansion Register
 * SIZE:     32
 * FIELDS:
 *     LNK_PART_AN_ABLE 
 *     PG_RECEIVED      
 *     NXT_PG_ABLE      
 *     LNK_PART_NXT_PG_ABLE 
 *     PARALLEL_DETECTION_FLT 
 *     NXT_PG_RCV_LOCATION 
 *     NXT_PG_RCV_LOC_ABLE 
 */
#define BCM84868_MII_AN_EXPr (0x0007ffe6 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_AN_EXPr_SIZE 4

/*
 * This structure should be used to declare and program MII_AN_EXP.
 */
typedef union BCM84868_MII_AN_EXPr_s {
	uint32_t v[1];
	uint32_t mii_an_exp[1];
	uint32_t _mii_an_exp;
} BCM84868_MII_AN_EXPr_t;

#define BCM84868_MII_AN_EXPr_CLR(r) (r).mii_an_exp[0] = 0
#define BCM84868_MII_AN_EXPr_SET(r,d) (r).mii_an_exp[0] = d
#define BCM84868_MII_AN_EXPr_GET(r) (r).mii_an_exp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOC_ABLEf_GET(r) ((((r).mii_an_exp[0]) >> 6) & 0x1)
#define BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOC_ABLEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOCATIONf_GET(r) ((((r).mii_an_exp[0]) >> 5) & 0x1)
#define BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOCATIONf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_MII_AN_EXPr_PARALLEL_DETECTION_FLTf_GET(r) ((((r).mii_an_exp[0]) >> 4) & 0x1)
#define BCM84868_MII_AN_EXPr_PARALLEL_DETECTION_FLTf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_MII_AN_EXPr_LNK_PART_NXT_PG_ABLEf_GET(r) ((((r).mii_an_exp[0]) >> 3) & 0x1)
#define BCM84868_MII_AN_EXPr_LNK_PART_NXT_PG_ABLEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_MII_AN_EXPr_NXT_PG_ABLEf_GET(r) ((((r).mii_an_exp[0]) >> 2) & 0x1)
#define BCM84868_MII_AN_EXPr_NXT_PG_ABLEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_MII_AN_EXPr_PG_RECEIVEDf_GET(r) ((((r).mii_an_exp[0]) >> 1) & 0x1)
#define BCM84868_MII_AN_EXPr_PG_RECEIVEDf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_MII_AN_EXPr_LNK_PART_AN_ABLEf_GET(r) (((r).mii_an_exp[0]) & 0x1)
#define BCM84868_MII_AN_EXPr_LNK_PART_AN_ABLEf_SET(r,f) (r).mii_an_exp[0]=(((r).mii_an_exp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MII_AN_EXP.
 */
#define BCM84868_READ_MII_AN_EXPr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_AN_EXPr,(_r._mii_an_exp))
#define BCM84868_WRITE_MII_AN_EXPr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_AN_EXPr,(_r._mii_an_exp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_AN_EXPr BCM84868_MII_AN_EXPr
#define MII_AN_EXPr_SIZE BCM84868_MII_AN_EXPr_SIZE
typedef BCM84868_MII_AN_EXPr_t MII_AN_EXPr_t;
#define MII_AN_EXPr_CLR BCM84868_MII_AN_EXPr_CLR
#define MII_AN_EXPr_SET BCM84868_MII_AN_EXPr_SET
#define MII_AN_EXPr_GET BCM84868_MII_AN_EXPr_GET
#define MII_AN_EXPr_NXT_PG_RCV_LOC_ABLEf_GET BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOC_ABLEf_GET
#define MII_AN_EXPr_NXT_PG_RCV_LOC_ABLEf_SET BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOC_ABLEf_SET
#define MII_AN_EXPr_NXT_PG_RCV_LOCATIONf_GET BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOCATIONf_GET
#define MII_AN_EXPr_NXT_PG_RCV_LOCATIONf_SET BCM84868_MII_AN_EXPr_NXT_PG_RCV_LOCATIONf_SET
#define MII_AN_EXPr_PARALLEL_DETECTION_FLTf_GET BCM84868_MII_AN_EXPr_PARALLEL_DETECTION_FLTf_GET
#define MII_AN_EXPr_PARALLEL_DETECTION_FLTf_SET BCM84868_MII_AN_EXPr_PARALLEL_DETECTION_FLTf_SET
#define MII_AN_EXPr_LNK_PART_NXT_PG_ABLEf_GET BCM84868_MII_AN_EXPr_LNK_PART_NXT_PG_ABLEf_GET
#define MII_AN_EXPr_LNK_PART_NXT_PG_ABLEf_SET BCM84868_MII_AN_EXPr_LNK_PART_NXT_PG_ABLEf_SET
#define MII_AN_EXPr_NXT_PG_ABLEf_GET BCM84868_MII_AN_EXPr_NXT_PG_ABLEf_GET
#define MII_AN_EXPr_NXT_PG_ABLEf_SET BCM84868_MII_AN_EXPr_NXT_PG_ABLEf_SET
#define MII_AN_EXPr_PG_RECEIVEDf_GET BCM84868_MII_AN_EXPr_PG_RECEIVEDf_GET
#define MII_AN_EXPr_PG_RECEIVEDf_SET BCM84868_MII_AN_EXPr_PG_RECEIVEDf_SET
#define MII_AN_EXPr_LNK_PART_AN_ABLEf_GET BCM84868_MII_AN_EXPr_LNK_PART_AN_ABLEf_GET
#define MII_AN_EXPr_LNK_PART_AN_ABLEf_SET BCM84868_MII_AN_EXPr_LNK_PART_AN_ABLEf_SET
#define READ_MII_AN_EXPr BCM84868_READ_MII_AN_EXPr
#define WRITE_MII_AN_EXPr BCM84868_WRITE_MII_AN_EXPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_AN_EXPr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_AUTONEGNP
 * BLOCKS:   IEEE
 * REGADDR:  0xffe7
 * DEVAD:    7
 * DESC:     Auto-negotiation Next Page Register
 * SIZE:     32
 * FIELDS:
 *     CODE_FIELD       
 *     TOGGLE           
 *     ACKNOWLEDGE_2    
 *     MESSAGE_PAGE     
 *     NEXT_PAGE        
 */
#define BCM84868_MII_AUTONEGNPr (0x0007ffe7 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_AUTONEGNPr_SIZE 4

/*
 * This structure should be used to declare and program MII_AUTONEGNP.
 */
typedef union BCM84868_MII_AUTONEGNPr_s {
	uint32_t v[1];
	uint32_t mii_autonegnp[1];
	uint32_t _mii_autonegnp;
} BCM84868_MII_AUTONEGNPr_t;

#define BCM84868_MII_AUTONEGNPr_CLR(r) (r).mii_autonegnp[0] = 0
#define BCM84868_MII_AUTONEGNPr_SET(r,d) (r).mii_autonegnp[0] = d
#define BCM84868_MII_AUTONEGNPr_GET(r) (r).mii_autonegnp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_AUTONEGNPr_NEXT_PAGEf_GET(r) ((((r).mii_autonegnp[0]) >> 15) & 0x1)
#define BCM84868_MII_AUTONEGNPr_NEXT_PAGEf_SET(r,f) (r).mii_autonegnp[0]=(((r).mii_autonegnp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_AUTONEGNPr_MESSAGE_PAGEf_GET(r) ((((r).mii_autonegnp[0]) >> 13) & 0x1)
#define BCM84868_MII_AUTONEGNPr_MESSAGE_PAGEf_SET(r,f) (r).mii_autonegnp[0]=(((r).mii_autonegnp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_AUTONEGNPr_ACKNOWLEDGE_2f_GET(r) ((((r).mii_autonegnp[0]) >> 12) & 0x1)
#define BCM84868_MII_AUTONEGNPr_ACKNOWLEDGE_2f_SET(r,f) (r).mii_autonegnp[0]=(((r).mii_autonegnp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_MII_AUTONEGNPr_TOGGLEf_GET(r) ((((r).mii_autonegnp[0]) >> 11) & 0x1)
#define BCM84868_MII_AUTONEGNPr_TOGGLEf_SET(r,f) (r).mii_autonegnp[0]=(((r).mii_autonegnp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_AUTONEGNPr_CODE_FIELDf_GET(r) (((r).mii_autonegnp[0]) & 0x7ff)
#define BCM84868_MII_AUTONEGNPr_CODE_FIELDf_SET(r,f) (r).mii_autonegnp[0]=(((r).mii_autonegnp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access MII_AUTONEGNP.
 */
#define BCM84868_READ_MII_AUTONEGNPr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_AUTONEGNPr,(_r._mii_autonegnp))
#define BCM84868_WRITE_MII_AUTONEGNPr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_AUTONEGNPr,(_r._mii_autonegnp))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_AUTONEGNPr BCM84868_MII_AUTONEGNPr
#define MII_AUTONEGNPr_SIZE BCM84868_MII_AUTONEGNPr_SIZE
typedef BCM84868_MII_AUTONEGNPr_t MII_AUTONEGNPr_t;
#define MII_AUTONEGNPr_CLR BCM84868_MII_AUTONEGNPr_CLR
#define MII_AUTONEGNPr_SET BCM84868_MII_AUTONEGNPr_SET
#define MII_AUTONEGNPr_GET BCM84868_MII_AUTONEGNPr_GET
#define MII_AUTONEGNPr_NEXT_PAGEf_GET BCM84868_MII_AUTONEGNPr_NEXT_PAGEf_GET
#define MII_AUTONEGNPr_NEXT_PAGEf_SET BCM84868_MII_AUTONEGNPr_NEXT_PAGEf_SET
#define MII_AUTONEGNPr_MESSAGE_PAGEf_GET BCM84868_MII_AUTONEGNPr_MESSAGE_PAGEf_GET
#define MII_AUTONEGNPr_MESSAGE_PAGEf_SET BCM84868_MII_AUTONEGNPr_MESSAGE_PAGEf_SET
#define MII_AUTONEGNPr_ACKNOWLEDGE_2f_GET BCM84868_MII_AUTONEGNPr_ACKNOWLEDGE_2f_GET
#define MII_AUTONEGNPr_ACKNOWLEDGE_2f_SET BCM84868_MII_AUTONEGNPr_ACKNOWLEDGE_2f_SET
#define MII_AUTONEGNPr_TOGGLEf_GET BCM84868_MII_AUTONEGNPr_TOGGLEf_GET
#define MII_AUTONEGNPr_TOGGLEf_SET BCM84868_MII_AUTONEGNPr_TOGGLEf_SET
#define MII_AUTONEGNPr_CODE_FIELDf_GET BCM84868_MII_AUTONEGNPr_CODE_FIELDf_GET
#define MII_AUTONEGNPr_CODE_FIELDf_SET BCM84868_MII_AUTONEGNPr_CODE_FIELDf_SET
#define READ_MII_AUTONEGNPr BCM84868_READ_MII_AUTONEGNPr
#define WRITE_MII_AUTONEGNPr BCM84868_WRITE_MII_AUTONEGNPr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_AUTONEGNPr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_AUTONEGLPABIL2
 * BLOCKS:   IEEE
 * REGADDR:  0xffe8
 * DEVAD:    7
 * DESC:     Auto-negotiation Link Partner Ability 2Register
 * SIZE:     32
 * FIELDS:
 *     CODE_FIELD       
 *     TOGGLE           
 *     ACKNOWLEDGE_2    
 *     MESSAGE_PAGE     
 *     ACKNOWLEDGE      
 *     NEXT_PAGE        
 */
#define BCM84868_MII_AUTONEGLPABIL2r (0x0007ffe8 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_AUTONEGLPABIL2r_SIZE 4

/*
 * This structure should be used to declare and program MII_AUTONEGLPABIL2.
 */
typedef union BCM84868_MII_AUTONEGLPABIL2r_s {
	uint32_t v[1];
	uint32_t mii_autoneglpabil2[1];
	uint32_t _mii_autoneglpabil2;
} BCM84868_MII_AUTONEGLPABIL2r_t;

#define BCM84868_MII_AUTONEGLPABIL2r_CLR(r) (r).mii_autoneglpabil2[0] = 0
#define BCM84868_MII_AUTONEGLPABIL2r_SET(r,d) (r).mii_autoneglpabil2[0] = d
#define BCM84868_MII_AUTONEGLPABIL2r_GET(r) (r).mii_autoneglpabil2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_AUTONEGLPABIL2r_NEXT_PAGEf_GET(r) ((((r).mii_autoneglpabil2[0]) >> 15) & 0x1)
#define BCM84868_MII_AUTONEGLPABIL2r_NEXT_PAGEf_SET(r,f) (r).mii_autoneglpabil2[0]=(((r).mii_autoneglpabil2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGEf_GET(r) ((((r).mii_autoneglpabil2[0]) >> 14) & 0x1)
#define BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGEf_SET(r,f) (r).mii_autoneglpabil2[0]=(((r).mii_autoneglpabil2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_MII_AUTONEGLPABIL2r_MESSAGE_PAGEf_GET(r) ((((r).mii_autoneglpabil2[0]) >> 13) & 0x1)
#define BCM84868_MII_AUTONEGLPABIL2r_MESSAGE_PAGEf_SET(r,f) (r).mii_autoneglpabil2[0]=(((r).mii_autoneglpabil2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGE_2f_GET(r) ((((r).mii_autoneglpabil2[0]) >> 12) & 0x1)
#define BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGE_2f_SET(r,f) (r).mii_autoneglpabil2[0]=(((r).mii_autoneglpabil2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_MII_AUTONEGLPABIL2r_TOGGLEf_GET(r) ((((r).mii_autoneglpabil2[0]) >> 11) & 0x1)
#define BCM84868_MII_AUTONEGLPABIL2r_TOGGLEf_SET(r,f) (r).mii_autoneglpabil2[0]=(((r).mii_autoneglpabil2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_AUTONEGLPABIL2r_CODE_FIELDf_GET(r) (((r).mii_autoneglpabil2[0]) & 0x7ff)
#define BCM84868_MII_AUTONEGLPABIL2r_CODE_FIELDf_SET(r,f) (r).mii_autoneglpabil2[0]=(((r).mii_autoneglpabil2[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access MII_AUTONEGLPABIL2.
 */
#define BCM84868_READ_MII_AUTONEGLPABIL2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_AUTONEGLPABIL2r,(_r._mii_autoneglpabil2))
#define BCM84868_WRITE_MII_AUTONEGLPABIL2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_AUTONEGLPABIL2r,(_r._mii_autoneglpabil2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_AUTONEGLPABIL2r BCM84868_MII_AUTONEGLPABIL2r
#define MII_AUTONEGLPABIL2r_SIZE BCM84868_MII_AUTONEGLPABIL2r_SIZE
typedef BCM84868_MII_AUTONEGLPABIL2r_t MII_AUTONEGLPABIL2r_t;
#define MII_AUTONEGLPABIL2r_CLR BCM84868_MII_AUTONEGLPABIL2r_CLR
#define MII_AUTONEGLPABIL2r_SET BCM84868_MII_AUTONEGLPABIL2r_SET
#define MII_AUTONEGLPABIL2r_GET BCM84868_MII_AUTONEGLPABIL2r_GET
#define MII_AUTONEGLPABIL2r_NEXT_PAGEf_GET BCM84868_MII_AUTONEGLPABIL2r_NEXT_PAGEf_GET
#define MII_AUTONEGLPABIL2r_NEXT_PAGEf_SET BCM84868_MII_AUTONEGLPABIL2r_NEXT_PAGEf_SET
#define MII_AUTONEGLPABIL2r_ACKNOWLEDGEf_GET BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGEf_GET
#define MII_AUTONEGLPABIL2r_ACKNOWLEDGEf_SET BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGEf_SET
#define MII_AUTONEGLPABIL2r_MESSAGE_PAGEf_GET BCM84868_MII_AUTONEGLPABIL2r_MESSAGE_PAGEf_GET
#define MII_AUTONEGLPABIL2r_MESSAGE_PAGEf_SET BCM84868_MII_AUTONEGLPABIL2r_MESSAGE_PAGEf_SET
#define MII_AUTONEGLPABIL2r_ACKNOWLEDGE_2f_GET BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGE_2f_GET
#define MII_AUTONEGLPABIL2r_ACKNOWLEDGE_2f_SET BCM84868_MII_AUTONEGLPABIL2r_ACKNOWLEDGE_2f_SET
#define MII_AUTONEGLPABIL2r_TOGGLEf_GET BCM84868_MII_AUTONEGLPABIL2r_TOGGLEf_GET
#define MII_AUTONEGLPABIL2r_TOGGLEf_SET BCM84868_MII_AUTONEGLPABIL2r_TOGGLEf_SET
#define MII_AUTONEGLPABIL2r_CODE_FIELDf_GET BCM84868_MII_AUTONEGLPABIL2r_CODE_FIELDf_GET
#define MII_AUTONEGLPABIL2r_CODE_FIELDf_SET BCM84868_MII_AUTONEGLPABIL2r_CODE_FIELDf_SET
#define READ_MII_AUTONEGLPABIL2r BCM84868_READ_MII_AUTONEGLPABIL2r
#define WRITE_MII_AUTONEGLPABIL2r BCM84868_WRITE_MII_AUTONEGLPABIL2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_AUTONEGLPABIL2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_GB_CTRL
 * BLOCKS:   IEEE
 * REGADDR:  0xffe9
 * DEVAD:    7
 * DESC:     1000Base-T Control Register
 * SIZE:     32
 * FIELDS:
 *     ADV_1000BASE_T_HALF_DUPLEX 
 *     ADV_1000BASE_T_FULL_DUPLEX 
 *     REPEATER_DTE     
 *     MASTER_SLAVE_CONFIG_VALUE 
 *     MASTER_SLAVE_CONFIG_ENABLE 
 *     TEST_MODE        
 */
#define BCM84868_MII_GB_CTRLr (0x0007ffe9 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_GB_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program MII_GB_CTRL.
 */
typedef union BCM84868_MII_GB_CTRLr_s {
	uint32_t v[1];
	uint32_t mii_gb_ctrl[1];
	uint32_t _mii_gb_ctrl;
} BCM84868_MII_GB_CTRLr_t;

#define BCM84868_MII_GB_CTRLr_CLR(r) (r).mii_gb_ctrl[0] = 0
#define BCM84868_MII_GB_CTRLr_SET(r,d) (r).mii_gb_ctrl[0] = d
#define BCM84868_MII_GB_CTRLr_GET(r) (r).mii_gb_ctrl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_GB_CTRLr_TEST_MODEf_GET(r) ((((r).mii_gb_ctrl[0]) >> 13) & 0x7)
#define BCM84868_MII_GB_CTRLr_TEST_MODEf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_ENABLEf_GET(r) ((((r).mii_gb_ctrl[0]) >> 12) & 0x1)
#define BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_ENABLEf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_VALUEf_GET(r) ((((r).mii_gb_ctrl[0]) >> 11) & 0x1)
#define BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_VALUEf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_GB_CTRLr_REPEATER_DTEf_GET(r) ((((r).mii_gb_ctrl[0]) >> 10) & 0x1)
#define BCM84868_MII_GB_CTRLr_REPEATER_DTEf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_FULL_DUPLEXf_GET(r) ((((r).mii_gb_ctrl[0]) >> 9) & 0x1)
#define BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_FULL_DUPLEXf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_HALF_DUPLEXf_GET(r) ((((r).mii_gb_ctrl[0]) >> 8) & 0x1)
#define BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_HALF_DUPLEXf_SET(r,f) (r).mii_gb_ctrl[0]=(((r).mii_gb_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MII_GB_CTRL.
 */
#define BCM84868_READ_MII_GB_CTRLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_GB_CTRLr,(_r._mii_gb_ctrl))
#define BCM84868_WRITE_MII_GB_CTRLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_GB_CTRLr,(_r._mii_gb_ctrl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_GB_CTRLr BCM84868_MII_GB_CTRLr
#define MII_GB_CTRLr_SIZE BCM84868_MII_GB_CTRLr_SIZE
typedef BCM84868_MII_GB_CTRLr_t MII_GB_CTRLr_t;
#define MII_GB_CTRLr_CLR BCM84868_MII_GB_CTRLr_CLR
#define MII_GB_CTRLr_SET BCM84868_MII_GB_CTRLr_SET
#define MII_GB_CTRLr_GET BCM84868_MII_GB_CTRLr_GET
#define MII_GB_CTRLr_TEST_MODEf_GET BCM84868_MII_GB_CTRLr_TEST_MODEf_GET
#define MII_GB_CTRLr_TEST_MODEf_SET BCM84868_MII_GB_CTRLr_TEST_MODEf_SET
#define MII_GB_CTRLr_MASTER_SLAVE_CONFIG_ENABLEf_GET BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_ENABLEf_GET
#define MII_GB_CTRLr_MASTER_SLAVE_CONFIG_ENABLEf_SET BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_ENABLEf_SET
#define MII_GB_CTRLr_MASTER_SLAVE_CONFIG_VALUEf_GET BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_VALUEf_GET
#define MII_GB_CTRLr_MASTER_SLAVE_CONFIG_VALUEf_SET BCM84868_MII_GB_CTRLr_MASTER_SLAVE_CONFIG_VALUEf_SET
#define MII_GB_CTRLr_REPEATER_DTEf_GET BCM84868_MII_GB_CTRLr_REPEATER_DTEf_GET
#define MII_GB_CTRLr_REPEATER_DTEf_SET BCM84868_MII_GB_CTRLr_REPEATER_DTEf_SET
#define MII_GB_CTRLr_ADV_1000BASE_T_FULL_DUPLEXf_GET BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_FULL_DUPLEXf_GET
#define MII_GB_CTRLr_ADV_1000BASE_T_FULL_DUPLEXf_SET BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_FULL_DUPLEXf_SET
#define MII_GB_CTRLr_ADV_1000BASE_T_HALF_DUPLEXf_GET BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_HALF_DUPLEXf_GET
#define MII_GB_CTRLr_ADV_1000BASE_T_HALF_DUPLEXf_SET BCM84868_MII_GB_CTRLr_ADV_1000BASE_T_HALF_DUPLEXf_SET
#define READ_MII_GB_CTRLr BCM84868_READ_MII_GB_CTRLr
#define WRITE_MII_GB_CTRLr BCM84868_WRITE_MII_GB_CTRLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_GB_CTRLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_GB_STAT
 * BLOCKS:   IEEE
 * REGADDR:  0xffea
 * DEVAD:    7
 * DESC:     1000Base-T Status Register
 * SIZE:     32
 * FIELDS:
 *     IDLE_ERROR_COUNT 
 *     LNK_PART_HALF_DUP_ABLE 
 *     LNK_PART_FULL_DUP_ABLE 
 *     REMOTE_RECEIVER_STATUS 
 *     LOCAL_RECEIVER_STATUS 
 *     MASTER_SLAVE_CONF_RES 
 *     MASTER_SLAVE_CONF_FLT 
 */
#define BCM84868_MII_GB_STATr (0x0007ffea | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_GB_STATr_SIZE 4

/*
 * This structure should be used to declare and program MII_GB_STAT.
 */
typedef union BCM84868_MII_GB_STATr_s {
	uint32_t v[1];
	uint32_t mii_gb_stat[1];
	uint32_t _mii_gb_stat;
} BCM84868_MII_GB_STATr_t;

#define BCM84868_MII_GB_STATr_CLR(r) (r).mii_gb_stat[0] = 0
#define BCM84868_MII_GB_STATr_SET(r,d) (r).mii_gb_stat[0] = d
#define BCM84868_MII_GB_STATr_GET(r) (r).mii_gb_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_FLTf_GET(r) ((((r).mii_gb_stat[0]) >> 15) & 0x1)
#define BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_FLTf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_RESf_GET(r) ((((r).mii_gb_stat[0]) >> 14) & 0x1)
#define BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_RESf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_MII_GB_STATr_LOCAL_RECEIVER_STATUSf_GET(r) ((((r).mii_gb_stat[0]) >> 13) & 0x1)
#define BCM84868_MII_GB_STATr_LOCAL_RECEIVER_STATUSf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_GB_STATr_REMOTE_RECEIVER_STATUSf_GET(r) ((((r).mii_gb_stat[0]) >> 12) & 0x1)
#define BCM84868_MII_GB_STATr_REMOTE_RECEIVER_STATUSf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_MII_GB_STATr_LNK_PART_FULL_DUP_ABLEf_GET(r) ((((r).mii_gb_stat[0]) >> 11) & 0x1)
#define BCM84868_MII_GB_STATr_LNK_PART_FULL_DUP_ABLEf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_MII_GB_STATr_LNK_PART_HALF_DUP_ABLEf_GET(r) ((((r).mii_gb_stat[0]) >> 10) & 0x1)
#define BCM84868_MII_GB_STATr_LNK_PART_HALF_DUP_ABLEf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_MII_GB_STATr_IDLE_ERROR_COUNTf_GET(r) (((r).mii_gb_stat[0]) & 0xff)
#define BCM84868_MII_GB_STATr_IDLE_ERROR_COUNTf_SET(r,f) (r).mii_gb_stat[0]=(((r).mii_gb_stat[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MII_GB_STAT.
 */
#define BCM84868_READ_MII_GB_STATr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_GB_STATr,(_r._mii_gb_stat))
#define BCM84868_WRITE_MII_GB_STATr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_GB_STATr,(_r._mii_gb_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_GB_STATr BCM84868_MII_GB_STATr
#define MII_GB_STATr_SIZE BCM84868_MII_GB_STATr_SIZE
typedef BCM84868_MII_GB_STATr_t MII_GB_STATr_t;
#define MII_GB_STATr_CLR BCM84868_MII_GB_STATr_CLR
#define MII_GB_STATr_SET BCM84868_MII_GB_STATr_SET
#define MII_GB_STATr_GET BCM84868_MII_GB_STATr_GET
#define MII_GB_STATr_MASTER_SLAVE_CONF_FLTf_GET BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_FLTf_GET
#define MII_GB_STATr_MASTER_SLAVE_CONF_FLTf_SET BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_FLTf_SET
#define MII_GB_STATr_MASTER_SLAVE_CONF_RESf_GET BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_RESf_GET
#define MII_GB_STATr_MASTER_SLAVE_CONF_RESf_SET BCM84868_MII_GB_STATr_MASTER_SLAVE_CONF_RESf_SET
#define MII_GB_STATr_LOCAL_RECEIVER_STATUSf_GET BCM84868_MII_GB_STATr_LOCAL_RECEIVER_STATUSf_GET
#define MII_GB_STATr_LOCAL_RECEIVER_STATUSf_SET BCM84868_MII_GB_STATr_LOCAL_RECEIVER_STATUSf_SET
#define MII_GB_STATr_REMOTE_RECEIVER_STATUSf_GET BCM84868_MII_GB_STATr_REMOTE_RECEIVER_STATUSf_GET
#define MII_GB_STATr_REMOTE_RECEIVER_STATUSf_SET BCM84868_MII_GB_STATr_REMOTE_RECEIVER_STATUSf_SET
#define MII_GB_STATr_LNK_PART_FULL_DUP_ABLEf_GET BCM84868_MII_GB_STATr_LNK_PART_FULL_DUP_ABLEf_GET
#define MII_GB_STATr_LNK_PART_FULL_DUP_ABLEf_SET BCM84868_MII_GB_STATr_LNK_PART_FULL_DUP_ABLEf_SET
#define MII_GB_STATr_LNK_PART_HALF_DUP_ABLEf_GET BCM84868_MII_GB_STATr_LNK_PART_HALF_DUP_ABLEf_GET
#define MII_GB_STATr_LNK_PART_HALF_DUP_ABLEf_SET BCM84868_MII_GB_STATr_LNK_PART_HALF_DUP_ABLEf_SET
#define MII_GB_STATr_IDLE_ERROR_COUNTf_GET BCM84868_MII_GB_STATr_IDLE_ERROR_COUNTf_GET
#define MII_GB_STATr_IDLE_ERROR_COUNTf_SET BCM84868_MII_GB_STATr_IDLE_ERROR_COUNTf_SET
#define READ_MII_GB_STATr BCM84868_READ_MII_GB_STATr
#define WRITE_MII_GB_STATr BCM84868_WRITE_MII_GB_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_GB_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MII_ESR
 * BLOCKS:   IEEE
 * REGADDR:  0xffef
 * DEVAD:    7
 * DESC:     Extended Status Register
 * SIZE:     32
 * FIELDS:
 *     X1000BASE_T_HALF_DUPLEX_CAPABLE 
 *     X1000BASE_T_FULL_DUPLEX_CAPABLE 
 *     X1000BASE_X_HALF_DUPLEX_CAPABLE 
 *     X1000BASE_X_FULL_DUPLEX_CAPABLE 
 */
#define BCM84868_MII_ESRr (0x0007ffef | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MII_ESRr_SIZE 4

/*
 * This structure should be used to declare and program MII_ESR.
 */
typedef union BCM84868_MII_ESRr_s {
	uint32_t v[1];
	uint32_t mii_esr[1];
	uint32_t _mii_esr;
} BCM84868_MII_ESRr_t;

#define BCM84868_MII_ESRr_CLR(r) (r).mii_esr[0] = 0
#define BCM84868_MII_ESRr_SET(r,d) (r).mii_esr[0] = d
#define BCM84868_MII_ESRr_GET(r) (r).mii_esr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MII_ESRr_X1000BASE_X_FULL_DUPLEX_CAPABLEf_GET(r) ((((r).mii_esr[0]) >> 15) & 0x1)
#define BCM84868_MII_ESRr_X1000BASE_X_FULL_DUPLEX_CAPABLEf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_MII_ESRr_X1000BASE_X_HALF_DUPLEX_CAPABLEf_GET(r) ((((r).mii_esr[0]) >> 14) & 0x1)
#define BCM84868_MII_ESRr_X1000BASE_X_HALF_DUPLEX_CAPABLEf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_MII_ESRr_X1000BASE_T_FULL_DUPLEX_CAPABLEf_GET(r) ((((r).mii_esr[0]) >> 13) & 0x1)
#define BCM84868_MII_ESRr_X1000BASE_T_FULL_DUPLEX_CAPABLEf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_MII_ESRr_X1000BASE_T_HALF_DUPLEX_CAPABLEf_GET(r) ((((r).mii_esr[0]) >> 12) & 0x1)
#define BCM84868_MII_ESRr_X1000BASE_T_HALF_DUPLEX_CAPABLEf_SET(r,f) (r).mii_esr[0]=(((r).mii_esr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access MII_ESR.
 */
#define BCM84868_READ_MII_ESRr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MII_ESRr,(_r._mii_esr))
#define BCM84868_WRITE_MII_ESRr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MII_ESRr,(_r._mii_esr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MII_ESRr BCM84868_MII_ESRr
#define MII_ESRr_SIZE BCM84868_MII_ESRr_SIZE
typedef BCM84868_MII_ESRr_t MII_ESRr_t;
#define MII_ESRr_CLR BCM84868_MII_ESRr_CLR
#define MII_ESRr_SET BCM84868_MII_ESRr_SET
#define MII_ESRr_GET BCM84868_MII_ESRr_GET
#define MII_ESRr_X1000BASE_X_FULL_DUPLEX_CAPABLEf_GET BCM84868_MII_ESRr_X1000BASE_X_FULL_DUPLEX_CAPABLEf_GET
#define MII_ESRr_X1000BASE_X_FULL_DUPLEX_CAPABLEf_SET BCM84868_MII_ESRr_X1000BASE_X_FULL_DUPLEX_CAPABLEf_SET
#define MII_ESRr_X1000BASE_X_HALF_DUPLEX_CAPABLEf_GET BCM84868_MII_ESRr_X1000BASE_X_HALF_DUPLEX_CAPABLEf_GET
#define MII_ESRr_X1000BASE_X_HALF_DUPLEX_CAPABLEf_SET BCM84868_MII_ESRr_X1000BASE_X_HALF_DUPLEX_CAPABLEf_SET
#define MII_ESRr_X1000BASE_T_FULL_DUPLEX_CAPABLEf_GET BCM84868_MII_ESRr_X1000BASE_T_FULL_DUPLEX_CAPABLEf_GET
#define MII_ESRr_X1000BASE_T_FULL_DUPLEX_CAPABLEf_SET BCM84868_MII_ESRr_X1000BASE_T_FULL_DUPLEX_CAPABLEf_SET
#define MII_ESRr_X1000BASE_T_HALF_DUPLEX_CAPABLEf_GET BCM84868_MII_ESRr_X1000BASE_T_HALF_DUPLEX_CAPABLEf_GET
#define MII_ESRr_X1000BASE_T_HALF_DUPLEX_CAPABLEf_SET BCM84868_MII_ESRr_X1000BASE_T_HALF_DUPLEX_CAPABLEf_SET
#define READ_MII_ESRr BCM84868_READ_MII_ESRr
#define WRITE_MII_ESRr BCM84868_WRITE_MII_ESRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MII_ESRr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHY_ECR
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfff0
 * DEVAD:    7
 * DESC:     PHY Extended Control Register
 * SIZE:     32
 * FIELDS:
 *     GMII_RGMII_FIFO_ELASTICITY 
 *     BLOCK_TXEN_MODE  
 *     FORCE_LEDS_OFF   
 *     FORCE_LEDS_ON    
 *     ENABLE_LED_TRAFFIC_MODE 
 *     RESET_SCRAMBLER  
 *     BYPASS_ALIGNMENT 
 *     BYPASS_NRZI_MLT3 
 *     BYPASS_SCRAMBLER 
 *     BYPASS_ENCODER   
 *     FORCE_INTERRUPT  
 *     INTERRUPT_DISABLE 
 *     TRANSMIT_DISABLE 
 *     DISABLE_AUTO_MDI_CROSSOVR 
 *     MAC_PHY_INTERFACE_MODE 
 */
#define BCM84868_PHY_ECRr (0x0007fff0 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHY_ECRr_SIZE 4

/*
 * This structure should be used to declare and program PHY_ECR.
 */
typedef union BCM84868_PHY_ECRr_s {
	uint32_t v[1];
	uint32_t phy_ecr[1];
	uint32_t _phy_ecr;
} BCM84868_PHY_ECRr_t;

#define BCM84868_PHY_ECRr_CLR(r) (r).phy_ecr[0] = 0
#define BCM84868_PHY_ECRr_SET(r,d) (r).phy_ecr[0] = d
#define BCM84868_PHY_ECRr_GET(r) (r).phy_ecr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHY_ECRr_MAC_PHY_INTERFACE_MODEf_GET(r) ((((r).phy_ecr[0]) >> 15) & 0x1)
#define BCM84868_PHY_ECRr_MAC_PHY_INTERFACE_MODEf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PHY_ECRr_DISABLE_AUTO_MDI_CROSSOVRf_GET(r) ((((r).phy_ecr[0]) >> 14) & 0x1)
#define BCM84868_PHY_ECRr_DISABLE_AUTO_MDI_CROSSOVRf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PHY_ECRr_TRANSMIT_DISABLEf_GET(r) ((((r).phy_ecr[0]) >> 13) & 0x1)
#define BCM84868_PHY_ECRr_TRANSMIT_DISABLEf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PHY_ECRr_INTERRUPT_DISABLEf_GET(r) ((((r).phy_ecr[0]) >> 12) & 0x1)
#define BCM84868_PHY_ECRr_INTERRUPT_DISABLEf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PHY_ECRr_FORCE_INTERRUPTf_GET(r) ((((r).phy_ecr[0]) >> 11) & 0x1)
#define BCM84868_PHY_ECRr_FORCE_INTERRUPTf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PHY_ECRr_BYPASS_ENCODERf_GET(r) ((((r).phy_ecr[0]) >> 10) & 0x1)
#define BCM84868_PHY_ECRr_BYPASS_ENCODERf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PHY_ECRr_BYPASS_SCRAMBLERf_GET(r) ((((r).phy_ecr[0]) >> 9) & 0x1)
#define BCM84868_PHY_ECRr_BYPASS_SCRAMBLERf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_PHY_ECRr_BYPASS_NRZI_MLT3f_GET(r) ((((r).phy_ecr[0]) >> 8) & 0x1)
#define BCM84868_PHY_ECRr_BYPASS_NRZI_MLT3f_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_PHY_ECRr_BYPASS_ALIGNMENTf_GET(r) ((((r).phy_ecr[0]) >> 7) & 0x1)
#define BCM84868_PHY_ECRr_BYPASS_ALIGNMENTf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PHY_ECRr_RESET_SCRAMBLERf_GET(r) ((((r).phy_ecr[0]) >> 6) & 0x1)
#define BCM84868_PHY_ECRr_RESET_SCRAMBLERf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PHY_ECRr_ENABLE_LED_TRAFFIC_MODEf_GET(r) ((((r).phy_ecr[0]) >> 5) & 0x1)
#define BCM84868_PHY_ECRr_ENABLE_LED_TRAFFIC_MODEf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PHY_ECRr_FORCE_LEDS_ONf_GET(r) ((((r).phy_ecr[0]) >> 4) & 0x1)
#define BCM84868_PHY_ECRr_FORCE_LEDS_ONf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PHY_ECRr_FORCE_LEDS_OFFf_GET(r) ((((r).phy_ecr[0]) >> 3) & 0x1)
#define BCM84868_PHY_ECRr_FORCE_LEDS_OFFf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PHY_ECRr_BLOCK_TXEN_MODEf_GET(r) ((((r).phy_ecr[0]) >> 2) & 0x1)
#define BCM84868_PHY_ECRr_BLOCK_TXEN_MODEf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PHY_ECRr_GMII_RGMII_FIFO_ELASTICITYf_GET(r) (((r).phy_ecr[0]) & 0x1)
#define BCM84868_PHY_ECRr_GMII_RGMII_FIFO_ELASTICITYf_SET(r,f) (r).phy_ecr[0]=(((r).phy_ecr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PHY_ECR.
 */
#define BCM84868_READ_PHY_ECRr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHY_ECRr,(_r._phy_ecr))
#define BCM84868_WRITE_PHY_ECRr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHY_ECRr,(_r._phy_ecr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHY_ECRr BCM84868_PHY_ECRr
#define PHY_ECRr_SIZE BCM84868_PHY_ECRr_SIZE
typedef BCM84868_PHY_ECRr_t PHY_ECRr_t;
#define PHY_ECRr_CLR BCM84868_PHY_ECRr_CLR
#define PHY_ECRr_SET BCM84868_PHY_ECRr_SET
#define PHY_ECRr_GET BCM84868_PHY_ECRr_GET
#define PHY_ECRr_MAC_PHY_INTERFACE_MODEf_GET BCM84868_PHY_ECRr_MAC_PHY_INTERFACE_MODEf_GET
#define PHY_ECRr_MAC_PHY_INTERFACE_MODEf_SET BCM84868_PHY_ECRr_MAC_PHY_INTERFACE_MODEf_SET
#define PHY_ECRr_DISABLE_AUTO_MDI_CROSSOVRf_GET BCM84868_PHY_ECRr_DISABLE_AUTO_MDI_CROSSOVRf_GET
#define PHY_ECRr_DISABLE_AUTO_MDI_CROSSOVRf_SET BCM84868_PHY_ECRr_DISABLE_AUTO_MDI_CROSSOVRf_SET
#define PHY_ECRr_TRANSMIT_DISABLEf_GET BCM84868_PHY_ECRr_TRANSMIT_DISABLEf_GET
#define PHY_ECRr_TRANSMIT_DISABLEf_SET BCM84868_PHY_ECRr_TRANSMIT_DISABLEf_SET
#define PHY_ECRr_INTERRUPT_DISABLEf_GET BCM84868_PHY_ECRr_INTERRUPT_DISABLEf_GET
#define PHY_ECRr_INTERRUPT_DISABLEf_SET BCM84868_PHY_ECRr_INTERRUPT_DISABLEf_SET
#define PHY_ECRr_FORCE_INTERRUPTf_GET BCM84868_PHY_ECRr_FORCE_INTERRUPTf_GET
#define PHY_ECRr_FORCE_INTERRUPTf_SET BCM84868_PHY_ECRr_FORCE_INTERRUPTf_SET
#define PHY_ECRr_BYPASS_ENCODERf_GET BCM84868_PHY_ECRr_BYPASS_ENCODERf_GET
#define PHY_ECRr_BYPASS_ENCODERf_SET BCM84868_PHY_ECRr_BYPASS_ENCODERf_SET
#define PHY_ECRr_BYPASS_SCRAMBLERf_GET BCM84868_PHY_ECRr_BYPASS_SCRAMBLERf_GET
#define PHY_ECRr_BYPASS_SCRAMBLERf_SET BCM84868_PHY_ECRr_BYPASS_SCRAMBLERf_SET
#define PHY_ECRr_BYPASS_NRZI_MLT3f_GET BCM84868_PHY_ECRr_BYPASS_NRZI_MLT3f_GET
#define PHY_ECRr_BYPASS_NRZI_MLT3f_SET BCM84868_PHY_ECRr_BYPASS_NRZI_MLT3f_SET
#define PHY_ECRr_BYPASS_ALIGNMENTf_GET BCM84868_PHY_ECRr_BYPASS_ALIGNMENTf_GET
#define PHY_ECRr_BYPASS_ALIGNMENTf_SET BCM84868_PHY_ECRr_BYPASS_ALIGNMENTf_SET
#define PHY_ECRr_RESET_SCRAMBLERf_GET BCM84868_PHY_ECRr_RESET_SCRAMBLERf_GET
#define PHY_ECRr_RESET_SCRAMBLERf_SET BCM84868_PHY_ECRr_RESET_SCRAMBLERf_SET
#define PHY_ECRr_ENABLE_LED_TRAFFIC_MODEf_GET BCM84868_PHY_ECRr_ENABLE_LED_TRAFFIC_MODEf_GET
#define PHY_ECRr_ENABLE_LED_TRAFFIC_MODEf_SET BCM84868_PHY_ECRr_ENABLE_LED_TRAFFIC_MODEf_SET
#define PHY_ECRr_FORCE_LEDS_ONf_GET BCM84868_PHY_ECRr_FORCE_LEDS_ONf_GET
#define PHY_ECRr_FORCE_LEDS_ONf_SET BCM84868_PHY_ECRr_FORCE_LEDS_ONf_SET
#define PHY_ECRr_FORCE_LEDS_OFFf_GET BCM84868_PHY_ECRr_FORCE_LEDS_OFFf_GET
#define PHY_ECRr_FORCE_LEDS_OFFf_SET BCM84868_PHY_ECRr_FORCE_LEDS_OFFf_SET
#define PHY_ECRr_BLOCK_TXEN_MODEf_GET BCM84868_PHY_ECRr_BLOCK_TXEN_MODEf_GET
#define PHY_ECRr_BLOCK_TXEN_MODEf_SET BCM84868_PHY_ECRr_BLOCK_TXEN_MODEf_SET
#define PHY_ECRr_GMII_RGMII_FIFO_ELASTICITYf_GET BCM84868_PHY_ECRr_GMII_RGMII_FIFO_ELASTICITYf_GET
#define PHY_ECRr_GMII_RGMII_FIFO_ELASTICITYf_SET BCM84868_PHY_ECRr_GMII_RGMII_FIFO_ELASTICITYf_SET
#define READ_PHY_ECRr BCM84868_READ_PHY_ECRr
#define WRITE_PHY_ECRr BCM84868_WRITE_PHY_ECRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHY_ECRr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHY_ESR
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfff1
 * DEVAD:    7
 * DESC:     PHY Extended Status Register
 * SIZE:     32
 * FIELDS:
 *     MLT3_CODE_ERROR_DETECTED 
 *     LOCK_ERROR_DETECTED 
 *     TRANSMIT_ERROR_DETECTED 
 *     RECEIVE_ERROR_DETECTED 
 *     BAD_ESD_DETECTED 
 *     BAD_SSD_DETECTED 
 *     CARRIER_EXT_ERR_DETECTED 
 *     CRC_ERROR_DETECTED 
 *     LINK_STATUS      
 *     LOCKED           
 *     LOCAL_RECEIVER_STATUS 
 *     REMOTE_RECEIVER_STATUS 
 *     INTERRUPT_STATUS 
 *     MDI_CROSSOVER_STATE 
 *     WIRESPEED_DOWNGRADE 
 *     AN_BSPG_SEL_FIELD_MISMATCH 
 */
#define BCM84868_PHY_ESRr (0x0007fff1 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHY_ESRr_SIZE 4

/*
 * This structure should be used to declare and program PHY_ESR.
 */
typedef union BCM84868_PHY_ESRr_s {
	uint32_t v[1];
	uint32_t phy_esr[1];
	uint32_t _phy_esr;
} BCM84868_PHY_ESRr_t;

#define BCM84868_PHY_ESRr_CLR(r) (r).phy_esr[0] = 0
#define BCM84868_PHY_ESRr_SET(r,d) (r).phy_esr[0] = d
#define BCM84868_PHY_ESRr_GET(r) (r).phy_esr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHY_ESRr_AN_BSPG_SEL_FIELD_MISMATCHf_GET(r) ((((r).phy_esr[0]) >> 15) & 0x1)
#define BCM84868_PHY_ESRr_AN_BSPG_SEL_FIELD_MISMATCHf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PHY_ESRr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).phy_esr[0]) >> 14) & 0x1)
#define BCM84868_PHY_ESRr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PHY_ESRr_MDI_CROSSOVER_STATEf_GET(r) ((((r).phy_esr[0]) >> 13) & 0x1)
#define BCM84868_PHY_ESRr_MDI_CROSSOVER_STATEf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PHY_ESRr_INTERRUPT_STATUSf_GET(r) ((((r).phy_esr[0]) >> 12) & 0x1)
#define BCM84868_PHY_ESRr_INTERRUPT_STATUSf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PHY_ESRr_REMOTE_RECEIVER_STATUSf_GET(r) ((((r).phy_esr[0]) >> 11) & 0x1)
#define BCM84868_PHY_ESRr_REMOTE_RECEIVER_STATUSf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PHY_ESRr_LOCAL_RECEIVER_STATUSf_GET(r) ((((r).phy_esr[0]) >> 10) & 0x1)
#define BCM84868_PHY_ESRr_LOCAL_RECEIVER_STATUSf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_PHY_ESRr_LOCKEDf_GET(r) ((((r).phy_esr[0]) >> 9) & 0x1)
#define BCM84868_PHY_ESRr_LOCKEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_PHY_ESRr_LINK_STATUSf_GET(r) ((((r).phy_esr[0]) >> 8) & 0x1)
#define BCM84868_PHY_ESRr_LINK_STATUSf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_PHY_ESRr_CRC_ERROR_DETECTEDf_GET(r) ((((r).phy_esr[0]) >> 7) & 0x1)
#define BCM84868_PHY_ESRr_CRC_ERROR_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PHY_ESRr_CARRIER_EXT_ERR_DETECTEDf_GET(r) ((((r).phy_esr[0]) >> 6) & 0x1)
#define BCM84868_PHY_ESRr_CARRIER_EXT_ERR_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PHY_ESRr_BAD_SSD_DETECTEDf_GET(r) ((((r).phy_esr[0]) >> 5) & 0x1)
#define BCM84868_PHY_ESRr_BAD_SSD_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PHY_ESRr_BAD_ESD_DETECTEDf_GET(r) ((((r).phy_esr[0]) >> 4) & 0x1)
#define BCM84868_PHY_ESRr_BAD_ESD_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PHY_ESRr_RECEIVE_ERROR_DETECTEDf_GET(r) ((((r).phy_esr[0]) >> 3) & 0x1)
#define BCM84868_PHY_ESRr_RECEIVE_ERROR_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PHY_ESRr_TRANSMIT_ERROR_DETECTEDf_GET(r) ((((r).phy_esr[0]) >> 2) & 0x1)
#define BCM84868_PHY_ESRr_TRANSMIT_ERROR_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PHY_ESRr_LOCK_ERROR_DETECTEDf_GET(r) ((((r).phy_esr[0]) >> 1) & 0x1)
#define BCM84868_PHY_ESRr_LOCK_ERROR_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PHY_ESRr_MLT3_CODE_ERROR_DETECTEDf_GET(r) (((r).phy_esr[0]) & 0x1)
#define BCM84868_PHY_ESRr_MLT3_CODE_ERROR_DETECTEDf_SET(r,f) (r).phy_esr[0]=(((r).phy_esr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PHY_ESR.
 */
#define BCM84868_READ_PHY_ESRr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHY_ESRr,(_r._phy_esr))
#define BCM84868_WRITE_PHY_ESRr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHY_ESRr,(_r._phy_esr))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHY_ESRr BCM84868_PHY_ESRr
#define PHY_ESRr_SIZE BCM84868_PHY_ESRr_SIZE
typedef BCM84868_PHY_ESRr_t PHY_ESRr_t;
#define PHY_ESRr_CLR BCM84868_PHY_ESRr_CLR
#define PHY_ESRr_SET BCM84868_PHY_ESRr_SET
#define PHY_ESRr_GET BCM84868_PHY_ESRr_GET
#define PHY_ESRr_AN_BSPG_SEL_FIELD_MISMATCHf_GET BCM84868_PHY_ESRr_AN_BSPG_SEL_FIELD_MISMATCHf_GET
#define PHY_ESRr_AN_BSPG_SEL_FIELD_MISMATCHf_SET BCM84868_PHY_ESRr_AN_BSPG_SEL_FIELD_MISMATCHf_SET
#define PHY_ESRr_WIRESPEED_DOWNGRADEf_GET BCM84868_PHY_ESRr_WIRESPEED_DOWNGRADEf_GET
#define PHY_ESRr_WIRESPEED_DOWNGRADEf_SET BCM84868_PHY_ESRr_WIRESPEED_DOWNGRADEf_SET
#define PHY_ESRr_MDI_CROSSOVER_STATEf_GET BCM84868_PHY_ESRr_MDI_CROSSOVER_STATEf_GET
#define PHY_ESRr_MDI_CROSSOVER_STATEf_SET BCM84868_PHY_ESRr_MDI_CROSSOVER_STATEf_SET
#define PHY_ESRr_INTERRUPT_STATUSf_GET BCM84868_PHY_ESRr_INTERRUPT_STATUSf_GET
#define PHY_ESRr_INTERRUPT_STATUSf_SET BCM84868_PHY_ESRr_INTERRUPT_STATUSf_SET
#define PHY_ESRr_REMOTE_RECEIVER_STATUSf_GET BCM84868_PHY_ESRr_REMOTE_RECEIVER_STATUSf_GET
#define PHY_ESRr_REMOTE_RECEIVER_STATUSf_SET BCM84868_PHY_ESRr_REMOTE_RECEIVER_STATUSf_SET
#define PHY_ESRr_LOCAL_RECEIVER_STATUSf_GET BCM84868_PHY_ESRr_LOCAL_RECEIVER_STATUSf_GET
#define PHY_ESRr_LOCAL_RECEIVER_STATUSf_SET BCM84868_PHY_ESRr_LOCAL_RECEIVER_STATUSf_SET
#define PHY_ESRr_LOCKEDf_GET BCM84868_PHY_ESRr_LOCKEDf_GET
#define PHY_ESRr_LOCKEDf_SET BCM84868_PHY_ESRr_LOCKEDf_SET
#define PHY_ESRr_LINK_STATUSf_GET BCM84868_PHY_ESRr_LINK_STATUSf_GET
#define PHY_ESRr_LINK_STATUSf_SET BCM84868_PHY_ESRr_LINK_STATUSf_SET
#define PHY_ESRr_CRC_ERROR_DETECTEDf_GET BCM84868_PHY_ESRr_CRC_ERROR_DETECTEDf_GET
#define PHY_ESRr_CRC_ERROR_DETECTEDf_SET BCM84868_PHY_ESRr_CRC_ERROR_DETECTEDf_SET
#define PHY_ESRr_CARRIER_EXT_ERR_DETECTEDf_GET BCM84868_PHY_ESRr_CARRIER_EXT_ERR_DETECTEDf_GET
#define PHY_ESRr_CARRIER_EXT_ERR_DETECTEDf_SET BCM84868_PHY_ESRr_CARRIER_EXT_ERR_DETECTEDf_SET
#define PHY_ESRr_BAD_SSD_DETECTEDf_GET BCM84868_PHY_ESRr_BAD_SSD_DETECTEDf_GET
#define PHY_ESRr_BAD_SSD_DETECTEDf_SET BCM84868_PHY_ESRr_BAD_SSD_DETECTEDf_SET
#define PHY_ESRr_BAD_ESD_DETECTEDf_GET BCM84868_PHY_ESRr_BAD_ESD_DETECTEDf_GET
#define PHY_ESRr_BAD_ESD_DETECTEDf_SET BCM84868_PHY_ESRr_BAD_ESD_DETECTEDf_SET
#define PHY_ESRr_RECEIVE_ERROR_DETECTEDf_GET BCM84868_PHY_ESRr_RECEIVE_ERROR_DETECTEDf_GET
#define PHY_ESRr_RECEIVE_ERROR_DETECTEDf_SET BCM84868_PHY_ESRr_RECEIVE_ERROR_DETECTEDf_SET
#define PHY_ESRr_TRANSMIT_ERROR_DETECTEDf_GET BCM84868_PHY_ESRr_TRANSMIT_ERROR_DETECTEDf_GET
#define PHY_ESRr_TRANSMIT_ERROR_DETECTEDf_SET BCM84868_PHY_ESRr_TRANSMIT_ERROR_DETECTEDf_SET
#define PHY_ESRr_LOCK_ERROR_DETECTEDf_GET BCM84868_PHY_ESRr_LOCK_ERROR_DETECTEDf_GET
#define PHY_ESRr_LOCK_ERROR_DETECTEDf_SET BCM84868_PHY_ESRr_LOCK_ERROR_DETECTEDf_SET
#define PHY_ESRr_MLT3_CODE_ERROR_DETECTEDf_GET BCM84868_PHY_ESRr_MLT3_CODE_ERROR_DETECTEDf_GET
#define PHY_ESRr_MLT3_CODE_ERROR_DETECTEDf_SET BCM84868_PHY_ESRr_MLT3_CODE_ERROR_DETECTEDf_SET
#define READ_PHY_ESRr BCM84868_READ_PHY_ESRr
#define WRITE_PHY_ESRr BCM84868_WRITE_PHY_ESRr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHY_ESRr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHY_RCVERRCOUNT
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfff2
 * DEVAD:    7
 * DESC:     Receive Error Counter
 * SIZE:     32
 * FIELDS:
 *     RECEIVE_ERROR_COUNTER 
 */
#define BCM84868_PHY_RCVERRCOUNTr (0x0007fff2 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHY_RCVERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program PHY_RCVERRCOUNT.
 */
typedef union BCM84868_PHY_RCVERRCOUNTr_s {
	uint32_t v[1];
	uint32_t phy_rcverrcount[1];
	uint32_t _phy_rcverrcount;
} BCM84868_PHY_RCVERRCOUNTr_t;

#define BCM84868_PHY_RCVERRCOUNTr_CLR(r) (r).phy_rcverrcount[0] = 0
#define BCM84868_PHY_RCVERRCOUNTr_SET(r,d) (r).phy_rcverrcount[0] = d
#define BCM84868_PHY_RCVERRCOUNTr_GET(r) (r).phy_rcverrcount[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHY_RCVERRCOUNTr_RECEIVE_ERROR_COUNTERf_GET(r) (((r).phy_rcverrcount[0]) & 0xffff)
#define BCM84868_PHY_RCVERRCOUNTr_RECEIVE_ERROR_COUNTERf_SET(r,f) (r).phy_rcverrcount[0]=(((r).phy_rcverrcount[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHY_RCVERRCOUNT.
 */
#define BCM84868_READ_PHY_RCVERRCOUNTr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHY_RCVERRCOUNTr,(_r._phy_rcverrcount))
#define BCM84868_WRITE_PHY_RCVERRCOUNTr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHY_RCVERRCOUNTr,(_r._phy_rcverrcount))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHY_RCVERRCOUNTr BCM84868_PHY_RCVERRCOUNTr
#define PHY_RCVERRCOUNTr_SIZE BCM84868_PHY_RCVERRCOUNTr_SIZE
typedef BCM84868_PHY_RCVERRCOUNTr_t PHY_RCVERRCOUNTr_t;
#define PHY_RCVERRCOUNTr_CLR BCM84868_PHY_RCVERRCOUNTr_CLR
#define PHY_RCVERRCOUNTr_SET BCM84868_PHY_RCVERRCOUNTr_SET
#define PHY_RCVERRCOUNTr_GET BCM84868_PHY_RCVERRCOUNTr_GET
#define PHY_RCVERRCOUNTr_RECEIVE_ERROR_COUNTERf_GET BCM84868_PHY_RCVERRCOUNTr_RECEIVE_ERROR_COUNTERf_GET
#define PHY_RCVERRCOUNTr_RECEIVE_ERROR_COUNTERf_SET BCM84868_PHY_RCVERRCOUNTr_RECEIVE_ERROR_COUNTERf_SET
#define READ_PHY_RCVERRCOUNTr BCM84868_READ_PHY_RCVERRCOUNTr
#define WRITE_PHY_RCVERRCOUNTr BCM84868_WRITE_PHY_RCVERRCOUNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHY_RCVERRCOUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHY_FALSECARRIERSENCECOUNT
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfff3
 * DEVAD:    7
 * DESC:     False Carrier Sense Counter
 * SIZE:     32
 * FIELDS:
 *     FALSE_CAR_SENSE_COUNT 
 *     SERDES_BER_COUNT 
 */
#define BCM84868_PHY_FALSECARRIERSENCECOUNTr (0x0007fff3 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_SIZE 4

/*
 * This structure should be used to declare and program PHY_FALSECARRIERSENCECOUNT.
 */
typedef union BCM84868_PHY_FALSECARRIERSENCECOUNTr_s {
	uint32_t v[1];
	uint32_t phy_falsecarriersencecount[1];
	uint32_t _phy_falsecarriersencecount;
} BCM84868_PHY_FALSECARRIERSENCECOUNTr_t;

#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_CLR(r) (r).phy_falsecarriersencecount[0] = 0
#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_SET(r,d) (r).phy_falsecarriersencecount[0] = d
#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_GET(r) (r).phy_falsecarriersencecount[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_SERDES_BER_COUNTf_GET(r) ((((r).phy_falsecarriersencecount[0]) >> 8) & 0xff)
#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_SERDES_BER_COUNTf_SET(r,f) (r).phy_falsecarriersencecount[0]=(((r).phy_falsecarriersencecount[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_FALSE_CAR_SENSE_COUNTf_GET(r) (((r).phy_falsecarriersencecount[0]) & 0xff)
#define BCM84868_PHY_FALSECARRIERSENCECOUNTr_FALSE_CAR_SENSE_COUNTf_SET(r,f) (r).phy_falsecarriersencecount[0]=(((r).phy_falsecarriersencecount[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PHY_FALSECARRIERSENCECOUNT.
 */
#define BCM84868_READ_PHY_FALSECARRIERSENCECOUNTr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHY_FALSECARRIERSENCECOUNTr,(_r._phy_falsecarriersencecount))
#define BCM84868_WRITE_PHY_FALSECARRIERSENCECOUNTr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHY_FALSECARRIERSENCECOUNTr,(_r._phy_falsecarriersencecount))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHY_FALSECARRIERSENCECOUNTr BCM84868_PHY_FALSECARRIERSENCECOUNTr
#define PHY_FALSECARRIERSENCECOUNTr_SIZE BCM84868_PHY_FALSECARRIERSENCECOUNTr_SIZE
typedef BCM84868_PHY_FALSECARRIERSENCECOUNTr_t PHY_FALSECARRIERSENCECOUNTr_t;
#define PHY_FALSECARRIERSENCECOUNTr_CLR BCM84868_PHY_FALSECARRIERSENCECOUNTr_CLR
#define PHY_FALSECARRIERSENCECOUNTr_SET BCM84868_PHY_FALSECARRIERSENCECOUNTr_SET
#define PHY_FALSECARRIERSENCECOUNTr_GET BCM84868_PHY_FALSECARRIERSENCECOUNTr_GET
#define PHY_FALSECARRIERSENCECOUNTr_SERDES_BER_COUNTf_GET BCM84868_PHY_FALSECARRIERSENCECOUNTr_SERDES_BER_COUNTf_GET
#define PHY_FALSECARRIERSENCECOUNTr_SERDES_BER_COUNTf_SET BCM84868_PHY_FALSECARRIERSENCECOUNTr_SERDES_BER_COUNTf_SET
#define PHY_FALSECARRIERSENCECOUNTr_FALSE_CAR_SENSE_COUNTf_GET BCM84868_PHY_FALSECARRIERSENCECOUNTr_FALSE_CAR_SENSE_COUNTf_GET
#define PHY_FALSECARRIERSENCECOUNTr_FALSE_CAR_SENSE_COUNTf_SET BCM84868_PHY_FALSECARRIERSENCECOUNTr_FALSE_CAR_SENSE_COUNTf_SET
#define READ_PHY_FALSECARRIERSENCECOUNTr BCM84868_READ_PHY_FALSECARRIERSENCECOUNTr
#define WRITE_PHY_FALSECARRIERSENCECOUNTr BCM84868_WRITE_PHY_FALSECARRIERSENCECOUNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHY_FALSECARRIERSENCECOUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHY_LCLRMTRCVNOTOKCOUNT
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfff4
 * DEVAD:    7
 * DESC:     Local/Remote Receiver NOT_OK Counters
 * SIZE:     32
 * FIELDS:
 *     RMT_RCV_NOT_OK_COUNT 
 *     LCL_RCV_NOT_OK_COUNT 
 */
#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr (0x0007fff4 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program PHY_LCLRMTRCVNOTOKCOUNT.
 */
typedef union BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_s {
	uint32_t v[1];
	uint32_t phy_lclrmtrcvnotokcount[1];
	uint32_t _phy_lclrmtrcvnotokcount;
} BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_t;

#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_CLR(r) (r).phy_lclrmtrcvnotokcount[0] = 0
#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_SET(r,d) (r).phy_lclrmtrcvnotokcount[0] = d
#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_GET(r) (r).phy_lclrmtrcvnotokcount[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_LCL_RCV_NOT_OK_COUNTf_GET(r) ((((r).phy_lclrmtrcvnotokcount[0]) >> 8) & 0xff)
#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_LCL_RCV_NOT_OK_COUNTf_SET(r,f) (r).phy_lclrmtrcvnotokcount[0]=(((r).phy_lclrmtrcvnotokcount[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_RMT_RCV_NOT_OK_COUNTf_GET(r) (((r).phy_lclrmtrcvnotokcount[0]) & 0xff)
#define BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_RMT_RCV_NOT_OK_COUNTf_SET(r,f) (r).phy_lclrmtrcvnotokcount[0]=(((r).phy_lclrmtrcvnotokcount[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PHY_LCLRMTRCVNOTOKCOUNT.
 */
#define BCM84868_READ_PHY_LCLRMTRCVNOTOKCOUNTr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr,(_r._phy_lclrmtrcvnotokcount))
#define BCM84868_WRITE_PHY_LCLRMTRCVNOTOKCOUNTr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr,(_r._phy_lclrmtrcvnotokcount))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHY_LCLRMTRCVNOTOKCOUNTr BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr
#define PHY_LCLRMTRCVNOTOKCOUNTr_SIZE BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_SIZE
typedef BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_t PHY_LCLRMTRCVNOTOKCOUNTr_t;
#define PHY_LCLRMTRCVNOTOKCOUNTr_CLR BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_CLR
#define PHY_LCLRMTRCVNOTOKCOUNTr_SET BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_SET
#define PHY_LCLRMTRCVNOTOKCOUNTr_GET BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_GET
#define PHY_LCLRMTRCVNOTOKCOUNTr_LCL_RCV_NOT_OK_COUNTf_GET BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_LCL_RCV_NOT_OK_COUNTf_GET
#define PHY_LCLRMTRCVNOTOKCOUNTr_LCL_RCV_NOT_OK_COUNTf_SET BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_LCL_RCV_NOT_OK_COUNTf_SET
#define PHY_LCLRMTRCVNOTOKCOUNTr_RMT_RCV_NOT_OK_COUNTf_GET BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_RMT_RCV_NOT_OK_COUNTf_GET
#define PHY_LCLRMTRCVNOTOKCOUNTr_RMT_RCV_NOT_OK_COUNTf_SET BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr_RMT_RCV_NOT_OK_COUNTf_SET
#define READ_PHY_LCLRMTRCVNOTOKCOUNTr BCM84868_READ_PHY_LCLRMTRCVNOTOKCOUNTr
#define WRITE_PHY_LCLRMTRCVNOTOKCOUNTr BCM84868_WRITE_PHY_LCLRMTRCVNOTOKCOUNTr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHY_LCLRMTRCVNOTOKCOUNTr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  PHY_AUXSTATSUMMARY
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfff9
 * DEVAD:    7
 * DESC:     Auxiliary Status Summary (copper side only)
 * SIZE:     32
 * FIELDS:
 *     PAUSE_RESOL_TRANSMIT_DIR 
 *     PAUSE_RESOL_RECEIVE_DIR 
 *     LNK_STATUS       
 *     LNK_PART_NEXT_PAGE_ABIL 
 *     LNK_PART_AUTONEG_ABIL 
 *     PAGE_RECEIVED    
 *     REMOTE_FAULT     
 *     PARALLEL_DETECTION_FAULT 
 *     AUTONEG_HCD      
 *     AUTONEG_NEXT_PAGE_WAIT 
 *     AUTONEG_ABIL_DETECT 
 *     AUTONEG_ACK_DETECT 
 *     AUTONEG_COMPLETE_ACK 
 *     AUTONEG_COMPLETE 
 */
#define BCM84868_PHY_AUXSTATSUMMARYr (0x0007fff9 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_PHY_AUXSTATSUMMARYr_SIZE 4

/*
 * This structure should be used to declare and program PHY_AUXSTATSUMMARY.
 */
typedef union BCM84868_PHY_AUXSTATSUMMARYr_s {
	uint32_t v[1];
	uint32_t phy_auxstatsummary[1];
	uint32_t _phy_auxstatsummary;
} BCM84868_PHY_AUXSTATSUMMARYr_t;

#define BCM84868_PHY_AUXSTATSUMMARYr_CLR(r) (r).phy_auxstatsummary[0] = 0
#define BCM84868_PHY_AUXSTATSUMMARYr_SET(r,d) (r).phy_auxstatsummary[0] = d
#define BCM84868_PHY_AUXSTATSUMMARYr_GET(r) (r).phy_auxstatsummary[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETEf_GET(r) ((((r).phy_auxstatsummary[0]) >> 15) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETEf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETE_ACKf_GET(r) ((((r).phy_auxstatsummary[0]) >> 14) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETE_ACKf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ACK_DETECTf_GET(r) ((((r).phy_auxstatsummary[0]) >> 13) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ACK_DETECTf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ABIL_DETECTf_GET(r) ((((r).phy_auxstatsummary[0]) >> 12) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ABIL_DETECTf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_NEXT_PAGE_WAITf_GET(r) ((((r).phy_auxstatsummary[0]) >> 11) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_NEXT_PAGE_WAITf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_HCDf_GET(r) ((((r).phy_auxstatsummary[0]) >> 8) & 0x7)
#define BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_HCDf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM84868_PHY_AUXSTATSUMMARYr_PARALLEL_DETECTION_FAULTf_GET(r) ((((r).phy_auxstatsummary[0]) >> 7) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_PARALLEL_DETECTION_FAULTf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_PHY_AUXSTATSUMMARYr_REMOTE_FAULTf_GET(r) ((((r).phy_auxstatsummary[0]) >> 6) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_REMOTE_FAULTf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_PHY_AUXSTATSUMMARYr_PAGE_RECEIVEDf_GET(r) ((((r).phy_auxstatsummary[0]) >> 5) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_PAGE_RECEIVEDf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_AUTONEG_ABILf_GET(r) ((((r).phy_auxstatsummary[0]) >> 4) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_AUTONEG_ABILf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_NEXT_PAGE_ABILf_GET(r) ((((r).phy_auxstatsummary[0]) >> 3) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_NEXT_PAGE_ABILf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_PHY_AUXSTATSUMMARYr_LNK_STATUSf_GET(r) ((((r).phy_auxstatsummary[0]) >> 2) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_LNK_STATUSf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_RECEIVE_DIRf_GET(r) ((((r).phy_auxstatsummary[0]) >> 1) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_RECEIVE_DIRf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_TRANSMIT_DIRf_GET(r) (((r).phy_auxstatsummary[0]) & 0x1)
#define BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_TRANSMIT_DIRf_SET(r,f) (r).phy_auxstatsummary[0]=(((r).phy_auxstatsummary[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access PHY_AUXSTATSUMMARY.
 */
#define BCM84868_READ_PHY_AUXSTATSUMMARYr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_PHY_AUXSTATSUMMARYr,(_r._phy_auxstatsummary))
#define BCM84868_WRITE_PHY_AUXSTATSUMMARYr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_PHY_AUXSTATSUMMARYr,(_r._phy_auxstatsummary))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define PHY_AUXSTATSUMMARYr BCM84868_PHY_AUXSTATSUMMARYr
#define PHY_AUXSTATSUMMARYr_SIZE BCM84868_PHY_AUXSTATSUMMARYr_SIZE
typedef BCM84868_PHY_AUXSTATSUMMARYr_t PHY_AUXSTATSUMMARYr_t;
#define PHY_AUXSTATSUMMARYr_CLR BCM84868_PHY_AUXSTATSUMMARYr_CLR
#define PHY_AUXSTATSUMMARYr_SET BCM84868_PHY_AUXSTATSUMMARYr_SET
#define PHY_AUXSTATSUMMARYr_GET BCM84868_PHY_AUXSTATSUMMARYr_GET
#define PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETEf_GET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETEf_GET
#define PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETEf_SET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETEf_SET
#define PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETE_ACKf_GET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETE_ACKf_GET
#define PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETE_ACKf_SET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_COMPLETE_ACKf_SET
#define PHY_AUXSTATSUMMARYr_AUTONEG_ACK_DETECTf_GET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ACK_DETECTf_GET
#define PHY_AUXSTATSUMMARYr_AUTONEG_ACK_DETECTf_SET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ACK_DETECTf_SET
#define PHY_AUXSTATSUMMARYr_AUTONEG_ABIL_DETECTf_GET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ABIL_DETECTf_GET
#define PHY_AUXSTATSUMMARYr_AUTONEG_ABIL_DETECTf_SET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_ABIL_DETECTf_SET
#define PHY_AUXSTATSUMMARYr_AUTONEG_NEXT_PAGE_WAITf_GET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_NEXT_PAGE_WAITf_GET
#define PHY_AUXSTATSUMMARYr_AUTONEG_NEXT_PAGE_WAITf_SET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_NEXT_PAGE_WAITf_SET
#define PHY_AUXSTATSUMMARYr_AUTONEG_HCDf_GET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_HCDf_GET
#define PHY_AUXSTATSUMMARYr_AUTONEG_HCDf_SET BCM84868_PHY_AUXSTATSUMMARYr_AUTONEG_HCDf_SET
#define PHY_AUXSTATSUMMARYr_PARALLEL_DETECTION_FAULTf_GET BCM84868_PHY_AUXSTATSUMMARYr_PARALLEL_DETECTION_FAULTf_GET
#define PHY_AUXSTATSUMMARYr_PARALLEL_DETECTION_FAULTf_SET BCM84868_PHY_AUXSTATSUMMARYr_PARALLEL_DETECTION_FAULTf_SET
#define PHY_AUXSTATSUMMARYr_REMOTE_FAULTf_GET BCM84868_PHY_AUXSTATSUMMARYr_REMOTE_FAULTf_GET
#define PHY_AUXSTATSUMMARYr_REMOTE_FAULTf_SET BCM84868_PHY_AUXSTATSUMMARYr_REMOTE_FAULTf_SET
#define PHY_AUXSTATSUMMARYr_PAGE_RECEIVEDf_GET BCM84868_PHY_AUXSTATSUMMARYr_PAGE_RECEIVEDf_GET
#define PHY_AUXSTATSUMMARYr_PAGE_RECEIVEDf_SET BCM84868_PHY_AUXSTATSUMMARYr_PAGE_RECEIVEDf_SET
#define PHY_AUXSTATSUMMARYr_LNK_PART_AUTONEG_ABILf_GET BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_AUTONEG_ABILf_GET
#define PHY_AUXSTATSUMMARYr_LNK_PART_AUTONEG_ABILf_SET BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_AUTONEG_ABILf_SET
#define PHY_AUXSTATSUMMARYr_LNK_PART_NEXT_PAGE_ABILf_GET BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_NEXT_PAGE_ABILf_GET
#define PHY_AUXSTATSUMMARYr_LNK_PART_NEXT_PAGE_ABILf_SET BCM84868_PHY_AUXSTATSUMMARYr_LNK_PART_NEXT_PAGE_ABILf_SET
#define PHY_AUXSTATSUMMARYr_LNK_STATUSf_GET BCM84868_PHY_AUXSTATSUMMARYr_LNK_STATUSf_GET
#define PHY_AUXSTATSUMMARYr_LNK_STATUSf_SET BCM84868_PHY_AUXSTATSUMMARYr_LNK_STATUSf_SET
#define PHY_AUXSTATSUMMARYr_PAUSE_RESOL_RECEIVE_DIRf_GET BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_RECEIVE_DIRf_GET
#define PHY_AUXSTATSUMMARYr_PAUSE_RESOL_RECEIVE_DIRf_SET BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_RECEIVE_DIRf_SET
#define PHY_AUXSTATSUMMARYr_PAUSE_RESOL_TRANSMIT_DIRf_GET BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_TRANSMIT_DIRf_GET
#define PHY_AUXSTATSUMMARYr_PAUSE_RESOL_TRANSMIT_DIRf_SET BCM84868_PHY_AUXSTATSUMMARYr_PAUSE_RESOL_TRANSMIT_DIRf_SET
#define READ_PHY_AUXSTATSUMMARYr BCM84868_READ_PHY_AUXSTATSUMMARYr
#define WRITE_PHY_AUXSTATSUMMARYr BCM84868_WRITE_PHY_AUXSTATSUMMARYr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_PHY_AUXSTATSUMMARYr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  INT_STAT
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfffa
 * DEVAD:    7
 * DESC:     Interrupt Status Register (copper side only)
 * SIZE:     32
 * FIELDS:
 *     CRC_ERROR        
 *     LINK_STATUS_CHANGE 
 *     LINK_SPEED_CHANGE 
 *     DUPLEX_MODE_CHANGE 
 *     LOCAL_RCV_STATUS_CHANGE 
 *     REMOTE_RCV_STATUS_CHANGE 
 *     SCRAMBLER_SYNC_ERROR 
 *     NEGOTIATED_UNSUPPORT_HCD 
 *     NO_HCD           
 *     HCD_NO_LINK      
 *     AUTONEG_PAGE_RX  
 *     EXCEEDED_LOW_COUNTER 
 *     EXCEEDED_HIGH_COUNTER 
 *     MDIX_STATUS_CHANGE 
 *     ILLEGAL_PAIR_SWAP 
 *     IP_STATUS_CHANGE 
 */
#define BCM84868_INT_STATr (0x0007fffa | PHY_REG_ACC_BRCM_XE)

#define BCM84868_INT_STATr_SIZE 4

/*
 * This structure should be used to declare and program INT_STAT.
 */
typedef union BCM84868_INT_STATr_s {
	uint32_t v[1];
	uint32_t int_stat[1];
	uint32_t _int_stat;
} BCM84868_INT_STATr_t;

#define BCM84868_INT_STATr_CLR(r) (r).int_stat[0] = 0
#define BCM84868_INT_STATr_SET(r,d) (r).int_stat[0] = d
#define BCM84868_INT_STATr_GET(r) (r).int_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_INT_STATr_IP_STATUS_CHANGEf_GET(r) ((((r).int_stat[0]) >> 15) & 0x1)
#define BCM84868_INT_STATr_IP_STATUS_CHANGEf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_INT_STATr_ILLEGAL_PAIR_SWAPf_GET(r) ((((r).int_stat[0]) >> 14) & 0x1)
#define BCM84868_INT_STATr_ILLEGAL_PAIR_SWAPf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_INT_STATr_MDIX_STATUS_CHANGEf_GET(r) ((((r).int_stat[0]) >> 13) & 0x1)
#define BCM84868_INT_STATr_MDIX_STATUS_CHANGEf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_INT_STATr_EXCEEDED_HIGH_COUNTERf_GET(r) ((((r).int_stat[0]) >> 12) & 0x1)
#define BCM84868_INT_STATr_EXCEEDED_HIGH_COUNTERf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_INT_STATr_EXCEEDED_LOW_COUNTERf_GET(r) ((((r).int_stat[0]) >> 11) & 0x1)
#define BCM84868_INT_STATr_EXCEEDED_LOW_COUNTERf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_INT_STATr_AUTONEG_PAGE_RXf_GET(r) ((((r).int_stat[0]) >> 10) & 0x1)
#define BCM84868_INT_STATr_AUTONEG_PAGE_RXf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_INT_STATr_HCD_NO_LINKf_GET(r) ((((r).int_stat[0]) >> 9) & 0x1)
#define BCM84868_INT_STATr_HCD_NO_LINKf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM84868_INT_STATr_NO_HCDf_GET(r) ((((r).int_stat[0]) >> 8) & 0x1)
#define BCM84868_INT_STATr_NO_HCDf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM84868_INT_STATr_NEGOTIATED_UNSUPPORT_HCDf_GET(r) ((((r).int_stat[0]) >> 7) & 0x1)
#define BCM84868_INT_STATr_NEGOTIATED_UNSUPPORT_HCDf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM84868_INT_STATr_SCRAMBLER_SYNC_ERRORf_GET(r) ((((r).int_stat[0]) >> 6) & 0x1)
#define BCM84868_INT_STATr_SCRAMBLER_SYNC_ERRORf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM84868_INT_STATr_REMOTE_RCV_STATUS_CHANGEf_GET(r) ((((r).int_stat[0]) >> 5) & 0x1)
#define BCM84868_INT_STATr_REMOTE_RCV_STATUS_CHANGEf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_INT_STATr_LOCAL_RCV_STATUS_CHANGEf_GET(r) ((((r).int_stat[0]) >> 4) & 0x1)
#define BCM84868_INT_STATr_LOCAL_RCV_STATUS_CHANGEf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_INT_STATr_DUPLEX_MODE_CHANGEf_GET(r) ((((r).int_stat[0]) >> 3) & 0x1)
#define BCM84868_INT_STATr_DUPLEX_MODE_CHANGEf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM84868_INT_STATr_LINK_SPEED_CHANGEf_GET(r) ((((r).int_stat[0]) >> 2) & 0x1)
#define BCM84868_INT_STATr_LINK_SPEED_CHANGEf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_INT_STATr_LINK_STATUS_CHANGEf_GET(r) ((((r).int_stat[0]) >> 1) & 0x1)
#define BCM84868_INT_STATr_LINK_STATUS_CHANGEf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_INT_STATr_CRC_ERRORf_GET(r) (((r).int_stat[0]) & 0x1)
#define BCM84868_INT_STATr_CRC_ERRORf_SET(r,f) (r).int_stat[0]=(((r).int_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access INT_STAT.
 */
#define BCM84868_READ_INT_STATr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_INT_STATr,(_r._int_stat))
#define BCM84868_WRITE_INT_STATr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_INT_STATr,(_r._int_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define INT_STATr BCM84868_INT_STATr
#define INT_STATr_SIZE BCM84868_INT_STATr_SIZE
typedef BCM84868_INT_STATr_t INT_STATr_t;
#define INT_STATr_CLR BCM84868_INT_STATr_CLR
#define INT_STATr_SET BCM84868_INT_STATr_SET
#define INT_STATr_GET BCM84868_INT_STATr_GET
#define INT_STATr_IP_STATUS_CHANGEf_GET BCM84868_INT_STATr_IP_STATUS_CHANGEf_GET
#define INT_STATr_IP_STATUS_CHANGEf_SET BCM84868_INT_STATr_IP_STATUS_CHANGEf_SET
#define INT_STATr_ILLEGAL_PAIR_SWAPf_GET BCM84868_INT_STATr_ILLEGAL_PAIR_SWAPf_GET
#define INT_STATr_ILLEGAL_PAIR_SWAPf_SET BCM84868_INT_STATr_ILLEGAL_PAIR_SWAPf_SET
#define INT_STATr_MDIX_STATUS_CHANGEf_GET BCM84868_INT_STATr_MDIX_STATUS_CHANGEf_GET
#define INT_STATr_MDIX_STATUS_CHANGEf_SET BCM84868_INT_STATr_MDIX_STATUS_CHANGEf_SET
#define INT_STATr_EXCEEDED_HIGH_COUNTERf_GET BCM84868_INT_STATr_EXCEEDED_HIGH_COUNTERf_GET
#define INT_STATr_EXCEEDED_HIGH_COUNTERf_SET BCM84868_INT_STATr_EXCEEDED_HIGH_COUNTERf_SET
#define INT_STATr_EXCEEDED_LOW_COUNTERf_GET BCM84868_INT_STATr_EXCEEDED_LOW_COUNTERf_GET
#define INT_STATr_EXCEEDED_LOW_COUNTERf_SET BCM84868_INT_STATr_EXCEEDED_LOW_COUNTERf_SET
#define INT_STATr_AUTONEG_PAGE_RXf_GET BCM84868_INT_STATr_AUTONEG_PAGE_RXf_GET
#define INT_STATr_AUTONEG_PAGE_RXf_SET BCM84868_INT_STATr_AUTONEG_PAGE_RXf_SET
#define INT_STATr_HCD_NO_LINKf_GET BCM84868_INT_STATr_HCD_NO_LINKf_GET
#define INT_STATr_HCD_NO_LINKf_SET BCM84868_INT_STATr_HCD_NO_LINKf_SET
#define INT_STATr_NO_HCDf_GET BCM84868_INT_STATr_NO_HCDf_GET
#define INT_STATr_NO_HCDf_SET BCM84868_INT_STATr_NO_HCDf_SET
#define INT_STATr_NEGOTIATED_UNSUPPORT_HCDf_GET BCM84868_INT_STATr_NEGOTIATED_UNSUPPORT_HCDf_GET
#define INT_STATr_NEGOTIATED_UNSUPPORT_HCDf_SET BCM84868_INT_STATr_NEGOTIATED_UNSUPPORT_HCDf_SET
#define INT_STATr_SCRAMBLER_SYNC_ERRORf_GET BCM84868_INT_STATr_SCRAMBLER_SYNC_ERRORf_GET
#define INT_STATr_SCRAMBLER_SYNC_ERRORf_SET BCM84868_INT_STATr_SCRAMBLER_SYNC_ERRORf_SET
#define INT_STATr_REMOTE_RCV_STATUS_CHANGEf_GET BCM84868_INT_STATr_REMOTE_RCV_STATUS_CHANGEf_GET
#define INT_STATr_REMOTE_RCV_STATUS_CHANGEf_SET BCM84868_INT_STATr_REMOTE_RCV_STATUS_CHANGEf_SET
#define INT_STATr_LOCAL_RCV_STATUS_CHANGEf_GET BCM84868_INT_STATr_LOCAL_RCV_STATUS_CHANGEf_GET
#define INT_STATr_LOCAL_RCV_STATUS_CHANGEf_SET BCM84868_INT_STATr_LOCAL_RCV_STATUS_CHANGEf_SET
#define INT_STATr_DUPLEX_MODE_CHANGEf_GET BCM84868_INT_STATr_DUPLEX_MODE_CHANGEf_GET
#define INT_STATr_DUPLEX_MODE_CHANGEf_SET BCM84868_INT_STATr_DUPLEX_MODE_CHANGEf_SET
#define INT_STATr_LINK_SPEED_CHANGEf_GET BCM84868_INT_STATr_LINK_SPEED_CHANGEf_GET
#define INT_STATr_LINK_SPEED_CHANGEf_SET BCM84868_INT_STATr_LINK_SPEED_CHANGEf_SET
#define INT_STATr_LINK_STATUS_CHANGEf_GET BCM84868_INT_STATr_LINK_STATUS_CHANGEf_GET
#define INT_STATr_LINK_STATUS_CHANGEf_SET BCM84868_INT_STATr_LINK_STATUS_CHANGEf_SET
#define INT_STATr_CRC_ERRORf_GET BCM84868_INT_STATr_CRC_ERRORf_GET
#define INT_STATr_CRC_ERRORf_SET BCM84868_INT_STATr_CRC_ERRORf_SET
#define READ_INT_STATr BCM84868_READ_INT_STATr
#define WRITE_INT_STATr BCM84868_WRITE_INT_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_INT_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  INT_MASK
 * BLOCKS:   CTRL_10_1FH
 * REGADDR:  0xfffb
 * DEVAD:    7
 * DESC:     Interrupt Mask Register
 * SIZE:     32
 * FIELDS:
 *     INTERRUPT_MASK_VECTOR 
 */
#define BCM84868_INT_MASKr (0x0007fffb | PHY_REG_ACC_BRCM_XE)

#define BCM84868_INT_MASKr_SIZE 4

/*
 * This structure should be used to declare and program INT_MASK.
 */
typedef union BCM84868_INT_MASKr_s {
	uint32_t v[1];
	uint32_t int_mask[1];
	uint32_t _int_mask;
} BCM84868_INT_MASKr_t;

#define BCM84868_INT_MASKr_CLR(r) (r).int_mask[0] = 0
#define BCM84868_INT_MASKr_SET(r,d) (r).int_mask[0] = d
#define BCM84868_INT_MASKr_GET(r) (r).int_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_INT_MASKr_INTERRUPT_MASK_VECTORf_GET(r) (((r).int_mask[0]) & 0xffff)
#define BCM84868_INT_MASKr_INTERRUPT_MASK_VECTORf_SET(r,f) (r).int_mask[0]=(((r).int_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access INT_MASK.
 */
#define BCM84868_READ_INT_MASKr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_INT_MASKr,(_r._int_mask))
#define BCM84868_WRITE_INT_MASKr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_INT_MASKr,(_r._int_mask))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define INT_MASKr BCM84868_INT_MASKr
#define INT_MASKr_SIZE BCM84868_INT_MASKr_SIZE
typedef BCM84868_INT_MASKr_t INT_MASKr_t;
#define INT_MASKr_CLR BCM84868_INT_MASKr_CLR
#define INT_MASKr_SET BCM84868_INT_MASKr_SET
#define INT_MASKr_GET BCM84868_INT_MASKr_GET
#define INT_MASKr_INTERRUPT_MASK_VECTORf_GET BCM84868_INT_MASKr_INTERRUPT_MASK_VECTORf_GET
#define INT_MASKr_INTERRUPT_MASK_VECTORf_SET BCM84868_INT_MASKr_INTERRUPT_MASK_VECTORf_SET
#define READ_INT_MASKr BCM84868_READ_INT_MASKr
#define WRITE_INT_MASKr BCM84868_WRITE_INT_MASKr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_INT_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_SCRATCH_0
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x4005
 * DEVAD:    30
 * DESC:     Scratch reg 0
 * SIZE:     32
 * FIELDS:
 *     SCRATCH          
 */
#define BCM84868_TOP_CONFIG_SCRATCH_0r (0x001e4005 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_SCRATCH_0r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_SCRATCH_0.
 */
typedef union BCM84868_TOP_CONFIG_SCRATCH_0r_s {
	uint32_t v[1];
	uint32_t top_config_scratch_0[1];
	uint32_t _top_config_scratch_0;
} BCM84868_TOP_CONFIG_SCRATCH_0r_t;

#define BCM84868_TOP_CONFIG_SCRATCH_0r_CLR(r) (r).top_config_scratch_0[0] = 0
#define BCM84868_TOP_CONFIG_SCRATCH_0r_SET(r,d) (r).top_config_scratch_0[0] = d
#define BCM84868_TOP_CONFIG_SCRATCH_0r_GET(r) (r).top_config_scratch_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_SCRATCH_0r_SCRATCHf_GET(r) (((r).top_config_scratch_0[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_SCRATCH_0r_SCRATCHf_SET(r,f) (r).top_config_scratch_0[0]=(((r).top_config_scratch_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_SCRATCH_0.
 */
#define BCM84868_READ_TOP_CONFIG_SCRATCH_0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_SCRATCH_0r,(_r._top_config_scratch_0))
#define BCM84868_WRITE_TOP_CONFIG_SCRATCH_0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_SCRATCH_0r,(_r._top_config_scratch_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_SCRATCH_0r BCM84868_TOP_CONFIG_SCRATCH_0r
#define TOP_CONFIG_SCRATCH_0r_SIZE BCM84868_TOP_CONFIG_SCRATCH_0r_SIZE
typedef BCM84868_TOP_CONFIG_SCRATCH_0r_t TOP_CONFIG_SCRATCH_0r_t;
#define TOP_CONFIG_SCRATCH_0r_CLR BCM84868_TOP_CONFIG_SCRATCH_0r_CLR
#define TOP_CONFIG_SCRATCH_0r_SET BCM84868_TOP_CONFIG_SCRATCH_0r_SET
#define TOP_CONFIG_SCRATCH_0r_GET BCM84868_TOP_CONFIG_SCRATCH_0r_GET
#define TOP_CONFIG_SCRATCH_0r_SCRATCHf_GET BCM84868_TOP_CONFIG_SCRATCH_0r_SCRATCHf_GET
#define TOP_CONFIG_SCRATCH_0r_SCRATCHf_SET BCM84868_TOP_CONFIG_SCRATCH_0r_SCRATCHf_SET
#define READ_TOP_CONFIG_SCRATCH_0r BCM84868_READ_TOP_CONFIG_SCRATCH_0r
#define WRITE_TOP_CONFIG_SCRATCH_0r BCM84868_WRITE_TOP_CONFIG_SCRATCH_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_SCRATCH_0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_AUTOGREEN_CONFIG1
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x400a
 * DEVAD:    30
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     TOP_CONFIG_AUTOGREEN_CONFIG1_REG 
 */
#define BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r (0x001e400a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_AUTOGREEN_CONFIG1.
 */
typedef union BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_s {
	uint32_t v[1];
	uint32_t top_config_autogreen_config1[1];
	uint32_t _top_config_autogreen_config1;
} BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_t;

#define BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_CLR(r) (r).top_config_autogreen_config1[0] = 0
#define BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_SET(r,d) (r).top_config_autogreen_config1[0] = d
#define BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_GET(r) (r).top_config_autogreen_config1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_TOP_CONFIG_AUTOGREEN_CONFIG1_REGf_GET(r) (((r).top_config_autogreen_config1[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_TOP_CONFIG_AUTOGREEN_CONFIG1_REGf_SET(r,f) (r).top_config_autogreen_config1[0]=(((r).top_config_autogreen_config1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_AUTOGREEN_CONFIG1.
 */
#define BCM84868_READ_TOP_CONFIG_AUTOGREEN_CONFIG1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r,(_r._top_config_autogreen_config1))
#define BCM84868_WRITE_TOP_CONFIG_AUTOGREEN_CONFIG1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r,(_r._top_config_autogreen_config1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_AUTOGREEN_CONFIG1r BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r
#define TOP_CONFIG_AUTOGREEN_CONFIG1r_SIZE BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_SIZE
typedef BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_t TOP_CONFIG_AUTOGREEN_CONFIG1r_t;
#define TOP_CONFIG_AUTOGREEN_CONFIG1r_CLR BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_CLR
#define TOP_CONFIG_AUTOGREEN_CONFIG1r_SET BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_SET
#define TOP_CONFIG_AUTOGREEN_CONFIG1r_GET BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_GET
#define TOP_CONFIG_AUTOGREEN_CONFIG1r_TOP_CONFIG_AUTOGREEN_CONFIG1_REGf_GET BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_TOP_CONFIG_AUTOGREEN_CONFIG1_REGf_GET
#define TOP_CONFIG_AUTOGREEN_CONFIG1r_TOP_CONFIG_AUTOGREEN_CONFIG1_REGf_SET BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r_TOP_CONFIG_AUTOGREEN_CONFIG1_REGf_SET
#define READ_TOP_CONFIG_AUTOGREEN_CONFIG1r BCM84868_READ_TOP_CONFIG_AUTOGREEN_CONFIG1r
#define WRITE_TOP_CONFIG_AUTOGREEN_CONFIG1r BCM84868_WRITE_TOP_CONFIG_AUTOGREEN_CONFIG1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_AUTOGREEN_CONFIG1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x400b
 * DEVAD:    30
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH_REG 
 */
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr (0x001e400b | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH.
 */
typedef union BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_s {
	uint32_t v[1];
	uint32_t top_config_autogreen_threshold_high[1];
	uint32_t _top_config_autogreen_threshold_high;
} BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_t;

#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_CLR(r) (r).top_config_autogreen_threshold_high[0] = 0
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_SET(r,d) (r).top_config_autogreen_threshold_high[0] = d
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_GET(r) (r).top_config_autogreen_threshold_high[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH_REGf_GET(r) (((r).top_config_autogreen_threshold_high[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH_REGf_SET(r,f) (r).top_config_autogreen_threshold_high[0]=(((r).top_config_autogreen_threshold_high[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH.
 */
#define BCM84868_READ_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr,(_r._top_config_autogreen_threshold_high))
#define BCM84868_WRITE_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr,(_r._top_config_autogreen_threshold_high))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_SIZE BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_SIZE
typedef BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_t TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_t;
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_CLR BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_CLR
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_SET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_SET
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_GET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_GET
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH_REGf_GET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH_REGf_GET
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH_REGf_SET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGH_REGf_SET
#define READ_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr BCM84868_READ_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr
#define WRITE_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr BCM84868_WRITE_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_HIGHr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x400c
 * DEVAD:    30
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW_REG 
 */
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr (0x001e400c | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW.
 */
typedef union BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_s {
	uint32_t v[1];
	uint32_t top_config_autogreen_threshold_low[1];
	uint32_t _top_config_autogreen_threshold_low;
} BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_t;

#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_CLR(r) (r).top_config_autogreen_threshold_low[0] = 0
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_SET(r,d) (r).top_config_autogreen_threshold_low[0] = d
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_GET(r) (r).top_config_autogreen_threshold_low[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW_REGf_GET(r) (((r).top_config_autogreen_threshold_low[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW_REGf_SET(r,f) (r).top_config_autogreen_threshold_low[0]=(((r).top_config_autogreen_threshold_low[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW.
 */
#define BCM84868_READ_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr,(_r._top_config_autogreen_threshold_low))
#define BCM84868_WRITE_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr,(_r._top_config_autogreen_threshold_low))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_SIZE BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_SIZE
typedef BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_t TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_t;
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_CLR BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_CLR
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_SET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_SET
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_GET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_GET
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW_REGf_GET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW_REGf_GET
#define TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW_REGf_SET BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOW_REGf_SET
#define READ_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr BCM84868_READ_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr
#define WRITE_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr BCM84868_WRITE_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_AUTOGREEN_THRESHOLD_LOWr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_LINK_STATUS
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x400d
 * DEVAD:    30
 * DESC:      
 * SIZE:     32
 * FIELDS:
 *     TOP_CONFIG_LINK_STATUS_REG 
 */
#define BCM84868_TOP_CONFIG_LINK_STATUSr (0x001e400d | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_LINK_STATUS.
 */
typedef union BCM84868_TOP_CONFIG_LINK_STATUSr_s {
	uint32_t v[1];
	uint32_t top_config_link_status[1];
	uint32_t _top_config_link_status;
} BCM84868_TOP_CONFIG_LINK_STATUSr_t;

#define BCM84868_TOP_CONFIG_LINK_STATUSr_CLR(r) (r).top_config_link_status[0] = 0
#define BCM84868_TOP_CONFIG_LINK_STATUSr_SET(r,d) (r).top_config_link_status[0] = d
#define BCM84868_TOP_CONFIG_LINK_STATUSr_GET(r) (r).top_config_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_LINK_STATUSr_TOP_CONFIG_LINK_STATUS_REGf_GET(r) (((r).top_config_link_status[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_LINK_STATUSr_TOP_CONFIG_LINK_STATUS_REGf_SET(r,f) (r).top_config_link_status[0]=(((r).top_config_link_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_LINK_STATUS.
 */
#define BCM84868_READ_TOP_CONFIG_LINK_STATUSr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_LINK_STATUSr,(_r._top_config_link_status))
#define BCM84868_WRITE_TOP_CONFIG_LINK_STATUSr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_LINK_STATUSr,(_r._top_config_link_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_LINK_STATUSr BCM84868_TOP_CONFIG_LINK_STATUSr
#define TOP_CONFIG_LINK_STATUSr_SIZE BCM84868_TOP_CONFIG_LINK_STATUSr_SIZE
typedef BCM84868_TOP_CONFIG_LINK_STATUSr_t TOP_CONFIG_LINK_STATUSr_t;
#define TOP_CONFIG_LINK_STATUSr_CLR BCM84868_TOP_CONFIG_LINK_STATUSr_CLR
#define TOP_CONFIG_LINK_STATUSr_SET BCM84868_TOP_CONFIG_LINK_STATUSr_SET
#define TOP_CONFIG_LINK_STATUSr_GET BCM84868_TOP_CONFIG_LINK_STATUSr_GET
#define TOP_CONFIG_LINK_STATUSr_TOP_CONFIG_LINK_STATUS_REGf_GET BCM84868_TOP_CONFIG_LINK_STATUSr_TOP_CONFIG_LINK_STATUS_REGf_GET
#define TOP_CONFIG_LINK_STATUSr_TOP_CONFIG_LINK_STATUS_REGf_SET BCM84868_TOP_CONFIG_LINK_STATUSr_TOP_CONFIG_LINK_STATUS_REGf_SET
#define READ_TOP_CONFIG_LINK_STATUSr BCM84868_READ_TOP_CONFIG_LINK_STATUSr
#define WRITE_TOP_CONFIG_LINK_STATUSr BCM84868_WRITE_TOP_CONFIG_LINK_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_LINK_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_LINK_STATUS
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x400d
 * DEVAD:    30
 * DESC:     CORE_CFG link status register
 * SIZE:     32
 * FIELDS:
 *     COPPER_DETECT    
 *     SPEED_MSB        
 *     COPPER_SPEED     
 *     SPEED_LSB        
 *     COPPER_LINK      
 *     MAC_LINK         
 *     MAC_LINK_STATUS  
 *     SPIROM_CRC_STAT  
 */
#define BCM84868_TOP_LINK_STATUSr (0x001e400d | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TOP_LINK_STATUS.
 */
typedef union BCM84868_TOP_LINK_STATUSr_s {
	uint32_t v[1];
	uint32_t top_link_status[1];
	uint32_t _top_link_status;
} BCM84868_TOP_LINK_STATUSr_t;

#define BCM84868_TOP_LINK_STATUSr_CLR(r) (r).top_link_status[0] = 0
#define BCM84868_TOP_LINK_STATUSr_SET(r,d) (r).top_link_status[0] = d
#define BCM84868_TOP_LINK_STATUSr_GET(r) (r).top_link_status[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_LINK_STATUSr_SPIROM_CRC_STATf_GET(r) ((((r).top_link_status[0]) >> 14) & 0x3)
#define BCM84868_TOP_LINK_STATUSr_SPIROM_CRC_STATf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM84868_TOP_LINK_STATUSr_MAC_LINKf_GET(r) ((((r).top_link_status[0]) >> 13) & 0x1)
#define BCM84868_TOP_LINK_STATUSr_MAC_LINKf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_TOP_LINK_STATUSr_MAC_LINK_STATUSf_GET(r) ((((r).top_link_status[0]) >> 13) & 0x1)
#define BCM84868_TOP_LINK_STATUSr_MAC_LINK_STATUSf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_TOP_LINK_STATUSr_COPPER_LINKf_GET(r) ((((r).top_link_status[0]) >> 5) & 0x1)
#define BCM84868_TOP_LINK_STATUSr_COPPER_LINKf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_TOP_LINK_STATUSr_COPPER_SPEEDf_GET(r) ((((r).top_link_status[0]) >> 3) & 0x3)
#define BCM84868_TOP_LINK_STATUSr_COPPER_SPEEDf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM84868_TOP_LINK_STATUSr_SPEED_LSBf_GET(r) ((((r).top_link_status[0]) >> 3) & 0x3)
#define BCM84868_TOP_LINK_STATUSr_SPEED_LSBf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM84868_TOP_LINK_STATUSr_SPEED_MSBf_GET(r) ((((r).top_link_status[0]) >> 2) & 0x1)
#define BCM84868_TOP_LINK_STATUSr_SPEED_MSBf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM84868_TOP_LINK_STATUSr_COPPER_DETECTf_GET(r) ((((r).top_link_status[0]) >> 1) & 0x1)
#define BCM84868_TOP_LINK_STATUSr_COPPER_DETECTf_SET(r,f) (r).top_link_status[0]=(((r).top_link_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access TOP_LINK_STATUS.
 */
#define BCM84868_READ_TOP_LINK_STATUSr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_LINK_STATUSr,(_r._top_link_status))
#define BCM84868_WRITE_TOP_LINK_STATUSr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_LINK_STATUSr,(_r._top_link_status))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_LINK_STATUSr BCM84868_TOP_LINK_STATUSr
#define TOP_LINK_STATUSr_SIZE BCM84868_TOP_LINK_STATUSr_SIZE
typedef BCM84868_TOP_LINK_STATUSr_t TOP_LINK_STATUSr_t;
#define TOP_LINK_STATUSr_CLR BCM84868_TOP_LINK_STATUSr_CLR
#define TOP_LINK_STATUSr_SET BCM84868_TOP_LINK_STATUSr_SET
#define TOP_LINK_STATUSr_GET BCM84868_TOP_LINK_STATUSr_GET
#define TOP_LINK_STATUSr_SPIROM_CRC_STATf_GET BCM84868_TOP_LINK_STATUSr_SPIROM_CRC_STATf_GET
#define TOP_LINK_STATUSr_SPIROM_CRC_STATf_SET BCM84868_TOP_LINK_STATUSr_SPIROM_CRC_STATf_SET
#define TOP_LINK_STATUSr_MAC_LINKf_GET BCM84868_TOP_LINK_STATUSr_MAC_LINKf_GET
#define TOP_LINK_STATUSr_MAC_LINKf_SET BCM84868_TOP_LINK_STATUSr_MAC_LINKf_SET
#define TOP_LINK_STATUSr_MAC_LINK_STATUSf_GET BCM84868_TOP_LINK_STATUSr_MAC_LINK_STATUSf_GET
#define TOP_LINK_STATUSr_MAC_LINK_STATUSf_SET BCM84868_TOP_LINK_STATUSr_MAC_LINK_STATUSf_SET
#define TOP_LINK_STATUSr_COPPER_LINKf_GET BCM84868_TOP_LINK_STATUSr_COPPER_LINKf_GET
#define TOP_LINK_STATUSr_COPPER_LINKf_SET BCM84868_TOP_LINK_STATUSr_COPPER_LINKf_SET
#define TOP_LINK_STATUSr_COPPER_SPEEDf_GET BCM84868_TOP_LINK_STATUSr_COPPER_SPEEDf_GET
#define TOP_LINK_STATUSr_COPPER_SPEEDf_SET BCM84868_TOP_LINK_STATUSr_COPPER_SPEEDf_SET
#define TOP_LINK_STATUSr_SPEED_LSBf_GET BCM84868_TOP_LINK_STATUSr_SPEED_LSBf_GET
#define TOP_LINK_STATUSr_SPEED_LSBf_SET BCM84868_TOP_LINK_STATUSr_SPEED_LSBf_SET
#define TOP_LINK_STATUSr_SPEED_MSBf_GET BCM84868_TOP_LINK_STATUSr_SPEED_MSBf_GET
#define TOP_LINK_STATUSr_SPEED_MSBf_SET BCM84868_TOP_LINK_STATUSr_SPEED_MSBf_SET
#define TOP_LINK_STATUSr_COPPER_DETECTf_GET BCM84868_TOP_LINK_STATUSr_COPPER_DETECTf_GET
#define TOP_LINK_STATUSr_COPPER_DETECTf_SET BCM84868_TOP_LINK_STATUSr_COPPER_DETECTf_SET
#define READ_TOP_LINK_STATUSr BCM84868_READ_TOP_LINK_STATUSr
#define WRITE_TOP_LINK_STATUSr BCM84868_WRITE_TOP_LINK_STATUSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_LINK_STATUSr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_USER_RQ1_STAT
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x400e
 * DEVAD:    30
 * DESC:     Scratch reg 9
 * SIZE:     32
 * FIELDS:
 *     STRAP_CHG_OK     
 */
#define BCM84868_TOP_USER_RQ1_STATr (0x001e400e | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_USER_RQ1_STATr_SIZE 4

/*
 * This structure should be used to declare and program TOP_USER_RQ1_STAT.
 */
typedef union BCM84868_TOP_USER_RQ1_STATr_s {
	uint32_t v[1];
	uint32_t top_user_rq1_stat[1];
	uint32_t _top_user_rq1_stat;
} BCM84868_TOP_USER_RQ1_STATr_t;

#define BCM84868_TOP_USER_RQ1_STATr_CLR(r) (r).top_user_rq1_stat[0] = 0
#define BCM84868_TOP_USER_RQ1_STATr_SET(r,d) (r).top_user_rq1_stat[0] = d
#define BCM84868_TOP_USER_RQ1_STATr_GET(r) (r).top_user_rq1_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_USER_RQ1_STATr_STRAP_CHG_OKf_GET(r) ((((r).top_user_rq1_stat[0]) >> 1) & 0x1)
#define BCM84868_TOP_USER_RQ1_STATr_STRAP_CHG_OKf_SET(r,f) (r).top_user_rq1_stat[0]=(((r).top_user_rq1_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access TOP_USER_RQ1_STAT.
 */
#define BCM84868_READ_TOP_USER_RQ1_STATr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_USER_RQ1_STATr,(_r._top_user_rq1_stat))
#define BCM84868_WRITE_TOP_USER_RQ1_STATr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_USER_RQ1_STATr,(_r._top_user_rq1_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_USER_RQ1_STATr BCM84868_TOP_USER_RQ1_STATr
#define TOP_USER_RQ1_STATr_SIZE BCM84868_TOP_USER_RQ1_STATr_SIZE
typedef BCM84868_TOP_USER_RQ1_STATr_t TOP_USER_RQ1_STATr_t;
#define TOP_USER_RQ1_STATr_CLR BCM84868_TOP_USER_RQ1_STATr_CLR
#define TOP_USER_RQ1_STATr_SET BCM84868_TOP_USER_RQ1_STATr_SET
#define TOP_USER_RQ1_STATr_GET BCM84868_TOP_USER_RQ1_STATr_GET
#define TOP_USER_RQ1_STATr_STRAP_CHG_OKf_GET BCM84868_TOP_USER_RQ1_STATr_STRAP_CHG_OKf_GET
#define TOP_USER_RQ1_STATr_STRAP_CHG_OKf_SET BCM84868_TOP_USER_RQ1_STATr_STRAP_CHG_OKf_SET
#define READ_TOP_USER_RQ1_STATr BCM84868_READ_TOP_USER_RQ1_STATr
#define WRITE_TOP_USER_RQ1_STATr BCM84868_WRITE_TOP_USER_RQ1_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_USER_RQ1_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_FW_VER
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x400f
 * DEVAD:    30
 * DESC:     Scratch reg 10
 * SIZE:     32
 * FIELDS:
 *     BRANCH           
 *     MAIN             
 *     CHIP_REV         
 */
#define BCM84868_TOP_FW_VERr (0x001e400f | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_FW_VERr_SIZE 4

/*
 * This structure should be used to declare and program TOP_FW_VER.
 */
typedef union BCM84868_TOP_FW_VERr_s {
	uint32_t v[1];
	uint32_t top_fw_ver[1];
	uint32_t _top_fw_ver;
} BCM84868_TOP_FW_VERr_t;

#define BCM84868_TOP_FW_VERr_CLR(r) (r).top_fw_ver[0] = 0
#define BCM84868_TOP_FW_VERr_SET(r,d) (r).top_fw_ver[0] = d
#define BCM84868_TOP_FW_VERr_GET(r) (r).top_fw_ver[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_FW_VERr_CHIP_REVf_GET(r) ((((r).top_fw_ver[0]) >> 12) & 0xf)
#define BCM84868_TOP_FW_VERr_CHIP_REVf_SET(r,f) (r).top_fw_ver[0]=(((r).top_fw_ver[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM84868_TOP_FW_VERr_MAINf_GET(r) ((((r).top_fw_ver[0]) >> 7) & 0x1f)
#define BCM84868_TOP_FW_VERr_MAINf_SET(r,f) (r).top_fw_ver[0]=(((r).top_fw_ver[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7))
#define BCM84868_TOP_FW_VERr_BRANCHf_GET(r) (((r).top_fw_ver[0]) & 0x7f)
#define BCM84868_TOP_FW_VERr_BRANCHf_SET(r,f) (r).top_fw_ver[0]=(((r).top_fw_ver[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access TOP_FW_VER.
 */
#define BCM84868_READ_TOP_FW_VERr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_FW_VERr,(_r._top_fw_ver))
#define BCM84868_WRITE_TOP_FW_VERr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_FW_VERr,(_r._top_fw_ver))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_FW_VERr BCM84868_TOP_FW_VERr
#define TOP_FW_VERr_SIZE BCM84868_TOP_FW_VERr_SIZE
typedef BCM84868_TOP_FW_VERr_t TOP_FW_VERr_t;
#define TOP_FW_VERr_CLR BCM84868_TOP_FW_VERr_CLR
#define TOP_FW_VERr_SET BCM84868_TOP_FW_VERr_SET
#define TOP_FW_VERr_GET BCM84868_TOP_FW_VERr_GET
#define TOP_FW_VERr_CHIP_REVf_GET BCM84868_TOP_FW_VERr_CHIP_REVf_GET
#define TOP_FW_VERr_CHIP_REVf_SET BCM84868_TOP_FW_VERr_CHIP_REVf_SET
#define TOP_FW_VERr_MAINf_GET BCM84868_TOP_FW_VERr_MAINf_GET
#define TOP_FW_VERr_MAINf_SET BCM84868_TOP_FW_VERr_MAINf_SET
#define TOP_FW_VERr_BRANCHf_GET BCM84868_TOP_FW_VERr_BRANCHf_GET
#define TOP_FW_VERr_BRANCHf_SET BCM84868_TOP_FW_VERr_BRANCHf_SET
#define READ_TOP_FW_VERr BCM84868_READ_TOP_FW_VERr
#define WRITE_TOP_FW_VERr BCM84868_WRITE_TOP_FW_VERr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_FW_VERr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_FW_DATE
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x4010
 * DEVAD:    30
 * DESC:     Scratch reg 11
 * SIZE:     32
 * FIELDS:
 *     YEAR             
 *     DAY              
 *     MONTH            
 */
#define BCM84868_TOP_FW_DATEr (0x001e4010 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_FW_DATEr_SIZE 4

/*
 * This structure should be used to declare and program TOP_FW_DATE.
 */
typedef union BCM84868_TOP_FW_DATEr_s {
	uint32_t v[1];
	uint32_t top_fw_date[1];
	uint32_t _top_fw_date;
} BCM84868_TOP_FW_DATEr_t;

#define BCM84868_TOP_FW_DATEr_CLR(r) (r).top_fw_date[0] = 0
#define BCM84868_TOP_FW_DATEr_SET(r,d) (r).top_fw_date[0] = d
#define BCM84868_TOP_FW_DATEr_GET(r) (r).top_fw_date[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_FW_DATEr_MONTHf_GET(r) ((((r).top_fw_date[0]) >> 9) & 0xf)
#define BCM84868_TOP_FW_DATEr_MONTHf_SET(r,f) (r).top_fw_date[0]=(((r).top_fw_date[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM84868_TOP_FW_DATEr_DAYf_GET(r) ((((r).top_fw_date[0]) >> 4) & 0x1f)
#define BCM84868_TOP_FW_DATEr_DAYf_SET(r,f) (r).top_fw_date[0]=(((r).top_fw_date[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM84868_TOP_FW_DATEr_YEARf_GET(r) (((r).top_fw_date[0]) & 0xf)
#define BCM84868_TOP_FW_DATEr_YEARf_SET(r,f) (r).top_fw_date[0]=(((r).top_fw_date[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access TOP_FW_DATE.
 */
#define BCM84868_READ_TOP_FW_DATEr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_FW_DATEr,(_r._top_fw_date))
#define BCM84868_WRITE_TOP_FW_DATEr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_FW_DATEr,(_r._top_fw_date))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_FW_DATEr BCM84868_TOP_FW_DATEr
#define TOP_FW_DATEr_SIZE BCM84868_TOP_FW_DATEr_SIZE
typedef BCM84868_TOP_FW_DATEr_t TOP_FW_DATEr_t;
#define TOP_FW_DATEr_CLR BCM84868_TOP_FW_DATEr_CLR
#define TOP_FW_DATEr_SET BCM84868_TOP_FW_DATEr_SET
#define TOP_FW_DATEr_GET BCM84868_TOP_FW_DATEr_GET
#define TOP_FW_DATEr_MONTHf_GET BCM84868_TOP_FW_DATEr_MONTHf_GET
#define TOP_FW_DATEr_MONTHf_SET BCM84868_TOP_FW_DATEr_MONTHf_SET
#define TOP_FW_DATEr_DAYf_GET BCM84868_TOP_FW_DATEr_DAYf_GET
#define TOP_FW_DATEr_DAYf_SET BCM84868_TOP_FW_DATEr_DAYf_SET
#define TOP_FW_DATEr_YEARf_GET BCM84868_TOP_FW_DATEr_YEARf_GET
#define TOP_FW_DATEr_YEARf_SET BCM84868_TOP_FW_DATEr_YEARf_SET
#define READ_TOP_FW_DATEr BCM84868_READ_TOP_FW_DATEr
#define WRITE_TOP_FW_DATEr BCM84868_WRITE_TOP_FW_DATEr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_FW_DATEr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_SCRATCH_12
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x4011
 * DEVAD:    30
 * DESC:     Scratch reg 12
 * SIZE:     32
 * FIELDS:
 *     SCRATCH          
 */
#define BCM84868_TOP_CONFIG_SCRATCH_12r (0x001e4011 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_SCRATCH_12r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_SCRATCH_12.
 */
typedef union BCM84868_TOP_CONFIG_SCRATCH_12r_s {
	uint32_t v[1];
	uint32_t top_config_scratch_12[1];
	uint32_t _top_config_scratch_12;
} BCM84868_TOP_CONFIG_SCRATCH_12r_t;

#define BCM84868_TOP_CONFIG_SCRATCH_12r_CLR(r) (r).top_config_scratch_12[0] = 0
#define BCM84868_TOP_CONFIG_SCRATCH_12r_SET(r,d) (r).top_config_scratch_12[0] = d
#define BCM84868_TOP_CONFIG_SCRATCH_12r_GET(r) (r).top_config_scratch_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_SCRATCH_12r_SCRATCHf_GET(r) (((r).top_config_scratch_12[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_SCRATCH_12r_SCRATCHf_SET(r,f) (r).top_config_scratch_12[0]=(((r).top_config_scratch_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_SCRATCH_12.
 */
#define BCM84868_READ_TOP_CONFIG_SCRATCH_12r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_SCRATCH_12r,(_r._top_config_scratch_12))
#define BCM84868_WRITE_TOP_CONFIG_SCRATCH_12r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_SCRATCH_12r,(_r._top_config_scratch_12))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_SCRATCH_12r BCM84868_TOP_CONFIG_SCRATCH_12r
#define TOP_CONFIG_SCRATCH_12r_SIZE BCM84868_TOP_CONFIG_SCRATCH_12r_SIZE
typedef BCM84868_TOP_CONFIG_SCRATCH_12r_t TOP_CONFIG_SCRATCH_12r_t;
#define TOP_CONFIG_SCRATCH_12r_CLR BCM84868_TOP_CONFIG_SCRATCH_12r_CLR
#define TOP_CONFIG_SCRATCH_12r_SET BCM84868_TOP_CONFIG_SCRATCH_12r_SET
#define TOP_CONFIG_SCRATCH_12r_GET BCM84868_TOP_CONFIG_SCRATCH_12r_GET
#define TOP_CONFIG_SCRATCH_12r_SCRATCHf_GET BCM84868_TOP_CONFIG_SCRATCH_12r_SCRATCHf_GET
#define TOP_CONFIG_SCRATCH_12r_SCRATCHf_SET BCM84868_TOP_CONFIG_SCRATCH_12r_SCRATCHf_SET
#define READ_TOP_CONFIG_SCRATCH_12r BCM84868_READ_TOP_CONFIG_SCRATCH_12r
#define WRITE_TOP_CONFIG_SCRATCH_12r BCM84868_WRITE_TOP_CONFIG_SCRATCH_12r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_SCRATCH_12r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_SCRATCH_13
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x4012
 * DEVAD:    30
 * DESC:     Scratch reg 13
 * SIZE:     32
 * FIELDS:
 *     SCRATCH          
 */
#define BCM84868_TOP_CONFIG_SCRATCH_13r (0x001e4012 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_SCRATCH_13r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_SCRATCH_13.
 */
typedef union BCM84868_TOP_CONFIG_SCRATCH_13r_s {
	uint32_t v[1];
	uint32_t top_config_scratch_13[1];
	uint32_t _top_config_scratch_13;
} BCM84868_TOP_CONFIG_SCRATCH_13r_t;

#define BCM84868_TOP_CONFIG_SCRATCH_13r_CLR(r) (r).top_config_scratch_13[0] = 0
#define BCM84868_TOP_CONFIG_SCRATCH_13r_SET(r,d) (r).top_config_scratch_13[0] = d
#define BCM84868_TOP_CONFIG_SCRATCH_13r_GET(r) (r).top_config_scratch_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_SCRATCH_13r_SCRATCHf_GET(r) (((r).top_config_scratch_13[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_SCRATCH_13r_SCRATCHf_SET(r,f) (r).top_config_scratch_13[0]=(((r).top_config_scratch_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_SCRATCH_13.
 */
#define BCM84868_READ_TOP_CONFIG_SCRATCH_13r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_SCRATCH_13r,(_r._top_config_scratch_13))
#define BCM84868_WRITE_TOP_CONFIG_SCRATCH_13r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_SCRATCH_13r,(_r._top_config_scratch_13))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_SCRATCH_13r BCM84868_TOP_CONFIG_SCRATCH_13r
#define TOP_CONFIG_SCRATCH_13r_SIZE BCM84868_TOP_CONFIG_SCRATCH_13r_SIZE
typedef BCM84868_TOP_CONFIG_SCRATCH_13r_t TOP_CONFIG_SCRATCH_13r_t;
#define TOP_CONFIG_SCRATCH_13r_CLR BCM84868_TOP_CONFIG_SCRATCH_13r_CLR
#define TOP_CONFIG_SCRATCH_13r_SET BCM84868_TOP_CONFIG_SCRATCH_13r_SET
#define TOP_CONFIG_SCRATCH_13r_GET BCM84868_TOP_CONFIG_SCRATCH_13r_GET
#define TOP_CONFIG_SCRATCH_13r_SCRATCHf_GET BCM84868_TOP_CONFIG_SCRATCH_13r_SCRATCHf_GET
#define TOP_CONFIG_SCRATCH_13r_SCRATCHf_SET BCM84868_TOP_CONFIG_SCRATCH_13r_SCRATCHf_SET
#define READ_TOP_CONFIG_SCRATCH_13r BCM84868_READ_TOP_CONFIG_SCRATCH_13r
#define WRITE_TOP_CONFIG_SCRATCH_13r BCM84868_WRITE_TOP_CONFIG_SCRATCH_13r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_SCRATCH_13r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_SCRATCH_14
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x4013
 * DEVAD:    30
 * DESC:     Scratch reg 14
 * SIZE:     32
 * FIELDS:
 *     SCRATCH          
 */
#define BCM84868_TOP_CONFIG_SCRATCH_14r (0x001e4013 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_SCRATCH_14r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_SCRATCH_14.
 */
typedef union BCM84868_TOP_CONFIG_SCRATCH_14r_s {
	uint32_t v[1];
	uint32_t top_config_scratch_14[1];
	uint32_t _top_config_scratch_14;
} BCM84868_TOP_CONFIG_SCRATCH_14r_t;

#define BCM84868_TOP_CONFIG_SCRATCH_14r_CLR(r) (r).top_config_scratch_14[0] = 0
#define BCM84868_TOP_CONFIG_SCRATCH_14r_SET(r,d) (r).top_config_scratch_14[0] = d
#define BCM84868_TOP_CONFIG_SCRATCH_14r_GET(r) (r).top_config_scratch_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_SCRATCH_14r_SCRATCHf_GET(r) (((r).top_config_scratch_14[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_SCRATCH_14r_SCRATCHf_SET(r,f) (r).top_config_scratch_14[0]=(((r).top_config_scratch_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_SCRATCH_14.
 */
#define BCM84868_READ_TOP_CONFIG_SCRATCH_14r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_SCRATCH_14r,(_r._top_config_scratch_14))
#define BCM84868_WRITE_TOP_CONFIG_SCRATCH_14r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_SCRATCH_14r,(_r._top_config_scratch_14))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_SCRATCH_14r BCM84868_TOP_CONFIG_SCRATCH_14r
#define TOP_CONFIG_SCRATCH_14r_SIZE BCM84868_TOP_CONFIG_SCRATCH_14r_SIZE
typedef BCM84868_TOP_CONFIG_SCRATCH_14r_t TOP_CONFIG_SCRATCH_14r_t;
#define TOP_CONFIG_SCRATCH_14r_CLR BCM84868_TOP_CONFIG_SCRATCH_14r_CLR
#define TOP_CONFIG_SCRATCH_14r_SET BCM84868_TOP_CONFIG_SCRATCH_14r_SET
#define TOP_CONFIG_SCRATCH_14r_GET BCM84868_TOP_CONFIG_SCRATCH_14r_GET
#define TOP_CONFIG_SCRATCH_14r_SCRATCHf_GET BCM84868_TOP_CONFIG_SCRATCH_14r_SCRATCHf_GET
#define TOP_CONFIG_SCRATCH_14r_SCRATCHf_SET BCM84868_TOP_CONFIG_SCRATCH_14r_SCRATCHf_SET
#define READ_TOP_CONFIG_SCRATCH_14r BCM84868_READ_TOP_CONFIG_SCRATCH_14r
#define WRITE_TOP_CONFIG_SCRATCH_14r BCM84868_WRITE_TOP_CONFIG_SCRATCH_14r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_SCRATCH_14r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_SCRATCH_15
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x4014
 * DEVAD:    30
 * DESC:     Scratch reg 15
 * SIZE:     32
 * FIELDS:
 *     SCRATCH          
 */
#define BCM84868_TOP_CONFIG_SCRATCH_15r (0x001e4014 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_SCRATCH_15r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_SCRATCH_15.
 */
typedef union BCM84868_TOP_CONFIG_SCRATCH_15r_s {
	uint32_t v[1];
	uint32_t top_config_scratch_15[1];
	uint32_t _top_config_scratch_15;
} BCM84868_TOP_CONFIG_SCRATCH_15r_t;

#define BCM84868_TOP_CONFIG_SCRATCH_15r_CLR(r) (r).top_config_scratch_15[0] = 0
#define BCM84868_TOP_CONFIG_SCRATCH_15r_SET(r,d) (r).top_config_scratch_15[0] = d
#define BCM84868_TOP_CONFIG_SCRATCH_15r_GET(r) (r).top_config_scratch_15[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_SCRATCH_15r_SCRATCHf_GET(r) (((r).top_config_scratch_15[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_SCRATCH_15r_SCRATCHf_SET(r,f) (r).top_config_scratch_15[0]=(((r).top_config_scratch_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_SCRATCH_15.
 */
#define BCM84868_READ_TOP_CONFIG_SCRATCH_15r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_SCRATCH_15r,(_r._top_config_scratch_15))
#define BCM84868_WRITE_TOP_CONFIG_SCRATCH_15r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_SCRATCH_15r,(_r._top_config_scratch_15))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_SCRATCH_15r BCM84868_TOP_CONFIG_SCRATCH_15r
#define TOP_CONFIG_SCRATCH_15r_SIZE BCM84868_TOP_CONFIG_SCRATCH_15r_SIZE
typedef BCM84868_TOP_CONFIG_SCRATCH_15r_t TOP_CONFIG_SCRATCH_15r_t;
#define TOP_CONFIG_SCRATCH_15r_CLR BCM84868_TOP_CONFIG_SCRATCH_15r_CLR
#define TOP_CONFIG_SCRATCH_15r_SET BCM84868_TOP_CONFIG_SCRATCH_15r_SET
#define TOP_CONFIG_SCRATCH_15r_GET BCM84868_TOP_CONFIG_SCRATCH_15r_GET
#define TOP_CONFIG_SCRATCH_15r_SCRATCHf_GET BCM84868_TOP_CONFIG_SCRATCH_15r_SCRATCHf_GET
#define TOP_CONFIG_SCRATCH_15r_SCRATCHf_SET BCM84868_TOP_CONFIG_SCRATCH_15r_SCRATCHf_SET
#define READ_TOP_CONFIG_SCRATCH_15r BCM84868_READ_TOP_CONFIG_SCRATCH_15r
#define WRITE_TOP_CONFIG_SCRATCH_15r BCM84868_WRITE_TOP_CONFIG_SCRATCH_15r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_SCRATCH_15r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_XGPHY_STRAP1
 * BLOCKS:   TOP_CONFIG
 * REGADDR:  0x401a
 * DEVAD:    30
 * DESC:     XGPHY pin strap read
 * SIZE:     32
 * FIELDS:
 *     SPARE_FW_STRAPS_12_0 
 *     ARM_BOOT_HIGH    
 *     SPARE_FW_STRAPS_14 
 *     SUPER_ISO_CHANGE 
 */
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r (0x001e401a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_XGPHY_STRAP1.
 */
typedef union BCM84868_TOP_CONFIG_XGPHY_STRAP1r_s {
	uint32_t v[1];
	uint32_t top_config_xgphy_strap1[1];
	uint32_t _top_config_xgphy_strap1;
} BCM84868_TOP_CONFIG_XGPHY_STRAP1r_t;

#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_CLR(r) (r).top_config_xgphy_strap1[0] = 0
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SET(r,d) (r).top_config_xgphy_strap1[0] = d
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_GET(r) (r).top_config_xgphy_strap1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SUPER_ISO_CHANGEf_GET(r) ((((r).top_config_xgphy_strap1[0]) >> 15) & 0x1)
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SUPER_ISO_CHANGEf_SET(r,f) (r).top_config_xgphy_strap1[0]=(((r).top_config_xgphy_strap1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_14f_GET(r) ((((r).top_config_xgphy_strap1[0]) >> 14) & 0x1)
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_14f_SET(r,f) (r).top_config_xgphy_strap1[0]=(((r).top_config_xgphy_strap1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_ARM_BOOT_HIGHf_GET(r) ((((r).top_config_xgphy_strap1[0]) >> 13) & 0x1)
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_ARM_BOOT_HIGHf_SET(r,f) (r).top_config_xgphy_strap1[0]=(((r).top_config_xgphy_strap1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_12_0f_GET(r) (((r).top_config_xgphy_strap1[0]) & 0x1fff)
#define BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_12_0f_SET(r,f) (r).top_config_xgphy_strap1[0]=(((r).top_config_xgphy_strap1[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access TOP_CONFIG_XGPHY_STRAP1.
 */
#define BCM84868_READ_TOP_CONFIG_XGPHY_STRAP1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_XGPHY_STRAP1r,(_r._top_config_xgphy_strap1))
#define BCM84868_WRITE_TOP_CONFIG_XGPHY_STRAP1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_XGPHY_STRAP1r,(_r._top_config_xgphy_strap1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_XGPHY_STRAP1r BCM84868_TOP_CONFIG_XGPHY_STRAP1r
#define TOP_CONFIG_XGPHY_STRAP1r_SIZE BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SIZE
typedef BCM84868_TOP_CONFIG_XGPHY_STRAP1r_t TOP_CONFIG_XGPHY_STRAP1r_t;
#define TOP_CONFIG_XGPHY_STRAP1r_CLR BCM84868_TOP_CONFIG_XGPHY_STRAP1r_CLR
#define TOP_CONFIG_XGPHY_STRAP1r_SET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SET
#define TOP_CONFIG_XGPHY_STRAP1r_GET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_GET
#define TOP_CONFIG_XGPHY_STRAP1r_SUPER_ISO_CHANGEf_GET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SUPER_ISO_CHANGEf_GET
#define TOP_CONFIG_XGPHY_STRAP1r_SUPER_ISO_CHANGEf_SET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SUPER_ISO_CHANGEf_SET
#define TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_14f_GET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_14f_GET
#define TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_14f_SET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_14f_SET
#define TOP_CONFIG_XGPHY_STRAP1r_ARM_BOOT_HIGHf_GET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_ARM_BOOT_HIGHf_GET
#define TOP_CONFIG_XGPHY_STRAP1r_ARM_BOOT_HIGHf_SET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_ARM_BOOT_HIGHf_SET
#define TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_12_0f_GET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_12_0f_GET
#define TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_12_0f_SET BCM84868_TOP_CONFIG_XGPHY_STRAP1r_SPARE_FW_STRAPS_12_0f_SET
#define READ_TOP_CONFIG_XGPHY_STRAP1r BCM84868_READ_TOP_CONFIG_XGPHY_STRAP1r
#define WRITE_TOP_CONFIG_XGPHY_STRAP1r BCM84868_WRITE_TOP_CONFIG_XGPHY_STRAP1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_XGPHY_STRAP1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_STAT
 * BLOCKS:   TOP
 * REGADDR:  0x4037
 * DEVAD:    30
 * DESC:     Scratch reg 26
 * SIZE:     32
 * FIELDS:
 *     STAT             
 */
#define BCM84868_TOP_MCH_STATr (0x001e4037 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_STATr_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_STAT.
 */
typedef union BCM84868_TOP_MCH_STATr_s {
	uint32_t v[1];
	uint32_t top_mch_stat[1];
	uint32_t _top_mch_stat;
} BCM84868_TOP_MCH_STATr_t;

#define BCM84868_TOP_MCH_STATr_CLR(r) (r).top_mch_stat[0] = 0
#define BCM84868_TOP_MCH_STATr_SET(r,d) (r).top_mch_stat[0] = d
#define BCM84868_TOP_MCH_STATr_GET(r) (r).top_mch_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_STATr_STATf_GET(r) (((r).top_mch_stat[0]) & 0xffff)
#define BCM84868_TOP_MCH_STATr_STATf_SET(r,f) (r).top_mch_stat[0]=(((r).top_mch_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_MCH_STAT.
 */
#define BCM84868_READ_TOP_MCH_STATr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_STATr,(_r._top_mch_stat))
#define BCM84868_WRITE_TOP_MCH_STATr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_STATr,(_r._top_mch_stat))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_STATr BCM84868_TOP_MCH_STATr
#define TOP_MCH_STATr_SIZE BCM84868_TOP_MCH_STATr_SIZE
typedef BCM84868_TOP_MCH_STATr_t TOP_MCH_STATr_t;
#define TOP_MCH_STATr_CLR BCM84868_TOP_MCH_STATr_CLR
#define TOP_MCH_STATr_SET BCM84868_TOP_MCH_STATr_SET
#define TOP_MCH_STATr_GET BCM84868_TOP_MCH_STATr_GET
#define TOP_MCH_STATr_STATf_GET BCM84868_TOP_MCH_STATr_STATf_GET
#define TOP_MCH_STATr_STATf_SET BCM84868_TOP_MCH_STATr_STATf_SET
#define READ_TOP_MCH_STATr BCM84868_READ_TOP_MCH_STATr
#define WRITE_TOP_MCH_STATr BCM84868_WRITE_TOP_MCH_STATr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_STATr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_DATA
 * BLOCKS:   TOP
 * REGADDR:  0x4038
 * DEVAD:    30
 * DESC:     Scratch reg 27
 * SIZE:     32
 * FIELDS:
 *     DATA             
 */
#define BCM84868_TOP_MCH_DATAr (0x001e4038 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_DATAr_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_DATA.
 */
typedef union BCM84868_TOP_MCH_DATAr_s {
	uint32_t v[1];
	uint32_t top_mch_data[1];
	uint32_t _top_mch_data;
} BCM84868_TOP_MCH_DATAr_t;

#define BCM84868_TOP_MCH_DATAr_CLR(r) (r).top_mch_data[0] = 0
#define BCM84868_TOP_MCH_DATAr_SET(r,d) (r).top_mch_data[0] = d
#define BCM84868_TOP_MCH_DATAr_GET(r) (r).top_mch_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_DATAr_DATAf_GET(r) (((r).top_mch_data[0]) & 0xffff)
#define BCM84868_TOP_MCH_DATAr_DATAf_SET(r,f) (r).top_mch_data[0]=(((r).top_mch_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_MCH_DATA.
 */
#define BCM84868_READ_TOP_MCH_DATAr(_pc,_i,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_DATAr+(_i),(_r._top_mch_data))
#define BCM84868_WRITE_TOP_MCH_DATAr(_pc,_i,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_DATAr+(_i),(_r._top_mch_data))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_DATAr BCM84868_TOP_MCH_DATAr
#define TOP_MCH_DATAr_SIZE BCM84868_TOP_MCH_DATAr_SIZE
typedef BCM84868_TOP_MCH_DATAr_t TOP_MCH_DATAr_t;
#define TOP_MCH_DATAr_CLR BCM84868_TOP_MCH_DATAr_CLR
#define TOP_MCH_DATAr_SET BCM84868_TOP_MCH_DATAr_SET
#define TOP_MCH_DATAr_GET BCM84868_TOP_MCH_DATAr_GET
#define TOP_MCH_DATAr_DATAf_GET BCM84868_TOP_MCH_DATAr_DATAf_GET
#define TOP_MCH_DATAr_DATAf_SET BCM84868_TOP_MCH_DATAr_DATAf_SET
#define READ_TOP_MCH_DATAr BCM84868_READ_TOP_MCH_DATAr
#define WRITE_TOP_MCH_DATAr BCM84868_WRITE_TOP_MCH_DATAr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_DATA1
 * BLOCKS:   TOP
 * REGADDR:  0x4038
 * DEVAD:    30
 * DESC:     Scratch reg 27
 * SIZE:     32
 * FIELDS:
 *     DATA             
 */
#define BCM84868_TOP_MCH_DATA1r (0x001e4038 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_DATA1.
 */
typedef union BCM84868_TOP_MCH_DATA1r_s {
	uint32_t v[1];
	uint32_t top_mch_data1[1];
	uint32_t _top_mch_data1;
} BCM84868_TOP_MCH_DATA1r_t;

#define BCM84868_TOP_MCH_DATA1r_CLR(r) (r).top_mch_data1[0] = 0
#define BCM84868_TOP_MCH_DATA1r_SET(r,d) (r).top_mch_data1[0] = d
#define BCM84868_TOP_MCH_DATA1r_GET(r) (r).top_mch_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_DATA1r_DATAf_GET(r) (((r).top_mch_data1[0]) & 0xffff)
#define BCM84868_TOP_MCH_DATA1r_DATAf_SET(r,f) (r).top_mch_data1[0]=(((r).top_mch_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_MCH_DATA1.
 */
#define BCM84868_READ_TOP_MCH_DATA1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_DATA1r,(_r._top_mch_data1))
#define BCM84868_WRITE_TOP_MCH_DATA1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_DATA1r,(_r._top_mch_data1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_DATA1r BCM84868_TOP_MCH_DATA1r
#define TOP_MCH_DATA1r_SIZE BCM84868_TOP_MCH_DATA1r_SIZE
typedef BCM84868_TOP_MCH_DATA1r_t TOP_MCH_DATA1r_t;
#define TOP_MCH_DATA1r_CLR BCM84868_TOP_MCH_DATA1r_CLR
#define TOP_MCH_DATA1r_SET BCM84868_TOP_MCH_DATA1r_SET
#define TOP_MCH_DATA1r_GET BCM84868_TOP_MCH_DATA1r_GET
#define TOP_MCH_DATA1r_DATAf_GET BCM84868_TOP_MCH_DATA1r_DATAf_GET
#define TOP_MCH_DATA1r_DATAf_SET BCM84868_TOP_MCH_DATA1r_DATAf_SET
#define READ_TOP_MCH_DATA1r BCM84868_READ_TOP_MCH_DATA1r
#define WRITE_TOP_MCH_DATA1r BCM84868_WRITE_TOP_MCH_DATA1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_DATA2
 * BLOCKS:   TOP
 * REGADDR:  0x4039
 * DEVAD:    30
 * DESC:     Scratch reg 28
 * SIZE:     32
 * FIELDS:
 *     DATA             
 */
#define BCM84868_TOP_MCH_DATA2r (0x001e4039 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_DATA2r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_DATA2.
 */
typedef union BCM84868_TOP_MCH_DATA2r_s {
	uint32_t v[1];
	uint32_t top_mch_data2[1];
	uint32_t _top_mch_data2;
} BCM84868_TOP_MCH_DATA2r_t;

#define BCM84868_TOP_MCH_DATA2r_CLR(r) (r).top_mch_data2[0] = 0
#define BCM84868_TOP_MCH_DATA2r_SET(r,d) (r).top_mch_data2[0] = d
#define BCM84868_TOP_MCH_DATA2r_GET(r) (r).top_mch_data2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_DATA2r_DATAf_GET(r) (((r).top_mch_data2[0]) & 0xffff)
#define BCM84868_TOP_MCH_DATA2r_DATAf_SET(r,f) (r).top_mch_data2[0]=(((r).top_mch_data2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_MCH_DATA2.
 */
#define BCM84868_READ_TOP_MCH_DATA2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_DATA2r,(_r._top_mch_data2))
#define BCM84868_WRITE_TOP_MCH_DATA2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_DATA2r,(_r._top_mch_data2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_DATA2r BCM84868_TOP_MCH_DATA2r
#define TOP_MCH_DATA2r_SIZE BCM84868_TOP_MCH_DATA2r_SIZE
typedef BCM84868_TOP_MCH_DATA2r_t TOP_MCH_DATA2r_t;
#define TOP_MCH_DATA2r_CLR BCM84868_TOP_MCH_DATA2r_CLR
#define TOP_MCH_DATA2r_SET BCM84868_TOP_MCH_DATA2r_SET
#define TOP_MCH_DATA2r_GET BCM84868_TOP_MCH_DATA2r_GET
#define TOP_MCH_DATA2r_DATAf_GET BCM84868_TOP_MCH_DATA2r_DATAf_GET
#define TOP_MCH_DATA2r_DATAf_SET BCM84868_TOP_MCH_DATA2r_DATAf_SET
#define READ_TOP_MCH_DATA2r BCM84868_READ_TOP_MCH_DATA2r
#define WRITE_TOP_MCH_DATA2r BCM84868_WRITE_TOP_MCH_DATA2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_DATA2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_DATA3
 * BLOCKS:   TOP
 * REGADDR:  0x403a
 * DEVAD:    30
 * DESC:     Scratch reg 29
 * SIZE:     32
 * FIELDS:
 *     DATA             
 */
#define BCM84868_TOP_MCH_DATA3r (0x001e403a | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_DATA3r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_DATA3.
 */
typedef union BCM84868_TOP_MCH_DATA3r_s {
	uint32_t v[1];
	uint32_t top_mch_data3[1];
	uint32_t _top_mch_data3;
} BCM84868_TOP_MCH_DATA3r_t;

#define BCM84868_TOP_MCH_DATA3r_CLR(r) (r).top_mch_data3[0] = 0
#define BCM84868_TOP_MCH_DATA3r_SET(r,d) (r).top_mch_data3[0] = d
#define BCM84868_TOP_MCH_DATA3r_GET(r) (r).top_mch_data3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_DATA3r_DATAf_GET(r) (((r).top_mch_data3[0]) & 0xffff)
#define BCM84868_TOP_MCH_DATA3r_DATAf_SET(r,f) (r).top_mch_data3[0]=(((r).top_mch_data3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_MCH_DATA3.
 */
#define BCM84868_READ_TOP_MCH_DATA3r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_DATA3r,(_r._top_mch_data3))
#define BCM84868_WRITE_TOP_MCH_DATA3r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_DATA3r,(_r._top_mch_data3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_DATA3r BCM84868_TOP_MCH_DATA3r
#define TOP_MCH_DATA3r_SIZE BCM84868_TOP_MCH_DATA3r_SIZE
typedef BCM84868_TOP_MCH_DATA3r_t TOP_MCH_DATA3r_t;
#define TOP_MCH_DATA3r_CLR BCM84868_TOP_MCH_DATA3r_CLR
#define TOP_MCH_DATA3r_SET BCM84868_TOP_MCH_DATA3r_SET
#define TOP_MCH_DATA3r_GET BCM84868_TOP_MCH_DATA3r_GET
#define TOP_MCH_DATA3r_DATAf_GET BCM84868_TOP_MCH_DATA3r_DATAf_GET
#define TOP_MCH_DATA3r_DATAf_SET BCM84868_TOP_MCH_DATA3r_DATAf_SET
#define READ_TOP_MCH_DATA3r BCM84868_READ_TOP_MCH_DATA3r
#define WRITE_TOP_MCH_DATA3r BCM84868_WRITE_TOP_MCH_DATA3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_DATA3r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_MCH_DATA4
 * BLOCKS:   TOP
 * REGADDR:  0x403b
 * DEVAD:    30
 * DESC:     Scratch reg 30
 * SIZE:     32
 * FIELDS:
 *     DATA             
 */
#define BCM84868_TOP_MCH_DATA4r (0x001e403b | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_MCH_DATA4r_SIZE 4

/*
 * This structure should be used to declare and program TOP_MCH_DATA4.
 */
typedef union BCM84868_TOP_MCH_DATA4r_s {
	uint32_t v[1];
	uint32_t top_mch_data4[1];
	uint32_t _top_mch_data4;
} BCM84868_TOP_MCH_DATA4r_t;

#define BCM84868_TOP_MCH_DATA4r_CLR(r) (r).top_mch_data4[0] = 0
#define BCM84868_TOP_MCH_DATA4r_SET(r,d) (r).top_mch_data4[0] = d
#define BCM84868_TOP_MCH_DATA4r_GET(r) (r).top_mch_data4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_MCH_DATA4r_DATAf_GET(r) (((r).top_mch_data4[0]) & 0xffff)
#define BCM84868_TOP_MCH_DATA4r_DATAf_SET(r,f) (r).top_mch_data4[0]=(((r).top_mch_data4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_MCH_DATA4.
 */
#define BCM84868_READ_TOP_MCH_DATA4r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_MCH_DATA4r,(_r._top_mch_data4))
#define BCM84868_WRITE_TOP_MCH_DATA4r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_MCH_DATA4r,(_r._top_mch_data4))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_MCH_DATA4r BCM84868_TOP_MCH_DATA4r
#define TOP_MCH_DATA4r_SIZE BCM84868_TOP_MCH_DATA4r_SIZE
typedef BCM84868_TOP_MCH_DATA4r_t TOP_MCH_DATA4r_t;
#define TOP_MCH_DATA4r_CLR BCM84868_TOP_MCH_DATA4r_CLR
#define TOP_MCH_DATA4r_SET BCM84868_TOP_MCH_DATA4r_SET
#define TOP_MCH_DATA4r_GET BCM84868_TOP_MCH_DATA4r_GET
#define TOP_MCH_DATA4r_DATAf_GET BCM84868_TOP_MCH_DATA4r_DATAf_GET
#define TOP_MCH_DATA4r_DATAf_SET BCM84868_TOP_MCH_DATA4r_DATAf_SET
#define READ_TOP_MCH_DATA4r BCM84868_READ_TOP_MCH_DATA4r
#define WRITE_TOP_MCH_DATA4r BCM84868_WRITE_TOP_MCH_DATA4r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_MCH_DATA4r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  TOP_CONFIG_SCRATCH_31
 * BLOCKS:   TOP
 * REGADDR:  0x403c
 * DEVAD:    30
 * DESC:     Scratch reg 31
 * SIZE:     32
 * FIELDS:
 *     SCRATCH          
 */
#define BCM84868_TOP_CONFIG_SCRATCH_31r (0x001e403c | PHY_REG_ACC_BRCM_XE)

#define BCM84868_TOP_CONFIG_SCRATCH_31r_SIZE 4

/*
 * This structure should be used to declare and program TOP_CONFIG_SCRATCH_31.
 */
typedef union BCM84868_TOP_CONFIG_SCRATCH_31r_s {
	uint32_t v[1];
	uint32_t top_config_scratch_31[1];
	uint32_t _top_config_scratch_31;
} BCM84868_TOP_CONFIG_SCRATCH_31r_t;

#define BCM84868_TOP_CONFIG_SCRATCH_31r_CLR(r) (r).top_config_scratch_31[0] = 0
#define BCM84868_TOP_CONFIG_SCRATCH_31r_SET(r,d) (r).top_config_scratch_31[0] = d
#define BCM84868_TOP_CONFIG_SCRATCH_31r_GET(r) (r).top_config_scratch_31[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_TOP_CONFIG_SCRATCH_31r_SCRATCHf_GET(r) (((r).top_config_scratch_31[0]) & 0xffff)
#define BCM84868_TOP_CONFIG_SCRATCH_31r_SCRATCHf_SET(r,f) (r).top_config_scratch_31[0]=(((r).top_config_scratch_31[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TOP_CONFIG_SCRATCH_31.
 */
#define BCM84868_READ_TOP_CONFIG_SCRATCH_31r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_TOP_CONFIG_SCRATCH_31r,(_r._top_config_scratch_31))
#define BCM84868_WRITE_TOP_CONFIG_SCRATCH_31r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_TOP_CONFIG_SCRATCH_31r,(_r._top_config_scratch_31))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define TOP_CONFIG_SCRATCH_31r BCM84868_TOP_CONFIG_SCRATCH_31r
#define TOP_CONFIG_SCRATCH_31r_SIZE BCM84868_TOP_CONFIG_SCRATCH_31r_SIZE
typedef BCM84868_TOP_CONFIG_SCRATCH_31r_t TOP_CONFIG_SCRATCH_31r_t;
#define TOP_CONFIG_SCRATCH_31r_CLR BCM84868_TOP_CONFIG_SCRATCH_31r_CLR
#define TOP_CONFIG_SCRATCH_31r_SET BCM84868_TOP_CONFIG_SCRATCH_31r_SET
#define TOP_CONFIG_SCRATCH_31r_GET BCM84868_TOP_CONFIG_SCRATCH_31r_GET
#define TOP_CONFIG_SCRATCH_31r_SCRATCHf_GET BCM84868_TOP_CONFIG_SCRATCH_31r_SCRATCHf_GET
#define TOP_CONFIG_SCRATCH_31r_SCRATCHf_SET BCM84868_TOP_CONFIG_SCRATCH_31r_SCRATCHf_SET
#define READ_TOP_CONFIG_SCRATCH_31r BCM84868_READ_TOP_CONFIG_SCRATCH_31r
#define WRITE_TOP_CONFIG_SCRATCH_31r BCM84868_WRITE_TOP_CONFIG_SCRATCH_31r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_TOP_CONFIG_SCRATCH_31r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XAUI1_MDIO_CTL
 * BLOCKS:   XAUI
 * REGADDR:  0x4080
 * DEVAD:    30
 * DESC:     xaui mdio control register 01
 * SIZE:     32
 * FIELDS:
 *     PRTAD            
 *     MD_DEVAD         
 *     MULTIMMDS_STRAP  
 *     MD_ST            
 *     REMOTEMDIOREQ    
 *     RESERVED0        
 */
#define BCM84868_XAUI1_MDIO_CTLr (0x001e4080 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XAUI1_MDIO_CTLr_SIZE 4

/*
 * This structure should be used to declare and program XAUI1_MDIO_CTL.
 */
typedef union BCM84868_XAUI1_MDIO_CTLr_s {
	uint32_t v[1];
	uint32_t xaui1_mdio_ctl[1];
	uint32_t _xaui1_mdio_ctl;
} BCM84868_XAUI1_MDIO_CTLr_t;

#define BCM84868_XAUI1_MDIO_CTLr_CLR(r) (r).xaui1_mdio_ctl[0] = 0
#define BCM84868_XAUI1_MDIO_CTLr_SET(r,d) (r).xaui1_mdio_ctl[0] = d
#define BCM84868_XAUI1_MDIO_CTLr_GET(r) (r).xaui1_mdio_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XAUI1_MDIO_CTLr_RESERVED0f_GET(r) ((((r).xaui1_mdio_ctl[0]) >> 13) & 0x7)
#define BCM84868_XAUI1_MDIO_CTLr_RESERVED0f_SET(r,f) (r).xaui1_mdio_ctl[0]=(((r).xaui1_mdio_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM84868_XAUI1_MDIO_CTLr_REMOTEMDIOREQf_GET(r) ((((r).xaui1_mdio_ctl[0]) >> 12) & 0x1)
#define BCM84868_XAUI1_MDIO_CTLr_REMOTEMDIOREQf_SET(r,f) (r).xaui1_mdio_ctl[0]=(((r).xaui1_mdio_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_XAUI1_MDIO_CTLr_MD_STf_GET(r) ((((r).xaui1_mdio_ctl[0]) >> 11) & 0x1)
#define BCM84868_XAUI1_MDIO_CTLr_MD_STf_SET(r,f) (r).xaui1_mdio_ctl[0]=(((r).xaui1_mdio_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_XAUI1_MDIO_CTLr_MULTIMMDS_STRAPf_GET(r) ((((r).xaui1_mdio_ctl[0]) >> 10) & 0x1)
#define BCM84868_XAUI1_MDIO_CTLr_MULTIMMDS_STRAPf_SET(r,f) (r).xaui1_mdio_ctl[0]=(((r).xaui1_mdio_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_XAUI1_MDIO_CTLr_MD_DEVADf_GET(r) ((((r).xaui1_mdio_ctl[0]) >> 5) & 0x1f)
#define BCM84868_XAUI1_MDIO_CTLr_MD_DEVADf_SET(r,f) (r).xaui1_mdio_ctl[0]=(((r).xaui1_mdio_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM84868_XAUI1_MDIO_CTLr_PRTADf_GET(r) (((r).xaui1_mdio_ctl[0]) & 0x1f)
#define BCM84868_XAUI1_MDIO_CTLr_PRTADf_SET(r,f) (r).xaui1_mdio_ctl[0]=(((r).xaui1_mdio_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access XAUI1_MDIO_CTL.
 */
#define BCM84868_READ_XAUI1_MDIO_CTLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XAUI1_MDIO_CTLr,(_r._xaui1_mdio_ctl))
#define BCM84868_WRITE_XAUI1_MDIO_CTLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XAUI1_MDIO_CTLr,(_r._xaui1_mdio_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XAUI1_MDIO_CTLr BCM84868_XAUI1_MDIO_CTLr
#define XAUI1_MDIO_CTLr_SIZE BCM84868_XAUI1_MDIO_CTLr_SIZE
typedef BCM84868_XAUI1_MDIO_CTLr_t XAUI1_MDIO_CTLr_t;
#define XAUI1_MDIO_CTLr_CLR BCM84868_XAUI1_MDIO_CTLr_CLR
#define XAUI1_MDIO_CTLr_SET BCM84868_XAUI1_MDIO_CTLr_SET
#define XAUI1_MDIO_CTLr_GET BCM84868_XAUI1_MDIO_CTLr_GET
#define XAUI1_MDIO_CTLr_RESERVED0f_GET BCM84868_XAUI1_MDIO_CTLr_RESERVED0f_GET
#define XAUI1_MDIO_CTLr_RESERVED0f_SET BCM84868_XAUI1_MDIO_CTLr_RESERVED0f_SET
#define XAUI1_MDIO_CTLr_REMOTEMDIOREQf_GET BCM84868_XAUI1_MDIO_CTLr_REMOTEMDIOREQf_GET
#define XAUI1_MDIO_CTLr_REMOTEMDIOREQf_SET BCM84868_XAUI1_MDIO_CTLr_REMOTEMDIOREQf_SET
#define XAUI1_MDIO_CTLr_MD_STf_GET BCM84868_XAUI1_MDIO_CTLr_MD_STf_GET
#define XAUI1_MDIO_CTLr_MD_STf_SET BCM84868_XAUI1_MDIO_CTLr_MD_STf_SET
#define XAUI1_MDIO_CTLr_MULTIMMDS_STRAPf_GET BCM84868_XAUI1_MDIO_CTLr_MULTIMMDS_STRAPf_GET
#define XAUI1_MDIO_CTLr_MULTIMMDS_STRAPf_SET BCM84868_XAUI1_MDIO_CTLr_MULTIMMDS_STRAPf_SET
#define XAUI1_MDIO_CTLr_MD_DEVADf_GET BCM84868_XAUI1_MDIO_CTLr_MD_DEVADf_GET
#define XAUI1_MDIO_CTLr_MD_DEVADf_SET BCM84868_XAUI1_MDIO_CTLr_MD_DEVADf_SET
#define XAUI1_MDIO_CTLr_PRTADf_GET BCM84868_XAUI1_MDIO_CTLr_PRTADf_GET
#define XAUI1_MDIO_CTLr_PRTADf_SET BCM84868_XAUI1_MDIO_CTLr_PRTADf_SET
#define READ_XAUI1_MDIO_CTLr BCM84868_READ_XAUI1_MDIO_CTLr
#define WRITE_XAUI1_MDIO_CTLr BCM84868_WRITE_XAUI1_MDIO_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XAUI1_MDIO_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XAUI1_RESET_CTL
 * BLOCKS:   XAUI
 * REGADDR:  0x4083
 * DEVAD:    30
 * DESC:     xaui reset control register 01
 * SIZE:     32
 * FIELDS:
 *     XAUI1_RESET_CTL_REG 
 */
#define BCM84868_XAUI1_RESET_CTLr (0x001e4083 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XAUI1_RESET_CTLr_SIZE 4

/*
 * This structure should be used to declare and program XAUI1_RESET_CTL.
 */
typedef union BCM84868_XAUI1_RESET_CTLr_s {
	uint32_t v[1];
	uint32_t xaui1_reset_ctl[1];
	uint32_t _xaui1_reset_ctl;
} BCM84868_XAUI1_RESET_CTLr_t;

#define BCM84868_XAUI1_RESET_CTLr_CLR(r) (r).xaui1_reset_ctl[0] = 0
#define BCM84868_XAUI1_RESET_CTLr_SET(r,d) (r).xaui1_reset_ctl[0] = d
#define BCM84868_XAUI1_RESET_CTLr_GET(r) (r).xaui1_reset_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XAUI1_RESET_CTLr_XAUI1_RESET_CTL_REGf_GET(r) (((r).xaui1_reset_ctl[0]) & 0xffff)
#define BCM84868_XAUI1_RESET_CTLr_XAUI1_RESET_CTL_REGf_SET(r,f) (r).xaui1_reset_ctl[0]=(((r).xaui1_reset_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XAUI1_RESET_CTL.
 */
#define BCM84868_READ_XAUI1_RESET_CTLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XAUI1_RESET_CTLr,(_r._xaui1_reset_ctl))
#define BCM84868_WRITE_XAUI1_RESET_CTLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XAUI1_RESET_CTLr,(_r._xaui1_reset_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XAUI1_RESET_CTLr BCM84868_XAUI1_RESET_CTLr
#define XAUI1_RESET_CTLr_SIZE BCM84868_XAUI1_RESET_CTLr_SIZE
typedef BCM84868_XAUI1_RESET_CTLr_t XAUI1_RESET_CTLr_t;
#define XAUI1_RESET_CTLr_CLR BCM84868_XAUI1_RESET_CTLr_CLR
#define XAUI1_RESET_CTLr_SET BCM84868_XAUI1_RESET_CTLr_SET
#define XAUI1_RESET_CTLr_GET BCM84868_XAUI1_RESET_CTLr_GET
#define XAUI1_RESET_CTLr_XAUI1_RESET_CTL_REGf_GET BCM84868_XAUI1_RESET_CTLr_XAUI1_RESET_CTL_REGf_GET
#define XAUI1_RESET_CTLr_XAUI1_RESET_CTL_REGf_SET BCM84868_XAUI1_RESET_CTLr_XAUI1_RESET_CTL_REGf_SET
#define READ_XAUI1_RESET_CTLr BCM84868_READ_XAUI1_RESET_CTLr
#define WRITE_XAUI1_RESET_CTLr BCM84868_WRITE_XAUI1_RESET_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XAUI1_RESET_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XAUI2_MDIO_CTL
 * BLOCKS:   XAUI
 * REGADDR:  0x4090
 * DEVAD:    30
 * DESC:     xaui mdio control register 02
 * SIZE:     32
 * FIELDS:
 *     PRTAD            
 *     MD_DEVAD         
 *     MULTIMMDS_STRAP  
 *     MD_ST            
 *     REMOTEMDIOREQ    
 *     RESERVED0        
 */
#define BCM84868_XAUI2_MDIO_CTLr (0x001e4090 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XAUI2_MDIO_CTLr_SIZE 4

/*
 * This structure should be used to declare and program XAUI2_MDIO_CTL.
 */
typedef union BCM84868_XAUI2_MDIO_CTLr_s {
	uint32_t v[1];
	uint32_t xaui2_mdio_ctl[1];
	uint32_t _xaui2_mdio_ctl;
} BCM84868_XAUI2_MDIO_CTLr_t;

#define BCM84868_XAUI2_MDIO_CTLr_CLR(r) (r).xaui2_mdio_ctl[0] = 0
#define BCM84868_XAUI2_MDIO_CTLr_SET(r,d) (r).xaui2_mdio_ctl[0] = d
#define BCM84868_XAUI2_MDIO_CTLr_GET(r) (r).xaui2_mdio_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XAUI2_MDIO_CTLr_RESERVED0f_GET(r) ((((r).xaui2_mdio_ctl[0]) >> 13) & 0x7)
#define BCM84868_XAUI2_MDIO_CTLr_RESERVED0f_SET(r,f) (r).xaui2_mdio_ctl[0]=(((r).xaui2_mdio_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM84868_XAUI2_MDIO_CTLr_REMOTEMDIOREQf_GET(r) ((((r).xaui2_mdio_ctl[0]) >> 12) & 0x1)
#define BCM84868_XAUI2_MDIO_CTLr_REMOTEMDIOREQf_SET(r,f) (r).xaui2_mdio_ctl[0]=(((r).xaui2_mdio_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM84868_XAUI2_MDIO_CTLr_MD_STf_GET(r) ((((r).xaui2_mdio_ctl[0]) >> 11) & 0x1)
#define BCM84868_XAUI2_MDIO_CTLr_MD_STf_SET(r,f) (r).xaui2_mdio_ctl[0]=(((r).xaui2_mdio_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM84868_XAUI2_MDIO_CTLr_MULTIMMDS_STRAPf_GET(r) ((((r).xaui2_mdio_ctl[0]) >> 10) & 0x1)
#define BCM84868_XAUI2_MDIO_CTLr_MULTIMMDS_STRAPf_SET(r,f) (r).xaui2_mdio_ctl[0]=(((r).xaui2_mdio_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM84868_XAUI2_MDIO_CTLr_MD_DEVADf_GET(r) ((((r).xaui2_mdio_ctl[0]) >> 5) & 0x1f)
#define BCM84868_XAUI2_MDIO_CTLr_MD_DEVADf_SET(r,f) (r).xaui2_mdio_ctl[0]=(((r).xaui2_mdio_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM84868_XAUI2_MDIO_CTLr_PRTADf_GET(r) (((r).xaui2_mdio_ctl[0]) & 0x1f)
#define BCM84868_XAUI2_MDIO_CTLr_PRTADf_SET(r,f) (r).xaui2_mdio_ctl[0]=(((r).xaui2_mdio_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access XAUI2_MDIO_CTL.
 */
#define BCM84868_READ_XAUI2_MDIO_CTLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XAUI2_MDIO_CTLr,(_r._xaui2_mdio_ctl))
#define BCM84868_WRITE_XAUI2_MDIO_CTLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XAUI2_MDIO_CTLr,(_r._xaui2_mdio_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XAUI2_MDIO_CTLr BCM84868_XAUI2_MDIO_CTLr
#define XAUI2_MDIO_CTLr_SIZE BCM84868_XAUI2_MDIO_CTLr_SIZE
typedef BCM84868_XAUI2_MDIO_CTLr_t XAUI2_MDIO_CTLr_t;
#define XAUI2_MDIO_CTLr_CLR BCM84868_XAUI2_MDIO_CTLr_CLR
#define XAUI2_MDIO_CTLr_SET BCM84868_XAUI2_MDIO_CTLr_SET
#define XAUI2_MDIO_CTLr_GET BCM84868_XAUI2_MDIO_CTLr_GET
#define XAUI2_MDIO_CTLr_RESERVED0f_GET BCM84868_XAUI2_MDIO_CTLr_RESERVED0f_GET
#define XAUI2_MDIO_CTLr_RESERVED0f_SET BCM84868_XAUI2_MDIO_CTLr_RESERVED0f_SET
#define XAUI2_MDIO_CTLr_REMOTEMDIOREQf_GET BCM84868_XAUI2_MDIO_CTLr_REMOTEMDIOREQf_GET
#define XAUI2_MDIO_CTLr_REMOTEMDIOREQf_SET BCM84868_XAUI2_MDIO_CTLr_REMOTEMDIOREQf_SET
#define XAUI2_MDIO_CTLr_MD_STf_GET BCM84868_XAUI2_MDIO_CTLr_MD_STf_GET
#define XAUI2_MDIO_CTLr_MD_STf_SET BCM84868_XAUI2_MDIO_CTLr_MD_STf_SET
#define XAUI2_MDIO_CTLr_MULTIMMDS_STRAPf_GET BCM84868_XAUI2_MDIO_CTLr_MULTIMMDS_STRAPf_GET
#define XAUI2_MDIO_CTLr_MULTIMMDS_STRAPf_SET BCM84868_XAUI2_MDIO_CTLr_MULTIMMDS_STRAPf_SET
#define XAUI2_MDIO_CTLr_MD_DEVADf_GET BCM84868_XAUI2_MDIO_CTLr_MD_DEVADf_GET
#define XAUI2_MDIO_CTLr_MD_DEVADf_SET BCM84868_XAUI2_MDIO_CTLr_MD_DEVADf_SET
#define XAUI2_MDIO_CTLr_PRTADf_GET BCM84868_XAUI2_MDIO_CTLr_PRTADf_GET
#define XAUI2_MDIO_CTLr_PRTADf_SET BCM84868_XAUI2_MDIO_CTLr_PRTADf_SET
#define READ_XAUI2_MDIO_CTLr BCM84868_READ_XAUI2_MDIO_CTLr
#define WRITE_XAUI2_MDIO_CTLr BCM84868_WRITE_XAUI2_MDIO_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XAUI2_MDIO_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XAUI2_RESET_CTL
 * BLOCKS:   XAUI
 * REGADDR:  0x4093
 * DEVAD:    30
 * DESC:     xaui reset control register 02
 * SIZE:     32
 * FIELDS:
 *     XAUI2_RESET_CTL_REG 
 */
#define BCM84868_XAUI2_RESET_CTLr (0x001e4093 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XAUI2_RESET_CTLr_SIZE 4

/*
 * This structure should be used to declare and program XAUI2_RESET_CTL.
 */
typedef union BCM84868_XAUI2_RESET_CTLr_s {
	uint32_t v[1];
	uint32_t xaui2_reset_ctl[1];
	uint32_t _xaui2_reset_ctl;
} BCM84868_XAUI2_RESET_CTLr_t;

#define BCM84868_XAUI2_RESET_CTLr_CLR(r) (r).xaui2_reset_ctl[0] = 0
#define BCM84868_XAUI2_RESET_CTLr_SET(r,d) (r).xaui2_reset_ctl[0] = d
#define BCM84868_XAUI2_RESET_CTLr_GET(r) (r).xaui2_reset_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XAUI2_RESET_CTLr_XAUI2_RESET_CTL_REGf_GET(r) (((r).xaui2_reset_ctl[0]) & 0xffff)
#define BCM84868_XAUI2_RESET_CTLr_XAUI2_RESET_CTL_REGf_SET(r,f) (r).xaui2_reset_ctl[0]=(((r).xaui2_reset_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XAUI2_RESET_CTL.
 */
#define BCM84868_READ_XAUI2_RESET_CTLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XAUI2_RESET_CTLr,(_r._xaui2_reset_ctl))
#define BCM84868_WRITE_XAUI2_RESET_CTLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XAUI2_RESET_CTLr,(_r._xaui2_reset_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XAUI2_RESET_CTLr BCM84868_XAUI2_RESET_CTLr
#define XAUI2_RESET_CTLr_SIZE BCM84868_XAUI2_RESET_CTLr_SIZE
typedef BCM84868_XAUI2_RESET_CTLr_t XAUI2_RESET_CTLr_t;
#define XAUI2_RESET_CTLr_CLR BCM84868_XAUI2_RESET_CTLr_CLR
#define XAUI2_RESET_CTLr_SET BCM84868_XAUI2_RESET_CTLr_SET
#define XAUI2_RESET_CTLr_GET BCM84868_XAUI2_RESET_CTLr_GET
#define XAUI2_RESET_CTLr_XAUI2_RESET_CTL_REGf_GET BCM84868_XAUI2_RESET_CTLr_XAUI2_RESET_CTL_REGf_GET
#define XAUI2_RESET_CTLr_XAUI2_RESET_CTL_REGf_SET BCM84868_XAUI2_RESET_CTLr_XAUI2_RESET_CTL_REGf_SET
#define READ_XAUI2_RESET_CTLr BCM84868_READ_XAUI2_RESET_CTLr
#define WRITE_XAUI2_RESET_CTLr BCM84868_WRITE_XAUI2_RESET_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XAUI2_RESET_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  IFC_XGPHY_CTL
 * BLOCKS:   XAUI
 * REGADDR:  0x40c0
 * DEVAD:    30
 * DESC:     IFC XGPHY CTL
 * SIZE:     32
 * FIELDS:
 *     IFC_XGPHY_CTL    
 */
#define BCM84868_IFC_XGPHY_CTLr (0x001e40c0 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_IFC_XGPHY_CTLr_SIZE 4

/*
 * This structure should be used to declare and program IFC_XGPHY_CTL.
 */
typedef union BCM84868_IFC_XGPHY_CTLr_s {
	uint32_t v[1];
	uint32_t ifc_xgphy_ctl[1];
	uint32_t _ifc_xgphy_ctl;
} BCM84868_IFC_XGPHY_CTLr_t;

#define BCM84868_IFC_XGPHY_CTLr_CLR(r) (r).ifc_xgphy_ctl[0] = 0
#define BCM84868_IFC_XGPHY_CTLr_SET(r,d) (r).ifc_xgphy_ctl[0] = d
#define BCM84868_IFC_XGPHY_CTLr_GET(r) (r).ifc_xgphy_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_IFC_XGPHY_CTLr_IFC_XGPHY_CTLf_GET(r) (((r).ifc_xgphy_ctl[0]) & 0xffff)
#define BCM84868_IFC_XGPHY_CTLr_IFC_XGPHY_CTLf_SET(r,f) (r).ifc_xgphy_ctl[0]=(((r).ifc_xgphy_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access IFC_XGPHY_CTL.
 */
#define BCM84868_READ_IFC_XGPHY_CTLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_IFC_XGPHY_CTLr,(_r._ifc_xgphy_ctl))
#define BCM84868_WRITE_IFC_XGPHY_CTLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_IFC_XGPHY_CTLr,(_r._ifc_xgphy_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define IFC_XGPHY_CTLr BCM84868_IFC_XGPHY_CTLr
#define IFC_XGPHY_CTLr_SIZE BCM84868_IFC_XGPHY_CTLr_SIZE
typedef BCM84868_IFC_XGPHY_CTLr_t IFC_XGPHY_CTLr_t;
#define IFC_XGPHY_CTLr_CLR BCM84868_IFC_XGPHY_CTLr_CLR
#define IFC_XGPHY_CTLr_SET BCM84868_IFC_XGPHY_CTLr_SET
#define IFC_XGPHY_CTLr_GET BCM84868_IFC_XGPHY_CTLr_GET
#define IFC_XGPHY_CTLr_IFC_XGPHY_CTLf_GET BCM84868_IFC_XGPHY_CTLr_IFC_XGPHY_CTLf_GET
#define IFC_XGPHY_CTLr_IFC_XGPHY_CTLf_SET BCM84868_IFC_XGPHY_CTLr_IFC_XGPHY_CTLf_SET
#define READ_IFC_XGPHY_CTLr BCM84868_READ_IFC_XGPHY_CTLr
#define WRITE_IFC_XGPHY_CTLr BCM84868_WRITE_IFC_XGPHY_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_IFC_XGPHY_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGP_PD_DEF_02
 * BLOCKS:   XGP
 * REGADDR:  0x4102
 * DEVAD:    30
 * DESC:     prtad/devad definition register 02
 * SIZE:     32
 * FIELDS:
 *     DEVAD            
 *     PRTAD            
 *     CLAUSE           
 */
#define BCM84868_XGP_PD_DEF_02r (0x001e4102 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGP_PD_DEF_02r_SIZE 4

/*
 * This structure should be used to declare and program XGP_PD_DEF_02.
 */
typedef union BCM84868_XGP_PD_DEF_02r_s {
	uint32_t v[1];
	uint32_t xgp_pd_def_02[1];
	uint32_t _xgp_pd_def_02;
} BCM84868_XGP_PD_DEF_02r_t;

#define BCM84868_XGP_PD_DEF_02r_CLR(r) (r).xgp_pd_def_02[0] = 0
#define BCM84868_XGP_PD_DEF_02r_SET(r,d) (r).xgp_pd_def_02[0] = d
#define BCM84868_XGP_PD_DEF_02r_GET(r) (r).xgp_pd_def_02[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGP_PD_DEF_02r_CLAUSEf_GET(r) ((((r).xgp_pd_def_02[0]) >> 10) & 0x3)
#define BCM84868_XGP_PD_DEF_02r_CLAUSEf_SET(r,f) (r).xgp_pd_def_02[0]=(((r).xgp_pd_def_02[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM84868_XGP_PD_DEF_02r_PRTADf_GET(r) ((((r).xgp_pd_def_02[0]) >> 5) & 0x1f)
#define BCM84868_XGP_PD_DEF_02r_PRTADf_SET(r,f) (r).xgp_pd_def_02[0]=(((r).xgp_pd_def_02[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM84868_XGP_PD_DEF_02r_DEVADf_GET(r) (((r).xgp_pd_def_02[0]) & 0x1f)
#define BCM84868_XGP_PD_DEF_02r_DEVADf_SET(r,f) (r).xgp_pd_def_02[0]=(((r).xgp_pd_def_02[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access XGP_PD_DEF_02.
 */
#define BCM84868_READ_XGP_PD_DEF_02r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGP_PD_DEF_02r,(_r._xgp_pd_def_02))
#define BCM84868_WRITE_XGP_PD_DEF_02r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGP_PD_DEF_02r,(_r._xgp_pd_def_02))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGP_PD_DEF_02r BCM84868_XGP_PD_DEF_02r
#define XGP_PD_DEF_02r_SIZE BCM84868_XGP_PD_DEF_02r_SIZE
typedef BCM84868_XGP_PD_DEF_02r_t XGP_PD_DEF_02r_t;
#define XGP_PD_DEF_02r_CLR BCM84868_XGP_PD_DEF_02r_CLR
#define XGP_PD_DEF_02r_SET BCM84868_XGP_PD_DEF_02r_SET
#define XGP_PD_DEF_02r_GET BCM84868_XGP_PD_DEF_02r_GET
#define XGP_PD_DEF_02r_CLAUSEf_GET BCM84868_XGP_PD_DEF_02r_CLAUSEf_GET
#define XGP_PD_DEF_02r_CLAUSEf_SET BCM84868_XGP_PD_DEF_02r_CLAUSEf_SET
#define XGP_PD_DEF_02r_PRTADf_GET BCM84868_XGP_PD_DEF_02r_PRTADf_GET
#define XGP_PD_DEF_02r_PRTADf_SET BCM84868_XGP_PD_DEF_02r_PRTADf_SET
#define XGP_PD_DEF_02r_DEVADf_GET BCM84868_XGP_PD_DEF_02r_DEVADf_GET
#define XGP_PD_DEF_02r_DEVADf_SET BCM84868_XGP_PD_DEF_02r_DEVADf_SET
#define READ_XGP_PD_DEF_02r BCM84868_READ_XGP_PD_DEF_02r
#define WRITE_XGP_PD_DEF_02r BCM84868_WRITE_XGP_PD_DEF_02r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGP_PD_DEF_02r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  XGP_PD_DEF_06
 * BLOCKS:   XGP
 * REGADDR:  0x4106
 * DEVAD:    30
 * DESC:     prtad/devad definition register 06
 * SIZE:     32
 * FIELDS:
 *     DEVAD            
 *     PRTAD            
 *     CLAUSE           
 */
#define BCM84868_XGP_PD_DEF_06r (0x001e4106 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_XGP_PD_DEF_06r_SIZE 4

/*
 * This structure should be used to declare and program XGP_PD_DEF_06.
 */
typedef union BCM84868_XGP_PD_DEF_06r_s {
	uint32_t v[1];
	uint32_t xgp_pd_def_06[1];
	uint32_t _xgp_pd_def_06;
} BCM84868_XGP_PD_DEF_06r_t;

#define BCM84868_XGP_PD_DEF_06r_CLR(r) (r).xgp_pd_def_06[0] = 0
#define BCM84868_XGP_PD_DEF_06r_SET(r,d) (r).xgp_pd_def_06[0] = d
#define BCM84868_XGP_PD_DEF_06r_GET(r) (r).xgp_pd_def_06[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_XGP_PD_DEF_06r_CLAUSEf_GET(r) ((((r).xgp_pd_def_06[0]) >> 10) & 0x3)
#define BCM84868_XGP_PD_DEF_06r_CLAUSEf_SET(r,f) (r).xgp_pd_def_06[0]=(((r).xgp_pd_def_06[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM84868_XGP_PD_DEF_06r_PRTADf_GET(r) ((((r).xgp_pd_def_06[0]) >> 5) & 0x1f)
#define BCM84868_XGP_PD_DEF_06r_PRTADf_SET(r,f) (r).xgp_pd_def_06[0]=(((r).xgp_pd_def_06[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM84868_XGP_PD_DEF_06r_DEVADf_GET(r) (((r).xgp_pd_def_06[0]) & 0x1f)
#define BCM84868_XGP_PD_DEF_06r_DEVADf_SET(r,f) (r).xgp_pd_def_06[0]=(((r).xgp_pd_def_06[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access XGP_PD_DEF_06.
 */
#define BCM84868_READ_XGP_PD_DEF_06r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_XGP_PD_DEF_06r,(_r._xgp_pd_def_06))
#define BCM84868_WRITE_XGP_PD_DEF_06r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_XGP_PD_DEF_06r,(_r._xgp_pd_def_06))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define XGP_PD_DEF_06r BCM84868_XGP_PD_DEF_06r
#define XGP_PD_DEF_06r_SIZE BCM84868_XGP_PD_DEF_06r_SIZE
typedef BCM84868_XGP_PD_DEF_06r_t XGP_PD_DEF_06r_t;
#define XGP_PD_DEF_06r_CLR BCM84868_XGP_PD_DEF_06r_CLR
#define XGP_PD_DEF_06r_SET BCM84868_XGP_PD_DEF_06r_SET
#define XGP_PD_DEF_06r_GET BCM84868_XGP_PD_DEF_06r_GET
#define XGP_PD_DEF_06r_CLAUSEf_GET BCM84868_XGP_PD_DEF_06r_CLAUSEf_GET
#define XGP_PD_DEF_06r_CLAUSEf_SET BCM84868_XGP_PD_DEF_06r_CLAUSEf_SET
#define XGP_PD_DEF_06r_PRTADf_GET BCM84868_XGP_PD_DEF_06r_PRTADf_GET
#define XGP_PD_DEF_06r_PRTADf_SET BCM84868_XGP_PD_DEF_06r_PRTADf_SET
#define XGP_PD_DEF_06r_DEVADf_GET BCM84868_XGP_PD_DEF_06r_DEVADf_GET
#define XGP_PD_DEF_06r_DEVADf_SET BCM84868_XGP_PD_DEF_06r_DEVADf_SET
#define READ_XGP_PD_DEF_06r BCM84868_READ_XGP_PD_DEF_06r
#define WRITE_XGP_PD_DEF_06r BCM84868_WRITE_XGP_PD_DEF_06r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_XGP_PD_DEF_06r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO_CTRL_0
 * BLOCKS:   XGP
 * REGADDR:  0x4110
 * DEVAD:    30
 * DESC:     MDIO Control 0 Register
 * SIZE:     32
 * FIELDS:
 *     MDIO_CTRL        
 */
#define BCM84868_MDIO_CTRL_0r (0x001e4110 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO_CTRL_0r_SIZE 4

/*
 * This structure should be used to declare and program MDIO_CTRL_0.
 */
typedef union BCM84868_MDIO_CTRL_0r_s {
	uint32_t v[1];
	uint32_t mdio_ctrl_0[1];
	uint32_t _mdio_ctrl_0;
} BCM84868_MDIO_CTRL_0r_t;

#define BCM84868_MDIO_CTRL_0r_CLR(r) (r).mdio_ctrl_0[0] = 0
#define BCM84868_MDIO_CTRL_0r_SET(r,d) (r).mdio_ctrl_0[0] = d
#define BCM84868_MDIO_CTRL_0r_GET(r) (r).mdio_ctrl_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO_CTRL_0r_MDIO_CTRLf_GET(r) (((r).mdio_ctrl_0[0]) & 0xffff)
#define BCM84868_MDIO_CTRL_0r_MDIO_CTRLf_SET(r,f) (r).mdio_ctrl_0[0]=(((r).mdio_ctrl_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO_CTRL_0.
 */
#define BCM84868_READ_MDIO_CTRL_0r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO_CTRL_0r,(_r._mdio_ctrl_0))
#define BCM84868_WRITE_MDIO_CTRL_0r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO_CTRL_0r,(_r._mdio_ctrl_0))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_CTRL_0r BCM84868_MDIO_CTRL_0r
#define MDIO_CTRL_0r_SIZE BCM84868_MDIO_CTRL_0r_SIZE
typedef BCM84868_MDIO_CTRL_0r_t MDIO_CTRL_0r_t;
#define MDIO_CTRL_0r_CLR BCM84868_MDIO_CTRL_0r_CLR
#define MDIO_CTRL_0r_SET BCM84868_MDIO_CTRL_0r_SET
#define MDIO_CTRL_0r_GET BCM84868_MDIO_CTRL_0r_GET
#define MDIO_CTRL_0r_MDIO_CTRLf_GET BCM84868_MDIO_CTRL_0r_MDIO_CTRLf_GET
#define MDIO_CTRL_0r_MDIO_CTRLf_SET BCM84868_MDIO_CTRL_0r_MDIO_CTRLf_SET
#define READ_MDIO_CTRL_0r BCM84868_READ_MDIO_CTRL_0r
#define WRITE_MDIO_CTRL_0r BCM84868_WRITE_MDIO_CTRL_0r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO_CTRL_0r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO_CTRL_1
 * BLOCKS:   XGP
 * REGADDR:  0x4111
 * DEVAD:    30
 * DESC:     MDIO Control 1 Register
 * SIZE:     32
 * FIELDS:
 *     MDIO_CTRL        
 */
#define BCM84868_MDIO_CTRL_1r (0x001e4111 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO_CTRL_1r_SIZE 4

/*
 * This structure should be used to declare and program MDIO_CTRL_1.
 */
typedef union BCM84868_MDIO_CTRL_1r_s {
	uint32_t v[1];
	uint32_t mdio_ctrl_1[1];
	uint32_t _mdio_ctrl_1;
} BCM84868_MDIO_CTRL_1r_t;

#define BCM84868_MDIO_CTRL_1r_CLR(r) (r).mdio_ctrl_1[0] = 0
#define BCM84868_MDIO_CTRL_1r_SET(r,d) (r).mdio_ctrl_1[0] = d
#define BCM84868_MDIO_CTRL_1r_GET(r) (r).mdio_ctrl_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO_CTRL_1r_MDIO_CTRLf_GET(r) (((r).mdio_ctrl_1[0]) & 0xffff)
#define BCM84868_MDIO_CTRL_1r_MDIO_CTRLf_SET(r,f) (r).mdio_ctrl_1[0]=(((r).mdio_ctrl_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO_CTRL_1.
 */
#define BCM84868_READ_MDIO_CTRL_1r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO_CTRL_1r,(_r._mdio_ctrl_1))
#define BCM84868_WRITE_MDIO_CTRL_1r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO_CTRL_1r,(_r._mdio_ctrl_1))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_CTRL_1r BCM84868_MDIO_CTRL_1r
#define MDIO_CTRL_1r_SIZE BCM84868_MDIO_CTRL_1r_SIZE
typedef BCM84868_MDIO_CTRL_1r_t MDIO_CTRL_1r_t;
#define MDIO_CTRL_1r_CLR BCM84868_MDIO_CTRL_1r_CLR
#define MDIO_CTRL_1r_SET BCM84868_MDIO_CTRL_1r_SET
#define MDIO_CTRL_1r_GET BCM84868_MDIO_CTRL_1r_GET
#define MDIO_CTRL_1r_MDIO_CTRLf_GET BCM84868_MDIO_CTRL_1r_MDIO_CTRLf_GET
#define MDIO_CTRL_1r_MDIO_CTRLf_SET BCM84868_MDIO_CTRL_1r_MDIO_CTRLf_SET
#define READ_MDIO_CTRL_1r BCM84868_READ_MDIO_CTRL_1r
#define WRITE_MDIO_CTRL_1r BCM84868_WRITE_MDIO_CTRL_1r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO_CTRL_1r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO_CTRL_2
 * BLOCKS:   XGP
 * REGADDR:  0x4112
 * DEVAD:    30
 * DESC:     MDIO Control 1 Register
 * SIZE:     32
 * FIELDS:
 *     MDIO_CTRL        
 */
#define BCM84868_MDIO_CTRL_2r (0x001e4112 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO_CTRL_2r_SIZE 4

/*
 * This structure should be used to declare and program MDIO_CTRL_2.
 */
typedef union BCM84868_MDIO_CTRL_2r_s {
	uint32_t v[1];
	uint32_t mdio_ctrl_2[1];
	uint32_t _mdio_ctrl_2;
} BCM84868_MDIO_CTRL_2r_t;

#define BCM84868_MDIO_CTRL_2r_CLR(r) (r).mdio_ctrl_2[0] = 0
#define BCM84868_MDIO_CTRL_2r_SET(r,d) (r).mdio_ctrl_2[0] = d
#define BCM84868_MDIO_CTRL_2r_GET(r) (r).mdio_ctrl_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO_CTRL_2r_MDIO_CTRLf_GET(r) (((r).mdio_ctrl_2[0]) & 0xffff)
#define BCM84868_MDIO_CTRL_2r_MDIO_CTRLf_SET(r,f) (r).mdio_ctrl_2[0]=(((r).mdio_ctrl_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO_CTRL_2.
 */
#define BCM84868_READ_MDIO_CTRL_2r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO_CTRL_2r,(_r._mdio_ctrl_2))
#define BCM84868_WRITE_MDIO_CTRL_2r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO_CTRL_2r,(_r._mdio_ctrl_2))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_CTRL_2r BCM84868_MDIO_CTRL_2r
#define MDIO_CTRL_2r_SIZE BCM84868_MDIO_CTRL_2r_SIZE
typedef BCM84868_MDIO_CTRL_2r_t MDIO_CTRL_2r_t;
#define MDIO_CTRL_2r_CLR BCM84868_MDIO_CTRL_2r_CLR
#define MDIO_CTRL_2r_SET BCM84868_MDIO_CTRL_2r_SET
#define MDIO_CTRL_2r_GET BCM84868_MDIO_CTRL_2r_GET
#define MDIO_CTRL_2r_MDIO_CTRLf_GET BCM84868_MDIO_CTRL_2r_MDIO_CTRLf_GET
#define MDIO_CTRL_2r_MDIO_CTRLf_SET BCM84868_MDIO_CTRL_2r_MDIO_CTRLf_SET
#define READ_MDIO_CTRL_2r BCM84868_READ_MDIO_CTRL_2r
#define WRITE_MDIO_CTRL_2r BCM84868_WRITE_MDIO_CTRL_2r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO_CTRL_2r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO_CTRL_3
 * BLOCKS:   XGP
 * REGADDR:  0x4113
 * DEVAD:    30
 * DESC:     MDIO Control 1 Register
 * SIZE:     32
 * FIELDS:
 *     MDIO_CTRL        
 */
#define BCM84868_MDIO_CTRL_3r (0x001e4113 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO_CTRL_3r_SIZE 4

/*
 * This structure should be used to declare and program MDIO_CTRL_3.
 */
typedef union BCM84868_MDIO_CTRL_3r_s {
	uint32_t v[1];
	uint32_t mdio_ctrl_3[1];
	uint32_t _mdio_ctrl_3;
} BCM84868_MDIO_CTRL_3r_t;

#define BCM84868_MDIO_CTRL_3r_CLR(r) (r).mdio_ctrl_3[0] = 0
#define BCM84868_MDIO_CTRL_3r_SET(r,d) (r).mdio_ctrl_3[0] = d
#define BCM84868_MDIO_CTRL_3r_GET(r) (r).mdio_ctrl_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO_CTRL_3r_MDIO_CTRLf_GET(r) (((r).mdio_ctrl_3[0]) & 0xffff)
#define BCM84868_MDIO_CTRL_3r_MDIO_CTRLf_SET(r,f) (r).mdio_ctrl_3[0]=(((r).mdio_ctrl_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MDIO_CTRL_3.
 */
#define BCM84868_READ_MDIO_CTRL_3r(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO_CTRL_3r,(_r._mdio_ctrl_3))
#define BCM84868_WRITE_MDIO_CTRL_3r(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO_CTRL_3r,(_r._mdio_ctrl_3))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO_CTRL_3r BCM84868_MDIO_CTRL_3r
#define MDIO_CTRL_3r_SIZE BCM84868_MDIO_CTRL_3r_SIZE
typedef BCM84868_MDIO_CTRL_3r_t MDIO_CTRL_3r_t;
#define MDIO_CTRL_3r_CLR BCM84868_MDIO_CTRL_3r_CLR
#define MDIO_CTRL_3r_SET BCM84868_MDIO_CTRL_3r_SET
#define MDIO_CTRL_3r_GET BCM84868_MDIO_CTRL_3r_GET
#define MDIO_CTRL_3r_MDIO_CTRLf_GET BCM84868_MDIO_CTRL_3r_MDIO_CTRLf_GET
#define MDIO_CTRL_3r_MDIO_CTRLf_SET BCM84868_MDIO_CTRL_3r_MDIO_CTRLf_SET
#define READ_MDIO_CTRL_3r BCM84868_READ_MDIO_CTRL_3r
#define WRITE_MDIO_CTRL_3r BCM84868_WRITE_MDIO_CTRL_3r

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO_CTRL_3r'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO2ARM_CTL
 * BLOCKS:   XAUI
 * REGADDR:  0xa817
 * DEVAD:    30
 * DESC:     Macros for MDIO2ARM operations
 * SIZE:     32
 * FIELDS:
 *     WR               
 *     RD               
 *     SIZE             
 *     BURST            
 *     SELF_INC_ADDR    
 *     RESERVED0        
 */
#define BCM84868_MDIO2ARM_CTLr (0x001ea817 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO2ARM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MDIO2ARM_CTL.
 */
typedef union BCM84868_MDIO2ARM_CTLr_s {
	uint32_t v[1];
	uint32_t mdio2arm_ctl[1];
	uint32_t _mdio2arm_ctl;
} BCM84868_MDIO2ARM_CTLr_t;

#define BCM84868_MDIO2ARM_CTLr_CLR(r) (r).mdio2arm_ctl[0] = 0
#define BCM84868_MDIO2ARM_CTLr_SET(r,d) (r).mdio2arm_ctl[0] = d
#define BCM84868_MDIO2ARM_CTLr_GET(r) (r).mdio2arm_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO2ARM_CTLr_RESERVED0f_GET(r) ((((r).mdio2arm_ctl[0]) >> 6) & 0x3ff)
#define BCM84868_MDIO2ARM_CTLr_RESERVED0f_SET(r,f) (r).mdio2arm_ctl[0]=(((r).mdio2arm_ctl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))
#define BCM84868_MDIO2ARM_CTLr_SELF_INC_ADDRf_GET(r) ((((r).mdio2arm_ctl[0]) >> 5) & 0x1)
#define BCM84868_MDIO2ARM_CTLr_SELF_INC_ADDRf_SET(r,f) (r).mdio2arm_ctl[0]=(((r).mdio2arm_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM84868_MDIO2ARM_CTLr_BURSTf_GET(r) ((((r).mdio2arm_ctl[0]) >> 4) & 0x1)
#define BCM84868_MDIO2ARM_CTLr_BURSTf_SET(r,f) (r).mdio2arm_ctl[0]=(((r).mdio2arm_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM84868_MDIO2ARM_CTLr_SIZEf_GET(r) ((((r).mdio2arm_ctl[0]) >> 2) & 0x3)
#define BCM84868_MDIO2ARM_CTLr_SIZEf_SET(r,f) (r).mdio2arm_ctl[0]=(((r).mdio2arm_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM84868_MDIO2ARM_CTLr_RDf_GET(r) ((((r).mdio2arm_ctl[0]) >> 1) & 0x1)
#define BCM84868_MDIO2ARM_CTLr_RDf_SET(r,f) (r).mdio2arm_ctl[0]=(((r).mdio2arm_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM84868_MDIO2ARM_CTLr_WRf_GET(r) (((r).mdio2arm_ctl[0]) & 0x1)
#define BCM84868_MDIO2ARM_CTLr_WRf_SET(r,f) (r).mdio2arm_ctl[0]=(((r).mdio2arm_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MDIO2ARM_CTL.
 */
#define BCM84868_READ_MDIO2ARM_CTLr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO2ARM_CTLr,(_r._mdio2arm_ctl))
#define BCM84868_WRITE_MDIO2ARM_CTLr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO2ARM_CTLr,(_r._mdio2arm_ctl))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO2ARM_CTLr BCM84868_MDIO2ARM_CTLr
#define MDIO2ARM_CTLr_SIZE BCM84868_MDIO2ARM_CTLr_SIZE
typedef BCM84868_MDIO2ARM_CTLr_t MDIO2ARM_CTLr_t;
#define MDIO2ARM_CTLr_CLR BCM84868_MDIO2ARM_CTLr_CLR
#define MDIO2ARM_CTLr_SET BCM84868_MDIO2ARM_CTLr_SET
#define MDIO2ARM_CTLr_GET BCM84868_MDIO2ARM_CTLr_GET
#define MDIO2ARM_CTLr_RESERVED0f_GET BCM84868_MDIO2ARM_CTLr_RESERVED0f_GET
#define MDIO2ARM_CTLr_RESERVED0f_SET BCM84868_MDIO2ARM_CTLr_RESERVED0f_SET
#define MDIO2ARM_CTLr_SELF_INC_ADDRf_GET BCM84868_MDIO2ARM_CTLr_SELF_INC_ADDRf_GET
#define MDIO2ARM_CTLr_SELF_INC_ADDRf_SET BCM84868_MDIO2ARM_CTLr_SELF_INC_ADDRf_SET
#define MDIO2ARM_CTLr_BURSTf_GET BCM84868_MDIO2ARM_CTLr_BURSTf_GET
#define MDIO2ARM_CTLr_BURSTf_SET BCM84868_MDIO2ARM_CTLr_BURSTf_SET
#define MDIO2ARM_CTLr_SIZEf_GET BCM84868_MDIO2ARM_CTLr_SIZEf_GET
#define MDIO2ARM_CTLr_SIZEf_SET BCM84868_MDIO2ARM_CTLr_SIZEf_SET
#define MDIO2ARM_CTLr_RDf_GET BCM84868_MDIO2ARM_CTLr_RDf_GET
#define MDIO2ARM_CTLr_RDf_SET BCM84868_MDIO2ARM_CTLr_RDf_SET
#define MDIO2ARM_CTLr_WRf_GET BCM84868_MDIO2ARM_CTLr_WRf_GET
#define MDIO2ARM_CTLr_WRf_SET BCM84868_MDIO2ARM_CTLr_WRf_SET
#define READ_MDIO2ARM_CTLr BCM84868_READ_MDIO2ARM_CTLr
#define WRITE_MDIO2ARM_CTLr BCM84868_WRITE_MDIO2ARM_CTLr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO2ARM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCM84868
 * REGISTER:  MDIO2ARM_STS
 * BLOCKS:   XAUI
 * REGADDR:  0xa818
 * DEVAD:    30
 * DESC:     Macros for MDIO2ARM operations
 * SIZE:     32
 * FIELDS:
 *     DONE             
 *     RESERVED0        
 */
#define BCM84868_MDIO2ARM_STSr (0x001ea818 | PHY_REG_ACC_BRCM_XE)

#define BCM84868_MDIO2ARM_STSr_SIZE 4

/*
 * This structure should be used to declare and program MDIO2ARM_STS.
 */
typedef union BCM84868_MDIO2ARM_STSr_s {
	uint32_t v[1];
	uint32_t mdio2arm_sts[1];
	uint32_t _mdio2arm_sts;
} BCM84868_MDIO2ARM_STSr_t;

#define BCM84868_MDIO2ARM_STSr_CLR(r) (r).mdio2arm_sts[0] = 0
#define BCM84868_MDIO2ARM_STSr_SET(r,d) (r).mdio2arm_sts[0] = d
#define BCM84868_MDIO2ARM_STSr_GET(r) (r).mdio2arm_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCM84868_MDIO2ARM_STSr_RESERVED0f_GET(r) ((((r).mdio2arm_sts[0]) >> 1) & 0x7fff)
#define BCM84868_MDIO2ARM_STSr_RESERVED0f_SET(r,f) (r).mdio2arm_sts[0]=(((r).mdio2arm_sts[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))
#define BCM84868_MDIO2ARM_STSr_DONEf_GET(r) (((r).mdio2arm_sts[0]) & 0x1)
#define BCM84868_MDIO2ARM_STSr_DONEf_SET(r,f) (r).mdio2arm_sts[0]=(((r).mdio2arm_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MDIO2ARM_STS.
 */
#define BCM84868_READ_MDIO2ARM_STSr(_pc,_r) phy_brcm_xe_read(_pc,BCM84868_MDIO2ARM_STSr,(_r._mdio2arm_sts))
#define BCM84868_WRITE_MDIO2ARM_STSr(_pc,_r) phy_brcm_xe_write(_pc,BCM84868_MDIO2ARM_STSr,(_r._mdio2arm_sts))

/*
 * Unless PHY_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHY_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHY_EXCLUDE_CHIPLESS_TYPES

#define MDIO2ARM_STSr BCM84868_MDIO2ARM_STSr
#define MDIO2ARM_STSr_SIZE BCM84868_MDIO2ARM_STSr_SIZE
typedef BCM84868_MDIO2ARM_STSr_t MDIO2ARM_STSr_t;
#define MDIO2ARM_STSr_CLR BCM84868_MDIO2ARM_STSr_CLR
#define MDIO2ARM_STSr_SET BCM84868_MDIO2ARM_STSr_SET
#define MDIO2ARM_STSr_GET BCM84868_MDIO2ARM_STSr_GET
#define MDIO2ARM_STSr_RESERVED0f_GET BCM84868_MDIO2ARM_STSr_RESERVED0f_GET
#define MDIO2ARM_STSr_RESERVED0f_SET BCM84868_MDIO2ARM_STSr_RESERVED0f_SET
#define MDIO2ARM_STSr_DONEf_GET BCM84868_MDIO2ARM_STSr_DONEf_GET
#define MDIO2ARM_STSr_DONEf_SET BCM84868_MDIO2ARM_STSr_DONEf_SET
#define READ_MDIO2ARM_STSr BCM84868_READ_MDIO2ARM_STSr
#define WRITE_MDIO2ARM_STSr BCM84868_WRITE_MDIO2ARM_STSr

#endif /* PHY_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM84868_MDIO2ARM_STSr'
 */




#endif /* __BCM84868_DEFS_H__ */
